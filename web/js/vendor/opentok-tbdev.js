/**
 * @license OpenTok.js 2.12.0 edb6972 Detached: edb6972765810b0458be920aaa5b5acb72b8af76
 *
 * Copyright (c) 2010-2017 TokBox, Inc.
 * Subject to the applicable Software Development Kit (SDK) License Agreement:
 * https://tokbox.com/support/sdk_license
 *
 * Date: July 18 17:11:59 2017
 */

(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.OT = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
(function (global){
'use strict';

// compare and isBuffer taken from https://github.com/feross/buffer/blob/680e9e5e488f22aac27599a57dc844a6315928dd/index.js
// original notice:

/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
function compare(a, b) {
  if (a === b) {
    return 0;
  }

  var x = a.length;
  var y = b.length;

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break;
    }
  }

  if (x < y) {
    return -1;
  }
  if (y < x) {
    return 1;
  }
  return 0;
}
function isBuffer(b) {
  if (global.Buffer && typeof global.Buffer.isBuffer === 'function') {
    return global.Buffer.isBuffer(b);
  }
  return !!(b != null && b._isBuffer);
}

// based on node assert, original notice:

// http://wiki.commonjs.org/wiki/Unit_Testing/1.0
//
// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!
//
// Originally from narwhal.js (http://narwhaljs.org)
// Copyright (c) 2009 Thomas Robinson <280north.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the 'Software'), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

var util = require('util/');
var hasOwn = Object.prototype.hasOwnProperty;
var pSlice = Array.prototype.slice;
var functionsHaveNames = (function () {
  return function foo() {}.name === 'foo';
}());
function pToString (obj) {
  return Object.prototype.toString.call(obj);
}
function isView(arrbuf) {
  if (isBuffer(arrbuf)) {
    return false;
  }
  if (typeof global.ArrayBuffer !== 'function') {
    return false;
  }
  if (typeof ArrayBuffer.isView === 'function') {
    return ArrayBuffer.isView(arrbuf);
  }
  if (!arrbuf) {
    return false;
  }
  if (arrbuf instanceof DataView) {
    return true;
  }
  if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {
    return true;
  }
  return false;
}
// 1. The assert module provides functions that throw
// AssertionError's when particular conditions are not met. The
// assert module must conform to the following interface.

var assert = module.exports = ok;

// 2. The AssertionError is defined in assert.
// new assert.AssertionError({ message: message,
//                             actual: actual,
//                             expected: expected })

var regex = /\s*function\s+([^\(\s]*)\s*/;
// based on https://github.com/ljharb/function.prototype.name/blob/adeeeec8bfcc6068b187d7d9fb3d5bb1d3a30899/implementation.js
function getName(func) {
  if (!util.isFunction(func)) {
    return;
  }
  if (functionsHaveNames) {
    return func.name;
  }
  var str = func.toString();
  var match = str.match(regex);
  return match && match[1];
}
assert.AssertionError = function AssertionError(options) {
  this.name = 'AssertionError';
  this.actual = options.actual;
  this.expected = options.expected;
  this.operator = options.operator;
  if (options.message) {
    this.message = options.message;
    this.generatedMessage = false;
  } else {
    this.message = getMessage(this);
    this.generatedMessage = true;
  }
  var stackStartFunction = options.stackStartFunction || fail;
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, stackStartFunction);
  } else {
    // non v8 browsers so we can have a stacktrace
    var err = new Error();
    if (err.stack) {
      var out = err.stack;

      // try to strip useless frames
      var fn_name = getName(stackStartFunction);
      var idx = out.indexOf('\n' + fn_name);
      if (idx >= 0) {
        // once we have located the function frame
        // we need to strip out everything before it (and its line)
        var next_line = out.indexOf('\n', idx + 1);
        out = out.substring(next_line + 1);
      }

      this.stack = out;
    }
  }
};

// assert.AssertionError instanceof Error
util.inherits(assert.AssertionError, Error);

function truncate(s, n) {
  if (typeof s === 'string') {
    return s.length < n ? s : s.slice(0, n);
  } else {
    return s;
  }
}
function inspect(something) {
  if (functionsHaveNames || !util.isFunction(something)) {
    return util.inspect(something);
  }
  var rawname = getName(something);
  var name = rawname ? ': ' + rawname : '';
  return '[Function' +  name + ']';
}
function getMessage(self) {
  return truncate(inspect(self.actual), 128) + ' ' +
         self.operator + ' ' +
         truncate(inspect(self.expected), 128);
}

// At present only the three keys mentioned above are used and
// understood by the spec. Implementations or sub modules can pass
// other keys to the AssertionError's constructor - they will be
// ignored.

// 3. All of the following functions must throw an AssertionError
// when a corresponding condition is not met, with a message that
// may be undefined if not provided.  All assertion methods provide
// both the actual and expected values to the assertion error for
// display purposes.

function fail(actual, expected, message, operator, stackStartFunction) {
  throw new assert.AssertionError({
    message: message,
    actual: actual,
    expected: expected,
    operator: operator,
    stackStartFunction: stackStartFunction
  });
}

// EXTENSION! allows for well behaved errors defined elsewhere.
assert.fail = fail;

// 4. Pure assertion tests whether a value is truthy, as determined
// by !!guard.
// assert.ok(guard, message_opt);
// This statement is equivalent to assert.equal(true, !!guard,
// message_opt);. To test strictly for the value true, use
// assert.strictEqual(true, guard, message_opt);.

function ok(value, message) {
  if (!value) fail(value, true, message, '==', assert.ok);
}
assert.ok = ok;

// 5. The equality assertion tests shallow, coercive equality with
// ==.
// assert.equal(actual, expected, message_opt);

assert.equal = function equal(actual, expected, message) {
  if (actual != expected) fail(actual, expected, message, '==', assert.equal);
};

// 6. The non-equality assertion tests for whether two objects are not equal
// with != assert.notEqual(actual, expected, message_opt);

assert.notEqual = function notEqual(actual, expected, message) {
  if (actual == expected) {
    fail(actual, expected, message, '!=', assert.notEqual);
  }
};

// 7. The equivalence assertion tests a deep equality relation.
// assert.deepEqual(actual, expected, message_opt);

assert.deepEqual = function deepEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected, false)) {
    fail(actual, expected, message, 'deepEqual', assert.deepEqual);
  }
};

assert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected, true)) {
    fail(actual, expected, message, 'deepStrictEqual', assert.deepStrictEqual);
  }
};

function _deepEqual(actual, expected, strict, memos) {
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;
  } else if (isBuffer(actual) && isBuffer(expected)) {
    return compare(actual, expected) === 0;

  // 7.2. If the expected value is a Date object, the actual value is
  // equivalent if it is also a Date object that refers to the same time.
  } else if (util.isDate(actual) && util.isDate(expected)) {
    return actual.getTime() === expected.getTime();

  // 7.3 If the expected value is a RegExp object, the actual value is
  // equivalent if it is also a RegExp object with the same source and
  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).
  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
    return actual.source === expected.source &&
           actual.global === expected.global &&
           actual.multiline === expected.multiline &&
           actual.lastIndex === expected.lastIndex &&
           actual.ignoreCase === expected.ignoreCase;

  // 7.4. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
  } else if ((actual === null || typeof actual !== 'object') &&
             (expected === null || typeof expected !== 'object')) {
    return strict ? actual === expected : actual == expected;

  // If both values are instances of typed arrays, wrap their underlying
  // ArrayBuffers in a Buffer each to increase performance
  // This optimization requires the arrays to have the same type as checked by
  // Object.prototype.toString (aka pToString). Never perform binary
  // comparisons for Float*Arrays, though, since e.g. +0 === -0 but their
  // bit patterns are not identical.
  } else if (isView(actual) && isView(expected) &&
             pToString(actual) === pToString(expected) &&
             !(actual instanceof Float32Array ||
               actual instanceof Float64Array)) {
    return compare(new Uint8Array(actual.buffer),
                   new Uint8Array(expected.buffer)) === 0;

  // 7.5 For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call), the same set of keys
  // (although not necessarily the same order), equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
  } else if (isBuffer(actual) !== isBuffer(expected)) {
    return false;
  } else {
    memos = memos || {actual: [], expected: []};

    var actualIndex = memos.actual.indexOf(actual);
    if (actualIndex !== -1) {
      if (actualIndex === memos.expected.indexOf(expected)) {
        return true;
      }
    }

    memos.actual.push(actual);
    memos.expected.push(expected);

    return objEquiv(actual, expected, strict, memos);
  }
}

function isArguments(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
}

function objEquiv(a, b, strict, actualVisitedObjects) {
  if (a === null || a === undefined || b === null || b === undefined)
    return false;
  // if one is a primitive, the other must be same
  if (util.isPrimitive(a) || util.isPrimitive(b))
    return a === b;
  if (strict && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b))
    return false;
  var aIsArgs = isArguments(a);
  var bIsArgs = isArguments(b);
  if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs))
    return false;
  if (aIsArgs) {
    a = pSlice.call(a);
    b = pSlice.call(b);
    return _deepEqual(a, b, strict);
  }
  var ka = objectKeys(a);
  var kb = objectKeys(b);
  var key, i;
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length !== kb.length)
    return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] !== kb[i])
      return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!_deepEqual(a[key], b[key], strict, actualVisitedObjects))
      return false;
  }
  return true;
}

// 8. The non-equivalence assertion tests for any deep inequality.
// assert.notDeepEqual(actual, expected, message_opt);

assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
  if (_deepEqual(actual, expected, false)) {
    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
  }
};

assert.notDeepStrictEqual = notDeepStrictEqual;
function notDeepStrictEqual(actual, expected, message) {
  if (_deepEqual(actual, expected, true)) {
    fail(actual, expected, message, 'notDeepStrictEqual', notDeepStrictEqual);
  }
}


// 9. The strict equality assertion tests strict equality, as determined by ===.
// assert.strictEqual(actual, expected, message_opt);

assert.strictEqual = function strictEqual(actual, expected, message) {
  if (actual !== expected) {
    fail(actual, expected, message, '===', assert.strictEqual);
  }
};

// 10. The strict non-equality assertion tests for strict inequality, as
// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);

assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
  if (actual === expected) {
    fail(actual, expected, message, '!==', assert.notStrictEqual);
  }
};

function expectedException(actual, expected) {
  if (!actual || !expected) {
    return false;
  }

  if (Object.prototype.toString.call(expected) == '[object RegExp]') {
    return expected.test(actual);
  }

  try {
    if (actual instanceof expected) {
      return true;
    }
  } catch (e) {
    // Ignore.  The instanceof check doesn't work for arrow functions.
  }

  if (Error.isPrototypeOf(expected)) {
    return false;
  }

  return expected.call({}, actual) === true;
}

function _tryBlock(block) {
  var error;
  try {
    block();
  } catch (e) {
    error = e;
  }
  return error;
}

function _throws(shouldThrow, block, expected, message) {
  var actual;

  if (typeof block !== 'function') {
    throw new TypeError('"block" argument must be a function');
  }

  if (typeof expected === 'string') {
    message = expected;
    expected = null;
  }

  actual = _tryBlock(block);

  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +
            (message ? ' ' + message : '.');

  if (shouldThrow && !actual) {
    fail(actual, expected, 'Missing expected exception' + message);
  }

  var userProvidedMessage = typeof message === 'string';
  var isUnwantedException = !shouldThrow && util.isError(actual);
  var isUnexpectedException = !shouldThrow && actual && !expected;

  if ((isUnwantedException &&
      userProvidedMessage &&
      expectedException(actual, expected)) ||
      isUnexpectedException) {
    fail(actual, expected, 'Got unwanted exception' + message);
  }

  if ((shouldThrow && actual && expected &&
      !expectedException(actual, expected)) || (!shouldThrow && actual)) {
    throw actual;
  }
}

// 11. Expected to throw an error:
// assert.throws(block, Error_opt, message_opt);

assert.throws = function(block, /*optional*/error, /*optional*/message) {
  _throws(true, block, error, message);
};

// EXTENSION! This is annoying to write outside this module.
assert.doesNotThrow = function(block, /*optional*/error, /*optional*/message) {
  _throws(false, block, error, message);
};

assert.ifError = function(err) { if (err) throw err; };

var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    if (hasOwn.call(obj, key)) keys.push(key);
  }
  return keys;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"util/":199}],2:[function(require,module,exports){
(function (process,global){
/* @preserve
 * The MIT License (MIT)
 *
 * Copyright (c) 2013-2017 Petka Antonov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 */
/**
 * bluebird build version 3.5.0
 * Features enabled: core, race, call_get, generators, map, nodeify, promisify, props, reduce, settle, some, using, timers, filter, any, each
*/
!function(e){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=e();else if("function"==typeof define&&define.amd)define([],e);else{var f;"undefined"!=typeof window?f=window:"undefined"!=typeof global?f=global:"undefined"!=typeof self&&(f=self),f.Promise=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof _dereq_=="function"&&_dereq_;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof _dereq_=="function"&&_dereq_;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
"use strict";
module.exports = function(Promise) {
var SomePromiseArray = Promise._SomePromiseArray;
function any(promises) {
    var ret = new SomePromiseArray(promises);
    var promise = ret.promise();
    ret.setHowMany(1);
    ret.setUnwrap();
    ret.init();
    return promise;
}

Promise.any = function (promises) {
    return any(promises);
};

Promise.prototype.any = function () {
    return any(this);
};

};

},{}],2:[function(_dereq_,module,exports){
"use strict";
var firstLineError;
try {throw new Error(); } catch (e) {firstLineError = e;}
var schedule = _dereq_("./schedule");
var Queue = _dereq_("./queue");
var util = _dereq_("./util");

function Async() {
    this._customScheduler = false;
    this._isTickUsed = false;
    this._lateQueue = new Queue(16);
    this._normalQueue = new Queue(16);
    this._haveDrainedQueues = false;
    this._trampolineEnabled = true;
    var self = this;
    this.drainQueues = function () {
        self._drainQueues();
    };
    this._schedule = schedule;
}

Async.prototype.setScheduler = function(fn) {
    var prev = this._schedule;
    this._schedule = fn;
    this._customScheduler = true;
    return prev;
};

Async.prototype.hasCustomScheduler = function() {
    return this._customScheduler;
};

Async.prototype.enableTrampoline = function() {
    this._trampolineEnabled = true;
};

Async.prototype.disableTrampolineIfNecessary = function() {
    if (util.hasDevTools) {
        this._trampolineEnabled = false;
    }
};

Async.prototype.haveItemsQueued = function () {
    return this._isTickUsed || this._haveDrainedQueues;
};


Async.prototype.fatalError = function(e, isNode) {
    if (isNode) {
        process.stderr.write("Fatal " + (e instanceof Error ? e.stack : e) +
            "\n");
        process.exit(2);
    } else {
        this.throwLater(e);
    }
};

Async.prototype.throwLater = function(fn, arg) {
    if (arguments.length === 1) {
        arg = fn;
        fn = function () { throw arg; };
    }
    if (typeof setTimeout !== "undefined") {
        setTimeout(function() {
            fn(arg);
        }, 0);
    } else try {
        this._schedule(function() {
            fn(arg);
        });
    } catch (e) {
        throw new Error("No async scheduler available\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
    }
};

function AsyncInvokeLater(fn, receiver, arg) {
    this._lateQueue.push(fn, receiver, arg);
    this._queueTick();
}

function AsyncInvoke(fn, receiver, arg) {
    this._normalQueue.push(fn, receiver, arg);
    this._queueTick();
}

function AsyncSettlePromises(promise) {
    this._normalQueue._pushOne(promise);
    this._queueTick();
}

if (!util.hasDevTools) {
    Async.prototype.invokeLater = AsyncInvokeLater;
    Async.prototype.invoke = AsyncInvoke;
    Async.prototype.settlePromises = AsyncSettlePromises;
} else {
    Async.prototype.invokeLater = function (fn, receiver, arg) {
        if (this._trampolineEnabled) {
            AsyncInvokeLater.call(this, fn, receiver, arg);
        } else {
            this._schedule(function() {
                setTimeout(function() {
                    fn.call(receiver, arg);
                }, 100);
            });
        }
    };

    Async.prototype.invoke = function (fn, receiver, arg) {
        if (this._trampolineEnabled) {
            AsyncInvoke.call(this, fn, receiver, arg);
        } else {
            this._schedule(function() {
                fn.call(receiver, arg);
            });
        }
    };

    Async.prototype.settlePromises = function(promise) {
        if (this._trampolineEnabled) {
            AsyncSettlePromises.call(this, promise);
        } else {
            this._schedule(function() {
                promise._settlePromises();
            });
        }
    };
}

Async.prototype._drainQueue = function(queue) {
    while (queue.length() > 0) {
        var fn = queue.shift();
        if (typeof fn !== "function") {
            fn._settlePromises();
            continue;
        }
        var receiver = queue.shift();
        var arg = queue.shift();
        fn.call(receiver, arg);
    }
};

Async.prototype._drainQueues = function () {
    this._drainQueue(this._normalQueue);
    this._reset();
    this._haveDrainedQueues = true;
    this._drainQueue(this._lateQueue);
};

Async.prototype._queueTick = function () {
    if (!this._isTickUsed) {
        this._isTickUsed = true;
        this._schedule(this.drainQueues);
    }
};

Async.prototype._reset = function () {
    this._isTickUsed = false;
};

module.exports = Async;
module.exports.firstLineError = firstLineError;

},{"./queue":26,"./schedule":29,"./util":36}],3:[function(_dereq_,module,exports){
"use strict";
module.exports = function(Promise, INTERNAL, tryConvertToPromise, debug) {
var calledBind = false;
var rejectThis = function(_, e) {
    this._reject(e);
};

var targetRejected = function(e, context) {
    context.promiseRejectionQueued = true;
    context.bindingPromise._then(rejectThis, rejectThis, null, this, e);
};

var bindingResolved = function(thisArg, context) {
    if (((this._bitField & 50397184) === 0)) {
        this._resolveCallback(context.target);
    }
};

var bindingRejected = function(e, context) {
    if (!context.promiseRejectionQueued) this._reject(e);
};

Promise.prototype.bind = function (thisArg) {
    if (!calledBind) {
        calledBind = true;
        Promise.prototype._propagateFrom = debug.propagateFromFunction();
        Promise.prototype._boundValue = debug.boundValueFunction();
    }
    var maybePromise = tryConvertToPromise(thisArg);
    var ret = new Promise(INTERNAL);
    ret._propagateFrom(this, 1);
    var target = this._target();
    ret._setBoundTo(maybePromise);
    if (maybePromise instanceof Promise) {
        var context = {
            promiseRejectionQueued: false,
            promise: ret,
            target: target,
            bindingPromise: maybePromise
        };
        target._then(INTERNAL, targetRejected, undefined, ret, context);
        maybePromise._then(
            bindingResolved, bindingRejected, undefined, ret, context);
        ret._setOnCancel(maybePromise);
    } else {
        ret._resolveCallback(target);
    }
    return ret;
};

Promise.prototype._setBoundTo = function (obj) {
    if (obj !== undefined) {
        this._bitField = this._bitField | 2097152;
        this._boundTo = obj;
    } else {
        this._bitField = this._bitField & (~2097152);
    }
};

Promise.prototype._isBound = function () {
    return (this._bitField & 2097152) === 2097152;
};

Promise.bind = function (thisArg, value) {
    return Promise.resolve(value).bind(thisArg);
};
};

},{}],4:[function(_dereq_,module,exports){
"use strict";
var old;
if (typeof Promise !== "undefined") old = Promise;
function noConflict() {
    try { if (Promise === bluebird) Promise = old; }
    catch (e) {}
    return bluebird;
}
var bluebird = _dereq_("./promise")();
bluebird.noConflict = noConflict;
module.exports = bluebird;

},{"./promise":22}],5:[function(_dereq_,module,exports){
"use strict";
var cr = Object.create;
if (cr) {
    var callerCache = cr(null);
    var getterCache = cr(null);
    callerCache[" size"] = getterCache[" size"] = 0;
}

module.exports = function(Promise) {
var util = _dereq_("./util");
var canEvaluate = util.canEvaluate;
var isIdentifier = util.isIdentifier;

var getMethodCaller;
var getGetter;
if (!true) {
var makeMethodCaller = function (methodName) {
    return new Function("ensureMethod", "                                    \n\
        return function(obj) {                                               \n\
            'use strict'                                                     \n\
            var len = this.length;                                           \n\
            ensureMethod(obj, 'methodName');                                 \n\
            switch(len) {                                                    \n\
                case 1: return obj.methodName(this[0]);                      \n\
                case 2: return obj.methodName(this[0], this[1]);             \n\
                case 3: return obj.methodName(this[0], this[1], this[2]);    \n\
                case 0: return obj.methodName();                             \n\
                default:                                                     \n\
                    return obj.methodName.apply(obj, this);                  \n\
            }                                                                \n\
        };                                                                   \n\
        ".replace(/methodName/g, methodName))(ensureMethod);
};

var makeGetter = function (propertyName) {
    return new Function("obj", "                                             \n\
        'use strict';                                                        \n\
        return obj.propertyName;                                             \n\
        ".replace("propertyName", propertyName));
};

var getCompiled = function(name, compiler, cache) {
    var ret = cache[name];
    if (typeof ret !== "function") {
        if (!isIdentifier(name)) {
            return null;
        }
        ret = compiler(name);
        cache[name] = ret;
        cache[" size"]++;
        if (cache[" size"] > 512) {
            var keys = Object.keys(cache);
            for (var i = 0; i < 256; ++i) delete cache[keys[i]];
            cache[" size"] = keys.length - 256;
        }
    }
    return ret;
};

getMethodCaller = function(name) {
    return getCompiled(name, makeMethodCaller, callerCache);
};

getGetter = function(name) {
    return getCompiled(name, makeGetter, getterCache);
};
}

function ensureMethod(obj, methodName) {
    var fn;
    if (obj != null) fn = obj[methodName];
    if (typeof fn !== "function") {
        var message = "Object " + util.classString(obj) + " has no method '" +
            util.toString(methodName) + "'";
        throw new Promise.TypeError(message);
    }
    return fn;
}

function caller(obj) {
    var methodName = this.pop();
    var fn = ensureMethod(obj, methodName);
    return fn.apply(obj, this);
}
Promise.prototype.call = function (methodName) {
    var args = [].slice.call(arguments, 1);;
    if (!true) {
        if (canEvaluate) {
            var maybeCaller = getMethodCaller(methodName);
            if (maybeCaller !== null) {
                return this._then(
                    maybeCaller, undefined, undefined, args, undefined);
            }
        }
    }
    args.push(methodName);
    return this._then(caller, undefined, undefined, args, undefined);
};

function namedGetter(obj) {
    return obj[this];
}
function indexedGetter(obj) {
    var index = +this;
    if (index < 0) index = Math.max(0, index + obj.length);
    return obj[index];
}
Promise.prototype.get = function (propertyName) {
    var isIndex = (typeof propertyName === "number");
    var getter;
    if (!isIndex) {
        if (canEvaluate) {
            var maybeGetter = getGetter(propertyName);
            getter = maybeGetter !== null ? maybeGetter : namedGetter;
        } else {
            getter = namedGetter;
        }
    } else {
        getter = indexedGetter;
    }
    return this._then(getter, undefined, undefined, propertyName, undefined);
};
};

},{"./util":36}],6:[function(_dereq_,module,exports){
"use strict";
module.exports = function(Promise, PromiseArray, apiRejection, debug) {
var util = _dereq_("./util");
var tryCatch = util.tryCatch;
var errorObj = util.errorObj;
var async = Promise._async;

Promise.prototype["break"] = Promise.prototype.cancel = function() {
    if (!debug.cancellation()) return this._warn("cancellation is disabled");

    var promise = this;
    var child = promise;
    while (promise._isCancellable()) {
        if (!promise._cancelBy(child)) {
            if (child._isFollowing()) {
                child._followee().cancel();
            } else {
                child._cancelBranched();
            }
            break;
        }

        var parent = promise._cancellationParent;
        if (parent == null || !parent._isCancellable()) {
            if (promise._isFollowing()) {
                promise._followee().cancel();
            } else {
                promise._cancelBranched();
            }
            break;
        } else {
            if (promise._isFollowing()) promise._followee().cancel();
            promise._setWillBeCancelled();
            child = promise;
            promise = parent;
        }
    }
};

Promise.prototype._branchHasCancelled = function() {
    this._branchesRemainingToCancel--;
};

Promise.prototype._enoughBranchesHaveCancelled = function() {
    return this._branchesRemainingToCancel === undefined ||
           this._branchesRemainingToCancel <= 0;
};

Promise.prototype._cancelBy = function(canceller) {
    if (canceller === this) {
        this._branchesRemainingToCancel = 0;
        this._invokeOnCancel();
        return true;
    } else {
        this._branchHasCancelled();
        if (this._enoughBranchesHaveCancelled()) {
            this._invokeOnCancel();
            return true;
        }
    }
    return false;
};

Promise.prototype._cancelBranched = function() {
    if (this._enoughBranchesHaveCancelled()) {
        this._cancel();
    }
};

Promise.prototype._cancel = function() {
    if (!this._isCancellable()) return;
    this._setCancelled();
    async.invoke(this._cancelPromises, this, undefined);
};

Promise.prototype._cancelPromises = function() {
    if (this._length() > 0) this._settlePromises();
};

Promise.prototype._unsetOnCancel = function() {
    this._onCancelField = undefined;
};

Promise.prototype._isCancellable = function() {
    return this.isPending() && !this._isCancelled();
};

Promise.prototype.isCancellable = function() {
    return this.isPending() && !this.isCancelled();
};

Promise.prototype._doInvokeOnCancel = function(onCancelCallback, internalOnly) {
    if (util.isArray(onCancelCallback)) {
        for (var i = 0; i < onCancelCallback.length; ++i) {
            this._doInvokeOnCancel(onCancelCallback[i], internalOnly);
        }
    } else if (onCancelCallback !== undefined) {
        if (typeof onCancelCallback === "function") {
            if (!internalOnly) {
                var e = tryCatch(onCancelCallback).call(this._boundValue());
                if (e === errorObj) {
                    this._attachExtraTrace(e.e);
                    async.throwLater(e.e);
                }
            }
        } else {
            onCancelCallback._resultCancelled(this);
        }
    }
};

Promise.prototype._invokeOnCancel = function() {
    var onCancelCallback = this._onCancel();
    this._unsetOnCancel();
    async.invoke(this._doInvokeOnCancel, this, onCancelCallback);
};

Promise.prototype._invokeInternalOnCancel = function() {
    if (this._isCancellable()) {
        this._doInvokeOnCancel(this._onCancel(), true);
        this._unsetOnCancel();
    }
};

Promise.prototype._resultCancelled = function() {
    this.cancel();
};

};

},{"./util":36}],7:[function(_dereq_,module,exports){
"use strict";
module.exports = function(NEXT_FILTER) {
var util = _dereq_("./util");
var getKeys = _dereq_("./es5").keys;
var tryCatch = util.tryCatch;
var errorObj = util.errorObj;

function catchFilter(instances, cb, promise) {
    return function(e) {
        var boundTo = promise._boundValue();
        predicateLoop: for (var i = 0; i < instances.length; ++i) {
            var item = instances[i];

            if (item === Error ||
                (item != null && item.prototype instanceof Error)) {
                if (e instanceof item) {
                    return tryCatch(cb).call(boundTo, e);
                }
            } else if (typeof item === "function") {
                var matchesPredicate = tryCatch(item).call(boundTo, e);
                if (matchesPredicate === errorObj) {
                    return matchesPredicate;
                } else if (matchesPredicate) {
                    return tryCatch(cb).call(boundTo, e);
                }
            } else if (util.isObject(e)) {
                var keys = getKeys(item);
                for (var j = 0; j < keys.length; ++j) {
                    var key = keys[j];
                    if (item[key] != e[key]) {
                        continue predicateLoop;
                    }
                }
                return tryCatch(cb).call(boundTo, e);
            }
        }
        return NEXT_FILTER;
    };
}

return catchFilter;
};

},{"./es5":13,"./util":36}],8:[function(_dereq_,module,exports){
"use strict";
module.exports = function(Promise) {
var longStackTraces = false;
var contextStack = [];

Promise.prototype._promiseCreated = function() {};
Promise.prototype._pushContext = function() {};
Promise.prototype._popContext = function() {return null;};
Promise._peekContext = Promise.prototype._peekContext = function() {};

function Context() {
    this._trace = new Context.CapturedTrace(peekContext());
}
Context.prototype._pushContext = function () {
    if (this._trace !== undefined) {
        this._trace._promiseCreated = null;
        contextStack.push(this._trace);
    }
};

Context.prototype._popContext = function () {
    if (this._trace !== undefined) {
        var trace = contextStack.pop();
        var ret = trace._promiseCreated;
        trace._promiseCreated = null;
        return ret;
    }
    return null;
};

function createContext() {
    if (longStackTraces) return new Context();
}

function peekContext() {
    var lastIndex = contextStack.length - 1;
    if (lastIndex >= 0) {
        return contextStack[lastIndex];
    }
    return undefined;
}
Context.CapturedTrace = null;
Context.create = createContext;
Context.deactivateLongStackTraces = function() {};
Context.activateLongStackTraces = function() {
    var Promise_pushContext = Promise.prototype._pushContext;
    var Promise_popContext = Promise.prototype._popContext;
    var Promise_PeekContext = Promise._peekContext;
    var Promise_peekContext = Promise.prototype._peekContext;
    var Promise_promiseCreated = Promise.prototype._promiseCreated;
    Context.deactivateLongStackTraces = function() {
        Promise.prototype._pushContext = Promise_pushContext;
        Promise.prototype._popContext = Promise_popContext;
        Promise._peekContext = Promise_PeekContext;
        Promise.prototype._peekContext = Promise_peekContext;
        Promise.prototype._promiseCreated = Promise_promiseCreated;
        longStackTraces = false;
    };
    longStackTraces = true;
    Promise.prototype._pushContext = Context.prototype._pushContext;
    Promise.prototype._popContext = Context.prototype._popContext;
    Promise._peekContext = Promise.prototype._peekContext = peekContext;
    Promise.prototype._promiseCreated = function() {
        var ctx = this._peekContext();
        if (ctx && ctx._promiseCreated == null) ctx._promiseCreated = this;
    };
};
return Context;
};

},{}],9:[function(_dereq_,module,exports){
"use strict";
module.exports = function(Promise, Context) {
var getDomain = Promise._getDomain;
var async = Promise._async;
var Warning = _dereq_("./errors").Warning;
var util = _dereq_("./util");
var canAttachTrace = util.canAttachTrace;
var unhandledRejectionHandled;
var possiblyUnhandledRejection;
var bluebirdFramePattern =
    /[\\\/]bluebird[\\\/]js[\\\/](release|debug|instrumented)/;
var nodeFramePattern = /\((?:timers\.js):\d+:\d+\)/;
var parseLinePattern = /[\/<\(](.+?):(\d+):(\d+)\)?\s*$/;
var stackFramePattern = null;
var formatStack = null;
var indentStackFrames = false;
var printWarning;
var debugging = !!(util.env("BLUEBIRD_DEBUG") != 0 &&
                        (true ||
                         util.env("BLUEBIRD_DEBUG") ||
                         util.env("NODE_ENV") === "development"));

var warnings = !!(util.env("BLUEBIRD_WARNINGS") != 0 &&
    (debugging || util.env("BLUEBIRD_WARNINGS")));

var longStackTraces = !!(util.env("BLUEBIRD_LONG_STACK_TRACES") != 0 &&
    (debugging || util.env("BLUEBIRD_LONG_STACK_TRACES")));

var wForgottenReturn = util.env("BLUEBIRD_W_FORGOTTEN_RETURN") != 0 &&
    (warnings || !!util.env("BLUEBIRD_W_FORGOTTEN_RETURN"));

Promise.prototype.suppressUnhandledRejections = function() {
    var target = this._target();
    target._bitField = ((target._bitField & (~1048576)) |
                      524288);
};

Promise.prototype._ensurePossibleRejectionHandled = function () {
    if ((this._bitField & 524288) !== 0) return;
    this._setRejectionIsUnhandled();
    async.invokeLater(this._notifyUnhandledRejection, this, undefined);
};

Promise.prototype._notifyUnhandledRejectionIsHandled = function () {
    fireRejectionEvent("rejectionHandled",
                                  unhandledRejectionHandled, undefined, this);
};

Promise.prototype._setReturnedNonUndefined = function() {
    this._bitField = this._bitField | 268435456;
};

Promise.prototype._returnedNonUndefined = function() {
    return (this._bitField & 268435456) !== 0;
};

Promise.prototype._notifyUnhandledRejection = function () {
    if (this._isRejectionUnhandled()) {
        var reason = this._settledValue();
        this._setUnhandledRejectionIsNotified();
        fireRejectionEvent("unhandledRejection",
                                      possiblyUnhandledRejection, reason, this);
    }
};

Promise.prototype._setUnhandledRejectionIsNotified = function () {
    this._bitField = this._bitField | 262144;
};

Promise.prototype._unsetUnhandledRejectionIsNotified = function () {
    this._bitField = this._bitField & (~262144);
};

Promise.prototype._isUnhandledRejectionNotified = function () {
    return (this._bitField & 262144) > 0;
};

Promise.prototype._setRejectionIsUnhandled = function () {
    this._bitField = this._bitField | 1048576;
};

Promise.prototype._unsetRejectionIsUnhandled = function () {
    this._bitField = this._bitField & (~1048576);
    if (this._isUnhandledRejectionNotified()) {
        this._unsetUnhandledRejectionIsNotified();
        this._notifyUnhandledRejectionIsHandled();
    }
};

Promise.prototype._isRejectionUnhandled = function () {
    return (this._bitField & 1048576) > 0;
};

Promise.prototype._warn = function(message, shouldUseOwnTrace, promise) {
    return warn(message, shouldUseOwnTrace, promise || this);
};

Promise.onPossiblyUnhandledRejection = function (fn) {
    var domain = getDomain();
    possiblyUnhandledRejection =
        typeof fn === "function" ? (domain === null ?
                                            fn : util.domainBind(domain, fn))
                                 : undefined;
};

Promise.onUnhandledRejectionHandled = function (fn) {
    var domain = getDomain();
    unhandledRejectionHandled =
        typeof fn === "function" ? (domain === null ?
                                            fn : util.domainBind(domain, fn))
                                 : undefined;
};

var disableLongStackTraces = function() {};
Promise.longStackTraces = function () {
    if (async.haveItemsQueued() && !config.longStackTraces) {
        throw new Error("cannot enable long stack traces after promises have been created\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
    }
    if (!config.longStackTraces && longStackTracesIsSupported()) {
        var Promise_captureStackTrace = Promise.prototype._captureStackTrace;
        var Promise_attachExtraTrace = Promise.prototype._attachExtraTrace;
        config.longStackTraces = true;
        disableLongStackTraces = function() {
            if (async.haveItemsQueued() && !config.longStackTraces) {
                throw new Error("cannot enable long stack traces after promises have been created\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
            }
            Promise.prototype._captureStackTrace = Promise_captureStackTrace;
            Promise.prototype._attachExtraTrace = Promise_attachExtraTrace;
            Context.deactivateLongStackTraces();
            async.enableTrampoline();
            config.longStackTraces = false;
        };
        Promise.prototype._captureStackTrace = longStackTracesCaptureStackTrace;
        Promise.prototype._attachExtraTrace = longStackTracesAttachExtraTrace;
        Context.activateLongStackTraces();
        async.disableTrampolineIfNecessary();
    }
};

Promise.hasLongStackTraces = function () {
    return config.longStackTraces && longStackTracesIsSupported();
};

var fireDomEvent = (function() {
    try {
        if (typeof CustomEvent === "function") {
            var event = new CustomEvent("CustomEvent");
            util.global.dispatchEvent(event);
            return function(name, event) {
                var domEvent = new CustomEvent(name.toLowerCase(), {
                    detail: event,
                    cancelable: true
                });
                return !util.global.dispatchEvent(domEvent);
            };
        } else if (typeof Event === "function") {
            var event = new Event("CustomEvent");
            util.global.dispatchEvent(event);
            return function(name, event) {
                var domEvent = new Event(name.toLowerCase(), {
                    cancelable: true
                });
                domEvent.detail = event;
                return !util.global.dispatchEvent(domEvent);
            };
        } else {
            var event = document.createEvent("CustomEvent");
            event.initCustomEvent("testingtheevent", false, true, {});
            util.global.dispatchEvent(event);
            return function(name, event) {
                var domEvent = document.createEvent("CustomEvent");
                domEvent.initCustomEvent(name.toLowerCase(), false, true,
                    event);
                return !util.global.dispatchEvent(domEvent);
            };
        }
    } catch (e) {}
    return function() {
        return false;
    };
})();

var fireGlobalEvent = (function() {
    if (util.isNode) {
        return function() {
            return process.emit.apply(process, arguments);
        };
    } else {
        if (!util.global) {
            return function() {
                return false;
            };
        }
        return function(name) {
            var methodName = "on" + name.toLowerCase();
            var method = util.global[methodName];
            if (!method) return false;
            method.apply(util.global, [].slice.call(arguments, 1));
            return true;
        };
    }
})();

function generatePromiseLifecycleEventObject(name, promise) {
    return {promise: promise};
}

var eventToObjectGenerator = {
    promiseCreated: generatePromiseLifecycleEventObject,
    promiseFulfilled: generatePromiseLifecycleEventObject,
    promiseRejected: generatePromiseLifecycleEventObject,
    promiseResolved: generatePromiseLifecycleEventObject,
    promiseCancelled: generatePromiseLifecycleEventObject,
    promiseChained: function(name, promise, child) {
        return {promise: promise, child: child};
    },
    warning: function(name, warning) {
        return {warning: warning};
    },
    unhandledRejection: function (name, reason, promise) {
        return {reason: reason, promise: promise};
    },
    rejectionHandled: generatePromiseLifecycleEventObject
};

var activeFireEvent = function (name) {
    var globalEventFired = false;
    try {
        globalEventFired = fireGlobalEvent.apply(null, arguments);
    } catch (e) {
        async.throwLater(e);
        globalEventFired = true;
    }

    var domEventFired = false;
    try {
        domEventFired = fireDomEvent(name,
                    eventToObjectGenerator[name].apply(null, arguments));
    } catch (e) {
        async.throwLater(e);
        domEventFired = true;
    }

    return domEventFired || globalEventFired;
};

Promise.config = function(opts) {
    opts = Object(opts);
    if ("longStackTraces" in opts) {
        if (opts.longStackTraces) {
            Promise.longStackTraces();
        } else if (!opts.longStackTraces && Promise.hasLongStackTraces()) {
            disableLongStackTraces();
        }
    }
    if ("warnings" in opts) {
        var warningsOption = opts.warnings;
        config.warnings = !!warningsOption;
        wForgottenReturn = config.warnings;

        if (util.isObject(warningsOption)) {
            if ("wForgottenReturn" in warningsOption) {
                wForgottenReturn = !!warningsOption.wForgottenReturn;
            }
        }
    }
    if ("cancellation" in opts && opts.cancellation && !config.cancellation) {
        if (async.haveItemsQueued()) {
            throw new Error(
                "cannot enable cancellation after promises are in use");
        }
        Promise.prototype._clearCancellationData =
            cancellationClearCancellationData;
        Promise.prototype._propagateFrom = cancellationPropagateFrom;
        Promise.prototype._onCancel = cancellationOnCancel;
        Promise.prototype._setOnCancel = cancellationSetOnCancel;
        Promise.prototype._attachCancellationCallback =
            cancellationAttachCancellationCallback;
        Promise.prototype._execute = cancellationExecute;
        propagateFromFunction = cancellationPropagateFrom;
        config.cancellation = true;
    }
    if ("monitoring" in opts) {
        if (opts.monitoring && !config.monitoring) {
            config.monitoring = true;
            Promise.prototype._fireEvent = activeFireEvent;
        } else if (!opts.monitoring && config.monitoring) {
            config.monitoring = false;
            Promise.prototype._fireEvent = defaultFireEvent;
        }
    }
    return Promise;
};

function defaultFireEvent() { return false; }

Promise.prototype._fireEvent = defaultFireEvent;
Promise.prototype._execute = function(executor, resolve, reject) {
    try {
        executor(resolve, reject);
    } catch (e) {
        return e;
    }
};
Promise.prototype._onCancel = function () {};
Promise.prototype._setOnCancel = function (handler) { ; };
Promise.prototype._attachCancellationCallback = function(onCancel) {
    ;
};
Promise.prototype._captureStackTrace = function () {};
Promise.prototype._attachExtraTrace = function () {};
Promise.prototype._clearCancellationData = function() {};
Promise.prototype._propagateFrom = function (parent, flags) {
    ;
    ;
};

function cancellationExecute(executor, resolve, reject) {
    var promise = this;
    try {
        executor(resolve, reject, function(onCancel) {
            if (typeof onCancel !== "function") {
                throw new TypeError("onCancel must be a function, got: " +
                                    util.toString(onCancel));
            }
            promise._attachCancellationCallback(onCancel);
        });
    } catch (e) {
        return e;
    }
}

function cancellationAttachCancellationCallback(onCancel) {
    if (!this._isCancellable()) return this;

    var previousOnCancel = this._onCancel();
    if (previousOnCancel !== undefined) {
        if (util.isArray(previousOnCancel)) {
            previousOnCancel.push(onCancel);
        } else {
            this._setOnCancel([previousOnCancel, onCancel]);
        }
    } else {
        this._setOnCancel(onCancel);
    }
}

function cancellationOnCancel() {
    return this._onCancelField;
}

function cancellationSetOnCancel(onCancel) {
    this._onCancelField = onCancel;
}

function cancellationClearCancellationData() {
    this._cancellationParent = undefined;
    this._onCancelField = undefined;
}

function cancellationPropagateFrom(parent, flags) {
    if ((flags & 1) !== 0) {
        this._cancellationParent = parent;
        var branchesRemainingToCancel = parent._branchesRemainingToCancel;
        if (branchesRemainingToCancel === undefined) {
            branchesRemainingToCancel = 0;
        }
        parent._branchesRemainingToCancel = branchesRemainingToCancel + 1;
    }
    if ((flags & 2) !== 0 && parent._isBound()) {
        this._setBoundTo(parent._boundTo);
    }
}

function bindingPropagateFrom(parent, flags) {
    if ((flags & 2) !== 0 && parent._isBound()) {
        this._setBoundTo(parent._boundTo);
    }
}
var propagateFromFunction = bindingPropagateFrom;

function boundValueFunction() {
    var ret = this._boundTo;
    if (ret !== undefined) {
        if (ret instanceof Promise) {
            if (ret.isFulfilled()) {
                return ret.value();
            } else {
                return undefined;
            }
        }
    }
    return ret;
}

function longStackTracesCaptureStackTrace() {
    this._trace = new CapturedTrace(this._peekContext());
}

function longStackTracesAttachExtraTrace(error, ignoreSelf) {
    if (canAttachTrace(error)) {
        var trace = this._trace;
        if (trace !== undefined) {
            if (ignoreSelf) trace = trace._parent;
        }
        if (trace !== undefined) {
            trace.attachExtraTrace(error);
        } else if (!error.__stackCleaned__) {
            var parsed = parseStackAndMessage(error);
            util.notEnumerableProp(error, "stack",
                parsed.message + "\n" + parsed.stack.join("\n"));
            util.notEnumerableProp(error, "__stackCleaned__", true);
        }
    }
}

function checkForgottenReturns(returnValue, promiseCreated, name, promise,
                               parent) {
    if (returnValue === undefined && promiseCreated !== null &&
        wForgottenReturn) {
        if (parent !== undefined && parent._returnedNonUndefined()) return;
        if ((promise._bitField & 65535) === 0) return;

        if (name) name = name + " ";
        var handlerLine = "";
        var creatorLine = "";
        if (promiseCreated._trace) {
            var traceLines = promiseCreated._trace.stack.split("\n");
            var stack = cleanStack(traceLines);
            for (var i = stack.length - 1; i >= 0; --i) {
                var line = stack[i];
                if (!nodeFramePattern.test(line)) {
                    var lineMatches = line.match(parseLinePattern);
                    if (lineMatches) {
                        handlerLine  = "at " + lineMatches[1] +
                            ":" + lineMatches[2] + ":" + lineMatches[3] + " ";
                    }
                    break;
                }
            }

            if (stack.length > 0) {
                var firstUserLine = stack[0];
                for (var i = 0; i < traceLines.length; ++i) {

                    if (traceLines[i] === firstUserLine) {
                        if (i > 0) {
                            creatorLine = "\n" + traceLines[i - 1];
                        }
                        break;
                    }
                }

            }
        }
        var msg = "a promise was created in a " + name +
            "handler " + handlerLine + "but was not returned from it, " +
            "see http://goo.gl/rRqMUw" +
            creatorLine;
        promise._warn(msg, true, promiseCreated);
    }
}

function deprecated(name, replacement) {
    var message = name +
        " is deprecated and will be removed in a future version.";
    if (replacement) message += " Use " + replacement + " instead.";
    return warn(message);
}

function warn(message, shouldUseOwnTrace, promise) {
    if (!config.warnings) return;
    var warning = new Warning(message);
    var ctx;
    if (shouldUseOwnTrace) {
        promise._attachExtraTrace(warning);
    } else if (config.longStackTraces && (ctx = Promise._peekContext())) {
        ctx.attachExtraTrace(warning);
    } else {
        var parsed = parseStackAndMessage(warning);
        warning.stack = parsed.message + "\n" + parsed.stack.join("\n");
    }

    if (!activeFireEvent("warning", warning)) {
        formatAndLogError(warning, "", true);
    }
}

function reconstructStack(message, stacks) {
    for (var i = 0; i < stacks.length - 1; ++i) {
        stacks[i].push("From previous event:");
        stacks[i] = stacks[i].join("\n");
    }
    if (i < stacks.length) {
        stacks[i] = stacks[i].join("\n");
    }
    return message + "\n" + stacks.join("\n");
}

function removeDuplicateOrEmptyJumps(stacks) {
    for (var i = 0; i < stacks.length; ++i) {
        if (stacks[i].length === 0 ||
            ((i + 1 < stacks.length) && stacks[i][0] === stacks[i+1][0])) {
            stacks.splice(i, 1);
            i--;
        }
    }
}

function removeCommonRoots(stacks) {
    var current = stacks[0];
    for (var i = 1; i < stacks.length; ++i) {
        var prev = stacks[i];
        var currentLastIndex = current.length - 1;
        var currentLastLine = current[currentLastIndex];
        var commonRootMeetPoint = -1;

        for (var j = prev.length - 1; j >= 0; --j) {
            if (prev[j] === currentLastLine) {
                commonRootMeetPoint = j;
                break;
            }
        }

        for (var j = commonRootMeetPoint; j >= 0; --j) {
            var line = prev[j];
            if (current[currentLastIndex] === line) {
                current.pop();
                currentLastIndex--;
            } else {
                break;
            }
        }
        current = prev;
    }
}

function cleanStack(stack) {
    var ret = [];
    for (var i = 0; i < stack.length; ++i) {
        var line = stack[i];
        var isTraceLine = "    (No stack trace)" === line ||
            stackFramePattern.test(line);
        var isInternalFrame = isTraceLine && shouldIgnore(line);
        if (isTraceLine && !isInternalFrame) {
            if (indentStackFrames && line.charAt(0) !== " ") {
                line = "    " + line;
            }
            ret.push(line);
        }
    }
    return ret;
}

function stackFramesAsArray(error) {
    var stack = error.stack.replace(/\s+$/g, "").split("\n");
    for (var i = 0; i < stack.length; ++i) {
        var line = stack[i];
        if ("    (No stack trace)" === line || stackFramePattern.test(line)) {
            break;
        }
    }
    if (i > 0 && error.name != "SyntaxError") {
        stack = stack.slice(i);
    }
    return stack;
}

function parseStackAndMessage(error) {
    var stack = error.stack;
    var message = error.toString();
    stack = typeof stack === "string" && stack.length > 0
                ? stackFramesAsArray(error) : ["    (No stack trace)"];
    return {
        message: message,
        stack: error.name == "SyntaxError" ? stack : cleanStack(stack)
    };
}

function formatAndLogError(error, title, isSoft) {
    if (typeof console !== "undefined") {
        var message;
        if (util.isObject(error)) {
            var stack = error.stack;
            message = title + formatStack(stack, error);
        } else {
            message = title + String(error);
        }
        if (typeof printWarning === "function") {
            printWarning(message, isSoft);
        } else if (typeof console.log === "function" ||
            typeof console.log === "object") {
            console.log(message);
        }
    }
}

function fireRejectionEvent(name, localHandler, reason, promise) {
    var localEventFired = false;
    try {
        if (typeof localHandler === "function") {
            localEventFired = true;
            if (name === "rejectionHandled") {
                localHandler(promise);
            } else {
                localHandler(reason, promise);
            }
        }
    } catch (e) {
        async.throwLater(e);
    }

    if (name === "unhandledRejection") {
        if (!activeFireEvent(name, reason, promise) && !localEventFired) {
            formatAndLogError(reason, "Unhandled rejection ");
        }
    } else {
        activeFireEvent(name, promise);
    }
}

function formatNonError(obj) {
    var str;
    if (typeof obj === "function") {
        str = "[function " +
            (obj.name || "anonymous") +
            "]";
    } else {
        str = obj && typeof obj.toString === "function"
            ? obj.toString() : util.toString(obj);
        var ruselessToString = /\[object [a-zA-Z0-9$_]+\]/;
        if (ruselessToString.test(str)) {
            try {
                var newStr = JSON.stringify(obj);
                str = newStr;
            }
            catch(e) {

            }
        }
        if (str.length === 0) {
            str = "(empty array)";
        }
    }
    return ("(<" + snip(str) + ">, no stack trace)");
}

function snip(str) {
    var maxChars = 41;
    if (str.length < maxChars) {
        return str;
    }
    return str.substr(0, maxChars - 3) + "...";
}

function longStackTracesIsSupported() {
    return typeof captureStackTrace === "function";
}

var shouldIgnore = function() { return false; };
var parseLineInfoRegex = /[\/<\(]([^:\/]+):(\d+):(?:\d+)\)?\s*$/;
function parseLineInfo(line) {
    var matches = line.match(parseLineInfoRegex);
    if (matches) {
        return {
            fileName: matches[1],
            line: parseInt(matches[2], 10)
        };
    }
}

function setBounds(firstLineError, lastLineError) {
    if (!longStackTracesIsSupported()) return;
    var firstStackLines = firstLineError.stack.split("\n");
    var lastStackLines = lastLineError.stack.split("\n");
    var firstIndex = -1;
    var lastIndex = -1;
    var firstFileName;
    var lastFileName;
    for (var i = 0; i < firstStackLines.length; ++i) {
        var result = parseLineInfo(firstStackLines[i]);
        if (result) {
            firstFileName = result.fileName;
            firstIndex = result.line;
            break;
        }
    }
    for (var i = 0; i < lastStackLines.length; ++i) {
        var result = parseLineInfo(lastStackLines[i]);
        if (result) {
            lastFileName = result.fileName;
            lastIndex = result.line;
            break;
        }
    }
    if (firstIndex < 0 || lastIndex < 0 || !firstFileName || !lastFileName ||
        firstFileName !== lastFileName || firstIndex >= lastIndex) {
        return;
    }

    shouldIgnore = function(line) {
        if (bluebirdFramePattern.test(line)) return true;
        var info = parseLineInfo(line);
        if (info) {
            if (info.fileName === firstFileName &&
                (firstIndex <= info.line && info.line <= lastIndex)) {
                return true;
            }
        }
        return false;
    };
}

function CapturedTrace(parent) {
    this._parent = parent;
    this._promisesCreated = 0;
    var length = this._length = 1 + (parent === undefined ? 0 : parent._length);
    captureStackTrace(this, CapturedTrace);
    if (length > 32) this.uncycle();
}
util.inherits(CapturedTrace, Error);
Context.CapturedTrace = CapturedTrace;

CapturedTrace.prototype.uncycle = function() {
    var length = this._length;
    if (length < 2) return;
    var nodes = [];
    var stackToIndex = {};

    for (var i = 0, node = this; node !== undefined; ++i) {
        nodes.push(node);
        node = node._parent;
    }
    length = this._length = i;
    for (var i = length - 1; i >= 0; --i) {
        var stack = nodes[i].stack;
        if (stackToIndex[stack] === undefined) {
            stackToIndex[stack] = i;
        }
    }
    for (var i = 0; i < length; ++i) {
        var currentStack = nodes[i].stack;
        var index = stackToIndex[currentStack];
        if (index !== undefined && index !== i) {
            if (index > 0) {
                nodes[index - 1]._parent = undefined;
                nodes[index - 1]._length = 1;
            }
            nodes[i]._parent = undefined;
            nodes[i]._length = 1;
            var cycleEdgeNode = i > 0 ? nodes[i - 1] : this;

            if (index < length - 1) {
                cycleEdgeNode._parent = nodes[index + 1];
                cycleEdgeNode._parent.uncycle();
                cycleEdgeNode._length =
                    cycleEdgeNode._parent._length + 1;
            } else {
                cycleEdgeNode._parent = undefined;
                cycleEdgeNode._length = 1;
            }
            var currentChildLength = cycleEdgeNode._length + 1;
            for (var j = i - 2; j >= 0; --j) {
                nodes[j]._length = currentChildLength;
                currentChildLength++;
            }
            return;
        }
    }
};

CapturedTrace.prototype.attachExtraTrace = function(error) {
    if (error.__stackCleaned__) return;
    this.uncycle();
    var parsed = parseStackAndMessage(error);
    var message = parsed.message;
    var stacks = [parsed.stack];

    var trace = this;
    while (trace !== undefined) {
        stacks.push(cleanStack(trace.stack.split("\n")));
        trace = trace._parent;
    }
    removeCommonRoots(stacks);
    removeDuplicateOrEmptyJumps(stacks);
    util.notEnumerableProp(error, "stack", reconstructStack(message, stacks));
    util.notEnumerableProp(error, "__stackCleaned__", true);
};

var captureStackTrace = (function stackDetection() {
    var v8stackFramePattern = /^\s*at\s*/;
    var v8stackFormatter = function(stack, error) {
        if (typeof stack === "string") return stack;

        if (error.name !== undefined &&
            error.message !== undefined) {
            return error.toString();
        }
        return formatNonError(error);
    };

    if (typeof Error.stackTraceLimit === "number" &&
        typeof Error.captureStackTrace === "function") {
        Error.stackTraceLimit += 6;
        stackFramePattern = v8stackFramePattern;
        formatStack = v8stackFormatter;
        var captureStackTrace = Error.captureStackTrace;

        shouldIgnore = function(line) {
            return bluebirdFramePattern.test(line);
        };
        return function(receiver, ignoreUntil) {
            Error.stackTraceLimit += 6;
            captureStackTrace(receiver, ignoreUntil);
            Error.stackTraceLimit -= 6;
        };
    }
    var err = new Error();

    if (typeof err.stack === "string" &&
        err.stack.split("\n")[0].indexOf("stackDetection@") >= 0) {
        stackFramePattern = /@/;
        formatStack = v8stackFormatter;
        indentStackFrames = true;
        return function captureStackTrace(o) {
            o.stack = new Error().stack;
        };
    }

    var hasStackAfterThrow;
    try { throw new Error(); }
    catch(e) {
        hasStackAfterThrow = ("stack" in e);
    }
    if (!("stack" in err) && hasStackAfterThrow &&
        typeof Error.stackTraceLimit === "number") {
        stackFramePattern = v8stackFramePattern;
        formatStack = v8stackFormatter;
        return function captureStackTrace(o) {
            Error.stackTraceLimit += 6;
            try { throw new Error(); }
            catch(e) { o.stack = e.stack; }
            Error.stackTraceLimit -= 6;
        };
    }

    formatStack = function(stack, error) {
        if (typeof stack === "string") return stack;

        if ((typeof error === "object" ||
            typeof error === "function") &&
            error.name !== undefined &&
            error.message !== undefined) {
            return error.toString();
        }
        return formatNonError(error);
    };

    return null;

})([]);

if (typeof console !== "undefined" && typeof console.warn !== "undefined") {
    printWarning = function (message) {
        console.warn(message);
    };
    if (util.isNode && process.stderr.isTTY) {
        printWarning = function(message, isSoft) {
            var color = isSoft ? "\u001b[33m" : "\u001b[31m";
            console.warn(color + message + "\u001b[0m\n");
        };
    } else if (!util.isNode && typeof (new Error().stack) === "string") {
        printWarning = function(message, isSoft) {
            console.warn("%c" + message,
                        isSoft ? "color: darkorange" : "color: red");
        };
    }
}

var config = {
    warnings: warnings,
    longStackTraces: false,
    cancellation: false,
    monitoring: false
};

if (longStackTraces) Promise.longStackTraces();

return {
    longStackTraces: function() {
        return config.longStackTraces;
    },
    warnings: function() {
        return config.warnings;
    },
    cancellation: function() {
        return config.cancellation;
    },
    monitoring: function() {
        return config.monitoring;
    },
    propagateFromFunction: function() {
        return propagateFromFunction;
    },
    boundValueFunction: function() {
        return boundValueFunction;
    },
    checkForgottenReturns: checkForgottenReturns,
    setBounds: setBounds,
    warn: warn,
    deprecated: deprecated,
    CapturedTrace: CapturedTrace,
    fireDomEvent: fireDomEvent,
    fireGlobalEvent: fireGlobalEvent
};
};

},{"./errors":12,"./util":36}],10:[function(_dereq_,module,exports){
"use strict";
module.exports = function(Promise) {
function returner() {
    return this.value;
}
function thrower() {
    throw this.reason;
}

Promise.prototype["return"] =
Promise.prototype.thenReturn = function (value) {
    if (value instanceof Promise) value.suppressUnhandledRejections();
    return this._then(
        returner, undefined, undefined, {value: value}, undefined);
};

Promise.prototype["throw"] =
Promise.prototype.thenThrow = function (reason) {
    return this._then(
        thrower, undefined, undefined, {reason: reason}, undefined);
};

Promise.prototype.catchThrow = function (reason) {
    if (arguments.length <= 1) {
        return this._then(
            undefined, thrower, undefined, {reason: reason}, undefined);
    } else {
        var _reason = arguments[1];
        var handler = function() {throw _reason;};
        return this.caught(reason, handler);
    }
};

Promise.prototype.catchReturn = function (value) {
    if (arguments.length <= 1) {
        if (value instanceof Promise) value.suppressUnhandledRejections();
        return this._then(
            undefined, returner, undefined, {value: value}, undefined);
    } else {
        var _value = arguments[1];
        if (_value instanceof Promise) _value.suppressUnhandledRejections();
        var handler = function() {return _value;};
        return this.caught(value, handler);
    }
};
};

},{}],11:[function(_dereq_,module,exports){
"use strict";
module.exports = function(Promise, INTERNAL) {
var PromiseReduce = Promise.reduce;
var PromiseAll = Promise.all;

function promiseAllThis() {
    return PromiseAll(this);
}

function PromiseMapSeries(promises, fn) {
    return PromiseReduce(promises, fn, INTERNAL, INTERNAL);
}

Promise.prototype.each = function (fn) {
    return PromiseReduce(this, fn, INTERNAL, 0)
              ._then(promiseAllThis, undefined, undefined, this, undefined);
};

Promise.prototype.mapSeries = function (fn) {
    return PromiseReduce(this, fn, INTERNAL, INTERNAL);
};

Promise.each = function (promises, fn) {
    return PromiseReduce(promises, fn, INTERNAL, 0)
              ._then(promiseAllThis, undefined, undefined, promises, undefined);
};

Promise.mapSeries = PromiseMapSeries;
};


},{}],12:[function(_dereq_,module,exports){
"use strict";
var es5 = _dereq_("./es5");
var Objectfreeze = es5.freeze;
var util = _dereq_("./util");
var inherits = util.inherits;
var notEnumerableProp = util.notEnumerableProp;

function subError(nameProperty, defaultMessage) {
    function SubError(message) {
        if (!(this instanceof SubError)) return new SubError(message);
        notEnumerableProp(this, "message",
            typeof message === "string" ? message : defaultMessage);
        notEnumerableProp(this, "name", nameProperty);
        if (Error.captureStackTrace) {
            Error.captureStackTrace(this, this.constructor);
        } else {
            Error.call(this);
        }
    }
    inherits(SubError, Error);
    return SubError;
}

var _TypeError, _RangeError;
var Warning = subError("Warning", "warning");
var CancellationError = subError("CancellationError", "cancellation error");
var TimeoutError = subError("TimeoutError", "timeout error");
var AggregateError = subError("AggregateError", "aggregate error");
try {
    _TypeError = TypeError;
    _RangeError = RangeError;
} catch(e) {
    _TypeError = subError("TypeError", "type error");
    _RangeError = subError("RangeError", "range error");
}

var methods = ("join pop push shift unshift slice filter forEach some " +
    "every map indexOf lastIndexOf reduce reduceRight sort reverse").split(" ");

for (var i = 0; i < methods.length; ++i) {
    if (typeof Array.prototype[methods[i]] === "function") {
        AggregateError.prototype[methods[i]] = Array.prototype[methods[i]];
    }
}

es5.defineProperty(AggregateError.prototype, "length", {
    value: 0,
    configurable: false,
    writable: true,
    enumerable: true
});
AggregateError.prototype["isOperational"] = true;
var level = 0;
AggregateError.prototype.toString = function() {
    var indent = Array(level * 4 + 1).join(" ");
    var ret = "\n" + indent + "AggregateError of:" + "\n";
    level++;
    indent = Array(level * 4 + 1).join(" ");
    for (var i = 0; i < this.length; ++i) {
        var str = this[i] === this ? "[Circular AggregateError]" : this[i] + "";
        var lines = str.split("\n");
        for (var j = 0; j < lines.length; ++j) {
            lines[j] = indent + lines[j];
        }
        str = lines.join("\n");
        ret += str + "\n";
    }
    level--;
    return ret;
};

function OperationalError(message) {
    if (!(this instanceof OperationalError))
        return new OperationalError(message);
    notEnumerableProp(this, "name", "OperationalError");
    notEnumerableProp(this, "message", message);
    this.cause = message;
    this["isOperational"] = true;

    if (message instanceof Error) {
        notEnumerableProp(this, "message", message.message);
        notEnumerableProp(this, "stack", message.stack);
    } else if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
    }

}
inherits(OperationalError, Error);

var errorTypes = Error["__BluebirdErrorTypes__"];
if (!errorTypes) {
    errorTypes = Objectfreeze({
        CancellationError: CancellationError,
        TimeoutError: TimeoutError,
        OperationalError: OperationalError,
        RejectionError: OperationalError,
        AggregateError: AggregateError
    });
    es5.defineProperty(Error, "__BluebirdErrorTypes__", {
        value: errorTypes,
        writable: false,
        enumerable: false,
        configurable: false
    });
}

module.exports = {
    Error: Error,
    TypeError: _TypeError,
    RangeError: _RangeError,
    CancellationError: errorTypes.CancellationError,
    OperationalError: errorTypes.OperationalError,
    TimeoutError: errorTypes.TimeoutError,
    AggregateError: errorTypes.AggregateError,
    Warning: Warning
};

},{"./es5":13,"./util":36}],13:[function(_dereq_,module,exports){
var isES5 = (function(){
    "use strict";
    return this === undefined;
})();

if (isES5) {
    module.exports = {
        freeze: Object.freeze,
        defineProperty: Object.defineProperty,
        getDescriptor: Object.getOwnPropertyDescriptor,
        keys: Object.keys,
        names: Object.getOwnPropertyNames,
        getPrototypeOf: Object.getPrototypeOf,
        isArray: Array.isArray,
        isES5: isES5,
        propertyIsWritable: function(obj, prop) {
            var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
            return !!(!descriptor || descriptor.writable || descriptor.set);
        }
    };
} else {
    var has = {}.hasOwnProperty;
    var str = {}.toString;
    var proto = {}.constructor.prototype;

    var ObjectKeys = function (o) {
        var ret = [];
        for (var key in o) {
            if (has.call(o, key)) {
                ret.push(key);
            }
        }
        return ret;
    };

    var ObjectGetDescriptor = function(o, key) {
        return {value: o[key]};
    };

    var ObjectDefineProperty = function (o, key, desc) {
        o[key] = desc.value;
        return o;
    };

    var ObjectFreeze = function (obj) {
        return obj;
    };

    var ObjectGetPrototypeOf = function (obj) {
        try {
            return Object(obj).constructor.prototype;
        }
        catch (e) {
            return proto;
        }
    };

    var ArrayIsArray = function (obj) {
        try {
            return str.call(obj) === "[object Array]";
        }
        catch(e) {
            return false;
        }
    };

    module.exports = {
        isArray: ArrayIsArray,
        keys: ObjectKeys,
        names: ObjectKeys,
        defineProperty: ObjectDefineProperty,
        getDescriptor: ObjectGetDescriptor,
        freeze: ObjectFreeze,
        getPrototypeOf: ObjectGetPrototypeOf,
        isES5: isES5,
        propertyIsWritable: function() {
            return true;
        }
    };
}

},{}],14:[function(_dereq_,module,exports){
"use strict";
module.exports = function(Promise, INTERNAL) {
var PromiseMap = Promise.map;

Promise.prototype.filter = function (fn, options) {
    return PromiseMap(this, fn, options, INTERNAL);
};

Promise.filter = function (promises, fn, options) {
    return PromiseMap(promises, fn, options, INTERNAL);
};
};

},{}],15:[function(_dereq_,module,exports){
"use strict";
module.exports = function(Promise, tryConvertToPromise, NEXT_FILTER) {
var util = _dereq_("./util");
var CancellationError = Promise.CancellationError;
var errorObj = util.errorObj;
var catchFilter = _dereq_("./catch_filter")(NEXT_FILTER);

function PassThroughHandlerContext(promise, type, handler) {
    this.promise = promise;
    this.type = type;
    this.handler = handler;
    this.called = false;
    this.cancelPromise = null;
}

PassThroughHandlerContext.prototype.isFinallyHandler = function() {
    return this.type === 0;
};

function FinallyHandlerCancelReaction(finallyHandler) {
    this.finallyHandler = finallyHandler;
}

FinallyHandlerCancelReaction.prototype._resultCancelled = function() {
    checkCancel(this.finallyHandler);
};

function checkCancel(ctx, reason) {
    if (ctx.cancelPromise != null) {
        if (arguments.length > 1) {
            ctx.cancelPromise._reject(reason);
        } else {
            ctx.cancelPromise._cancel();
        }
        ctx.cancelPromise = null;
        return true;
    }
    return false;
}

function succeed() {
    return finallyHandler.call(this, this.promise._target()._settledValue());
}
function fail(reason) {
    if (checkCancel(this, reason)) return;
    errorObj.e = reason;
    return errorObj;
}
function finallyHandler(reasonOrValue) {
    var promise = this.promise;
    var handler = this.handler;

    if (!this.called) {
        this.called = true;
        var ret = this.isFinallyHandler()
            ? handler.call(promise._boundValue())
            : handler.call(promise._boundValue(), reasonOrValue);
        if (ret === NEXT_FILTER) {
            return ret;
        } else if (ret !== undefined) {
            promise._setReturnedNonUndefined();
            var maybePromise = tryConvertToPromise(ret, promise);
            if (maybePromise instanceof Promise) {
                if (this.cancelPromise != null) {
                    if (maybePromise._isCancelled()) {
                        var reason =
                            new CancellationError("late cancellation observer");
                        promise._attachExtraTrace(reason);
                        errorObj.e = reason;
                        return errorObj;
                    } else if (maybePromise.isPending()) {
                        maybePromise._attachCancellationCallback(
                            new FinallyHandlerCancelReaction(this));
                    }
                }
                return maybePromise._then(
                    succeed, fail, undefined, this, undefined);
            }
        }
    }

    if (promise.isRejected()) {
        checkCancel(this);
        errorObj.e = reasonOrValue;
        return errorObj;
    } else {
        checkCancel(this);
        return reasonOrValue;
    }
}

Promise.prototype._passThrough = function(handler, type, success, fail) {
    if (typeof handler !== "function") return this.then();
    return this._then(success,
                      fail,
                      undefined,
                      new PassThroughHandlerContext(this, type, handler),
                      undefined);
};

Promise.prototype.lastly =
Promise.prototype["finally"] = function (handler) {
    return this._passThrough(handler,
                             0,
                             finallyHandler,
                             finallyHandler);
};


Promise.prototype.tap = function (handler) {
    return this._passThrough(handler, 1, finallyHandler);
};

Promise.prototype.tapCatch = function (handlerOrPredicate) {
    var len = arguments.length;
    if(len === 1) {
        return this._passThrough(handlerOrPredicate,
                                 1,
                                 undefined,
                                 finallyHandler);
    } else {
         var catchInstances = new Array(len - 1),
            j = 0, i;
        for (i = 0; i < len - 1; ++i) {
            var item = arguments[i];
            if (util.isObject(item)) {
                catchInstances[j++] = item;
            } else {
                return Promise.reject(new TypeError(
                    "tapCatch statement predicate: "
                    + "expecting an object but got " + util.classString(item)
                ));
            }
        }
        catchInstances.length = j;
        var handler = arguments[i];
        return this._passThrough(catchFilter(catchInstances, handler, this),
                                 1,
                                 undefined,
                                 finallyHandler);
    }

};

return PassThroughHandlerContext;
};

},{"./catch_filter":7,"./util":36}],16:[function(_dereq_,module,exports){
"use strict";
module.exports = function(Promise,
                          apiRejection,
                          INTERNAL,
                          tryConvertToPromise,
                          Proxyable,
                          debug) {
var errors = _dereq_("./errors");
var TypeError = errors.TypeError;
var util = _dereq_("./util");
var errorObj = util.errorObj;
var tryCatch = util.tryCatch;
var yieldHandlers = [];

function promiseFromYieldHandler(value, yieldHandlers, traceParent) {
    for (var i = 0; i < yieldHandlers.length; ++i) {
        traceParent._pushContext();
        var result = tryCatch(yieldHandlers[i])(value);
        traceParent._popContext();
        if (result === errorObj) {
            traceParent._pushContext();
            var ret = Promise.reject(errorObj.e);
            traceParent._popContext();
            return ret;
        }
        var maybePromise = tryConvertToPromise(result, traceParent);
        if (maybePromise instanceof Promise) return maybePromise;
    }
    return null;
}

function PromiseSpawn(generatorFunction, receiver, yieldHandler, stack) {
    if (debug.cancellation()) {
        var internal = new Promise(INTERNAL);
        var _finallyPromise = this._finallyPromise = new Promise(INTERNAL);
        this._promise = internal.lastly(function() {
            return _finallyPromise;
        });
        internal._captureStackTrace();
        internal._setOnCancel(this);
    } else {
        var promise = this._promise = new Promise(INTERNAL);
        promise._captureStackTrace();
    }
    this._stack = stack;
    this._generatorFunction = generatorFunction;
    this._receiver = receiver;
    this._generator = undefined;
    this._yieldHandlers = typeof yieldHandler === "function"
        ? [yieldHandler].concat(yieldHandlers)
        : yieldHandlers;
    this._yieldedPromise = null;
    this._cancellationPhase = false;
}
util.inherits(PromiseSpawn, Proxyable);

PromiseSpawn.prototype._isResolved = function() {
    return this._promise === null;
};

PromiseSpawn.prototype._cleanup = function() {
    this._promise = this._generator = null;
    if (debug.cancellation() && this._finallyPromise !== null) {
        this._finallyPromise._fulfill();
        this._finallyPromise = null;
    }
};

PromiseSpawn.prototype._promiseCancelled = function() {
    if (this._isResolved()) return;
    var implementsReturn = typeof this._generator["return"] !== "undefined";

    var result;
    if (!implementsReturn) {
        var reason = new Promise.CancellationError(
            "generator .return() sentinel");
        Promise.coroutine.returnSentinel = reason;
        this._promise._attachExtraTrace(reason);
        this._promise._pushContext();
        result = tryCatch(this._generator["throw"]).call(this._generator,
                                                         reason);
        this._promise._popContext();
    } else {
        this._promise._pushContext();
        result = tryCatch(this._generator["return"]).call(this._generator,
                                                          undefined);
        this._promise._popContext();
    }
    this._cancellationPhase = true;
    this._yieldedPromise = null;
    this._continue(result);
};

PromiseSpawn.prototype._promiseFulfilled = function(value) {
    this._yieldedPromise = null;
    this._promise._pushContext();
    var result = tryCatch(this._generator.next).call(this._generator, value);
    this._promise._popContext();
    this._continue(result);
};

PromiseSpawn.prototype._promiseRejected = function(reason) {
    this._yieldedPromise = null;
    this._promise._attachExtraTrace(reason);
    this._promise._pushContext();
    var result = tryCatch(this._generator["throw"])
        .call(this._generator, reason);
    this._promise._popContext();
    this._continue(result);
};

PromiseSpawn.prototype._resultCancelled = function() {
    if (this._yieldedPromise instanceof Promise) {
        var promise = this._yieldedPromise;
        this._yieldedPromise = null;
        promise.cancel();
    }
};

PromiseSpawn.prototype.promise = function () {
    return this._promise;
};

PromiseSpawn.prototype._run = function () {
    this._generator = this._generatorFunction.call(this._receiver);
    this._receiver =
        this._generatorFunction = undefined;
    this._promiseFulfilled(undefined);
};

PromiseSpawn.prototype._continue = function (result) {
    var promise = this._promise;
    if (result === errorObj) {
        this._cleanup();
        if (this._cancellationPhase) {
            return promise.cancel();
        } else {
            return promise._rejectCallback(result.e, false);
        }
    }

    var value = result.value;
    if (result.done === true) {
        this._cleanup();
        if (this._cancellationPhase) {
            return promise.cancel();
        } else {
            return promise._resolveCallback(value);
        }
    } else {
        var maybePromise = tryConvertToPromise(value, this._promise);
        if (!(maybePromise instanceof Promise)) {
            maybePromise =
                promiseFromYieldHandler(maybePromise,
                                        this._yieldHandlers,
                                        this._promise);
            if (maybePromise === null) {
                this._promiseRejected(
                    new TypeError(
                        "A value %s was yielded that could not be treated as a promise\u000a\u000a    See http://goo.gl/MqrFmX\u000a\u000a".replace("%s", String(value)) +
                        "From coroutine:\u000a" +
                        this._stack.split("\n").slice(1, -7).join("\n")
                    )
                );
                return;
            }
        }
        maybePromise = maybePromise._target();
        var bitField = maybePromise._bitField;
        ;
        if (((bitField & 50397184) === 0)) {
            this._yieldedPromise = maybePromise;
            maybePromise._proxy(this, null);
        } else if (((bitField & 33554432) !== 0)) {
            Promise._async.invoke(
                this._promiseFulfilled, this, maybePromise._value()
            );
        } else if (((bitField & 16777216) !== 0)) {
            Promise._async.invoke(
                this._promiseRejected, this, maybePromise._reason()
            );
        } else {
            this._promiseCancelled();
        }
    }
};

Promise.coroutine = function (generatorFunction, options) {
    if (typeof generatorFunction !== "function") {
        throw new TypeError("generatorFunction must be a function\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
    }
    var yieldHandler = Object(options).yieldHandler;
    var PromiseSpawn$ = PromiseSpawn;
    var stack = new Error().stack;
    return function () {
        var generator = generatorFunction.apply(this, arguments);
        var spawn = new PromiseSpawn$(undefined, undefined, yieldHandler,
                                      stack);
        var ret = spawn.promise();
        spawn._generator = generator;
        spawn._promiseFulfilled(undefined);
        return ret;
    };
};

Promise.coroutine.addYieldHandler = function(fn) {
    if (typeof fn !== "function") {
        throw new TypeError("expecting a function but got " + util.classString(fn));
    }
    yieldHandlers.push(fn);
};

Promise.spawn = function (generatorFunction) {
    debug.deprecated("Promise.spawn()", "Promise.coroutine()");
    if (typeof generatorFunction !== "function") {
        return apiRejection("generatorFunction must be a function\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
    }
    var spawn = new PromiseSpawn(generatorFunction, this);
    var ret = spawn.promise();
    spawn._run(Promise.spawn);
    return ret;
};
};

},{"./errors":12,"./util":36}],17:[function(_dereq_,module,exports){
"use strict";
module.exports =
function(Promise, PromiseArray, tryConvertToPromise, INTERNAL, async,
         getDomain) {
var util = _dereq_("./util");
var canEvaluate = util.canEvaluate;
var tryCatch = util.tryCatch;
var errorObj = util.errorObj;
var reject;

if (!true) {
if (canEvaluate) {
    var thenCallback = function(i) {
        return new Function("value", "holder", "                             \n\
            'use strict';                                                    \n\
            holder.pIndex = value;                                           \n\
            holder.checkFulfillment(this);                                   \n\
            ".replace(/Index/g, i));
    };

    var promiseSetter = function(i) {
        return new Function("promise", "holder", "                           \n\
            'use strict';                                                    \n\
            holder.pIndex = promise;                                         \n\
            ".replace(/Index/g, i));
    };

    var generateHolderClass = function(total) {
        var props = new Array(total);
        for (var i = 0; i < props.length; ++i) {
            props[i] = "this.p" + (i+1);
        }
        var assignment = props.join(" = ") + " = null;";
        var cancellationCode= "var promise;\n" + props.map(function(prop) {
            return "                                                         \n\
                promise = " + prop + ";                                      \n\
                if (promise instanceof Promise) {                            \n\
                    promise.cancel();                                        \n\
                }                                                            \n\
            ";
        }).join("\n");
        var passedArguments = props.join(", ");
        var name = "Holder$" + total;


        var code = "return function(tryCatch, errorObj, Promise, async) {    \n\
            'use strict';                                                    \n\
            function [TheName](fn) {                                         \n\
                [TheProperties]                                              \n\
                this.fn = fn;                                                \n\
                this.asyncNeeded = true;                                     \n\
                this.now = 0;                                                \n\
            }                                                                \n\
                                                                             \n\
            [TheName].prototype._callFunction = function(promise) {          \n\
                promise._pushContext();                                      \n\
                var ret = tryCatch(this.fn)([ThePassedArguments]);           \n\
                promise._popContext();                                       \n\
                if (ret === errorObj) {                                      \n\
                    promise._rejectCallback(ret.e, false);                   \n\
                } else {                                                     \n\
                    promise._resolveCallback(ret);                           \n\
                }                                                            \n\
            };                                                               \n\
                                                                             \n\
            [TheName].prototype.checkFulfillment = function(promise) {       \n\
                var now = ++this.now;                                        \n\
                if (now === [TheTotal]) {                                    \n\
                    if (this.asyncNeeded) {                                  \n\
                        async.invoke(this._callFunction, this, promise);     \n\
                    } else {                                                 \n\
                        this._callFunction(promise);                         \n\
                    }                                                        \n\
                                                                             \n\
                }                                                            \n\
            };                                                               \n\
                                                                             \n\
            [TheName].prototype._resultCancelled = function() {              \n\
                [CancellationCode]                                           \n\
            };                                                               \n\
                                                                             \n\
            return [TheName];                                                \n\
        }(tryCatch, errorObj, Promise, async);                               \n\
        ";

        code = code.replace(/\[TheName\]/g, name)
            .replace(/\[TheTotal\]/g, total)
            .replace(/\[ThePassedArguments\]/g, passedArguments)
            .replace(/\[TheProperties\]/g, assignment)
            .replace(/\[CancellationCode\]/g, cancellationCode);

        return new Function("tryCatch", "errorObj", "Promise", "async", code)
                           (tryCatch, errorObj, Promise, async);
    };

    var holderClasses = [];
    var thenCallbacks = [];
    var promiseSetters = [];

    for (var i = 0; i < 8; ++i) {
        holderClasses.push(generateHolderClass(i + 1));
        thenCallbacks.push(thenCallback(i + 1));
        promiseSetters.push(promiseSetter(i + 1));
    }

    reject = function (reason) {
        this._reject(reason);
    };
}}

Promise.join = function () {
    var last = arguments.length - 1;
    var fn;
    if (last > 0 && typeof arguments[last] === "function") {
        fn = arguments[last];
        if (!true) {
            if (last <= 8 && canEvaluate) {
                var ret = new Promise(INTERNAL);
                ret._captureStackTrace();
                var HolderClass = holderClasses[last - 1];
                var holder = new HolderClass(fn);
                var callbacks = thenCallbacks;

                for (var i = 0; i < last; ++i) {
                    var maybePromise = tryConvertToPromise(arguments[i], ret);
                    if (maybePromise instanceof Promise) {
                        maybePromise = maybePromise._target();
                        var bitField = maybePromise._bitField;
                        ;
                        if (((bitField & 50397184) === 0)) {
                            maybePromise._then(callbacks[i], reject,
                                               undefined, ret, holder);
                            promiseSetters[i](maybePromise, holder);
                            holder.asyncNeeded = false;
                        } else if (((bitField & 33554432) !== 0)) {
                            callbacks[i].call(ret,
                                              maybePromise._value(), holder);
                        } else if (((bitField & 16777216) !== 0)) {
                            ret._reject(maybePromise._reason());
                        } else {
                            ret._cancel();
                        }
                    } else {
                        callbacks[i].call(ret, maybePromise, holder);
                    }
                }

                if (!ret._isFateSealed()) {
                    if (holder.asyncNeeded) {
                        var domain = getDomain();
                        if (domain !== null) {
                            holder.fn = util.domainBind(domain, holder.fn);
                        }
                    }
                    ret._setAsyncGuaranteed();
                    ret._setOnCancel(holder);
                }
                return ret;
            }
        }
    }
    var args = [].slice.call(arguments);;
    if (fn) args.pop();
    var ret = new PromiseArray(args).promise();
    return fn !== undefined ? ret.spread(fn) : ret;
};

};

},{"./util":36}],18:[function(_dereq_,module,exports){
"use strict";
module.exports = function(Promise,
                          PromiseArray,
                          apiRejection,
                          tryConvertToPromise,
                          INTERNAL,
                          debug) {
var getDomain = Promise._getDomain;
var util = _dereq_("./util");
var tryCatch = util.tryCatch;
var errorObj = util.errorObj;
var async = Promise._async;

function MappingPromiseArray(promises, fn, limit, _filter) {
    this.constructor$(promises);
    this._promise._captureStackTrace();
    var domain = getDomain();
    this._callback = domain === null ? fn : util.domainBind(domain, fn);
    this._preservedValues = _filter === INTERNAL
        ? new Array(this.length())
        : null;
    this._limit = limit;
    this._inFlight = 0;
    this._queue = [];
    async.invoke(this._asyncInit, this, undefined);
}
util.inherits(MappingPromiseArray, PromiseArray);

MappingPromiseArray.prototype._asyncInit = function() {
    this._init$(undefined, -2);
};

MappingPromiseArray.prototype._init = function () {};

MappingPromiseArray.prototype._promiseFulfilled = function (value, index) {
    var values = this._values;
    var length = this.length();
    var preservedValues = this._preservedValues;
    var limit = this._limit;

    if (index < 0) {
        index = (index * -1) - 1;
        values[index] = value;
        if (limit >= 1) {
            this._inFlight--;
            this._drainQueue();
            if (this._isResolved()) return true;
        }
    } else {
        if (limit >= 1 && this._inFlight >= limit) {
            values[index] = value;
            this._queue.push(index);
            return false;
        }
        if (preservedValues !== null) preservedValues[index] = value;

        var promise = this._promise;
        var callback = this._callback;
        var receiver = promise._boundValue();
        promise._pushContext();
        var ret = tryCatch(callback).call(receiver, value, index, length);
        var promiseCreated = promise._popContext();
        debug.checkForgottenReturns(
            ret,
            promiseCreated,
            preservedValues !== null ? "Promise.filter" : "Promise.map",
            promise
        );
        if (ret === errorObj) {
            this._reject(ret.e);
            return true;
        }

        var maybePromise = tryConvertToPromise(ret, this._promise);
        if (maybePromise instanceof Promise) {
            maybePromise = maybePromise._target();
            var bitField = maybePromise._bitField;
            ;
            if (((bitField & 50397184) === 0)) {
                if (limit >= 1) this._inFlight++;
                values[index] = maybePromise;
                maybePromise._proxy(this, (index + 1) * -1);
                return false;
            } else if (((bitField & 33554432) !== 0)) {
                ret = maybePromise._value();
            } else if (((bitField & 16777216) !== 0)) {
                this._reject(maybePromise._reason());
                return true;
            } else {
                this._cancel();
                return true;
            }
        }
        values[index] = ret;
    }
    var totalResolved = ++this._totalResolved;
    if (totalResolved >= length) {
        if (preservedValues !== null) {
            this._filter(values, preservedValues);
        } else {
            this._resolve(values);
        }
        return true;
    }
    return false;
};

MappingPromiseArray.prototype._drainQueue = function () {
    var queue = this._queue;
    var limit = this._limit;
    var values = this._values;
    while (queue.length > 0 && this._inFlight < limit) {
        if (this._isResolved()) return;
        var index = queue.pop();
        this._promiseFulfilled(values[index], index);
    }
};

MappingPromiseArray.prototype._filter = function (booleans, values) {
    var len = values.length;
    var ret = new Array(len);
    var j = 0;
    for (var i = 0; i < len; ++i) {
        if (booleans[i]) ret[j++] = values[i];
    }
    ret.length = j;
    this._resolve(ret);
};

MappingPromiseArray.prototype.preservedValues = function () {
    return this._preservedValues;
};

function map(promises, fn, options, _filter) {
    if (typeof fn !== "function") {
        return apiRejection("expecting a function but got " + util.classString(fn));
    }

    var limit = 0;
    if (options !== undefined) {
        if (typeof options === "object" && options !== null) {
            if (typeof options.concurrency !== "number") {
                return Promise.reject(
                    new TypeError("'concurrency' must be a number but it is " +
                                    util.classString(options.concurrency)));
            }
            limit = options.concurrency;
        } else {
            return Promise.reject(new TypeError(
                            "options argument must be an object but it is " +
                             util.classString(options)));
        }
    }
    limit = typeof limit === "number" &&
        isFinite(limit) && limit >= 1 ? limit : 0;
    return new MappingPromiseArray(promises, fn, limit, _filter).promise();
}

Promise.prototype.map = function (fn, options) {
    return map(this, fn, options, null);
};

Promise.map = function (promises, fn, options, _filter) {
    return map(promises, fn, options, _filter);
};


};

},{"./util":36}],19:[function(_dereq_,module,exports){
"use strict";
module.exports =
function(Promise, INTERNAL, tryConvertToPromise, apiRejection, debug) {
var util = _dereq_("./util");
var tryCatch = util.tryCatch;

Promise.method = function (fn) {
    if (typeof fn !== "function") {
        throw new Promise.TypeError("expecting a function but got " + util.classString(fn));
    }
    return function () {
        var ret = new Promise(INTERNAL);
        ret._captureStackTrace();
        ret._pushContext();
        var value = tryCatch(fn).apply(this, arguments);
        var promiseCreated = ret._popContext();
        debug.checkForgottenReturns(
            value, promiseCreated, "Promise.method", ret);
        ret._resolveFromSyncValue(value);
        return ret;
    };
};

Promise.attempt = Promise["try"] = function (fn) {
    if (typeof fn !== "function") {
        return apiRejection("expecting a function but got " + util.classString(fn));
    }
    var ret = new Promise(INTERNAL);
    ret._captureStackTrace();
    ret._pushContext();
    var value;
    if (arguments.length > 1) {
        debug.deprecated("calling Promise.try with more than 1 argument");
        var arg = arguments[1];
        var ctx = arguments[2];
        value = util.isArray(arg) ? tryCatch(fn).apply(ctx, arg)
                                  : tryCatch(fn).call(ctx, arg);
    } else {
        value = tryCatch(fn)();
    }
    var promiseCreated = ret._popContext();
    debug.checkForgottenReturns(
        value, promiseCreated, "Promise.try", ret);
    ret._resolveFromSyncValue(value);
    return ret;
};

Promise.prototype._resolveFromSyncValue = function (value) {
    if (value === util.errorObj) {
        this._rejectCallback(value.e, false);
    } else {
        this._resolveCallback(value, true);
    }
};
};

},{"./util":36}],20:[function(_dereq_,module,exports){
"use strict";
var util = _dereq_("./util");
var maybeWrapAsError = util.maybeWrapAsError;
var errors = _dereq_("./errors");
var OperationalError = errors.OperationalError;
var es5 = _dereq_("./es5");

function isUntypedError(obj) {
    return obj instanceof Error &&
        es5.getPrototypeOf(obj) === Error.prototype;
}

var rErrorKey = /^(?:name|message|stack|cause)$/;
function wrapAsOperationalError(obj) {
    var ret;
    if (isUntypedError(obj)) {
        ret = new OperationalError(obj);
        ret.name = obj.name;
        ret.message = obj.message;
        ret.stack = obj.stack;
        var keys = es5.keys(obj);
        for (var i = 0; i < keys.length; ++i) {
            var key = keys[i];
            if (!rErrorKey.test(key)) {
                ret[key] = obj[key];
            }
        }
        return ret;
    }
    util.markAsOriginatingFromRejection(obj);
    return obj;
}

function nodebackForPromise(promise, multiArgs) {
    return function(err, value) {
        if (promise === null) return;
        if (err) {
            var wrapped = wrapAsOperationalError(maybeWrapAsError(err));
            promise._attachExtraTrace(wrapped);
            promise._reject(wrapped);
        } else if (!multiArgs) {
            promise._fulfill(value);
        } else {
            var args = [].slice.call(arguments, 1);;
            promise._fulfill(args);
        }
        promise = null;
    };
}

module.exports = nodebackForPromise;

},{"./errors":12,"./es5":13,"./util":36}],21:[function(_dereq_,module,exports){
"use strict";
module.exports = function(Promise) {
var util = _dereq_("./util");
var async = Promise._async;
var tryCatch = util.tryCatch;
var errorObj = util.errorObj;

function spreadAdapter(val, nodeback) {
    var promise = this;
    if (!util.isArray(val)) return successAdapter.call(promise, val, nodeback);
    var ret =
        tryCatch(nodeback).apply(promise._boundValue(), [null].concat(val));
    if (ret === errorObj) {
        async.throwLater(ret.e);
    }
}

function successAdapter(val, nodeback) {
    var promise = this;
    var receiver = promise._boundValue();
    var ret = val === undefined
        ? tryCatch(nodeback).call(receiver, null)
        : tryCatch(nodeback).call(receiver, null, val);
    if (ret === errorObj) {
        async.throwLater(ret.e);
    }
}
function errorAdapter(reason, nodeback) {
    var promise = this;
    if (!reason) {
        var newReason = new Error(reason + "");
        newReason.cause = reason;
        reason = newReason;
    }
    var ret = tryCatch(nodeback).call(promise._boundValue(), reason);
    if (ret === errorObj) {
        async.throwLater(ret.e);
    }
}

Promise.prototype.asCallback = Promise.prototype.nodeify = function (nodeback,
                                                                     options) {
    if (typeof nodeback == "function") {
        var adapter = successAdapter;
        if (options !== undefined && Object(options).spread) {
            adapter = spreadAdapter;
        }
        this._then(
            adapter,
            errorAdapter,
            undefined,
            this,
            nodeback
        );
    }
    return this;
};
};

},{"./util":36}],22:[function(_dereq_,module,exports){
"use strict";
module.exports = function() {
var makeSelfResolutionError = function () {
    return new TypeError("circular promise resolution chain\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
};
var reflectHandler = function() {
    return new Promise.PromiseInspection(this._target());
};
var apiRejection = function(msg) {
    return Promise.reject(new TypeError(msg));
};
function Proxyable() {}
var UNDEFINED_BINDING = {};
var util = _dereq_("./util");

var getDomain;
if (util.isNode) {
    getDomain = function() {
        var ret = process.domain;
        if (ret === undefined) ret = null;
        return ret;
    };
} else {
    getDomain = function() {
        return null;
    };
}
util.notEnumerableProp(Promise, "_getDomain", getDomain);

var es5 = _dereq_("./es5");
var Async = _dereq_("./async");
var async = new Async();
es5.defineProperty(Promise, "_async", {value: async});
var errors = _dereq_("./errors");
var TypeError = Promise.TypeError = errors.TypeError;
Promise.RangeError = errors.RangeError;
var CancellationError = Promise.CancellationError = errors.CancellationError;
Promise.TimeoutError = errors.TimeoutError;
Promise.OperationalError = errors.OperationalError;
Promise.RejectionError = errors.OperationalError;
Promise.AggregateError = errors.AggregateError;
var INTERNAL = function(){};
var APPLY = {};
var NEXT_FILTER = {};
var tryConvertToPromise = _dereq_("./thenables")(Promise, INTERNAL);
var PromiseArray =
    _dereq_("./promise_array")(Promise, INTERNAL,
                               tryConvertToPromise, apiRejection, Proxyable);
var Context = _dereq_("./context")(Promise);
 /*jshint unused:false*/
var createContext = Context.create;
var debug = _dereq_("./debuggability")(Promise, Context);
var CapturedTrace = debug.CapturedTrace;
var PassThroughHandlerContext =
    _dereq_("./finally")(Promise, tryConvertToPromise, NEXT_FILTER);
var catchFilter = _dereq_("./catch_filter")(NEXT_FILTER);
var nodebackForPromise = _dereq_("./nodeback");
var errorObj = util.errorObj;
var tryCatch = util.tryCatch;
function check(self, executor) {
    if (self == null || self.constructor !== Promise) {
        throw new TypeError("the promise constructor cannot be invoked directly\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
    }
    if (typeof executor !== "function") {
        throw new TypeError("expecting a function but got " + util.classString(executor));
    }

}

function Promise(executor) {
    if (executor !== INTERNAL) {
        check(this, executor);
    }
    this._bitField = 0;
    this._fulfillmentHandler0 = undefined;
    this._rejectionHandler0 = undefined;
    this._promise0 = undefined;
    this._receiver0 = undefined;
    this._resolveFromExecutor(executor);
    this._promiseCreated();
    this._fireEvent("promiseCreated", this);
}

Promise.prototype.toString = function () {
    return "[object Promise]";
};

Promise.prototype.caught = Promise.prototype["catch"] = function (fn) {
    var len = arguments.length;
    if (len > 1) {
        var catchInstances = new Array(len - 1),
            j = 0, i;
        for (i = 0; i < len - 1; ++i) {
            var item = arguments[i];
            if (util.isObject(item)) {
                catchInstances[j++] = item;
            } else {
                return apiRejection("Catch statement predicate: " +
                    "expecting an object but got " + util.classString(item));
            }
        }
        catchInstances.length = j;
        fn = arguments[i];
        return this.then(undefined, catchFilter(catchInstances, fn, this));
    }
    return this.then(undefined, fn);
};

Promise.prototype.reflect = function () {
    return this._then(reflectHandler,
        reflectHandler, undefined, this, undefined);
};

Promise.prototype.then = function (didFulfill, didReject) {
    if (debug.warnings() && arguments.length > 0 &&
        typeof didFulfill !== "function" &&
        typeof didReject !== "function") {
        var msg = ".then() only accepts functions but was passed: " +
                util.classString(didFulfill);
        if (arguments.length > 1) {
            msg += ", " + util.classString(didReject);
        }
        this._warn(msg);
    }
    return this._then(didFulfill, didReject, undefined, undefined, undefined);
};

Promise.prototype.done = function (didFulfill, didReject) {
    var promise =
        this._then(didFulfill, didReject, undefined, undefined, undefined);
    promise._setIsFinal();
};

Promise.prototype.spread = function (fn) {
    if (typeof fn !== "function") {
        return apiRejection("expecting a function but got " + util.classString(fn));
    }
    return this.all()._then(fn, undefined, undefined, APPLY, undefined);
};

Promise.prototype.toJSON = function () {
    var ret = {
        isFulfilled: false,
        isRejected: false,
        fulfillmentValue: undefined,
        rejectionReason: undefined
    };
    if (this.isFulfilled()) {
        ret.fulfillmentValue = this.value();
        ret.isFulfilled = true;
    } else if (this.isRejected()) {
        ret.rejectionReason = this.reason();
        ret.isRejected = true;
    }
    return ret;
};

Promise.prototype.all = function () {
    if (arguments.length > 0) {
        this._warn(".all() was passed arguments but it does not take any");
    }
    return new PromiseArray(this).promise();
};

Promise.prototype.error = function (fn) {
    return this.caught(util.originatesFromRejection, fn);
};

Promise.getNewLibraryCopy = module.exports;

Promise.is = function (val) {
    return val instanceof Promise;
};

Promise.fromNode = Promise.fromCallback = function(fn) {
    var ret = new Promise(INTERNAL);
    ret._captureStackTrace();
    var multiArgs = arguments.length > 1 ? !!Object(arguments[1]).multiArgs
                                         : false;
    var result = tryCatch(fn)(nodebackForPromise(ret, multiArgs));
    if (result === errorObj) {
        ret._rejectCallback(result.e, true);
    }
    if (!ret._isFateSealed()) ret._setAsyncGuaranteed();
    return ret;
};

Promise.all = function (promises) {
    return new PromiseArray(promises).promise();
};

Promise.cast = function (obj) {
    var ret = tryConvertToPromise(obj);
    if (!(ret instanceof Promise)) {
        ret = new Promise(INTERNAL);
        ret._captureStackTrace();
        ret._setFulfilled();
        ret._rejectionHandler0 = obj;
    }
    return ret;
};

Promise.resolve = Promise.fulfilled = Promise.cast;

Promise.reject = Promise.rejected = function (reason) {
    var ret = new Promise(INTERNAL);
    ret._captureStackTrace();
    ret._rejectCallback(reason, true);
    return ret;
};

Promise.setScheduler = function(fn) {
    if (typeof fn !== "function") {
        throw new TypeError("expecting a function but got " + util.classString(fn));
    }
    return async.setScheduler(fn);
};

Promise.prototype._then = function (
    didFulfill,
    didReject,
    _,    receiver,
    internalData
) {
    var haveInternalData = internalData !== undefined;
    var promise = haveInternalData ? internalData : new Promise(INTERNAL);
    var target = this._target();
    var bitField = target._bitField;

    if (!haveInternalData) {
        promise._propagateFrom(this, 3);
        promise._captureStackTrace();
        if (receiver === undefined &&
            ((this._bitField & 2097152) !== 0)) {
            if (!((bitField & 50397184) === 0)) {
                receiver = this._boundValue();
            } else {
                receiver = target === this ? undefined : this._boundTo;
            }
        }
        this._fireEvent("promiseChained", this, promise);
    }

    var domain = getDomain();
    if (!((bitField & 50397184) === 0)) {
        var handler, value, settler = target._settlePromiseCtx;
        if (((bitField & 33554432) !== 0)) {
            value = target._rejectionHandler0;
            handler = didFulfill;
        } else if (((bitField & 16777216) !== 0)) {
            value = target._fulfillmentHandler0;
            handler = didReject;
            target._unsetRejectionIsUnhandled();
        } else {
            settler = target._settlePromiseLateCancellationObserver;
            value = new CancellationError("late cancellation observer");
            target._attachExtraTrace(value);
            handler = didReject;
        }

        async.invoke(settler, target, {
            handler: domain === null ? handler
                : (typeof handler === "function" &&
                    util.domainBind(domain, handler)),
            promise: promise,
            receiver: receiver,
            value: value
        });
    } else {
        target._addCallbacks(didFulfill, didReject, promise, receiver, domain);
    }

    return promise;
};

Promise.prototype._length = function () {
    return this._bitField & 65535;
};

Promise.prototype._isFateSealed = function () {
    return (this._bitField & 117506048) !== 0;
};

Promise.prototype._isFollowing = function () {
    return (this._bitField & 67108864) === 67108864;
};

Promise.prototype._setLength = function (len) {
    this._bitField = (this._bitField & -65536) |
        (len & 65535);
};

Promise.prototype._setFulfilled = function () {
    this._bitField = this._bitField | 33554432;
    this._fireEvent("promiseFulfilled", this);
};

Promise.prototype._setRejected = function () {
    this._bitField = this._bitField | 16777216;
    this._fireEvent("promiseRejected", this);
};

Promise.prototype._setFollowing = function () {
    this._bitField = this._bitField | 67108864;
    this._fireEvent("promiseResolved", this);
};

Promise.prototype._setIsFinal = function () {
    this._bitField = this._bitField | 4194304;
};

Promise.prototype._isFinal = function () {
    return (this._bitField & 4194304) > 0;
};

Promise.prototype._unsetCancelled = function() {
    this._bitField = this._bitField & (~65536);
};

Promise.prototype._setCancelled = function() {
    this._bitField = this._bitField | 65536;
    this._fireEvent("promiseCancelled", this);
};

Promise.prototype._setWillBeCancelled = function() {
    this._bitField = this._bitField | 8388608;
};

Promise.prototype._setAsyncGuaranteed = function() {
    if (async.hasCustomScheduler()) return;
    this._bitField = this._bitField | 134217728;
};

Promise.prototype._receiverAt = function (index) {
    var ret = index === 0 ? this._receiver0 : this[
            index * 4 - 4 + 3];
    if (ret === UNDEFINED_BINDING) {
        return undefined;
    } else if (ret === undefined && this._isBound()) {
        return this._boundValue();
    }
    return ret;
};

Promise.prototype._promiseAt = function (index) {
    return this[
            index * 4 - 4 + 2];
};

Promise.prototype._fulfillmentHandlerAt = function (index) {
    return this[
            index * 4 - 4 + 0];
};

Promise.prototype._rejectionHandlerAt = function (index) {
    return this[
            index * 4 - 4 + 1];
};

Promise.prototype._boundValue = function() {};

Promise.prototype._migrateCallback0 = function (follower) {
    var bitField = follower._bitField;
    var fulfill = follower._fulfillmentHandler0;
    var reject = follower._rejectionHandler0;
    var promise = follower._promise0;
    var receiver = follower._receiverAt(0);
    if (receiver === undefined) receiver = UNDEFINED_BINDING;
    this._addCallbacks(fulfill, reject, promise, receiver, null);
};

Promise.prototype._migrateCallbackAt = function (follower, index) {
    var fulfill = follower._fulfillmentHandlerAt(index);
    var reject = follower._rejectionHandlerAt(index);
    var promise = follower._promiseAt(index);
    var receiver = follower._receiverAt(index);
    if (receiver === undefined) receiver = UNDEFINED_BINDING;
    this._addCallbacks(fulfill, reject, promise, receiver, null);
};

Promise.prototype._addCallbacks = function (
    fulfill,
    reject,
    promise,
    receiver,
    domain
) {
    var index = this._length();

    if (index >= 65535 - 4) {
        index = 0;
        this._setLength(0);
    }

    if (index === 0) {
        this._promise0 = promise;
        this._receiver0 = receiver;
        if (typeof fulfill === "function") {
            this._fulfillmentHandler0 =
                domain === null ? fulfill : util.domainBind(domain, fulfill);
        }
        if (typeof reject === "function") {
            this._rejectionHandler0 =
                domain === null ? reject : util.domainBind(domain, reject);
        }
    } else {
        var base = index * 4 - 4;
        this[base + 2] = promise;
        this[base + 3] = receiver;
        if (typeof fulfill === "function") {
            this[base + 0] =
                domain === null ? fulfill : util.domainBind(domain, fulfill);
        }
        if (typeof reject === "function") {
            this[base + 1] =
                domain === null ? reject : util.domainBind(domain, reject);
        }
    }
    this._setLength(index + 1);
    return index;
};

Promise.prototype._proxy = function (proxyable, arg) {
    this._addCallbacks(undefined, undefined, arg, proxyable, null);
};

Promise.prototype._resolveCallback = function(value, shouldBind) {
    if (((this._bitField & 117506048) !== 0)) return;
    if (value === this)
        return this._rejectCallback(makeSelfResolutionError(), false);
    var maybePromise = tryConvertToPromise(value, this);
    if (!(maybePromise instanceof Promise)) return this._fulfill(value);

    if (shouldBind) this._propagateFrom(maybePromise, 2);

    var promise = maybePromise._target();

    if (promise === this) {
        this._reject(makeSelfResolutionError());
        return;
    }

    var bitField = promise._bitField;
    if (((bitField & 50397184) === 0)) {
        var len = this._length();
        if (len > 0) promise._migrateCallback0(this);
        for (var i = 1; i < len; ++i) {
            promise._migrateCallbackAt(this, i);
        }
        this._setFollowing();
        this._setLength(0);
        this._setFollowee(promise);
    } else if (((bitField & 33554432) !== 0)) {
        this._fulfill(promise._value());
    } else if (((bitField & 16777216) !== 0)) {
        this._reject(promise._reason());
    } else {
        var reason = new CancellationError("late cancellation observer");
        promise._attachExtraTrace(reason);
        this._reject(reason);
    }
};

Promise.prototype._rejectCallback =
function(reason, synchronous, ignoreNonErrorWarnings) {
    var trace = util.ensureErrorObject(reason);
    var hasStack = trace === reason;
    if (!hasStack && !ignoreNonErrorWarnings && debug.warnings()) {
        var message = "a promise was rejected with a non-error: " +
            util.classString(reason);
        this._warn(message, true);
    }
    this._attachExtraTrace(trace, synchronous ? hasStack : false);
    this._reject(reason);
};

Promise.prototype._resolveFromExecutor = function (executor) {
    if (executor === INTERNAL) return;
    var promise = this;
    this._captureStackTrace();
    this._pushContext();
    var synchronous = true;
    var r = this._execute(executor, function(value) {
        promise._resolveCallback(value);
    }, function (reason) {
        promise._rejectCallback(reason, synchronous);
    });
    synchronous = false;
    this._popContext();

    if (r !== undefined) {
        promise._rejectCallback(r, true);
    }
};

Promise.prototype._settlePromiseFromHandler = function (
    handler, receiver, value, promise
) {
    var bitField = promise._bitField;
    if (((bitField & 65536) !== 0)) return;
    promise._pushContext();
    var x;
    if (receiver === APPLY) {
        if (!value || typeof value.length !== "number") {
            x = errorObj;
            x.e = new TypeError("cannot .spread() a non-array: " +
                                    util.classString(value));
        } else {
            x = tryCatch(handler).apply(this._boundValue(), value);
        }
    } else {
        x = tryCatch(handler).call(receiver, value);
    }
    var promiseCreated = promise._popContext();
    bitField = promise._bitField;
    if (((bitField & 65536) !== 0)) return;

    if (x === NEXT_FILTER) {
        promise._reject(value);
    } else if (x === errorObj) {
        promise._rejectCallback(x.e, false);
    } else {
        debug.checkForgottenReturns(x, promiseCreated, "",  promise, this);
        promise._resolveCallback(x);
    }
};

Promise.prototype._target = function() {
    var ret = this;
    while (ret._isFollowing()) ret = ret._followee();
    return ret;
};

Promise.prototype._followee = function() {
    return this._rejectionHandler0;
};

Promise.prototype._setFollowee = function(promise) {
    this._rejectionHandler0 = promise;
};

Promise.prototype._settlePromise = function(promise, handler, receiver, value) {
    var isPromise = promise instanceof Promise;
    var bitField = this._bitField;
    var asyncGuaranteed = ((bitField & 134217728) !== 0);
    if (((bitField & 65536) !== 0)) {
        if (isPromise) promise._invokeInternalOnCancel();

        if (receiver instanceof PassThroughHandlerContext &&
            receiver.isFinallyHandler()) {
            receiver.cancelPromise = promise;
            if (tryCatch(handler).call(receiver, value) === errorObj) {
                promise._reject(errorObj.e);
            }
        } else if (handler === reflectHandler) {
            promise._fulfill(reflectHandler.call(receiver));
        } else if (receiver instanceof Proxyable) {
            receiver._promiseCancelled(promise);
        } else if (isPromise || promise instanceof PromiseArray) {
            promise._cancel();
        } else {
            receiver.cancel();
        }
    } else if (typeof handler === "function") {
        if (!isPromise) {
            handler.call(receiver, value, promise);
        } else {
            if (asyncGuaranteed) promise._setAsyncGuaranteed();
            this._settlePromiseFromHandler(handler, receiver, value, promise);
        }
    } else if (receiver instanceof Proxyable) {
        if (!receiver._isResolved()) {
            if (((bitField & 33554432) !== 0)) {
                receiver._promiseFulfilled(value, promise);
            } else {
                receiver._promiseRejected(value, promise);
            }
        }
    } else if (isPromise) {
        if (asyncGuaranteed) promise._setAsyncGuaranteed();
        if (((bitField & 33554432) !== 0)) {
            promise._fulfill(value);
        } else {
            promise._reject(value);
        }
    }
};

Promise.prototype._settlePromiseLateCancellationObserver = function(ctx) {
    var handler = ctx.handler;
    var promise = ctx.promise;
    var receiver = ctx.receiver;
    var value = ctx.value;
    if (typeof handler === "function") {
        if (!(promise instanceof Promise)) {
            handler.call(receiver, value, promise);
        } else {
            this._settlePromiseFromHandler(handler, receiver, value, promise);
        }
    } else if (promise instanceof Promise) {
        promise._reject(value);
    }
};

Promise.prototype._settlePromiseCtx = function(ctx) {
    this._settlePromise(ctx.promise, ctx.handler, ctx.receiver, ctx.value);
};

Promise.prototype._settlePromise0 = function(handler, value, bitField) {
    var promise = this._promise0;
    var receiver = this._receiverAt(0);
    this._promise0 = undefined;
    this._receiver0 = undefined;
    this._settlePromise(promise, handler, receiver, value);
};

Promise.prototype._clearCallbackDataAtIndex = function(index) {
    var base = index * 4 - 4;
    this[base + 2] =
    this[base + 3] =
    this[base + 0] =
    this[base + 1] = undefined;
};

Promise.prototype._fulfill = function (value) {
    var bitField = this._bitField;
    if (((bitField & 117506048) >>> 16)) return;
    if (value === this) {
        var err = makeSelfResolutionError();
        this._attachExtraTrace(err);
        return this._reject(err);
    }
    this._setFulfilled();
    this._rejectionHandler0 = value;

    if ((bitField & 65535) > 0) {
        if (((bitField & 134217728) !== 0)) {
            this._settlePromises();
        } else {
            async.settlePromises(this);
        }
    }
};

Promise.prototype._reject = function (reason) {
    var bitField = this._bitField;
    if (((bitField & 117506048) >>> 16)) return;
    this._setRejected();
    this._fulfillmentHandler0 = reason;

    if (this._isFinal()) {
        return async.fatalError(reason, util.isNode);
    }

    if ((bitField & 65535) > 0) {
        async.settlePromises(this);
    } else {
        this._ensurePossibleRejectionHandled();
    }
};

Promise.prototype._fulfillPromises = function (len, value) {
    for (var i = 1; i < len; i++) {
        var handler = this._fulfillmentHandlerAt(i);
        var promise = this._promiseAt(i);
        var receiver = this._receiverAt(i);
        this._clearCallbackDataAtIndex(i);
        this._settlePromise(promise, handler, receiver, value);
    }
};

Promise.prototype._rejectPromises = function (len, reason) {
    for (var i = 1; i < len; i++) {
        var handler = this._rejectionHandlerAt(i);
        var promise = this._promiseAt(i);
        var receiver = this._receiverAt(i);
        this._clearCallbackDataAtIndex(i);
        this._settlePromise(promise, handler, receiver, reason);
    }
};

Promise.prototype._settlePromises = function () {
    var bitField = this._bitField;
    var len = (bitField & 65535);

    if (len > 0) {
        if (((bitField & 16842752) !== 0)) {
            var reason = this._fulfillmentHandler0;
            this._settlePromise0(this._rejectionHandler0, reason, bitField);
            this._rejectPromises(len, reason);
        } else {
            var value = this._rejectionHandler0;
            this._settlePromise0(this._fulfillmentHandler0, value, bitField);
            this._fulfillPromises(len, value);
        }
        this._setLength(0);
    }
    this._clearCancellationData();
};

Promise.prototype._settledValue = function() {
    var bitField = this._bitField;
    if (((bitField & 33554432) !== 0)) {
        return this._rejectionHandler0;
    } else if (((bitField & 16777216) !== 0)) {
        return this._fulfillmentHandler0;
    }
};

function deferResolve(v) {this.promise._resolveCallback(v);}
function deferReject(v) {this.promise._rejectCallback(v, false);}

Promise.defer = Promise.pending = function() {
    debug.deprecated("Promise.defer", "new Promise");
    var promise = new Promise(INTERNAL);
    return {
        promise: promise,
        resolve: deferResolve,
        reject: deferReject
    };
};

util.notEnumerableProp(Promise,
                       "_makeSelfResolutionError",
                       makeSelfResolutionError);

_dereq_("./method")(Promise, INTERNAL, tryConvertToPromise, apiRejection,
    debug);
_dereq_("./bind")(Promise, INTERNAL, tryConvertToPromise, debug);
_dereq_("./cancel")(Promise, PromiseArray, apiRejection, debug);
_dereq_("./direct_resolve")(Promise);
_dereq_("./synchronous_inspection")(Promise);
_dereq_("./join")(
    Promise, PromiseArray, tryConvertToPromise, INTERNAL, async, getDomain);
Promise.Promise = Promise;
Promise.version = "3.5.0";
_dereq_('./map.js')(Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug);
_dereq_('./call_get.js')(Promise);
_dereq_('./using.js')(Promise, apiRejection, tryConvertToPromise, createContext, INTERNAL, debug);
_dereq_('./timers.js')(Promise, INTERNAL, debug);
_dereq_('./generators.js')(Promise, apiRejection, INTERNAL, tryConvertToPromise, Proxyable, debug);
_dereq_('./nodeify.js')(Promise);
_dereq_('./promisify.js')(Promise, INTERNAL);
_dereq_('./props.js')(Promise, PromiseArray, tryConvertToPromise, apiRejection);
_dereq_('./race.js')(Promise, INTERNAL, tryConvertToPromise, apiRejection);
_dereq_('./reduce.js')(Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug);
_dereq_('./settle.js')(Promise, PromiseArray, debug);
_dereq_('./some.js')(Promise, PromiseArray, apiRejection);
_dereq_('./filter.js')(Promise, INTERNAL);
_dereq_('./each.js')(Promise, INTERNAL);
_dereq_('./any.js')(Promise);

    util.toFastProperties(Promise);
    util.toFastProperties(Promise.prototype);
    function fillTypes(value) {
        var p = new Promise(INTERNAL);
        p._fulfillmentHandler0 = value;
        p._rejectionHandler0 = value;
        p._promise0 = value;
        p._receiver0 = value;
    }
    // Complete slack tracking, opt out of field-type tracking and
    // stabilize map
    fillTypes({a: 1});
    fillTypes({b: 2});
    fillTypes({c: 3});
    fillTypes(1);
    fillTypes(function(){});
    fillTypes(undefined);
    fillTypes(false);
    fillTypes(new Promise(INTERNAL));
    debug.setBounds(Async.firstLineError, util.lastLineError);
    return Promise;

};

},{"./any.js":1,"./async":2,"./bind":3,"./call_get.js":5,"./cancel":6,"./catch_filter":7,"./context":8,"./debuggability":9,"./direct_resolve":10,"./each.js":11,"./errors":12,"./es5":13,"./filter.js":14,"./finally":15,"./generators.js":16,"./join":17,"./map.js":18,"./method":19,"./nodeback":20,"./nodeify.js":21,"./promise_array":23,"./promisify.js":24,"./props.js":25,"./race.js":27,"./reduce.js":28,"./settle.js":30,"./some.js":31,"./synchronous_inspection":32,"./thenables":33,"./timers.js":34,"./using.js":35,"./util":36}],23:[function(_dereq_,module,exports){
"use strict";
module.exports = function(Promise, INTERNAL, tryConvertToPromise,
    apiRejection, Proxyable) {
var util = _dereq_("./util");
var isArray = util.isArray;

function toResolutionValue(val) {
    switch(val) {
    case -2: return [];
    case -3: return {};
    case -6: return new Map();
    }
}

function PromiseArray(values) {
    var promise = this._promise = new Promise(INTERNAL);
    if (values instanceof Promise) {
        promise._propagateFrom(values, 3);
    }
    promise._setOnCancel(this);
    this._values = values;
    this._length = 0;
    this._totalResolved = 0;
    this._init(undefined, -2);
}
util.inherits(PromiseArray, Proxyable);

PromiseArray.prototype.length = function () {
    return this._length;
};

PromiseArray.prototype.promise = function () {
    return this._promise;
};

PromiseArray.prototype._init = function init(_, resolveValueIfEmpty) {
    var values = tryConvertToPromise(this._values, this._promise);
    if (values instanceof Promise) {
        values = values._target();
        var bitField = values._bitField;
        ;
        this._values = values;

        if (((bitField & 50397184) === 0)) {
            this._promise._setAsyncGuaranteed();
            return values._then(
                init,
                this._reject,
                undefined,
                this,
                resolveValueIfEmpty
           );
        } else if (((bitField & 33554432) !== 0)) {
            values = values._value();
        } else if (((bitField & 16777216) !== 0)) {
            return this._reject(values._reason());
        } else {
            return this._cancel();
        }
    }
    values = util.asArray(values);
    if (values === null) {
        var err = apiRejection(
            "expecting an array or an iterable object but got " + util.classString(values)).reason();
        this._promise._rejectCallback(err, false);
        return;
    }

    if (values.length === 0) {
        if (resolveValueIfEmpty === -5) {
            this._resolveEmptyArray();
        }
        else {
            this._resolve(toResolutionValue(resolveValueIfEmpty));
        }
        return;
    }
    this._iterate(values);
};

PromiseArray.prototype._iterate = function(values) {
    var len = this.getActualLength(values.length);
    this._length = len;
    this._values = this.shouldCopyValues() ? new Array(len) : this._values;
    var result = this._promise;
    var isResolved = false;
    var bitField = null;
    for (var i = 0; i < len; ++i) {
        var maybePromise = tryConvertToPromise(values[i], result);

        if (maybePromise instanceof Promise) {
            maybePromise = maybePromise._target();
            bitField = maybePromise._bitField;
        } else {
            bitField = null;
        }

        if (isResolved) {
            if (bitField !== null) {
                maybePromise.suppressUnhandledRejections();
            }
        } else if (bitField !== null) {
            if (((bitField & 50397184) === 0)) {
                maybePromise._proxy(this, i);
                this._values[i] = maybePromise;
            } else if (((bitField & 33554432) !== 0)) {
                isResolved = this._promiseFulfilled(maybePromise._value(), i);
            } else if (((bitField & 16777216) !== 0)) {
                isResolved = this._promiseRejected(maybePromise._reason(), i);
            } else {
                isResolved = this._promiseCancelled(i);
            }
        } else {
            isResolved = this._promiseFulfilled(maybePromise, i);
        }
    }
    if (!isResolved) result._setAsyncGuaranteed();
};

PromiseArray.prototype._isResolved = function () {
    return this._values === null;
};

PromiseArray.prototype._resolve = function (value) {
    this._values = null;
    this._promise._fulfill(value);
};

PromiseArray.prototype._cancel = function() {
    if (this._isResolved() || !this._promise._isCancellable()) return;
    this._values = null;
    this._promise._cancel();
};

PromiseArray.prototype._reject = function (reason) {
    this._values = null;
    this._promise._rejectCallback(reason, false);
};

PromiseArray.prototype._promiseFulfilled = function (value, index) {
    this._values[index] = value;
    var totalResolved = ++this._totalResolved;
    if (totalResolved >= this._length) {
        this._resolve(this._values);
        return true;
    }
    return false;
};

PromiseArray.prototype._promiseCancelled = function() {
    this._cancel();
    return true;
};

PromiseArray.prototype._promiseRejected = function (reason) {
    this._totalResolved++;
    this._reject(reason);
    return true;
};

PromiseArray.prototype._resultCancelled = function() {
    if (this._isResolved()) return;
    var values = this._values;
    this._cancel();
    if (values instanceof Promise) {
        values.cancel();
    } else {
        for (var i = 0; i < values.length; ++i) {
            if (values[i] instanceof Promise) {
                values[i].cancel();
            }
        }
    }
};

PromiseArray.prototype.shouldCopyValues = function () {
    return true;
};

PromiseArray.prototype.getActualLength = function (len) {
    return len;
};

return PromiseArray;
};

},{"./util":36}],24:[function(_dereq_,module,exports){
"use strict";
module.exports = function(Promise, INTERNAL) {
var THIS = {};
var util = _dereq_("./util");
var nodebackForPromise = _dereq_("./nodeback");
var withAppended = util.withAppended;
var maybeWrapAsError = util.maybeWrapAsError;
var canEvaluate = util.canEvaluate;
var TypeError = _dereq_("./errors").TypeError;
var defaultSuffix = "Async";
var defaultPromisified = {__isPromisified__: true};
var noCopyProps = [
    "arity",    "length",
    "name",
    "arguments",
    "caller",
    "callee",
    "prototype",
    "__isPromisified__"
];
var noCopyPropsPattern = new RegExp("^(?:" + noCopyProps.join("|") + ")$");

var defaultFilter = function(name) {
    return util.isIdentifier(name) &&
        name.charAt(0) !== "_" &&
        name !== "constructor";
};

function propsFilter(key) {
    return !noCopyPropsPattern.test(key);
}

function isPromisified(fn) {
    try {
        return fn.__isPromisified__ === true;
    }
    catch (e) {
        return false;
    }
}

function hasPromisified(obj, key, suffix) {
    var val = util.getDataPropertyOrDefault(obj, key + suffix,
                                            defaultPromisified);
    return val ? isPromisified(val) : false;
}
function checkValid(ret, suffix, suffixRegexp) {
    for (var i = 0; i < ret.length; i += 2) {
        var key = ret[i];
        if (suffixRegexp.test(key)) {
            var keyWithoutAsyncSuffix = key.replace(suffixRegexp, "");
            for (var j = 0; j < ret.length; j += 2) {
                if (ret[j] === keyWithoutAsyncSuffix) {
                    throw new TypeError("Cannot promisify an API that has normal methods with '%s'-suffix\u000a\u000a    See http://goo.gl/MqrFmX\u000a"
                        .replace("%s", suffix));
                }
            }
        }
    }
}

function promisifiableMethods(obj, suffix, suffixRegexp, filter) {
    var keys = util.inheritedDataKeys(obj);
    var ret = [];
    for (var i = 0; i < keys.length; ++i) {
        var key = keys[i];
        var value = obj[key];
        var passesDefaultFilter = filter === defaultFilter
            ? true : defaultFilter(key, value, obj);
        if (typeof value === "function" &&
            !isPromisified(value) &&
            !hasPromisified(obj, key, suffix) &&
            filter(key, value, obj, passesDefaultFilter)) {
            ret.push(key, value);
        }
    }
    checkValid(ret, suffix, suffixRegexp);
    return ret;
}

var escapeIdentRegex = function(str) {
    return str.replace(/([$])/, "\\$");
};

var makeNodePromisifiedEval;
if (!true) {
var switchCaseArgumentOrder = function(likelyArgumentCount) {
    var ret = [likelyArgumentCount];
    var min = Math.max(0, likelyArgumentCount - 1 - 3);
    for(var i = likelyArgumentCount - 1; i >= min; --i) {
        ret.push(i);
    }
    for(var i = likelyArgumentCount + 1; i <= 3; ++i) {
        ret.push(i);
    }
    return ret;
};

var argumentSequence = function(argumentCount) {
    return util.filledRange(argumentCount, "_arg", "");
};

var parameterDeclaration = function(parameterCount) {
    return util.filledRange(
        Math.max(parameterCount, 3), "_arg", "");
};

var parameterCount = function(fn) {
    if (typeof fn.length === "number") {
        return Math.max(Math.min(fn.length, 1023 + 1), 0);
    }
    return 0;
};

makeNodePromisifiedEval =
function(callback, receiver, originalName, fn, _, multiArgs) {
    var newParameterCount = Math.max(0, parameterCount(fn) - 1);
    var argumentOrder = switchCaseArgumentOrder(newParameterCount);
    var shouldProxyThis = typeof callback === "string" || receiver === THIS;

    function generateCallForArgumentCount(count) {
        var args = argumentSequence(count).join(", ");
        var comma = count > 0 ? ", " : "";
        var ret;
        if (shouldProxyThis) {
            ret = "ret = callback.call(this, {{args}}, nodeback); break;\n";
        } else {
            ret = receiver === undefined
                ? "ret = callback({{args}}, nodeback); break;\n"
                : "ret = callback.call(receiver, {{args}}, nodeback); break;\n";
        }
        return ret.replace("{{args}}", args).replace(", ", comma);
    }

    function generateArgumentSwitchCase() {
        var ret = "";
        for (var i = 0; i < argumentOrder.length; ++i) {
            ret += "case " + argumentOrder[i] +":" +
                generateCallForArgumentCount(argumentOrder[i]);
        }

        ret += "                                                             \n\
        default:                                                             \n\
            var args = new Array(len + 1);                                   \n\
            var i = 0;                                                       \n\
            for (var i = 0; i < len; ++i) {                                  \n\
               args[i] = arguments[i];                                       \n\
            }                                                                \n\
            args[i] = nodeback;                                              \n\
            [CodeForCall]                                                    \n\
            break;                                                           \n\
        ".replace("[CodeForCall]", (shouldProxyThis
                                ? "ret = callback.apply(this, args);\n"
                                : "ret = callback.apply(receiver, args);\n"));
        return ret;
    }

    var getFunctionCode = typeof callback === "string"
                                ? ("this != null ? this['"+callback+"'] : fn")
                                : "fn";
    var body = "'use strict';                                                \n\
        var ret = function (Parameters) {                                    \n\
            'use strict';                                                    \n\
            var len = arguments.length;                                      \n\
            var promise = new Promise(INTERNAL);                             \n\
            promise._captureStackTrace();                                    \n\
            var nodeback = nodebackForPromise(promise, " + multiArgs + ");   \n\
            var ret;                                                         \n\
            var callback = tryCatch([GetFunctionCode]);                      \n\
            switch(len) {                                                    \n\
                [CodeForSwitchCase]                                          \n\
            }                                                                \n\
            if (ret === errorObj) {                                          \n\
                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\n\
            }                                                                \n\
            if (!promise._isFateSealed()) promise._setAsyncGuaranteed();     \n\
            return promise;                                                  \n\
        };                                                                   \n\
        notEnumerableProp(ret, '__isPromisified__', true);                   \n\
        return ret;                                                          \n\
    ".replace("[CodeForSwitchCase]", generateArgumentSwitchCase())
        .replace("[GetFunctionCode]", getFunctionCode);
    body = body.replace("Parameters", parameterDeclaration(newParameterCount));
    return new Function("Promise",
                        "fn",
                        "receiver",
                        "withAppended",
                        "maybeWrapAsError",
                        "nodebackForPromise",
                        "tryCatch",
                        "errorObj",
                        "notEnumerableProp",
                        "INTERNAL",
                        body)(
                    Promise,
                    fn,
                    receiver,
                    withAppended,
                    maybeWrapAsError,
                    nodebackForPromise,
                    util.tryCatch,
                    util.errorObj,
                    util.notEnumerableProp,
                    INTERNAL);
};
}

function makeNodePromisifiedClosure(callback, receiver, _, fn, __, multiArgs) {
    var defaultThis = (function() {return this;})();
    var method = callback;
    if (typeof method === "string") {
        callback = fn;
    }
    function promisified() {
        var _receiver = receiver;
        if (receiver === THIS) _receiver = this;
        var promise = new Promise(INTERNAL);
        promise._captureStackTrace();
        var cb = typeof method === "string" && this !== defaultThis
            ? this[method] : callback;
        var fn = nodebackForPromise(promise, multiArgs);
        try {
            cb.apply(_receiver, withAppended(arguments, fn));
        } catch(e) {
            promise._rejectCallback(maybeWrapAsError(e), true, true);
        }
        if (!promise._isFateSealed()) promise._setAsyncGuaranteed();
        return promise;
    }
    util.notEnumerableProp(promisified, "__isPromisified__", true);
    return promisified;
}

var makeNodePromisified = canEvaluate
    ? makeNodePromisifiedEval
    : makeNodePromisifiedClosure;

function promisifyAll(obj, suffix, filter, promisifier, multiArgs) {
    var suffixRegexp = new RegExp(escapeIdentRegex(suffix) + "$");
    var methods =
        promisifiableMethods(obj, suffix, suffixRegexp, filter);

    for (var i = 0, len = methods.length; i < len; i+= 2) {
        var key = methods[i];
        var fn = methods[i+1];
        var promisifiedKey = key + suffix;
        if (promisifier === makeNodePromisified) {
            obj[promisifiedKey] =
                makeNodePromisified(key, THIS, key, fn, suffix, multiArgs);
        } else {
            var promisified = promisifier(fn, function() {
                return makeNodePromisified(key, THIS, key,
                                           fn, suffix, multiArgs);
            });
            util.notEnumerableProp(promisified, "__isPromisified__", true);
            obj[promisifiedKey] = promisified;
        }
    }
    util.toFastProperties(obj);
    return obj;
}

function promisify(callback, receiver, multiArgs) {
    return makeNodePromisified(callback, receiver, undefined,
                                callback, null, multiArgs);
}

Promise.promisify = function (fn, options) {
    if (typeof fn !== "function") {
        throw new TypeError("expecting a function but got " + util.classString(fn));
    }
    if (isPromisified(fn)) {
        return fn;
    }
    options = Object(options);
    var receiver = options.context === undefined ? THIS : options.context;
    var multiArgs = !!options.multiArgs;
    var ret = promisify(fn, receiver, multiArgs);
    util.copyDescriptors(fn, ret, propsFilter);
    return ret;
};

Promise.promisifyAll = function (target, options) {
    if (typeof target !== "function" && typeof target !== "object") {
        throw new TypeError("the target of promisifyAll must be an object or a function\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
    }
    options = Object(options);
    var multiArgs = !!options.multiArgs;
    var suffix = options.suffix;
    if (typeof suffix !== "string") suffix = defaultSuffix;
    var filter = options.filter;
    if (typeof filter !== "function") filter = defaultFilter;
    var promisifier = options.promisifier;
    if (typeof promisifier !== "function") promisifier = makeNodePromisified;

    if (!util.isIdentifier(suffix)) {
        throw new RangeError("suffix must be a valid identifier\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
    }

    var keys = util.inheritedDataKeys(target);
    for (var i = 0; i < keys.length; ++i) {
        var value = target[keys[i]];
        if (keys[i] !== "constructor" &&
            util.isClass(value)) {
            promisifyAll(value.prototype, suffix, filter, promisifier,
                multiArgs);
            promisifyAll(value, suffix, filter, promisifier, multiArgs);
        }
    }

    return promisifyAll(target, suffix, filter, promisifier, multiArgs);
};
};


},{"./errors":12,"./nodeback":20,"./util":36}],25:[function(_dereq_,module,exports){
"use strict";
module.exports = function(
    Promise, PromiseArray, tryConvertToPromise, apiRejection) {
var util = _dereq_("./util");
var isObject = util.isObject;
var es5 = _dereq_("./es5");
var Es6Map;
if (typeof Map === "function") Es6Map = Map;

var mapToEntries = (function() {
    var index = 0;
    var size = 0;

    function extractEntry(value, key) {
        this[index] = value;
        this[index + size] = key;
        index++;
    }

    return function mapToEntries(map) {
        size = map.size;
        index = 0;
        var ret = new Array(map.size * 2);
        map.forEach(extractEntry, ret);
        return ret;
    };
})();

var entriesToMap = function(entries) {
    var ret = new Es6Map();
    var length = entries.length / 2 | 0;
    for (var i = 0; i < length; ++i) {
        var key = entries[length + i];
        var value = entries[i];
        ret.set(key, value);
    }
    return ret;
};

function PropertiesPromiseArray(obj) {
    var isMap = false;
    var entries;
    if (Es6Map !== undefined && obj instanceof Es6Map) {
        entries = mapToEntries(obj);
        isMap = true;
    } else {
        var keys = es5.keys(obj);
        var len = keys.length;
        entries = new Array(len * 2);
        for (var i = 0; i < len; ++i) {
            var key = keys[i];
            entries[i] = obj[key];
            entries[i + len] = key;
        }
    }
    this.constructor$(entries);
    this._isMap = isMap;
    this._init$(undefined, isMap ? -6 : -3);
}
util.inherits(PropertiesPromiseArray, PromiseArray);

PropertiesPromiseArray.prototype._init = function () {};

PropertiesPromiseArray.prototype._promiseFulfilled = function (value, index) {
    this._values[index] = value;
    var totalResolved = ++this._totalResolved;
    if (totalResolved >= this._length) {
        var val;
        if (this._isMap) {
            val = entriesToMap(this._values);
        } else {
            val = {};
            var keyOffset = this.length();
            for (var i = 0, len = this.length(); i < len; ++i) {
                val[this._values[i + keyOffset]] = this._values[i];
            }
        }
        this._resolve(val);
        return true;
    }
    return false;
};

PropertiesPromiseArray.prototype.shouldCopyValues = function () {
    return false;
};

PropertiesPromiseArray.prototype.getActualLength = function (len) {
    return len >> 1;
};

function props(promises) {
    var ret;
    var castValue = tryConvertToPromise(promises);

    if (!isObject(castValue)) {
        return apiRejection("cannot await properties of a non-object\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
    } else if (castValue instanceof Promise) {
        ret = castValue._then(
            Promise.props, undefined, undefined, undefined, undefined);
    } else {
        ret = new PropertiesPromiseArray(castValue).promise();
    }

    if (castValue instanceof Promise) {
        ret._propagateFrom(castValue, 2);
    }
    return ret;
}

Promise.prototype.props = function () {
    return props(this);
};

Promise.props = function (promises) {
    return props(promises);
};
};

},{"./es5":13,"./util":36}],26:[function(_dereq_,module,exports){
"use strict";
function arrayMove(src, srcIndex, dst, dstIndex, len) {
    for (var j = 0; j < len; ++j) {
        dst[j + dstIndex] = src[j + srcIndex];
        src[j + srcIndex] = void 0;
    }
}

function Queue(capacity) {
    this._capacity = capacity;
    this._length = 0;
    this._front = 0;
}

Queue.prototype._willBeOverCapacity = function (size) {
    return this._capacity < size;
};

Queue.prototype._pushOne = function (arg) {
    var length = this.length();
    this._checkCapacity(length + 1);
    var i = (this._front + length) & (this._capacity - 1);
    this[i] = arg;
    this._length = length + 1;
};

Queue.prototype.push = function (fn, receiver, arg) {
    var length = this.length() + 3;
    if (this._willBeOverCapacity(length)) {
        this._pushOne(fn);
        this._pushOne(receiver);
        this._pushOne(arg);
        return;
    }
    var j = this._front + length - 3;
    this._checkCapacity(length);
    var wrapMask = this._capacity - 1;
    this[(j + 0) & wrapMask] = fn;
    this[(j + 1) & wrapMask] = receiver;
    this[(j + 2) & wrapMask] = arg;
    this._length = length;
};

Queue.prototype.shift = function () {
    var front = this._front,
        ret = this[front];

    this[front] = undefined;
    this._front = (front + 1) & (this._capacity - 1);
    this._length--;
    return ret;
};

Queue.prototype.length = function () {
    return this._length;
};

Queue.prototype._checkCapacity = function (size) {
    if (this._capacity < size) {
        this._resizeTo(this._capacity << 1);
    }
};

Queue.prototype._resizeTo = function (capacity) {
    var oldCapacity = this._capacity;
    this._capacity = capacity;
    var front = this._front;
    var length = this._length;
    var moveItemsCount = (front + length) & (oldCapacity - 1);
    arrayMove(this, 0, this, oldCapacity, moveItemsCount);
};

module.exports = Queue;

},{}],27:[function(_dereq_,module,exports){
"use strict";
module.exports = function(
    Promise, INTERNAL, tryConvertToPromise, apiRejection) {
var util = _dereq_("./util");

var raceLater = function (promise) {
    return promise.then(function(array) {
        return race(array, promise);
    });
};

function race(promises, parent) {
    var maybePromise = tryConvertToPromise(promises);

    if (maybePromise instanceof Promise) {
        return raceLater(maybePromise);
    } else {
        promises = util.asArray(promises);
        if (promises === null)
            return apiRejection("expecting an array or an iterable object but got " + util.classString(promises));
    }

    var ret = new Promise(INTERNAL);
    if (parent !== undefined) {
        ret._propagateFrom(parent, 3);
    }
    var fulfill = ret._fulfill;
    var reject = ret._reject;
    for (var i = 0, len = promises.length; i < len; ++i) {
        var val = promises[i];

        if (val === undefined && !(i in promises)) {
            continue;
        }

        Promise.cast(val)._then(fulfill, reject, undefined, ret, null);
    }
    return ret;
}

Promise.race = function (promises) {
    return race(promises, undefined);
};

Promise.prototype.race = function () {
    return race(this, undefined);
};

};

},{"./util":36}],28:[function(_dereq_,module,exports){
"use strict";
module.exports = function(Promise,
                          PromiseArray,
                          apiRejection,
                          tryConvertToPromise,
                          INTERNAL,
                          debug) {
var getDomain = Promise._getDomain;
var util = _dereq_("./util");
var tryCatch = util.tryCatch;

function ReductionPromiseArray(promises, fn, initialValue, _each) {
    this.constructor$(promises);
    var domain = getDomain();
    this._fn = domain === null ? fn : util.domainBind(domain, fn);
    if (initialValue !== undefined) {
        initialValue = Promise.resolve(initialValue);
        initialValue._attachCancellationCallback(this);
    }
    this._initialValue = initialValue;
    this._currentCancellable = null;
    if(_each === INTERNAL) {
        this._eachValues = Array(this._length);
    } else if (_each === 0) {
        this._eachValues = null;
    } else {
        this._eachValues = undefined;
    }
    this._promise._captureStackTrace();
    this._init$(undefined, -5);
}
util.inherits(ReductionPromiseArray, PromiseArray);

ReductionPromiseArray.prototype._gotAccum = function(accum) {
    if (this._eachValues !== undefined &&
        this._eachValues !== null &&
        accum !== INTERNAL) {
        this._eachValues.push(accum);
    }
};

ReductionPromiseArray.prototype._eachComplete = function(value) {
    if (this._eachValues !== null) {
        this._eachValues.push(value);
    }
    return this._eachValues;
};

ReductionPromiseArray.prototype._init = function() {};

ReductionPromiseArray.prototype._resolveEmptyArray = function() {
    this._resolve(this._eachValues !== undefined ? this._eachValues
                                                 : this._initialValue);
};

ReductionPromiseArray.prototype.shouldCopyValues = function () {
    return false;
};

ReductionPromiseArray.prototype._resolve = function(value) {
    this._promise._resolveCallback(value);
    this._values = null;
};

ReductionPromiseArray.prototype._resultCancelled = function(sender) {
    if (sender === this._initialValue) return this._cancel();
    if (this._isResolved()) return;
    this._resultCancelled$();
    if (this._currentCancellable instanceof Promise) {
        this._currentCancellable.cancel();
    }
    if (this._initialValue instanceof Promise) {
        this._initialValue.cancel();
    }
};

ReductionPromiseArray.prototype._iterate = function (values) {
    this._values = values;
    var value;
    var i;
    var length = values.length;
    if (this._initialValue !== undefined) {
        value = this._initialValue;
        i = 0;
    } else {
        value = Promise.resolve(values[0]);
        i = 1;
    }

    this._currentCancellable = value;

    if (!value.isRejected()) {
        for (; i < length; ++i) {
            var ctx = {
                accum: null,
                value: values[i],
                index: i,
                length: length,
                array: this
            };
            value = value._then(gotAccum, undefined, undefined, ctx, undefined);
        }
    }

    if (this._eachValues !== undefined) {
        value = value
            ._then(this._eachComplete, undefined, undefined, this, undefined);
    }
    value._then(completed, completed, undefined, value, this);
};

Promise.prototype.reduce = function (fn, initialValue) {
    return reduce(this, fn, initialValue, null);
};

Promise.reduce = function (promises, fn, initialValue, _each) {
    return reduce(promises, fn, initialValue, _each);
};

function completed(valueOrReason, array) {
    if (this.isFulfilled()) {
        array._resolve(valueOrReason);
    } else {
        array._reject(valueOrReason);
    }
}

function reduce(promises, fn, initialValue, _each) {
    if (typeof fn !== "function") {
        return apiRejection("expecting a function but got " + util.classString(fn));
    }
    var array = new ReductionPromiseArray(promises, fn, initialValue, _each);
    return array.promise();
}

function gotAccum(accum) {
    this.accum = accum;
    this.array._gotAccum(accum);
    var value = tryConvertToPromise(this.value, this.array._promise);
    if (value instanceof Promise) {
        this.array._currentCancellable = value;
        return value._then(gotValue, undefined, undefined, this, undefined);
    } else {
        return gotValue.call(this, value);
    }
}

function gotValue(value) {
    var array = this.array;
    var promise = array._promise;
    var fn = tryCatch(array._fn);
    promise._pushContext();
    var ret;
    if (array._eachValues !== undefined) {
        ret = fn.call(promise._boundValue(), value, this.index, this.length);
    } else {
        ret = fn.call(promise._boundValue(),
                              this.accum, value, this.index, this.length);
    }
    if (ret instanceof Promise) {
        array._currentCancellable = ret;
    }
    var promiseCreated = promise._popContext();
    debug.checkForgottenReturns(
        ret,
        promiseCreated,
        array._eachValues !== undefined ? "Promise.each" : "Promise.reduce",
        promise
    );
    return ret;
}
};

},{"./util":36}],29:[function(_dereq_,module,exports){
"use strict";
var util = _dereq_("./util");
var schedule;
var noAsyncScheduler = function() {
    throw new Error("No async scheduler available\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
};
var NativePromise = util.getNativePromise();
if (util.isNode && typeof MutationObserver === "undefined") {
    var GlobalSetImmediate = global.setImmediate;
    var ProcessNextTick = process.nextTick;
    schedule = util.isRecentNode
                ? function(fn) { GlobalSetImmediate.call(global, fn); }
                : function(fn) { ProcessNextTick.call(process, fn); };
} else if (typeof NativePromise === "function" &&
           typeof NativePromise.resolve === "function") {
    var nativePromise = NativePromise.resolve();
    schedule = function(fn) {
        nativePromise.then(fn);
    };
} else if ((typeof MutationObserver !== "undefined") &&
          !(typeof window !== "undefined" &&
            window.navigator &&
            (window.navigator.standalone || window.cordova))) {
    schedule = (function() {
        var div = document.createElement("div");
        var opts = {attributes: true};
        var toggleScheduled = false;
        var div2 = document.createElement("div");
        var o2 = new MutationObserver(function() {
            div.classList.toggle("foo");
            toggleScheduled = false;
        });
        o2.observe(div2, opts);

        var scheduleToggle = function() {
            if (toggleScheduled) return;
            toggleScheduled = true;
            div2.classList.toggle("foo");
        };

        return function schedule(fn) {
            var o = new MutationObserver(function() {
                o.disconnect();
                fn();
            });
            o.observe(div, opts);
            scheduleToggle();
        };
    })();
} else if (typeof setImmediate !== "undefined") {
    schedule = function (fn) {
        setImmediate(fn);
    };
} else if (typeof setTimeout !== "undefined") {
    schedule = function (fn) {
        setTimeout(fn, 0);
    };
} else {
    schedule = noAsyncScheduler;
}
module.exports = schedule;

},{"./util":36}],30:[function(_dereq_,module,exports){
"use strict";
module.exports =
    function(Promise, PromiseArray, debug) {
var PromiseInspection = Promise.PromiseInspection;
var util = _dereq_("./util");

function SettledPromiseArray(values) {
    this.constructor$(values);
}
util.inherits(SettledPromiseArray, PromiseArray);

SettledPromiseArray.prototype._promiseResolved = function (index, inspection) {
    this._values[index] = inspection;
    var totalResolved = ++this._totalResolved;
    if (totalResolved >= this._length) {
        this._resolve(this._values);
        return true;
    }
    return false;
};

SettledPromiseArray.prototype._promiseFulfilled = function (value, index) {
    var ret = new PromiseInspection();
    ret._bitField = 33554432;
    ret._settledValueField = value;
    return this._promiseResolved(index, ret);
};
SettledPromiseArray.prototype._promiseRejected = function (reason, index) {
    var ret = new PromiseInspection();
    ret._bitField = 16777216;
    ret._settledValueField = reason;
    return this._promiseResolved(index, ret);
};

Promise.settle = function (promises) {
    debug.deprecated(".settle()", ".reflect()");
    return new SettledPromiseArray(promises).promise();
};

Promise.prototype.settle = function () {
    return Promise.settle(this);
};
};

},{"./util":36}],31:[function(_dereq_,module,exports){
"use strict";
module.exports =
function(Promise, PromiseArray, apiRejection) {
var util = _dereq_("./util");
var RangeError = _dereq_("./errors").RangeError;
var AggregateError = _dereq_("./errors").AggregateError;
var isArray = util.isArray;
var CANCELLATION = {};


function SomePromiseArray(values) {
    this.constructor$(values);
    this._howMany = 0;
    this._unwrap = false;
    this._initialized = false;
}
util.inherits(SomePromiseArray, PromiseArray);

SomePromiseArray.prototype._init = function () {
    if (!this._initialized) {
        return;
    }
    if (this._howMany === 0) {
        this._resolve([]);
        return;
    }
    this._init$(undefined, -5);
    var isArrayResolved = isArray(this._values);
    if (!this._isResolved() &&
        isArrayResolved &&
        this._howMany > this._canPossiblyFulfill()) {
        this._reject(this._getRangeError(this.length()));
    }
};

SomePromiseArray.prototype.init = function () {
    this._initialized = true;
    this._init();
};

SomePromiseArray.prototype.setUnwrap = function () {
    this._unwrap = true;
};

SomePromiseArray.prototype.howMany = function () {
    return this._howMany;
};

SomePromiseArray.prototype.setHowMany = function (count) {
    this._howMany = count;
};

SomePromiseArray.prototype._promiseFulfilled = function (value) {
    this._addFulfilled(value);
    if (this._fulfilled() === this.howMany()) {
        this._values.length = this.howMany();
        if (this.howMany() === 1 && this._unwrap) {
            this._resolve(this._values[0]);
        } else {
            this._resolve(this._values);
        }
        return true;
    }
    return false;

};
SomePromiseArray.prototype._promiseRejected = function (reason) {
    this._addRejected(reason);
    return this._checkOutcome();
};

SomePromiseArray.prototype._promiseCancelled = function () {
    if (this._values instanceof Promise || this._values == null) {
        return this._cancel();
    }
    this._addRejected(CANCELLATION);
    return this._checkOutcome();
};

SomePromiseArray.prototype._checkOutcome = function() {
    if (this.howMany() > this._canPossiblyFulfill()) {
        var e = new AggregateError();
        for (var i = this.length(); i < this._values.length; ++i) {
            if (this._values[i] !== CANCELLATION) {
                e.push(this._values[i]);
            }
        }
        if (e.length > 0) {
            this._reject(e);
        } else {
            this._cancel();
        }
        return true;
    }
    return false;
};

SomePromiseArray.prototype._fulfilled = function () {
    return this._totalResolved;
};

SomePromiseArray.prototype._rejected = function () {
    return this._values.length - this.length();
};

SomePromiseArray.prototype._addRejected = function (reason) {
    this._values.push(reason);
};

SomePromiseArray.prototype._addFulfilled = function (value) {
    this._values[this._totalResolved++] = value;
};

SomePromiseArray.prototype._canPossiblyFulfill = function () {
    return this.length() - this._rejected();
};

SomePromiseArray.prototype._getRangeError = function (count) {
    var message = "Input array must contain at least " +
            this._howMany + " items but contains only " + count + " items";
    return new RangeError(message);
};

SomePromiseArray.prototype._resolveEmptyArray = function () {
    this._reject(this._getRangeError(0));
};

function some(promises, howMany) {
    if ((howMany | 0) !== howMany || howMany < 0) {
        return apiRejection("expecting a positive integer\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
    }
    var ret = new SomePromiseArray(promises);
    var promise = ret.promise();
    ret.setHowMany(howMany);
    ret.init();
    return promise;
}

Promise.some = function (promises, howMany) {
    return some(promises, howMany);
};

Promise.prototype.some = function (howMany) {
    return some(this, howMany);
};

Promise._SomePromiseArray = SomePromiseArray;
};

},{"./errors":12,"./util":36}],32:[function(_dereq_,module,exports){
"use strict";
module.exports = function(Promise) {
function PromiseInspection(promise) {
    if (promise !== undefined) {
        promise = promise._target();
        this._bitField = promise._bitField;
        this._settledValueField = promise._isFateSealed()
            ? promise._settledValue() : undefined;
    }
    else {
        this._bitField = 0;
        this._settledValueField = undefined;
    }
}

PromiseInspection.prototype._settledValue = function() {
    return this._settledValueField;
};

var value = PromiseInspection.prototype.value = function () {
    if (!this.isFulfilled()) {
        throw new TypeError("cannot get fulfillment value of a non-fulfilled promise\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
    }
    return this._settledValue();
};

var reason = PromiseInspection.prototype.error =
PromiseInspection.prototype.reason = function () {
    if (!this.isRejected()) {
        throw new TypeError("cannot get rejection reason of a non-rejected promise\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
    }
    return this._settledValue();
};

var isFulfilled = PromiseInspection.prototype.isFulfilled = function() {
    return (this._bitField & 33554432) !== 0;
};

var isRejected = PromiseInspection.prototype.isRejected = function () {
    return (this._bitField & 16777216) !== 0;
};

var isPending = PromiseInspection.prototype.isPending = function () {
    return (this._bitField & 50397184) === 0;
};

var isResolved = PromiseInspection.prototype.isResolved = function () {
    return (this._bitField & 50331648) !== 0;
};

PromiseInspection.prototype.isCancelled = function() {
    return (this._bitField & 8454144) !== 0;
};

Promise.prototype.__isCancelled = function() {
    return (this._bitField & 65536) === 65536;
};

Promise.prototype._isCancelled = function() {
    return this._target().__isCancelled();
};

Promise.prototype.isCancelled = function() {
    return (this._target()._bitField & 8454144) !== 0;
};

Promise.prototype.isPending = function() {
    return isPending.call(this._target());
};

Promise.prototype.isRejected = function() {
    return isRejected.call(this._target());
};

Promise.prototype.isFulfilled = function() {
    return isFulfilled.call(this._target());
};

Promise.prototype.isResolved = function() {
    return isResolved.call(this._target());
};

Promise.prototype.value = function() {
    return value.call(this._target());
};

Promise.prototype.reason = function() {
    var target = this._target();
    target._unsetRejectionIsUnhandled();
    return reason.call(target);
};

Promise.prototype._value = function() {
    return this._settledValue();
};

Promise.prototype._reason = function() {
    this._unsetRejectionIsUnhandled();
    return this._settledValue();
};

Promise.PromiseInspection = PromiseInspection;
};

},{}],33:[function(_dereq_,module,exports){
"use strict";
module.exports = function(Promise, INTERNAL) {
var util = _dereq_("./util");
var errorObj = util.errorObj;
var isObject = util.isObject;

function tryConvertToPromise(obj, context) {
    if (isObject(obj)) {
        if (obj instanceof Promise) return obj;
        var then = getThen(obj);
        if (then === errorObj) {
            if (context) context._pushContext();
            var ret = Promise.reject(then.e);
            if (context) context._popContext();
            return ret;
        } else if (typeof then === "function") {
            if (isAnyBluebirdPromise(obj)) {
                var ret = new Promise(INTERNAL);
                obj._then(
                    ret._fulfill,
                    ret._reject,
                    undefined,
                    ret,
                    null
                );
                return ret;
            }
            return doThenable(obj, then, context);
        }
    }
    return obj;
}

function doGetThen(obj) {
    return obj.then;
}

function getThen(obj) {
    try {
        return doGetThen(obj);
    } catch (e) {
        errorObj.e = e;
        return errorObj;
    }
}

var hasProp = {}.hasOwnProperty;
function isAnyBluebirdPromise(obj) {
    try {
        return hasProp.call(obj, "_promise0");
    } catch (e) {
        return false;
    }
}

function doThenable(x, then, context) {
    var promise = new Promise(INTERNAL);
    var ret = promise;
    if (context) context._pushContext();
    promise._captureStackTrace();
    if (context) context._popContext();
    var synchronous = true;
    var result = util.tryCatch(then).call(x, resolve, reject);
    synchronous = false;

    if (promise && result === errorObj) {
        promise._rejectCallback(result.e, true, true);
        promise = null;
    }

    function resolve(value) {
        if (!promise) return;
        promise._resolveCallback(value);
        promise = null;
    }

    function reject(reason) {
        if (!promise) return;
        promise._rejectCallback(reason, synchronous, true);
        promise = null;
    }
    return ret;
}

return tryConvertToPromise;
};

},{"./util":36}],34:[function(_dereq_,module,exports){
"use strict";
module.exports = function(Promise, INTERNAL, debug) {
var util = _dereq_("./util");
var TimeoutError = Promise.TimeoutError;

function HandleWrapper(handle)  {
    this.handle = handle;
}

HandleWrapper.prototype._resultCancelled = function() {
    clearTimeout(this.handle);
};

var afterValue = function(value) { return delay(+this).thenReturn(value); };
var delay = Promise.delay = function (ms, value) {
    var ret;
    var handle;
    if (value !== undefined) {
        ret = Promise.resolve(value)
                ._then(afterValue, null, null, ms, undefined);
        if (debug.cancellation() && value instanceof Promise) {
            ret._setOnCancel(value);
        }
    } else {
        ret = new Promise(INTERNAL);
        handle = setTimeout(function() { ret._fulfill(); }, +ms);
        if (debug.cancellation()) {
            ret._setOnCancel(new HandleWrapper(handle));
        }
        ret._captureStackTrace();
    }
    ret._setAsyncGuaranteed();
    return ret;
};

Promise.prototype.delay = function (ms) {
    return delay(ms, this);
};

var afterTimeout = function (promise, message, parent) {
    var err;
    if (typeof message !== "string") {
        if (message instanceof Error) {
            err = message;
        } else {
            err = new TimeoutError("operation timed out");
        }
    } else {
        err = new TimeoutError(message);
    }
    util.markAsOriginatingFromRejection(err);
    promise._attachExtraTrace(err);
    promise._reject(err);

    if (parent != null) {
        parent.cancel();
    }
};

function successClear(value) {
    clearTimeout(this.handle);
    return value;
}

function failureClear(reason) {
    clearTimeout(this.handle);
    throw reason;
}

Promise.prototype.timeout = function (ms, message) {
    ms = +ms;
    var ret, parent;

    var handleWrapper = new HandleWrapper(setTimeout(function timeoutTimeout() {
        if (ret.isPending()) {
            afterTimeout(ret, message, parent);
        }
    }, ms));

    if (debug.cancellation()) {
        parent = this.then();
        ret = parent._then(successClear, failureClear,
                            undefined, handleWrapper, undefined);
        ret._setOnCancel(handleWrapper);
    } else {
        ret = this._then(successClear, failureClear,
                            undefined, handleWrapper, undefined);
    }

    return ret;
};

};

},{"./util":36}],35:[function(_dereq_,module,exports){
"use strict";
module.exports = function (Promise, apiRejection, tryConvertToPromise,
    createContext, INTERNAL, debug) {
    var util = _dereq_("./util");
    var TypeError = _dereq_("./errors").TypeError;
    var inherits = _dereq_("./util").inherits;
    var errorObj = util.errorObj;
    var tryCatch = util.tryCatch;
    var NULL = {};

    function thrower(e) {
        setTimeout(function(){throw e;}, 0);
    }

    function castPreservingDisposable(thenable) {
        var maybePromise = tryConvertToPromise(thenable);
        if (maybePromise !== thenable &&
            typeof thenable._isDisposable === "function" &&
            typeof thenable._getDisposer === "function" &&
            thenable._isDisposable()) {
            maybePromise._setDisposable(thenable._getDisposer());
        }
        return maybePromise;
    }
    function dispose(resources, inspection) {
        var i = 0;
        var len = resources.length;
        var ret = new Promise(INTERNAL);
        function iterator() {
            if (i >= len) return ret._fulfill();
            var maybePromise = castPreservingDisposable(resources[i++]);
            if (maybePromise instanceof Promise &&
                maybePromise._isDisposable()) {
                try {
                    maybePromise = tryConvertToPromise(
                        maybePromise._getDisposer().tryDispose(inspection),
                        resources.promise);
                } catch (e) {
                    return thrower(e);
                }
                if (maybePromise instanceof Promise) {
                    return maybePromise._then(iterator, thrower,
                                              null, null, null);
                }
            }
            iterator();
        }
        iterator();
        return ret;
    }

    function Disposer(data, promise, context) {
        this._data = data;
        this._promise = promise;
        this._context = context;
    }

    Disposer.prototype.data = function () {
        return this._data;
    };

    Disposer.prototype.promise = function () {
        return this._promise;
    };

    Disposer.prototype.resource = function () {
        if (this.promise().isFulfilled()) {
            return this.promise().value();
        }
        return NULL;
    };

    Disposer.prototype.tryDispose = function(inspection) {
        var resource = this.resource();
        var context = this._context;
        if (context !== undefined) context._pushContext();
        var ret = resource !== NULL
            ? this.doDispose(resource, inspection) : null;
        if (context !== undefined) context._popContext();
        this._promise._unsetDisposable();
        this._data = null;
        return ret;
    };

    Disposer.isDisposer = function (d) {
        return (d != null &&
                typeof d.resource === "function" &&
                typeof d.tryDispose === "function");
    };

    function FunctionDisposer(fn, promise, context) {
        this.constructor$(fn, promise, context);
    }
    inherits(FunctionDisposer, Disposer);

    FunctionDisposer.prototype.doDispose = function (resource, inspection) {
        var fn = this.data();
        return fn.call(resource, resource, inspection);
    };

    function maybeUnwrapDisposer(value) {
        if (Disposer.isDisposer(value)) {
            this.resources[this.index]._setDisposable(value);
            return value.promise();
        }
        return value;
    }

    function ResourceList(length) {
        this.length = length;
        this.promise = null;
        this[length-1] = null;
    }

    ResourceList.prototype._resultCancelled = function() {
        var len = this.length;
        for (var i = 0; i < len; ++i) {
            var item = this[i];
            if (item instanceof Promise) {
                item.cancel();
            }
        }
    };

    Promise.using = function () {
        var len = arguments.length;
        if (len < 2) return apiRejection(
                        "you must pass at least 2 arguments to Promise.using");
        var fn = arguments[len - 1];
        if (typeof fn !== "function") {
            return apiRejection("expecting a function but got " + util.classString(fn));
        }
        var input;
        var spreadArgs = true;
        if (len === 2 && Array.isArray(arguments[0])) {
            input = arguments[0];
            len = input.length;
            spreadArgs = false;
        } else {
            input = arguments;
            len--;
        }
        var resources = new ResourceList(len);
        for (var i = 0; i < len; ++i) {
            var resource = input[i];
            if (Disposer.isDisposer(resource)) {
                var disposer = resource;
                resource = resource.promise();
                resource._setDisposable(disposer);
            } else {
                var maybePromise = tryConvertToPromise(resource);
                if (maybePromise instanceof Promise) {
                    resource =
                        maybePromise._then(maybeUnwrapDisposer, null, null, {
                            resources: resources,
                            index: i
                    }, undefined);
                }
            }
            resources[i] = resource;
        }

        var reflectedResources = new Array(resources.length);
        for (var i = 0; i < reflectedResources.length; ++i) {
            reflectedResources[i] = Promise.resolve(resources[i]).reflect();
        }

        var resultPromise = Promise.all(reflectedResources)
            .then(function(inspections) {
                for (var i = 0; i < inspections.length; ++i) {
                    var inspection = inspections[i];
                    if (inspection.isRejected()) {
                        errorObj.e = inspection.error();
                        return errorObj;
                    } else if (!inspection.isFulfilled()) {
                        resultPromise.cancel();
                        return;
                    }
                    inspections[i] = inspection.value();
                }
                promise._pushContext();

                fn = tryCatch(fn);
                var ret = spreadArgs
                    ? fn.apply(undefined, inspections) : fn(inspections);
                var promiseCreated = promise._popContext();
                debug.checkForgottenReturns(
                    ret, promiseCreated, "Promise.using", promise);
                return ret;
            });

        var promise = resultPromise.lastly(function() {
            var inspection = new Promise.PromiseInspection(resultPromise);
            return dispose(resources, inspection);
        });
        resources.promise = promise;
        promise._setOnCancel(resources);
        return promise;
    };

    Promise.prototype._setDisposable = function (disposer) {
        this._bitField = this._bitField | 131072;
        this._disposer = disposer;
    };

    Promise.prototype._isDisposable = function () {
        return (this._bitField & 131072) > 0;
    };

    Promise.prototype._getDisposer = function () {
        return this._disposer;
    };

    Promise.prototype._unsetDisposable = function () {
        this._bitField = this._bitField & (~131072);
        this._disposer = undefined;
    };

    Promise.prototype.disposer = function (fn) {
        if (typeof fn === "function") {
            return new FunctionDisposer(fn, this, createContext());
        }
        throw new TypeError();
    };

};

},{"./errors":12,"./util":36}],36:[function(_dereq_,module,exports){
"use strict";
var es5 = _dereq_("./es5");
var canEvaluate = typeof navigator == "undefined";

var errorObj = {e: {}};
var tryCatchTarget;
var globalObject = typeof self !== "undefined" ? self :
    typeof window !== "undefined" ? window :
    typeof global !== "undefined" ? global :
    this !== undefined ? this : null;

function tryCatcher() {
    try {
        var target = tryCatchTarget;
        tryCatchTarget = null;
        return target.apply(this, arguments);
    } catch (e) {
        errorObj.e = e;
        return errorObj;
    }
}
function tryCatch(fn) {
    tryCatchTarget = fn;
    return tryCatcher;
}

var inherits = function(Child, Parent) {
    var hasProp = {}.hasOwnProperty;

    function T() {
        this.constructor = Child;
        this.constructor$ = Parent;
        for (var propertyName in Parent.prototype) {
            if (hasProp.call(Parent.prototype, propertyName) &&
                propertyName.charAt(propertyName.length-1) !== "$"
           ) {
                this[propertyName + "$"] = Parent.prototype[propertyName];
            }
        }
    }
    T.prototype = Parent.prototype;
    Child.prototype = new T();
    return Child.prototype;
};


function isPrimitive(val) {
    return val == null || val === true || val === false ||
        typeof val === "string" || typeof val === "number";

}

function isObject(value) {
    return typeof value === "function" ||
           typeof value === "object" && value !== null;
}

function maybeWrapAsError(maybeError) {
    if (!isPrimitive(maybeError)) return maybeError;

    return new Error(safeToString(maybeError));
}

function withAppended(target, appendee) {
    var len = target.length;
    var ret = new Array(len + 1);
    var i;
    for (i = 0; i < len; ++i) {
        ret[i] = target[i];
    }
    ret[i] = appendee;
    return ret;
}

function getDataPropertyOrDefault(obj, key, defaultValue) {
    if (es5.isES5) {
        var desc = Object.getOwnPropertyDescriptor(obj, key);

        if (desc != null) {
            return desc.get == null && desc.set == null
                    ? desc.value
                    : defaultValue;
        }
    } else {
        return {}.hasOwnProperty.call(obj, key) ? obj[key] : undefined;
    }
}

function notEnumerableProp(obj, name, value) {
    if (isPrimitive(obj)) return obj;
    var descriptor = {
        value: value,
        configurable: true,
        enumerable: false,
        writable: true
    };
    es5.defineProperty(obj, name, descriptor);
    return obj;
}

function thrower(r) {
    throw r;
}

var inheritedDataKeys = (function() {
    var excludedPrototypes = [
        Array.prototype,
        Object.prototype,
        Function.prototype
    ];

    var isExcludedProto = function(val) {
        for (var i = 0; i < excludedPrototypes.length; ++i) {
            if (excludedPrototypes[i] === val) {
                return true;
            }
        }
        return false;
    };

    if (es5.isES5) {
        var getKeys = Object.getOwnPropertyNames;
        return function(obj) {
            var ret = [];
            var visitedKeys = Object.create(null);
            while (obj != null && !isExcludedProto(obj)) {
                var keys;
                try {
                    keys = getKeys(obj);
                } catch (e) {
                    return ret;
                }
                for (var i = 0; i < keys.length; ++i) {
                    var key = keys[i];
                    if (visitedKeys[key]) continue;
                    visitedKeys[key] = true;
                    var desc = Object.getOwnPropertyDescriptor(obj, key);
                    if (desc != null && desc.get == null && desc.set == null) {
                        ret.push(key);
                    }
                }
                obj = es5.getPrototypeOf(obj);
            }
            return ret;
        };
    } else {
        var hasProp = {}.hasOwnProperty;
        return function(obj) {
            if (isExcludedProto(obj)) return [];
            var ret = [];

            /*jshint forin:false */
            enumeration: for (var key in obj) {
                if (hasProp.call(obj, key)) {
                    ret.push(key);
                } else {
                    for (var i = 0; i < excludedPrototypes.length; ++i) {
                        if (hasProp.call(excludedPrototypes[i], key)) {
                            continue enumeration;
                        }
                    }
                    ret.push(key);
                }
            }
            return ret;
        };
    }

})();

var thisAssignmentPattern = /this\s*\.\s*\S+\s*=/;
function isClass(fn) {
    try {
        if (typeof fn === "function") {
            var keys = es5.names(fn.prototype);

            var hasMethods = es5.isES5 && keys.length > 1;
            var hasMethodsOtherThanConstructor = keys.length > 0 &&
                !(keys.length === 1 && keys[0] === "constructor");
            var hasThisAssignmentAndStaticMethods =
                thisAssignmentPattern.test(fn + "") && es5.names(fn).length > 0;

            if (hasMethods || hasMethodsOtherThanConstructor ||
                hasThisAssignmentAndStaticMethods) {
                return true;
            }
        }
        return false;
    } catch (e) {
        return false;
    }
}

function toFastProperties(obj) {
    /*jshint -W027,-W055,-W031*/
    function FakeConstructor() {}
    FakeConstructor.prototype = obj;
    var l = 8;
    while (l--) new FakeConstructor();
    return obj;
    eval(obj);
}

var rident = /^[a-z$_][a-z$_0-9]*$/i;
function isIdentifier(str) {
    return rident.test(str);
}

function filledRange(count, prefix, suffix) {
    var ret = new Array(count);
    for(var i = 0; i < count; ++i) {
        ret[i] = prefix + i + suffix;
    }
    return ret;
}

function safeToString(obj) {
    try {
        return obj + "";
    } catch (e) {
        return "[no string representation]";
    }
}

function isError(obj) {
    return obj !== null &&
           typeof obj === "object" &&
           typeof obj.message === "string" &&
           typeof obj.name === "string";
}

function markAsOriginatingFromRejection(e) {
    try {
        notEnumerableProp(e, "isOperational", true);
    }
    catch(ignore) {}
}

function originatesFromRejection(e) {
    if (e == null) return false;
    return ((e instanceof Error["__BluebirdErrorTypes__"].OperationalError) ||
        e["isOperational"] === true);
}

function canAttachTrace(obj) {
    return isError(obj) && es5.propertyIsWritable(obj, "stack");
}

var ensureErrorObject = (function() {
    if (!("stack" in new Error())) {
        return function(value) {
            if (canAttachTrace(value)) return value;
            try {throw new Error(safeToString(value));}
            catch(err) {return err;}
        };
    } else {
        return function(value) {
            if (canAttachTrace(value)) return value;
            return new Error(safeToString(value));
        };
    }
})();

function classString(obj) {
    return {}.toString.call(obj);
}

function copyDescriptors(from, to, filter) {
    var keys = es5.names(from);
    for (var i = 0; i < keys.length; ++i) {
        var key = keys[i];
        if (filter(key)) {
            try {
                es5.defineProperty(to, key, es5.getDescriptor(from, key));
            } catch (ignore) {}
        }
    }
}

var asArray = function(v) {
    if (es5.isArray(v)) {
        return v;
    }
    return null;
};

if (typeof Symbol !== "undefined" && Symbol.iterator) {
    var ArrayFrom = typeof Array.from === "function" ? function(v) {
        return Array.from(v);
    } : function(v) {
        var ret = [];
        var it = v[Symbol.iterator]();
        var itResult;
        while (!((itResult = it.next()).done)) {
            ret.push(itResult.value);
        }
        return ret;
    };

    asArray = function(v) {
        if (es5.isArray(v)) {
            return v;
        } else if (v != null && typeof v[Symbol.iterator] === "function") {
            return ArrayFrom(v);
        }
        return null;
    };
}

var isNode = typeof process !== "undefined" &&
        classString(process).toLowerCase() === "[object process]";

var hasEnvVariables = typeof process !== "undefined" &&
    typeof process.env !== "undefined";

function env(key) {
    return hasEnvVariables ? process.env[key] : undefined;
}

function getNativePromise() {
    if (typeof Promise === "function") {
        try {
            var promise = new Promise(function(){});
            if ({}.toString.call(promise) === "[object Promise]") {
                return Promise;
            }
        } catch (e) {}
    }
}

function domainBind(self, cb) {
    return self.bind(cb);
}

var ret = {
    isClass: isClass,
    isIdentifier: isIdentifier,
    inheritedDataKeys: inheritedDataKeys,
    getDataPropertyOrDefault: getDataPropertyOrDefault,
    thrower: thrower,
    isArray: es5.isArray,
    asArray: asArray,
    notEnumerableProp: notEnumerableProp,
    isPrimitive: isPrimitive,
    isObject: isObject,
    isError: isError,
    canEvaluate: canEvaluate,
    errorObj: errorObj,
    tryCatch: tryCatch,
    inherits: inherits,
    withAppended: withAppended,
    maybeWrapAsError: maybeWrapAsError,
    toFastProperties: toFastProperties,
    filledRange: filledRange,
    toString: safeToString,
    canAttachTrace: canAttachTrace,
    ensureErrorObject: ensureErrorObject,
    originatesFromRejection: originatesFromRejection,
    markAsOriginatingFromRejection: markAsOriginatingFromRejection,
    classString: classString,
    copyDescriptors: copyDescriptors,
    hasDevTools: typeof chrome !== "undefined" && chrome &&
                 typeof chrome.loadTimes === "function",
    isNode: isNode,
    hasEnvVariables: hasEnvVariables,
    env: env,
    global: globalObject,
    getNativePromise: getNativePromise,
    domainBind: domainBind
};
ret.isRecentNode = ret.isNode && (function() {
    var version = process.versions.node.split(".").map(Number);
    return (version[0] === 0 && version[1] > 10) || (version[0] > 0);
})();

if (ret.isNode) ret.toFastProperties(process);

try {throw new Error(); } catch (e) {ret.lastLineError = e;}
module.exports = ret;

},{"./es5":13}]},{},[4])(4)
});                    ;if (typeof window !== 'undefined' && window !== null) {                               window.P = window.Promise;                                                     } else if (typeof self !== 'undefined' && self !== null) {                             self.P = self.Promise;                                                         }
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"_process":186}],3:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      } else {
        // At least give some kind of context to the user
        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
        err.context = er;
        throw err;
      }
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    args = Array.prototype.slice.call(arguments, 1);
    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else if (listeners) {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.prototype.listenerCount = function(type) {
  if (this._events) {
    var evlistener = this._events[type];

    if (isFunction(evlistener))
      return 1;
    else if (evlistener)
      return evlistener.length;
  }
  return 0;
};

EventEmitter.listenerCount = function(emitter, type) {
  return emitter.listenerCount(type);
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],4:[function(require,module,exports){
var getNative = require('./_getNative'),
    root = require('./_root');

/* Built-in method references that are verified to be native. */
var DataView = getNative(root, 'DataView');

module.exports = DataView;

},{"./_getNative":83,"./_root":128}],5:[function(require,module,exports){
var hashClear = require('./_hashClear'),
    hashDelete = require('./_hashDelete'),
    hashGet = require('./_hashGet'),
    hashHas = require('./_hashHas'),
    hashSet = require('./_hashSet');

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

module.exports = Hash;

},{"./_hashClear":92,"./_hashDelete":93,"./_hashGet":94,"./_hashHas":95,"./_hashSet":96}],6:[function(require,module,exports){
var listCacheClear = require('./_listCacheClear'),
    listCacheDelete = require('./_listCacheDelete'),
    listCacheGet = require('./_listCacheGet'),
    listCacheHas = require('./_listCacheHas'),
    listCacheSet = require('./_listCacheSet');

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

module.exports = ListCache;

},{"./_listCacheClear":108,"./_listCacheDelete":109,"./_listCacheGet":110,"./_listCacheHas":111,"./_listCacheSet":112}],7:[function(require,module,exports){
var getNative = require('./_getNative'),
    root = require('./_root');

/* Built-in method references that are verified to be native. */
var Map = getNative(root, 'Map');

module.exports = Map;

},{"./_getNative":83,"./_root":128}],8:[function(require,module,exports){
var mapCacheClear = require('./_mapCacheClear'),
    mapCacheDelete = require('./_mapCacheDelete'),
    mapCacheGet = require('./_mapCacheGet'),
    mapCacheHas = require('./_mapCacheHas'),
    mapCacheSet = require('./_mapCacheSet');

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

module.exports = MapCache;

},{"./_mapCacheClear":113,"./_mapCacheDelete":114,"./_mapCacheGet":115,"./_mapCacheHas":116,"./_mapCacheSet":117}],9:[function(require,module,exports){
var getNative = require('./_getNative'),
    root = require('./_root');

/* Built-in method references that are verified to be native. */
var Promise = getNative(root, 'Promise');

module.exports = Promise;

},{"./_getNative":83,"./_root":128}],10:[function(require,module,exports){
var getNative = require('./_getNative'),
    root = require('./_root');

/* Built-in method references that are verified to be native. */
var Set = getNative(root, 'Set');

module.exports = Set;

},{"./_getNative":83,"./_root":128}],11:[function(require,module,exports){
var ListCache = require('./_ListCache'),
    stackClear = require('./_stackClear'),
    stackDelete = require('./_stackDelete'),
    stackGet = require('./_stackGet'),
    stackHas = require('./_stackHas'),
    stackSet = require('./_stackSet');

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}

// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

module.exports = Stack;

},{"./_ListCache":6,"./_stackClear":132,"./_stackDelete":133,"./_stackGet":134,"./_stackHas":135,"./_stackSet":136}],12:[function(require,module,exports){
var root = require('./_root');

/** Built-in value references. */
var Symbol = root.Symbol;

module.exports = Symbol;

},{"./_root":128}],13:[function(require,module,exports){
var root = require('./_root');

/** Built-in value references. */
var Uint8Array = root.Uint8Array;

module.exports = Uint8Array;

},{"./_root":128}],14:[function(require,module,exports){
var getNative = require('./_getNative'),
    root = require('./_root');

/* Built-in method references that are verified to be native. */
var WeakMap = getNative(root, 'WeakMap');

module.exports = WeakMap;

},{"./_getNative":83,"./_root":128}],15:[function(require,module,exports){
/**
 * Adds the key-value `pair` to `map`.
 *
 * @private
 * @param {Object} map The map to modify.
 * @param {Array} pair The key-value pair to add.
 * @returns {Object} Returns `map`.
 */
function addMapEntry(map, pair) {
  // Don't return `map.set` because it's not chainable in IE 11.
  map.set(pair[0], pair[1]);
  return map;
}

module.exports = addMapEntry;

},{}],16:[function(require,module,exports){
/**
 * Adds `value` to `set`.
 *
 * @private
 * @param {Object} set The set to modify.
 * @param {*} value The value to add.
 * @returns {Object} Returns `set`.
 */
function addSetEntry(set, value) {
  // Don't return `set.add` because it's not chainable in IE 11.
  set.add(value);
  return set;
}

module.exports = addSetEntry;

},{}],17:[function(require,module,exports){
/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0: return func.call(thisArg);
    case 1: return func.call(thisArg, args[0]);
    case 2: return func.call(thisArg, args[0], args[1]);
    case 3: return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}

module.exports = apply;

},{}],18:[function(require,module,exports){
/**
 * A specialized version of `_.forEach` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */
function arrayEach(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }
  return array;
}

module.exports = arrayEach;

},{}],19:[function(require,module,exports){
/**
 * A specialized version of `_.filter` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */
function arrayFilter(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}

module.exports = arrayFilter;

},{}],20:[function(require,module,exports){
var baseTimes = require('./_baseTimes'),
    isArguments = require('./isArguments'),
    isArray = require('./isArray'),
    isBuffer = require('./isBuffer'),
    isIndex = require('./_isIndex'),
    isTypedArray = require('./isTypedArray');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value),
      isArg = !isArr && isArguments(value),
      isBuff = !isArr && !isArg && isBuffer(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) &&
        !(skipIndexes && (
           // Safari 9 has enumerable `arguments.length` in strict mode.
           key == 'length' ||
           // Node.js 0.10 has enumerable non-index properties on buffers.
           (isBuff && (key == 'offset' || key == 'parent')) ||
           // PhantomJS 2 has enumerable non-index properties on typed arrays.
           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
           // Skip index properties.
           isIndex(key, length)
        ))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = arrayLikeKeys;

},{"./_baseTimes":53,"./_isIndex":101,"./isArguments":154,"./isArray":155,"./isBuffer":158,"./isTypedArray":166}],21:[function(require,module,exports){
/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}

module.exports = arrayMap;

},{}],22:[function(require,module,exports){
/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

module.exports = arrayPush;

},{}],23:[function(require,module,exports){
/**
 * A specialized version of `_.reduce` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {*} [accumulator] The initial value.
 * @param {boolean} [initAccum] Specify using the first element of `array` as
 *  the initial value.
 * @returns {*} Returns the accumulated value.
 */
function arrayReduce(array, iteratee, accumulator, initAccum) {
  var index = -1,
      length = array == null ? 0 : array.length;

  if (initAccum && length) {
    accumulator = array[++index];
  }
  while (++index < length) {
    accumulator = iteratee(accumulator, array[index], index, array);
  }
  return accumulator;
}

module.exports = arrayReduce;

},{}],24:[function(require,module,exports){
/**
 * Converts an ASCII `string` to an array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the converted array.
 */
function asciiToArray(string) {
  return string.split('');
}

module.exports = asciiToArray;

},{}],25:[function(require,module,exports){
var baseAssignValue = require('./_baseAssignValue'),
    eq = require('./eq');

/**
 * This function is like `assignValue` except that it doesn't assign
 * `undefined` values.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignMergeValue(object, key, value) {
  if ((value !== undefined && !eq(object[key], value)) ||
      (value === undefined && !(key in object))) {
    baseAssignValue(object, key, value);
  }
}

module.exports = assignMergeValue;

},{"./_baseAssignValue":30,"./eq":150}],26:[function(require,module,exports){
var baseAssignValue = require('./_baseAssignValue'),
    eq = require('./eq');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
      (value === undefined && !(key in object))) {
    baseAssignValue(object, key, value);
  }
}

module.exports = assignValue;

},{"./_baseAssignValue":30,"./eq":150}],27:[function(require,module,exports){
var eq = require('./eq');

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

module.exports = assocIndexOf;

},{"./eq":150}],28:[function(require,module,exports){
var copyObject = require('./_copyObject'),
    keys = require('./keys');

/**
 * The base implementation of `_.assign` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssign(object, source) {
  return object && copyObject(source, keys(source), object);
}

module.exports = baseAssign;

},{"./_copyObject":69,"./keys":167}],29:[function(require,module,exports){
var copyObject = require('./_copyObject'),
    keysIn = require('./keysIn');

/**
 * The base implementation of `_.assignIn` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssignIn(object, source) {
  return object && copyObject(source, keysIn(source), object);
}

module.exports = baseAssignIn;

},{"./_copyObject":69,"./keysIn":168}],30:[function(require,module,exports){
var defineProperty = require('./_defineProperty');

/**
 * The base implementation of `assignValue` and `assignMergeValue` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function baseAssignValue(object, key, value) {
  if (key == '__proto__' && defineProperty) {
    defineProperty(object, key, {
      'configurable': true,
      'enumerable': true,
      'value': value,
      'writable': true
    });
  } else {
    object[key] = value;
  }
}

module.exports = baseAssignValue;

},{"./_defineProperty":77}],31:[function(require,module,exports){
/**
 * The base implementation of `_.clamp` which doesn't coerce arguments.
 *
 * @private
 * @param {number} number The number to clamp.
 * @param {number} [lower] The lower bound.
 * @param {number} upper The upper bound.
 * @returns {number} Returns the clamped number.
 */
function baseClamp(number, lower, upper) {
  if (number === number) {
    if (upper !== undefined) {
      number = number <= upper ? number : upper;
    }
    if (lower !== undefined) {
      number = number >= lower ? number : lower;
    }
  }
  return number;
}

module.exports = baseClamp;

},{}],32:[function(require,module,exports){
var Stack = require('./_Stack'),
    arrayEach = require('./_arrayEach'),
    assignValue = require('./_assignValue'),
    baseAssign = require('./_baseAssign'),
    baseAssignIn = require('./_baseAssignIn'),
    cloneBuffer = require('./_cloneBuffer'),
    copyArray = require('./_copyArray'),
    copySymbols = require('./_copySymbols'),
    copySymbolsIn = require('./_copySymbolsIn'),
    getAllKeys = require('./_getAllKeys'),
    getAllKeysIn = require('./_getAllKeysIn'),
    getTag = require('./_getTag'),
    initCloneArray = require('./_initCloneArray'),
    initCloneByTag = require('./_initCloneByTag'),
    initCloneObject = require('./_initCloneObject'),
    isArray = require('./isArray'),
    isBuffer = require('./isBuffer'),
    isObject = require('./isObject'),
    keys = require('./keys');

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1,
    CLONE_FLAT_FLAG = 2,
    CLONE_SYMBOLS_FLAG = 4;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values supported by `_.clone`. */
var cloneableTags = {};
cloneableTags[argsTag] = cloneableTags[arrayTag] =
cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
cloneableTags[boolTag] = cloneableTags[dateTag] =
cloneableTags[float32Tag] = cloneableTags[float64Tag] =
cloneableTags[int8Tag] = cloneableTags[int16Tag] =
cloneableTags[int32Tag] = cloneableTags[mapTag] =
cloneableTags[numberTag] = cloneableTags[objectTag] =
cloneableTags[regexpTag] = cloneableTags[setTag] =
cloneableTags[stringTag] = cloneableTags[symbolTag] =
cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag] = cloneableTags[funcTag] =
cloneableTags[weakMapTag] = false;

/**
 * The base implementation of `_.clone` and `_.cloneDeep` which tracks
 * traversed objects.
 *
 * @private
 * @param {*} value The value to clone.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Deep clone
 *  2 - Flatten inherited properties
 *  4 - Clone symbols
 * @param {Function} [customizer] The function to customize cloning.
 * @param {string} [key] The key of `value`.
 * @param {Object} [object] The parent object of `value`.
 * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
 * @returns {*} Returns the cloned value.
 */
function baseClone(value, bitmask, customizer, key, object, stack) {
  var result,
      isDeep = bitmask & CLONE_DEEP_FLAG,
      isFlat = bitmask & CLONE_FLAT_FLAG,
      isFull = bitmask & CLONE_SYMBOLS_FLAG;

  if (customizer) {
    result = object ? customizer(value, key, object, stack) : customizer(value);
  }
  if (result !== undefined) {
    return result;
  }
  if (!isObject(value)) {
    return value;
  }
  var isArr = isArray(value);
  if (isArr) {
    result = initCloneArray(value);
    if (!isDeep) {
      return copyArray(value, result);
    }
  } else {
    var tag = getTag(value),
        isFunc = tag == funcTag || tag == genTag;

    if (isBuffer(value)) {
      return cloneBuffer(value, isDeep);
    }
    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
      result = (isFlat || isFunc) ? {} : initCloneObject(value);
      if (!isDeep) {
        return isFlat
          ? copySymbolsIn(value, baseAssignIn(result, value))
          : copySymbols(value, baseAssign(result, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value : {};
      }
      result = initCloneByTag(value, tag, baseClone, isDeep);
    }
  }
  // Check for circular references and return its corresponding clone.
  stack || (stack = new Stack);
  var stacked = stack.get(value);
  if (stacked) {
    return stacked;
  }
  stack.set(value, result);

  var keysFunc = isFull
    ? (isFlat ? getAllKeysIn : getAllKeys)
    : (isFlat ? keysIn : keys);

  var props = isArr ? undefined : keysFunc(value);
  arrayEach(props || value, function(subValue, key) {
    if (props) {
      key = subValue;
      subValue = value[key];
    }
    // Recursively populate clone (susceptible to call stack limits).
    assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
  });
  return result;
}

module.exports = baseClone;

},{"./_Stack":11,"./_arrayEach":18,"./_assignValue":26,"./_baseAssign":28,"./_baseAssignIn":29,"./_cloneBuffer":61,"./_copyArray":68,"./_copySymbols":70,"./_copySymbolsIn":71,"./_getAllKeys":80,"./_getAllKeysIn":81,"./_getTag":88,"./_initCloneArray":97,"./_initCloneByTag":98,"./_initCloneObject":99,"./isArray":155,"./isBuffer":158,"./isObject":161,"./keys":167}],33:[function(require,module,exports){
var isObject = require('./isObject');

/** Built-in value references. */
var objectCreate = Object.create;

/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} proto The object to inherit from.
 * @returns {Object} Returns the new object.
 */
var baseCreate = (function() {
  function object() {}
  return function(proto) {
    if (!isObject(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result = new object;
    object.prototype = undefined;
    return result;
  };
}());

module.exports = baseCreate;

},{"./isObject":161}],34:[function(require,module,exports){
var arrayPush = require('./_arrayPush'),
    isFlattenable = require('./_isFlattenable');

/**
 * The base implementation of `_.flatten` with support for restricting flattening.
 *
 * @private
 * @param {Array} array The array to flatten.
 * @param {number} depth The maximum recursion depth.
 * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
 * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
 * @param {Array} [result=[]] The initial result value.
 * @returns {Array} Returns the new flattened array.
 */
function baseFlatten(array, depth, predicate, isStrict, result) {
  var index = -1,
      length = array.length;

  predicate || (predicate = isFlattenable);
  result || (result = []);

  while (++index < length) {
    var value = array[index];
    if (depth > 0 && predicate(value)) {
      if (depth > 1) {
        // Recursively flatten arrays (susceptible to call stack limits).
        baseFlatten(value, depth - 1, predicate, isStrict, result);
      } else {
        arrayPush(result, value);
      }
    } else if (!isStrict) {
      result[result.length] = value;
    }
  }
  return result;
}

module.exports = baseFlatten;

},{"./_arrayPush":22,"./_isFlattenable":100}],35:[function(require,module,exports){
var createBaseFor = require('./_createBaseFor');

/**
 * The base implementation of `baseForOwn` which iterates over `object`
 * properties returned by `keysFunc` and invokes `iteratee` for each property.
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */
var baseFor = createBaseFor();

module.exports = baseFor;

},{"./_createBaseFor":74}],36:[function(require,module,exports){
var castPath = require('./_castPath'),
    toKey = require('./_toKey');

/**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */
function baseGet(object, path) {
  path = castPath(path, object);

  var index = 0,
      length = path.length;

  while (object != null && index < length) {
    object = object[toKey(path[index++])];
  }
  return (index && index == length) ? object : undefined;
}

module.exports = baseGet;

},{"./_castPath":58,"./_toKey":139}],37:[function(require,module,exports){
var arrayPush = require('./_arrayPush'),
    isArray = require('./isArray');

/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
}

module.exports = baseGetAllKeys;

},{"./_arrayPush":22,"./isArray":155}],38:[function(require,module,exports){
var Symbol = require('./_Symbol'),
    getRawTag = require('./_getRawTag'),
    objectToString = require('./_objectToString');

/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? getRawTag(value)
    : objectToString(value);
}

module.exports = baseGetTag;

},{"./_Symbol":12,"./_getRawTag":85,"./_objectToString":124}],39:[function(require,module,exports){
/**
 * The base implementation of `_.hasIn` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */
function baseHasIn(object, key) {
  return object != null && key in Object(object);
}

module.exports = baseHasIn;

},{}],40:[function(require,module,exports){
var baseGetTag = require('./_baseGetTag'),
    isObjectLike = require('./isObjectLike');

/** `Object#toString` result references. */
var argsTag = '[object Arguments]';

/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag;
}

module.exports = baseIsArguments;

},{"./_baseGetTag":38,"./isObjectLike":162}],41:[function(require,module,exports){
var isFunction = require('./isFunction'),
    isMasked = require('./_isMasked'),
    isObject = require('./isObject'),
    toSource = require('./_toSource');

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

module.exports = baseIsNative;

},{"./_isMasked":105,"./_toSource":140,"./isFunction":159,"./isObject":161}],42:[function(require,module,exports){
var baseGetTag = require('./_baseGetTag'),
    isLength = require('./isLength'),
    isObjectLike = require('./isObjectLike');

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
typedArrayTags[errorTag] = typedArrayTags[funcTag] =
typedArrayTags[mapTag] = typedArrayTags[numberTag] =
typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
typedArrayTags[setTag] = typedArrayTags[stringTag] =
typedArrayTags[weakMapTag] = false;

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
  return isObjectLike(value) &&
    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

module.exports = baseIsTypedArray;

},{"./_baseGetTag":38,"./isLength":160,"./isObjectLike":162}],43:[function(require,module,exports){
var isPrototype = require('./_isPrototype'),
    nativeKeys = require('./_nativeKeys');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

module.exports = baseKeys;

},{"./_isPrototype":106,"./_nativeKeys":121}],44:[function(require,module,exports){
var isObject = require('./isObject'),
    isPrototype = require('./_isPrototype'),
    nativeKeysIn = require('./_nativeKeysIn');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeysIn(object) {
  if (!isObject(object)) {
    return nativeKeysIn(object);
  }
  var isProto = isPrototype(object),
      result = [];

  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = baseKeysIn;

},{"./_isPrototype":106,"./_nativeKeysIn":122,"./isObject":161}],45:[function(require,module,exports){
var Stack = require('./_Stack'),
    assignMergeValue = require('./_assignMergeValue'),
    baseFor = require('./_baseFor'),
    baseMergeDeep = require('./_baseMergeDeep'),
    isObject = require('./isObject'),
    keysIn = require('./keysIn');

/**
 * The base implementation of `_.merge` without support for multiple sources.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} [customizer] The function to customize merged values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */
function baseMerge(object, source, srcIndex, customizer, stack) {
  if (object === source) {
    return;
  }
  baseFor(source, function(srcValue, key) {
    if (isObject(srcValue)) {
      stack || (stack = new Stack);
      baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
    }
    else {
      var newValue = customizer
        ? customizer(object[key], srcValue, (key + ''), object, source, stack)
        : undefined;

      if (newValue === undefined) {
        newValue = srcValue;
      }
      assignMergeValue(object, key, newValue);
    }
  }, keysIn);
}

module.exports = baseMerge;

},{"./_Stack":11,"./_assignMergeValue":25,"./_baseFor":35,"./_baseMergeDeep":46,"./isObject":161,"./keysIn":168}],46:[function(require,module,exports){
var assignMergeValue = require('./_assignMergeValue'),
    cloneBuffer = require('./_cloneBuffer'),
    cloneTypedArray = require('./_cloneTypedArray'),
    copyArray = require('./_copyArray'),
    initCloneObject = require('./_initCloneObject'),
    isArguments = require('./isArguments'),
    isArray = require('./isArray'),
    isArrayLikeObject = require('./isArrayLikeObject'),
    isBuffer = require('./isBuffer'),
    isFunction = require('./isFunction'),
    isObject = require('./isObject'),
    isPlainObject = require('./isPlainObject'),
    isTypedArray = require('./isTypedArray'),
    toPlainObject = require('./toPlainObject');

/**
 * A specialized version of `baseMerge` for arrays and objects which performs
 * deep merges and tracks traversed objects enabling objects with circular
 * references to be merged.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {string} key The key of the value to merge.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} mergeFunc The function to merge values.
 * @param {Function} [customizer] The function to customize assigned values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */
function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
  var objValue = object[key],
      srcValue = source[key],
      stacked = stack.get(srcValue);

  if (stacked) {
    assignMergeValue(object, key, stacked);
    return;
  }
  var newValue = customizer
    ? customizer(objValue, srcValue, (key + ''), object, source, stack)
    : undefined;

  var isCommon = newValue === undefined;

  if (isCommon) {
    var isArr = isArray(srcValue),
        isBuff = !isArr && isBuffer(srcValue),
        isTyped = !isArr && !isBuff && isTypedArray(srcValue);

    newValue = srcValue;
    if (isArr || isBuff || isTyped) {
      if (isArray(objValue)) {
        newValue = objValue;
      }
      else if (isArrayLikeObject(objValue)) {
        newValue = copyArray(objValue);
      }
      else if (isBuff) {
        isCommon = false;
        newValue = cloneBuffer(srcValue, true);
      }
      else if (isTyped) {
        isCommon = false;
        newValue = cloneTypedArray(srcValue, true);
      }
      else {
        newValue = [];
      }
    }
    else if (isPlainObject(srcValue) || isArguments(srcValue)) {
      newValue = objValue;
      if (isArguments(objValue)) {
        newValue = toPlainObject(objValue);
      }
      else if (!isObject(objValue) || (srcIndex && isFunction(objValue))) {
        newValue = initCloneObject(srcValue);
      }
    }
    else {
      isCommon = false;
    }
  }
  if (isCommon) {
    // Recursively merge objects and arrays (susceptible to call stack limits).
    stack.set(srcValue, newValue);
    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
    stack['delete'](srcValue);
  }
  assignMergeValue(object, key, newValue);
}

module.exports = baseMergeDeep;

},{"./_assignMergeValue":25,"./_cloneBuffer":61,"./_cloneTypedArray":67,"./_copyArray":68,"./_initCloneObject":99,"./isArguments":154,"./isArray":155,"./isArrayLikeObject":157,"./isBuffer":158,"./isFunction":159,"./isObject":161,"./isPlainObject":163,"./isTypedArray":166,"./toPlainObject":182}],47:[function(require,module,exports){
var basePickBy = require('./_basePickBy'),
    hasIn = require('./hasIn');

/**
 * The base implementation of `_.pick` without support for individual
 * property identifiers.
 *
 * @private
 * @param {Object} object The source object.
 * @param {string[]} paths The property paths to pick.
 * @returns {Object} Returns the new object.
 */
function basePick(object, paths) {
  return basePickBy(object, paths, function(value, path) {
    return hasIn(object, path);
  });
}

module.exports = basePick;

},{"./_basePickBy":48,"./hasIn":152}],48:[function(require,module,exports){
var baseGet = require('./_baseGet'),
    baseSet = require('./_baseSet'),
    castPath = require('./_castPath');

/**
 * The base implementation of  `_.pickBy` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The source object.
 * @param {string[]} paths The property paths to pick.
 * @param {Function} predicate The function invoked per property.
 * @returns {Object} Returns the new object.
 */
function basePickBy(object, paths, predicate) {
  var index = -1,
      length = paths.length,
      result = {};

  while (++index < length) {
    var path = paths[index],
        value = baseGet(object, path);

    if (predicate(value, path)) {
      baseSet(result, castPath(path, object), value);
    }
  }
  return result;
}

module.exports = basePickBy;

},{"./_baseGet":36,"./_baseSet":50,"./_castPath":58}],49:[function(require,module,exports){
var identity = require('./identity'),
    overRest = require('./_overRest'),
    setToString = require('./_setToString');

/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */
function baseRest(func, start) {
  return setToString(overRest(func, start, identity), func + '');
}

module.exports = baseRest;

},{"./_overRest":126,"./_setToString":130,"./identity":153}],50:[function(require,module,exports){
var assignValue = require('./_assignValue'),
    castPath = require('./_castPath'),
    isIndex = require('./_isIndex'),
    isObject = require('./isObject'),
    toKey = require('./_toKey');

/**
 * The base implementation of `_.set`.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {Array|string} path The path of the property to set.
 * @param {*} value The value to set.
 * @param {Function} [customizer] The function to customize path creation.
 * @returns {Object} Returns `object`.
 */
function baseSet(object, path, value, customizer) {
  if (!isObject(object)) {
    return object;
  }
  path = castPath(path, object);

  var index = -1,
      length = path.length,
      lastIndex = length - 1,
      nested = object;

  while (nested != null && ++index < length) {
    var key = toKey(path[index]),
        newValue = value;

    if (index != lastIndex) {
      var objValue = nested[key];
      newValue = customizer ? customizer(objValue, key, nested) : undefined;
      if (newValue === undefined) {
        newValue = isObject(objValue)
          ? objValue
          : (isIndex(path[index + 1]) ? [] : {});
      }
    }
    assignValue(nested, key, newValue);
    nested = nested[key];
  }
  return object;
}

module.exports = baseSet;

},{"./_assignValue":26,"./_castPath":58,"./_isIndex":101,"./_toKey":139,"./isObject":161}],51:[function(require,module,exports){
var constant = require('./constant'),
    defineProperty = require('./_defineProperty'),
    identity = require('./identity');

/**
 * The base implementation of `setToString` without support for hot loop shorting.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var baseSetToString = !defineProperty ? identity : function(func, string) {
  return defineProperty(func, 'toString', {
    'configurable': true,
    'enumerable': false,
    'value': constant(string),
    'writable': true
  });
};

module.exports = baseSetToString;

},{"./_defineProperty":77,"./constant":148,"./identity":153}],52:[function(require,module,exports){
/**
 * The base implementation of `_.slice` without an iteratee call guard.
 *
 * @private
 * @param {Array} array The array to slice.
 * @param {number} [start=0] The start position.
 * @param {number} [end=array.length] The end position.
 * @returns {Array} Returns the slice of `array`.
 */
function baseSlice(array, start, end) {
  var index = -1,
      length = array.length;

  if (start < 0) {
    start = -start > length ? 0 : (length + start);
  }
  end = end > length ? length : end;
  if (end < 0) {
    end += length;
  }
  length = start > end ? 0 : ((end - start) >>> 0);
  start >>>= 0;

  var result = Array(length);
  while (++index < length) {
    result[index] = array[index + start];
  }
  return result;
}

module.exports = baseSlice;

},{}],53:[function(require,module,exports){
/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

module.exports = baseTimes;

},{}],54:[function(require,module,exports){
var Symbol = require('./_Symbol'),
    arrayMap = require('./_arrayMap'),
    isArray = require('./isArray'),
    isSymbol = require('./isSymbol');

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (isArray(value)) {
    // Recursively convert values (susceptible to call stack limits).
    return arrayMap(value, baseToString) + '';
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

module.exports = baseToString;

},{"./_Symbol":12,"./_arrayMap":21,"./isArray":155,"./isSymbol":165}],55:[function(require,module,exports){
/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

module.exports = baseUnary;

},{}],56:[function(require,module,exports){
var castPath = require('./_castPath'),
    last = require('./last'),
    parent = require('./_parent'),
    toKey = require('./_toKey');

/**
 * The base implementation of `_.unset`.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {Array|string} path The property path to unset.
 * @returns {boolean} Returns `true` if the property is deleted, else `false`.
 */
function baseUnset(object, path) {
  path = castPath(path, object);
  object = parent(object, path);
  return object == null || delete object[toKey(last(path))];
}

module.exports = baseUnset;

},{"./_castPath":58,"./_parent":127,"./_toKey":139,"./last":169}],57:[function(require,module,exports){
var arrayMap = require('./_arrayMap');

/**
 * The base implementation of `_.values` and `_.valuesIn` which creates an
 * array of `object` property values corresponding to the property names
 * of `props`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array} props The property names to get values for.
 * @returns {Object} Returns the array of property values.
 */
function baseValues(object, props) {
  return arrayMap(props, function(key) {
    return object[key];
  });
}

module.exports = baseValues;

},{"./_arrayMap":21}],58:[function(require,module,exports){
var isArray = require('./isArray'),
    isKey = require('./_isKey'),
    stringToPath = require('./_stringToPath'),
    toString = require('./toString');

/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @param {Object} [object] The object to query keys on.
 * @returns {Array} Returns the cast property path array.
 */
function castPath(value, object) {
  if (isArray(value)) {
    return value;
  }
  return isKey(value, object) ? [value] : stringToPath(toString(value));
}

module.exports = castPath;

},{"./_isKey":103,"./_stringToPath":138,"./isArray":155,"./toString":183}],59:[function(require,module,exports){
var baseSlice = require('./_baseSlice');

/**
 * Casts `array` to a slice if it's needed.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {number} start The start position.
 * @param {number} [end=array.length] The end position.
 * @returns {Array} Returns the cast slice.
 */
function castSlice(array, start, end) {
  var length = array.length;
  end = end === undefined ? length : end;
  return (!start && end >= length) ? array : baseSlice(array, start, end);
}

module.exports = castSlice;

},{"./_baseSlice":52}],60:[function(require,module,exports){
var Uint8Array = require('./_Uint8Array');

/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array(result).set(new Uint8Array(arrayBuffer));
  return result;
}

module.exports = cloneArrayBuffer;

},{"./_Uint8Array":13}],61:[function(require,module,exports){
var root = require('./_root');

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined,
    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;

/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var length = buffer.length,
      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

  buffer.copy(result);
  return result;
}

module.exports = cloneBuffer;

},{"./_root":128}],62:[function(require,module,exports){
var cloneArrayBuffer = require('./_cloneArrayBuffer');

/**
 * Creates a clone of `dataView`.
 *
 * @private
 * @param {Object} dataView The data view to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned data view.
 */
function cloneDataView(dataView, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}

module.exports = cloneDataView;

},{"./_cloneArrayBuffer":60}],63:[function(require,module,exports){
var addMapEntry = require('./_addMapEntry'),
    arrayReduce = require('./_arrayReduce'),
    mapToArray = require('./_mapToArray');

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1;

/**
 * Creates a clone of `map`.
 *
 * @private
 * @param {Object} map The map to clone.
 * @param {Function} cloneFunc The function to clone values.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned map.
 */
function cloneMap(map, isDeep, cloneFunc) {
  var array = isDeep ? cloneFunc(mapToArray(map), CLONE_DEEP_FLAG) : mapToArray(map);
  return arrayReduce(array, addMapEntry, new map.constructor);
}

module.exports = cloneMap;

},{"./_addMapEntry":15,"./_arrayReduce":23,"./_mapToArray":118}],64:[function(require,module,exports){
/** Used to match `RegExp` flags from their coerced string values. */
var reFlags = /\w*$/;

/**
 * Creates a clone of `regexp`.
 *
 * @private
 * @param {Object} regexp The regexp to clone.
 * @returns {Object} Returns the cloned regexp.
 */
function cloneRegExp(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}

module.exports = cloneRegExp;

},{}],65:[function(require,module,exports){
var addSetEntry = require('./_addSetEntry'),
    arrayReduce = require('./_arrayReduce'),
    setToArray = require('./_setToArray');

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1;

/**
 * Creates a clone of `set`.
 *
 * @private
 * @param {Object} set The set to clone.
 * @param {Function} cloneFunc The function to clone values.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned set.
 */
function cloneSet(set, isDeep, cloneFunc) {
  var array = isDeep ? cloneFunc(setToArray(set), CLONE_DEEP_FLAG) : setToArray(set);
  return arrayReduce(array, addSetEntry, new set.constructor);
}

module.exports = cloneSet;

},{"./_addSetEntry":16,"./_arrayReduce":23,"./_setToArray":129}],66:[function(require,module,exports){
var Symbol = require('./_Symbol');

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * Creates a clone of the `symbol` object.
 *
 * @private
 * @param {Object} symbol The symbol object to clone.
 * @returns {Object} Returns the cloned symbol object.
 */
function cloneSymbol(symbol) {
  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
}

module.exports = cloneSymbol;

},{"./_Symbol":12}],67:[function(require,module,exports){
var cloneArrayBuffer = require('./_cloneArrayBuffer');

/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}

module.exports = cloneTypedArray;

},{"./_cloneArrayBuffer":60}],68:[function(require,module,exports){
/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;

  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}

module.exports = copyArray;

},{}],69:[function(require,module,exports){
var assignValue = require('./_assignValue'),
    baseAssignValue = require('./_baseAssignValue');

/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */
function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});

  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];

    var newValue = customizer
      ? customizer(object[key], source[key], key, object, source)
      : undefined;

    if (newValue === undefined) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue(object, key, newValue);
    } else {
      assignValue(object, key, newValue);
    }
  }
  return object;
}

module.exports = copyObject;

},{"./_assignValue":26,"./_baseAssignValue":30}],70:[function(require,module,exports){
var copyObject = require('./_copyObject'),
    getSymbols = require('./_getSymbols');

/**
 * Copies own symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbols(source, object) {
  return copyObject(source, getSymbols(source), object);
}

module.exports = copySymbols;

},{"./_copyObject":69,"./_getSymbols":86}],71:[function(require,module,exports){
var copyObject = require('./_copyObject'),
    getSymbolsIn = require('./_getSymbolsIn');

/**
 * Copies own and inherited symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbolsIn(source, object) {
  return copyObject(source, getSymbolsIn(source), object);
}

module.exports = copySymbolsIn;

},{"./_copyObject":69,"./_getSymbolsIn":87}],72:[function(require,module,exports){
var root = require('./_root');

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

module.exports = coreJsData;

},{"./_root":128}],73:[function(require,module,exports){
var baseRest = require('./_baseRest'),
    isIterateeCall = require('./_isIterateeCall');

/**
 * Creates a function like `_.assign`.
 *
 * @private
 * @param {Function} assigner The function to assign values.
 * @returns {Function} Returns the new assigner function.
 */
function createAssigner(assigner) {
  return baseRest(function(object, sources) {
    var index = -1,
        length = sources.length,
        customizer = length > 1 ? sources[length - 1] : undefined,
        guard = length > 2 ? sources[2] : undefined;

    customizer = (assigner.length > 3 && typeof customizer == 'function')
      ? (length--, customizer)
      : undefined;

    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length < 3 ? undefined : customizer;
      length = 1;
    }
    object = Object(object);
    while (++index < length) {
      var source = sources[index];
      if (source) {
        assigner(object, source, index, customizer);
      }
    }
    return object;
  });
}

module.exports = createAssigner;

},{"./_baseRest":49,"./_isIterateeCall":102}],74:[function(require,module,exports){
/**
 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseFor(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index = -1,
        iterable = Object(object),
        props = keysFunc(object),
        length = props.length;

    while (length--) {
      var key = props[fromRight ? length : ++index];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}

module.exports = createBaseFor;

},{}],75:[function(require,module,exports){
var castSlice = require('./_castSlice'),
    hasUnicode = require('./_hasUnicode'),
    stringToArray = require('./_stringToArray'),
    toString = require('./toString');

/**
 * Creates a function like `_.lowerFirst`.
 *
 * @private
 * @param {string} methodName The name of the `String` case method to use.
 * @returns {Function} Returns the new case function.
 */
function createCaseFirst(methodName) {
  return function(string) {
    string = toString(string);

    var strSymbols = hasUnicode(string)
      ? stringToArray(string)
      : undefined;

    var chr = strSymbols
      ? strSymbols[0]
      : string.charAt(0);

    var trailing = strSymbols
      ? castSlice(strSymbols, 1).join('')
      : string.slice(1);

    return chr[methodName]() + trailing;
  };
}

module.exports = createCaseFirst;

},{"./_castSlice":59,"./_hasUnicode":91,"./_stringToArray":137,"./toString":183}],76:[function(require,module,exports){
var isPlainObject = require('./isPlainObject');

/**
 * Used by `_.omit` to customize its `_.cloneDeep` use to only clone plain
 * objects.
 *
 * @private
 * @param {*} value The value to inspect.
 * @param {string} key The key of the property to inspect.
 * @returns {*} Returns the uncloned value or `undefined` to defer cloning to `_.cloneDeep`.
 */
function customOmitClone(value) {
  return isPlainObject(value) ? undefined : value;
}

module.exports = customOmitClone;

},{"./isPlainObject":163}],77:[function(require,module,exports){
var getNative = require('./_getNative');

var defineProperty = (function() {
  try {
    var func = getNative(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}());

module.exports = defineProperty;

},{"./_getNative":83}],78:[function(require,module,exports){
var flatten = require('./flatten'),
    overRest = require('./_overRest'),
    setToString = require('./_setToString');

/**
 * A specialized version of `baseRest` which flattens the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @returns {Function} Returns the new function.
 */
function flatRest(func) {
  return setToString(overRest(func, undefined, flatten), func + '');
}

module.exports = flatRest;

},{"./_overRest":126,"./_setToString":130,"./flatten":151}],79:[function(require,module,exports){
(function (global){
/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

module.exports = freeGlobal;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],80:[function(require,module,exports){
var baseGetAllKeys = require('./_baseGetAllKeys'),
    getSymbols = require('./_getSymbols'),
    keys = require('./keys');

/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeys(object) {
  return baseGetAllKeys(object, keys, getSymbols);
}

module.exports = getAllKeys;

},{"./_baseGetAllKeys":37,"./_getSymbols":86,"./keys":167}],81:[function(require,module,exports){
var baseGetAllKeys = require('./_baseGetAllKeys'),
    getSymbolsIn = require('./_getSymbolsIn'),
    keysIn = require('./keysIn');

/**
 * Creates an array of own and inherited enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeysIn(object) {
  return baseGetAllKeys(object, keysIn, getSymbolsIn);
}

module.exports = getAllKeysIn;

},{"./_baseGetAllKeys":37,"./_getSymbolsIn":87,"./keysIn":168}],82:[function(require,module,exports){
var isKeyable = require('./_isKeyable');

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

module.exports = getMapData;

},{"./_isKeyable":104}],83:[function(require,module,exports){
var baseIsNative = require('./_baseIsNative'),
    getValue = require('./_getValue');

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

module.exports = getNative;

},{"./_baseIsNative":41,"./_getValue":89}],84:[function(require,module,exports){
var overArg = require('./_overArg');

/** Built-in value references. */
var getPrototype = overArg(Object.getPrototypeOf, Object);

module.exports = getPrototype;

},{"./_overArg":125}],85:[function(require,module,exports){
var Symbol = require('./_Symbol');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

module.exports = getRawTag;

},{"./_Symbol":12}],86:[function(require,module,exports){
var arrayFilter = require('./_arrayFilter'),
    stubArray = require('./stubArray');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter(nativeGetSymbols(object), function(symbol) {
    return propertyIsEnumerable.call(object, symbol);
  });
};

module.exports = getSymbols;

},{"./_arrayFilter":19,"./stubArray":176}],87:[function(require,module,exports){
var arrayPush = require('./_arrayPush'),
    getPrototype = require('./_getPrototype'),
    getSymbols = require('./_getSymbols'),
    stubArray = require('./stubArray');

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own and inherited enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
  var result = [];
  while (object) {
    arrayPush(result, getSymbols(object));
    object = getPrototype(object);
  }
  return result;
};

module.exports = getSymbolsIn;

},{"./_arrayPush":22,"./_getPrototype":84,"./_getSymbols":86,"./stubArray":176}],88:[function(require,module,exports){
var DataView = require('./_DataView'),
    Map = require('./_Map'),
    Promise = require('./_Promise'),
    Set = require('./_Set'),
    WeakMap = require('./_WeakMap'),
    baseGetTag = require('./_baseGetTag'),
    toSource = require('./_toSource');

/** `Object#toString` result references. */
var mapTag = '[object Map]',
    objectTag = '[object Object]',
    promiseTag = '[object Promise]',
    setTag = '[object Set]',
    weakMapTag = '[object WeakMap]';

var dataViewTag = '[object DataView]';

/** Used to detect maps, sets, and weakmaps. */
var dataViewCtorString = toSource(DataView),
    mapCtorString = toSource(Map),
    promiseCtorString = toSource(Promise),
    setCtorString = toSource(Set),
    weakMapCtorString = toSource(WeakMap);

/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
var getTag = baseGetTag;

// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
    (Map && getTag(new Map) != mapTag) ||
    (Promise && getTag(Promise.resolve()) != promiseTag) ||
    (Set && getTag(new Set) != setTag) ||
    (WeakMap && getTag(new WeakMap) != weakMapTag)) {
  getTag = function(value) {
    var result = baseGetTag(value),
        Ctor = result == objectTag ? value.constructor : undefined,
        ctorString = Ctor ? toSource(Ctor) : '';

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString: return dataViewTag;
        case mapCtorString: return mapTag;
        case promiseCtorString: return promiseTag;
        case setCtorString: return setTag;
        case weakMapCtorString: return weakMapTag;
      }
    }
    return result;
  };
}

module.exports = getTag;

},{"./_DataView":4,"./_Map":7,"./_Promise":9,"./_Set":10,"./_WeakMap":14,"./_baseGetTag":38,"./_toSource":140}],89:[function(require,module,exports){
/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

module.exports = getValue;

},{}],90:[function(require,module,exports){
var castPath = require('./_castPath'),
    isArguments = require('./isArguments'),
    isArray = require('./isArray'),
    isIndex = require('./_isIndex'),
    isLength = require('./isLength'),
    toKey = require('./_toKey');

/**
 * Checks if `path` exists on `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @param {Function} hasFunc The function to check properties.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 */
function hasPath(object, path, hasFunc) {
  path = castPath(path, object);

  var index = -1,
      length = path.length,
      result = false;

  while (++index < length) {
    var key = toKey(path[index]);
    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }
    object = object[key];
  }
  if (result || ++index != length) {
    return result;
  }
  length = object == null ? 0 : object.length;
  return !!length && isLength(length) && isIndex(key, length) &&
    (isArray(object) || isArguments(object));
}

module.exports = hasPath;

},{"./_castPath":58,"./_isIndex":101,"./_toKey":139,"./isArguments":154,"./isArray":155,"./isLength":160}],91:[function(require,module,exports){
/** Used to compose unicode character classes. */
var rsAstralRange = '\\ud800-\\udfff',
    rsComboMarksRange = '\\u0300-\\u036f',
    reComboHalfMarksRange = '\\ufe20-\\ufe2f',
    rsComboSymbolsRange = '\\u20d0-\\u20ff',
    rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
    rsVarRange = '\\ufe0e\\ufe0f';

/** Used to compose unicode capture groups. */
var rsZWJ = '\\u200d';

/** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange  + rsComboRange + rsVarRange + ']');

/**
 * Checks if `string` contains Unicode symbols.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {boolean} Returns `true` if a symbol is found, else `false`.
 */
function hasUnicode(string) {
  return reHasUnicode.test(string);
}

module.exports = hasUnicode;

},{}],92:[function(require,module,exports){
var nativeCreate = require('./_nativeCreate');

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
  this.size = 0;
}

module.exports = hashClear;

},{"./_nativeCreate":120}],93:[function(require,module,exports){
/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = hashDelete;

},{}],94:[function(require,module,exports){
var nativeCreate = require('./_nativeCreate');

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

module.exports = hashGet;

},{"./_nativeCreate":120}],95:[function(require,module,exports){
var nativeCreate = require('./_nativeCreate');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
}

module.exports = hashHas;

},{"./_nativeCreate":120}],96:[function(require,module,exports){
var nativeCreate = require('./_nativeCreate');

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

module.exports = hashSet;

},{"./_nativeCreate":120}],97:[function(require,module,exports){
/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Initializes an array clone.
 *
 * @private
 * @param {Array} array The array to clone.
 * @returns {Array} Returns the initialized clone.
 */
function initCloneArray(array) {
  var length = array.length,
      result = array.constructor(length);

  // Add properties assigned by `RegExp#exec`.
  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
    result.index = array.index;
    result.input = array.input;
  }
  return result;
}

module.exports = initCloneArray;

},{}],98:[function(require,module,exports){
var cloneArrayBuffer = require('./_cloneArrayBuffer'),
    cloneDataView = require('./_cloneDataView'),
    cloneMap = require('./_cloneMap'),
    cloneRegExp = require('./_cloneRegExp'),
    cloneSet = require('./_cloneSet'),
    cloneSymbol = require('./_cloneSymbol'),
    cloneTypedArray = require('./_cloneTypedArray');

/** `Object#toString` result references. */
var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/**
 * Initializes an object clone based on its `toStringTag`.
 *
 * **Note:** This function only supports cloning values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to clone.
 * @param {string} tag The `toStringTag` of the object to clone.
 * @param {Function} cloneFunc The function to clone values.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneByTag(object, tag, cloneFunc, isDeep) {
  var Ctor = object.constructor;
  switch (tag) {
    case arrayBufferTag:
      return cloneArrayBuffer(object);

    case boolTag:
    case dateTag:
      return new Ctor(+object);

    case dataViewTag:
      return cloneDataView(object, isDeep);

    case float32Tag: case float64Tag:
    case int8Tag: case int16Tag: case int32Tag:
    case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
      return cloneTypedArray(object, isDeep);

    case mapTag:
      return cloneMap(object, isDeep, cloneFunc);

    case numberTag:
    case stringTag:
      return new Ctor(object);

    case regexpTag:
      return cloneRegExp(object);

    case setTag:
      return cloneSet(object, isDeep, cloneFunc);

    case symbolTag:
      return cloneSymbol(object);
  }
}

module.exports = initCloneByTag;

},{"./_cloneArrayBuffer":60,"./_cloneDataView":62,"./_cloneMap":63,"./_cloneRegExp":64,"./_cloneSet":65,"./_cloneSymbol":66,"./_cloneTypedArray":67}],99:[function(require,module,exports){
var baseCreate = require('./_baseCreate'),
    getPrototype = require('./_getPrototype'),
    isPrototype = require('./_isPrototype');

/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneObject(object) {
  return (typeof object.constructor == 'function' && !isPrototype(object))
    ? baseCreate(getPrototype(object))
    : {};
}

module.exports = initCloneObject;

},{"./_baseCreate":33,"./_getPrototype":84,"./_isPrototype":106}],100:[function(require,module,exports){
var Symbol = require('./_Symbol'),
    isArguments = require('./isArguments'),
    isArray = require('./isArray');

/** Built-in value references. */
var spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined;

/**
 * Checks if `value` is a flattenable `arguments` object or array.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
 */
function isFlattenable(value) {
  return isArray(value) || isArguments(value) ||
    !!(spreadableSymbol && value && value[spreadableSymbol]);
}

module.exports = isFlattenable;

},{"./_Symbol":12,"./isArguments":154,"./isArray":155}],101:[function(require,module,exports){
/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length &&
    (typeof value == 'number' || reIsUint.test(value)) &&
    (value > -1 && value % 1 == 0 && value < length);
}

module.exports = isIndex;

},{}],102:[function(require,module,exports){
var eq = require('./eq'),
    isArrayLike = require('./isArrayLike'),
    isIndex = require('./_isIndex'),
    isObject = require('./isObject');

/**
 * Checks if the given arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
 *  else `false`.
 */
function isIterateeCall(value, index, object) {
  if (!isObject(object)) {
    return false;
  }
  var type = typeof index;
  if (type == 'number'
        ? (isArrayLike(object) && isIndex(index, object.length))
        : (type == 'string' && index in object)
      ) {
    return eq(object[index], value);
  }
  return false;
}

module.exports = isIterateeCall;

},{"./_isIndex":101,"./eq":150,"./isArrayLike":156,"./isObject":161}],103:[function(require,module,exports){
var isArray = require('./isArray'),
    isSymbol = require('./isSymbol');

/** Used to match property names within property paths. */
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    reIsPlainProp = /^\w*$/;

/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */
function isKey(value, object) {
  if (isArray(value)) {
    return false;
  }
  var type = typeof value;
  if (type == 'number' || type == 'symbol' || type == 'boolean' ||
      value == null || isSymbol(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
    (object != null && value in Object(object));
}

module.exports = isKey;

},{"./isArray":155,"./isSymbol":165}],104:[function(require,module,exports){
/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

module.exports = isKeyable;

},{}],105:[function(require,module,exports){
var coreJsData = require('./_coreJsData');

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

module.exports = isMasked;

},{"./_coreJsData":72}],106:[function(require,module,exports){
/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

  return value === proto;
}

module.exports = isPrototype;

},{}],107:[function(require,module,exports){
/**
 * Converts `iterator` to an array.
 *
 * @private
 * @param {Object} iterator The iterator to convert.
 * @returns {Array} Returns the converted array.
 */
function iteratorToArray(iterator) {
  var data,
      result = [];

  while (!(data = iterator.next()).done) {
    result.push(data.value);
  }
  return result;
}

module.exports = iteratorToArray;

},{}],108:[function(require,module,exports){
/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

module.exports = listCacheClear;

},{}],109:[function(require,module,exports){
var assocIndexOf = require('./_assocIndexOf');

/** Used for built-in method references. */
var arrayProto = Array.prototype;

/** Built-in value references. */
var splice = arrayProto.splice;

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}

module.exports = listCacheDelete;

},{"./_assocIndexOf":27}],110:[function(require,module,exports){
var assocIndexOf = require('./_assocIndexOf');

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

module.exports = listCacheGet;

},{"./_assocIndexOf":27}],111:[function(require,module,exports){
var assocIndexOf = require('./_assocIndexOf');

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

module.exports = listCacheHas;

},{"./_assocIndexOf":27}],112:[function(require,module,exports){
var assocIndexOf = require('./_assocIndexOf');

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

module.exports = listCacheSet;

},{"./_assocIndexOf":27}],113:[function(require,module,exports){
var Hash = require('./_Hash'),
    ListCache = require('./_ListCache'),
    Map = require('./_Map');

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

module.exports = mapCacheClear;

},{"./_Hash":5,"./_ListCache":6,"./_Map":7}],114:[function(require,module,exports){
var getMapData = require('./_getMapData');

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  var result = getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = mapCacheDelete;

},{"./_getMapData":82}],115:[function(require,module,exports){
var getMapData = require('./_getMapData');

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

module.exports = mapCacheGet;

},{"./_getMapData":82}],116:[function(require,module,exports){
var getMapData = require('./_getMapData');

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

module.exports = mapCacheHas;

},{"./_getMapData":82}],117:[function(require,module,exports){
var getMapData = require('./_getMapData');

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  var data = getMapData(this, key),
      size = data.size;

  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

module.exports = mapCacheSet;

},{"./_getMapData":82}],118:[function(require,module,exports){
/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */
function mapToArray(map) {
  var index = -1,
      result = Array(map.size);

  map.forEach(function(value, key) {
    result[++index] = [key, value];
  });
  return result;
}

module.exports = mapToArray;

},{}],119:[function(require,module,exports){
var memoize = require('./memoize');

/** Used as the maximum memoize cache size. */
var MAX_MEMOIZE_SIZE = 500;

/**
 * A specialized version of `_.memoize` which clears the memoized function's
 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
 *
 * @private
 * @param {Function} func The function to have its output memoized.
 * @returns {Function} Returns the new memoized function.
 */
function memoizeCapped(func) {
  var result = memoize(func, function(key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }
    return key;
  });

  var cache = result.cache;
  return result;
}

module.exports = memoizeCapped;

},{"./memoize":170}],120:[function(require,module,exports){
var getNative = require('./_getNative');

/* Built-in method references that are verified to be native. */
var nativeCreate = getNative(Object, 'create');

module.exports = nativeCreate;

},{"./_getNative":83}],121:[function(require,module,exports){
var overArg = require('./_overArg');

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeKeys = overArg(Object.keys, Object);

module.exports = nativeKeys;

},{"./_overArg":125}],122:[function(require,module,exports){
/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}

module.exports = nativeKeysIn;

},{}],123:[function(require,module,exports){
var freeGlobal = require('./_freeGlobal');

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports && freeGlobal.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = (function() {
  try {
    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}());

module.exports = nodeUtil;

},{"./_freeGlobal":79}],124:[function(require,module,exports){
/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

module.exports = objectToString;

},{}],125:[function(require,module,exports){
/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

module.exports = overArg;

},{}],126:[function(require,module,exports){
var apply = require('./_apply');

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * A specialized version of `baseRest` which transforms the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @param {Function} transform The rest array transform.
 * @returns {Function} Returns the new function.
 */
function overRest(func, start, transform) {
  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
  return function() {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = transform(array);
    return apply(func, this, otherArgs);
  };
}

module.exports = overRest;

},{"./_apply":17}],127:[function(require,module,exports){
var baseGet = require('./_baseGet'),
    baseSlice = require('./_baseSlice');

/**
 * Gets the parent value at `path` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array} path The path to get the parent value of.
 * @returns {*} Returns the parent value.
 */
function parent(object, path) {
  return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
}

module.exports = parent;

},{"./_baseGet":36,"./_baseSlice":52}],128:[function(require,module,exports){
var freeGlobal = require('./_freeGlobal');

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

module.exports = root;

},{"./_freeGlobal":79}],129:[function(require,module,exports){
/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function setToArray(set) {
  var index = -1,
      result = Array(set.size);

  set.forEach(function(value) {
    result[++index] = value;
  });
  return result;
}

module.exports = setToArray;

},{}],130:[function(require,module,exports){
var baseSetToString = require('./_baseSetToString'),
    shortOut = require('./_shortOut');

/**
 * Sets the `toString` method of `func` to return `string`.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var setToString = shortOut(baseSetToString);

module.exports = setToString;

},{"./_baseSetToString":51,"./_shortOut":131}],131:[function(require,module,exports){
/** Used to detect hot functions by number of calls within a span of milliseconds. */
var HOT_COUNT = 800,
    HOT_SPAN = 16;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeNow = Date.now;

/**
 * Creates a function that'll short out and invoke `identity` instead
 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
 * milliseconds.
 *
 * @private
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new shortable function.
 */
function shortOut(func) {
  var count = 0,
      lastCalled = 0;

  return function() {
    var stamp = nativeNow(),
        remaining = HOT_SPAN - (stamp - lastCalled);

    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(undefined, arguments);
  };
}

module.exports = shortOut;

},{}],132:[function(require,module,exports){
var ListCache = require('./_ListCache');

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new ListCache;
  this.size = 0;
}

module.exports = stackClear;

},{"./_ListCache":6}],133:[function(require,module,exports){
/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  var data = this.__data__,
      result = data['delete'](key);

  this.size = data.size;
  return result;
}

module.exports = stackDelete;

},{}],134:[function(require,module,exports){
/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

module.exports = stackGet;

},{}],135:[function(require,module,exports){
/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

module.exports = stackHas;

},{}],136:[function(require,module,exports){
var ListCache = require('./_ListCache'),
    Map = require('./_Map'),
    MapCache = require('./_MapCache');

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache) {
    var pairs = data.__data__;
    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}

module.exports = stackSet;

},{"./_ListCache":6,"./_Map":7,"./_MapCache":8}],137:[function(require,module,exports){
var asciiToArray = require('./_asciiToArray'),
    hasUnicode = require('./_hasUnicode'),
    unicodeToArray = require('./_unicodeToArray');

/**
 * Converts `string` to an array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the converted array.
 */
function stringToArray(string) {
  return hasUnicode(string)
    ? unicodeToArray(string)
    : asciiToArray(string);
}

module.exports = stringToArray;

},{"./_asciiToArray":24,"./_hasUnicode":91,"./_unicodeToArray":141}],138:[function(require,module,exports){
var memoizeCapped = require('./_memoizeCapped');

/** Used to match property names within property paths. */
var reLeadingDot = /^\./,
    rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

/** Used to match backslashes in property paths. */
var reEscapeChar = /\\(\\)?/g;

/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */
var stringToPath = memoizeCapped(function(string) {
  var result = [];
  if (reLeadingDot.test(string)) {
    result.push('');
  }
  string.replace(rePropName, function(match, number, quote, string) {
    result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));
  });
  return result;
});

module.exports = stringToPath;

},{"./_memoizeCapped":119}],139:[function(require,module,exports){
var isSymbol = require('./isSymbol');

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */
function toKey(value) {
  if (typeof value == 'string' || isSymbol(value)) {
    return value;
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

module.exports = toKey;

},{"./isSymbol":165}],140:[function(require,module,exports){
/** Used for built-in method references. */
var funcProto = Function.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

module.exports = toSource;

},{}],141:[function(require,module,exports){
/** Used to compose unicode character classes. */
var rsAstralRange = '\\ud800-\\udfff',
    rsComboMarksRange = '\\u0300-\\u036f',
    reComboHalfMarksRange = '\\ufe20-\\ufe2f',
    rsComboSymbolsRange = '\\u20d0-\\u20ff',
    rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
    rsVarRange = '\\ufe0e\\ufe0f';

/** Used to compose unicode capture groups. */
var rsAstral = '[' + rsAstralRange + ']',
    rsCombo = '[' + rsComboRange + ']',
    rsFitz = '\\ud83c[\\udffb-\\udfff]',
    rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
    rsNonAstral = '[^' + rsAstralRange + ']',
    rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
    rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
    rsZWJ = '\\u200d';

/** Used to compose unicode regexes. */
var reOptMod = rsModifier + '?',
    rsOptVar = '[' + rsVarRange + ']?',
    rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
    rsSeq = rsOptVar + reOptMod + rsOptJoin,
    rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';

/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');

/**
 * Converts a Unicode `string` to an array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the converted array.
 */
function unicodeToArray(string) {
  return string.match(reUnicode) || [];
}

module.exports = unicodeToArray;

},{}],142:[function(require,module,exports){
var assignValue = require('./_assignValue'),
    copyObject = require('./_copyObject'),
    createAssigner = require('./_createAssigner'),
    isArrayLike = require('./isArrayLike'),
    isPrototype = require('./_isPrototype'),
    keys = require('./keys');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Assigns own enumerable string keyed properties of source objects to the
 * destination object. Source objects are applied from left to right.
 * Subsequent sources overwrite property assignments of previous sources.
 *
 * **Note:** This method mutates `object` and is loosely based on
 * [`Object.assign`](https://mdn.io/Object/assign).
 *
 * @static
 * @memberOf _
 * @since 0.10.0
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @see _.assignIn
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * function Bar() {
 *   this.c = 3;
 * }
 *
 * Foo.prototype.b = 2;
 * Bar.prototype.d = 4;
 *
 * _.assign({ 'a': 0 }, new Foo, new Bar);
 * // => { 'a': 1, 'c': 3 }
 */
var assign = createAssigner(function(object, source) {
  if (isPrototype(source) || isArrayLike(source)) {
    copyObject(source, keys(source), object);
    return;
  }
  for (var key in source) {
    if (hasOwnProperty.call(source, key)) {
      assignValue(object, key, source[key]);
    }
  }
});

module.exports = assign;

},{"./_assignValue":26,"./_copyObject":69,"./_createAssigner":73,"./_isPrototype":106,"./isArrayLike":156,"./keys":167}],143:[function(require,module,exports){
var toInteger = require('./toInteger');

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a function that invokes `func`, with the `this` binding and arguments
 * of the created function, while it's called less than `n` times. Subsequent
 * calls to the created function return the result of the last `func` invocation.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Function
 * @param {number} n The number of calls at which `func` is no longer invoked.
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new restricted function.
 * @example
 *
 * jQuery(element).on('click', _.before(5, addContactToList));
 * // => Allows adding up to 4 contacts to the list.
 */
function before(n, func) {
  var result;
  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  n = toInteger(n);
  return function() {
    if (--n > 0) {
      result = func.apply(this, arguments);
    }
    if (n <= 1) {
      func = undefined;
    }
    return result;
  };
}

module.exports = before;

},{"./toInteger":180}],144:[function(require,module,exports){
var toString = require('./toString'),
    upperFirst = require('./upperFirst');

/**
 * Converts the first character of `string` to upper case and the remaining
 * to lower case.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to capitalize.
 * @returns {string} Returns the capitalized string.
 * @example
 *
 * _.capitalize('FRED');
 * // => 'Fred'
 */
function capitalize(string) {
  return upperFirst(toString(string).toLowerCase());
}

module.exports = capitalize;

},{"./toString":183,"./upperFirst":184}],145:[function(require,module,exports){
var baseClamp = require('./_baseClamp'),
    toNumber = require('./toNumber');

/**
 * Clamps `number` within the inclusive `lower` and `upper` bounds.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Number
 * @param {number} number The number to clamp.
 * @param {number} [lower] The lower bound.
 * @param {number} upper The upper bound.
 * @returns {number} Returns the clamped number.
 * @example
 *
 * _.clamp(-10, -5, 5);
 * // => -5
 *
 * _.clamp(10, -5, 5);
 * // => 5
 */
function clamp(number, lower, upper) {
  if (upper === undefined) {
    upper = lower;
    lower = undefined;
  }
  if (upper !== undefined) {
    upper = toNumber(upper);
    upper = upper === upper ? upper : 0;
  }
  if (lower !== undefined) {
    lower = toNumber(lower);
    lower = lower === lower ? lower : 0;
  }
  return baseClamp(toNumber(number), lower, upper);
}

module.exports = clamp;

},{"./_baseClamp":31,"./toNumber":181}],146:[function(require,module,exports){
var baseClone = require('./_baseClone');

/** Used to compose bitmasks for cloning. */
var CLONE_SYMBOLS_FLAG = 4;

/**
 * Creates a shallow clone of `value`.
 *
 * **Note:** This method is loosely based on the
 * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
 * and supports cloning arrays, array buffers, booleans, date objects, maps,
 * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
 * arrays. The own enumerable properties of `arguments` objects are cloned
 * as plain objects. An empty object is returned for uncloneable values such
 * as error objects, functions, DOM nodes, and WeakMaps.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to clone.
 * @returns {*} Returns the cloned value.
 * @see _.cloneDeep
 * @example
 *
 * var objects = [{ 'a': 1 }, { 'b': 2 }];
 *
 * var shallow = _.clone(objects);
 * console.log(shallow[0] === objects[0]);
 * // => true
 */
function clone(value) {
  return baseClone(value, CLONE_SYMBOLS_FLAG);
}

module.exports = clone;

},{"./_baseClone":32}],147:[function(require,module,exports){
var baseClone = require('./_baseClone');

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1,
    CLONE_SYMBOLS_FLAG = 4;

/**
 * This method is like `_.clone` except that it recursively clones `value`.
 *
 * @static
 * @memberOf _
 * @since 1.0.0
 * @category Lang
 * @param {*} value The value to recursively clone.
 * @returns {*} Returns the deep cloned value.
 * @see _.clone
 * @example
 *
 * var objects = [{ 'a': 1 }, { 'b': 2 }];
 *
 * var deep = _.cloneDeep(objects);
 * console.log(deep[0] === objects[0]);
 * // => false
 */
function cloneDeep(value) {
  return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
}

module.exports = cloneDeep;

},{"./_baseClone":32}],148:[function(require,module,exports){
/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new constant function.
 * @example
 *
 * var objects = _.times(2, _.constant({ 'a': 1 }));
 *
 * console.log(objects);
 * // => [{ 'a': 1 }, { 'a': 1 }]
 *
 * console.log(objects[0] === objects[1]);
 * // => true
 */
function constant(value) {
  return function() {
    return value;
  };
}

module.exports = constant;

},{}],149:[function(require,module,exports){
var isObject = require('./isObject'),
    now = require('./now'),
    toNumber = require('./toNumber');

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max,
    nativeMin = Math.min;

/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide `options` to indicate whether `func` should be invoked on the
 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent
 * calls to the debounced function return the result of the last `func`
 * invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the debounced function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */
function debounce(func, wait, options) {
  var lastArgs,
      lastThis,
      maxWait,
      result,
      timerId,
      lastCallTime,
      lastInvokeTime = 0,
      leading = false,
      maxing = false,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  wait = toNumber(wait) || 0;
  if (isObject(options)) {
    leading = !!options.leading;
    maxing = 'maxWait' in options;
    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }

  function invokeFunc(time) {
    var args = lastArgs,
        thisArg = lastThis;

    lastArgs = lastThis = undefined;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }

  function leadingEdge(time) {
    // Reset any `maxWait` timer.
    lastInvokeTime = time;
    // Start the timer for the trailing edge.
    timerId = setTimeout(timerExpired, wait);
    // Invoke the leading edge.
    return leading ? invokeFunc(time) : result;
  }

  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime,
        result = wait - timeSinceLastCall;

    return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;
  }

  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime;

    // Either this is the first call, activity has stopped and we're at the
    // trailing edge, the system time has gone backwards and we're treating
    // it as the trailing edge, or we've hit the `maxWait` limit.
    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
  }

  function timerExpired() {
    var time = now();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    // Restart the timer.
    timerId = setTimeout(timerExpired, remainingWait(time));
  }

  function trailingEdge(time) {
    timerId = undefined;

    // Only invoke if we have `lastArgs` which means `func` has been
    // debounced at least once.
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = undefined;
    return result;
  }

  function cancel() {
    if (timerId !== undefined) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = undefined;
  }

  function flush() {
    return timerId === undefined ? result : trailingEdge(now());
  }

  function debounced() {
    var time = now(),
        isInvoking = shouldInvoke(time);

    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;

    if (isInvoking) {
      if (timerId === undefined) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        // Handle invocations in a tight loop.
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === undefined) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}

module.exports = debounce;

},{"./isObject":161,"./now":172,"./toNumber":181}],150:[function(require,module,exports){
/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

module.exports = eq;

},{}],151:[function(require,module,exports){
var baseFlatten = require('./_baseFlatten');

/**
 * Flattens `array` a single level deep.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to flatten.
 * @returns {Array} Returns the new flattened array.
 * @example
 *
 * _.flatten([1, [2, [3, [4]], 5]]);
 * // => [1, 2, [3, [4]], 5]
 */
function flatten(array) {
  var length = array == null ? 0 : array.length;
  return length ? baseFlatten(array, 1) : [];
}

module.exports = flatten;

},{"./_baseFlatten":34}],152:[function(require,module,exports){
var baseHasIn = require('./_baseHasIn'),
    hasPath = require('./_hasPath');

/**
 * Checks if `path` is a direct or inherited property of `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.hasIn(object, 'a');
 * // => true
 *
 * _.hasIn(object, 'a.b');
 * // => true
 *
 * _.hasIn(object, ['a', 'b']);
 * // => true
 *
 * _.hasIn(object, 'b');
 * // => false
 */
function hasIn(object, path) {
  return object != null && hasPath(object, path, baseHasIn);
}

module.exports = hasIn;

},{"./_baseHasIn":39,"./_hasPath":90}],153:[function(require,module,exports){
/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

module.exports = identity;

},{}],154:[function(require,module,exports){
var baseIsArguments = require('./_baseIsArguments'),
    isObjectLike = require('./isObjectLike');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
    !propertyIsEnumerable.call(value, 'callee');
};

module.exports = isArguments;

},{"./_baseIsArguments":40,"./isObjectLike":162}],155:[function(require,module,exports){
/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

module.exports = isArray;

},{}],156:[function(require,module,exports){
var isFunction = require('./isFunction'),
    isLength = require('./isLength');

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

module.exports = isArrayLike;

},{"./isFunction":159,"./isLength":160}],157:[function(require,module,exports){
var isArrayLike = require('./isArrayLike'),
    isObjectLike = require('./isObjectLike');

/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */
function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}

module.exports = isArrayLikeObject;

},{"./isArrayLike":156,"./isObjectLike":162}],158:[function(require,module,exports){
var root = require('./_root'),
    stubFalse = require('./stubFalse');

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || stubFalse;

module.exports = isBuffer;

},{"./_root":128,"./stubFalse":177}],159:[function(require,module,exports){
var baseGetTag = require('./_baseGetTag'),
    isObject = require('./isObject');

/** `Object#toString` result references. */
var asyncTag = '[object AsyncFunction]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  if (!isObject(value)) {
    return false;
  }
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag = baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

module.exports = isFunction;

},{"./_baseGetTag":38,"./isObject":161}],160:[function(require,module,exports){
/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

module.exports = isLength;

},{}],161:[function(require,module,exports){
/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

module.exports = isObject;

},{}],162:[function(require,module,exports){
/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

module.exports = isObjectLike;

},{}],163:[function(require,module,exports){
var baseGetTag = require('./_baseGetTag'),
    getPrototype = require('./_getPrototype'),
    isObjectLike = require('./isObjectLike');

/** `Object#toString` result references. */
var objectTag = '[object Object]';

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to infer the `Object` constructor. */
var objectCtorString = funcToString.call(Object);

/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */
function isPlainObject(value) {
  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
    return false;
  }
  var proto = getPrototype(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
  return typeof Ctor == 'function' && Ctor instanceof Ctor &&
    funcToString.call(Ctor) == objectCtorString;
}

module.exports = isPlainObject;

},{"./_baseGetTag":38,"./_getPrototype":84,"./isObjectLike":162}],164:[function(require,module,exports){
var baseGetTag = require('./_baseGetTag'),
    isArray = require('./isArray'),
    isObjectLike = require('./isObjectLike');

/** `Object#toString` result references. */
var stringTag = '[object String]';

/**
 * Checks if `value` is classified as a `String` primitive or object.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a string, else `false`.
 * @example
 *
 * _.isString('abc');
 * // => true
 *
 * _.isString(1);
 * // => false
 */
function isString(value) {
  return typeof value == 'string' ||
    (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag);
}

module.exports = isString;

},{"./_baseGetTag":38,"./isArray":155,"./isObjectLike":162}],165:[function(require,module,exports){
var baseGetTag = require('./_baseGetTag'),
    isObjectLike = require('./isObjectLike');

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && baseGetTag(value) == symbolTag);
}

module.exports = isSymbol;

},{"./_baseGetTag":38,"./isObjectLike":162}],166:[function(require,module,exports){
var baseIsTypedArray = require('./_baseIsTypedArray'),
    baseUnary = require('./_baseUnary'),
    nodeUtil = require('./_nodeUtil');

/* Node.js helper references. */
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

module.exports = isTypedArray;

},{"./_baseIsTypedArray":42,"./_baseUnary":55,"./_nodeUtil":123}],167:[function(require,module,exports){
var arrayLikeKeys = require('./_arrayLikeKeys'),
    baseKeys = require('./_baseKeys'),
    isArrayLike = require('./isArrayLike');

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

module.exports = keys;

},{"./_arrayLikeKeys":20,"./_baseKeys":43,"./isArrayLike":156}],168:[function(require,module,exports){
var arrayLikeKeys = require('./_arrayLikeKeys'),
    baseKeysIn = require('./_baseKeysIn'),
    isArrayLike = require('./isArrayLike');

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
function keysIn(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}

module.exports = keysIn;

},{"./_arrayLikeKeys":20,"./_baseKeysIn":44,"./isArrayLike":156}],169:[function(require,module,exports){
/**
 * Gets the last element of `array`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to query.
 * @returns {*} Returns the last element of `array`.
 * @example
 *
 * _.last([1, 2, 3]);
 * // => 3
 */
function last(array) {
  var length = array == null ? 0 : array.length;
  return length ? array[length - 1] : undefined;
}

module.exports = last;

},{}],170:[function(require,module,exports){
var MapCache = require('./_MapCache');

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */
function memoize(func, resolver) {
  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache);
  return memoized;
}

// Expose `MapCache`.
memoize.Cache = MapCache;

module.exports = memoize;

},{"./_MapCache":8}],171:[function(require,module,exports){
var baseMerge = require('./_baseMerge'),
    createAssigner = require('./_createAssigner');

/**
 * This method is like `_.assign` except that it recursively merges own and
 * inherited enumerable string keyed properties of source objects into the
 * destination object. Source properties that resolve to `undefined` are
 * skipped if a destination value exists. Array and plain object properties
 * are merged recursively. Other objects and value types are overridden by
 * assignment. Source objects are applied from left to right. Subsequent
 * sources overwrite property assignments of previous sources.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 0.5.0
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @example
 *
 * var object = {
 *   'a': [{ 'b': 2 }, { 'd': 4 }]
 * };
 *
 * var other = {
 *   'a': [{ 'c': 3 }, { 'e': 5 }]
 * };
 *
 * _.merge(object, other);
 * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
 */
var merge = createAssigner(function(object, source, srcIndex) {
  baseMerge(object, source, srcIndex);
});

module.exports = merge;

},{"./_baseMerge":45,"./_createAssigner":73}],172:[function(require,module,exports){
var root = require('./_root');

/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */
var now = function() {
  return root.Date.now();
};

module.exports = now;

},{"./_root":128}],173:[function(require,module,exports){
var arrayMap = require('./_arrayMap'),
    baseClone = require('./_baseClone'),
    baseUnset = require('./_baseUnset'),
    castPath = require('./_castPath'),
    copyObject = require('./_copyObject'),
    customOmitClone = require('./_customOmitClone'),
    flatRest = require('./_flatRest'),
    getAllKeysIn = require('./_getAllKeysIn');

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1,
    CLONE_FLAT_FLAG = 2,
    CLONE_SYMBOLS_FLAG = 4;

/**
 * The opposite of `_.pick`; this method creates an object composed of the
 * own and inherited enumerable property paths of `object` that are not omitted.
 *
 * **Note:** This method is considerably slower than `_.pick`.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The source object.
 * @param {...(string|string[])} [paths] The property paths to omit.
 * @returns {Object} Returns the new object.
 * @example
 *
 * var object = { 'a': 1, 'b': '2', 'c': 3 };
 *
 * _.omit(object, ['a', 'c']);
 * // => { 'b': '2' }
 */
var omit = flatRest(function(object, paths) {
  var result = {};
  if (object == null) {
    return result;
  }
  var isDeep = false;
  paths = arrayMap(paths, function(path) {
    path = castPath(path, object);
    isDeep || (isDeep = path.length > 1);
    return path;
  });
  copyObject(object, getAllKeysIn(object), result);
  if (isDeep) {
    result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
  }
  var length = paths.length;
  while (length--) {
    baseUnset(result, paths[length]);
  }
  return result;
});

module.exports = omit;

},{"./_arrayMap":21,"./_baseClone":32,"./_baseUnset":56,"./_castPath":58,"./_copyObject":69,"./_customOmitClone":76,"./_flatRest":78,"./_getAllKeysIn":81}],174:[function(require,module,exports){
var before = require('./before');

/**
 * Creates a function that is restricted to invoking `func` once. Repeat calls
 * to the function return the value of the first invocation. The `func` is
 * invoked with the `this` binding and arguments of the created function.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new restricted function.
 * @example
 *
 * var initialize = _.once(createApplication);
 * initialize();
 * initialize();
 * // => `createApplication` is invoked once
 */
function once(func) {
  return before(2, func);
}

module.exports = once;

},{"./before":143}],175:[function(require,module,exports){
var basePick = require('./_basePick'),
    flatRest = require('./_flatRest');

/**
 * Creates an object composed of the picked `object` properties.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The source object.
 * @param {...(string|string[])} [paths] The property paths to pick.
 * @returns {Object} Returns the new object.
 * @example
 *
 * var object = { 'a': 1, 'b': '2', 'c': 3 };
 *
 * _.pick(object, ['a', 'c']);
 * // => { 'a': 1, 'c': 3 }
 */
var pick = flatRest(function(object, paths) {
  return object == null ? {} : basePick(object, paths);
});

module.exports = pick;

},{"./_basePick":47,"./_flatRest":78}],176:[function(require,module,exports){
/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */
function stubArray() {
  return [];
}

module.exports = stubArray;

},{}],177:[function(require,module,exports){
/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

module.exports = stubFalse;

},{}],178:[function(require,module,exports){
var Symbol = require('./_Symbol'),
    copyArray = require('./_copyArray'),
    getTag = require('./_getTag'),
    isArrayLike = require('./isArrayLike'),
    isString = require('./isString'),
    iteratorToArray = require('./_iteratorToArray'),
    mapToArray = require('./_mapToArray'),
    setToArray = require('./_setToArray'),
    stringToArray = require('./_stringToArray'),
    values = require('./values');

/** `Object#toString` result references. */
var mapTag = '[object Map]',
    setTag = '[object Set]';

/** Built-in value references. */
var symIterator = Symbol ? Symbol.iterator : undefined;

/**
 * Converts `value` to an array.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {Array} Returns the converted array.
 * @example
 *
 * _.toArray({ 'a': 1, 'b': 2 });
 * // => [1, 2]
 *
 * _.toArray('abc');
 * // => ['a', 'b', 'c']
 *
 * _.toArray(1);
 * // => []
 *
 * _.toArray(null);
 * // => []
 */
function toArray(value) {
  if (!value) {
    return [];
  }
  if (isArrayLike(value)) {
    return isString(value) ? stringToArray(value) : copyArray(value);
  }
  if (symIterator && value[symIterator]) {
    return iteratorToArray(value[symIterator]());
  }
  var tag = getTag(value),
      func = tag == mapTag ? mapToArray : (tag == setTag ? setToArray : values);

  return func(value);
}

module.exports = toArray;

},{"./_Symbol":12,"./_copyArray":68,"./_getTag":88,"./_iteratorToArray":107,"./_mapToArray":118,"./_setToArray":129,"./_stringToArray":137,"./isArrayLike":156,"./isString":164,"./values":185}],179:[function(require,module,exports){
var toNumber = require('./toNumber');

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0,
    MAX_INTEGER = 1.7976931348623157e+308;

/**
 * Converts `value` to a finite number.
 *
 * @static
 * @memberOf _
 * @since 4.12.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted number.
 * @example
 *
 * _.toFinite(3.2);
 * // => 3.2
 *
 * _.toFinite(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toFinite(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toFinite('3.2');
 * // => 3.2
 */
function toFinite(value) {
  if (!value) {
    return value === 0 ? value : 0;
  }
  value = toNumber(value);
  if (value === INFINITY || value === -INFINITY) {
    var sign = (value < 0 ? -1 : 1);
    return sign * MAX_INTEGER;
  }
  return value === value ? value : 0;
}

module.exports = toFinite;

},{"./toNumber":181}],180:[function(require,module,exports){
var toFinite = require('./toFinite');

/**
 * Converts `value` to an integer.
 *
 * **Note:** This method is loosely based on
 * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted integer.
 * @example
 *
 * _.toInteger(3.2);
 * // => 3
 *
 * _.toInteger(Number.MIN_VALUE);
 * // => 0
 *
 * _.toInteger(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toInteger('3.2');
 * // => 3
 */
function toInteger(value) {
  var result = toFinite(value),
      remainder = result % 1;

  return result === result ? (remainder ? result - remainder : result) : 0;
}

module.exports = toInteger;

},{"./toFinite":179}],181:[function(require,module,exports){
var isObject = require('./isObject'),
    isSymbol = require('./isSymbol');

/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** Used to match leading and trailing whitespace. */
var reTrim = /^\s+|\s+$/g;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = value.replace(reTrim, '');
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

module.exports = toNumber;

},{"./isObject":161,"./isSymbol":165}],182:[function(require,module,exports){
var copyObject = require('./_copyObject'),
    keysIn = require('./keysIn');

/**
 * Converts `value` to a plain object flattening inherited enumerable string
 * keyed properties of `value` to own properties of the plain object.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {Object} Returns the converted plain object.
 * @example
 *
 * function Foo() {
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.assign({ 'a': 1 }, new Foo);
 * // => { 'a': 1, 'b': 2 }
 *
 * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
 * // => { 'a': 1, 'b': 2, 'c': 3 }
 */
function toPlainObject(value) {
  return copyObject(value, keysIn(value));
}

module.exports = toPlainObject;

},{"./_copyObject":69,"./keysIn":168}],183:[function(require,module,exports){
var baseToString = require('./_baseToString');

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString(value) {
  return value == null ? '' : baseToString(value);
}

module.exports = toString;

},{"./_baseToString":54}],184:[function(require,module,exports){
var createCaseFirst = require('./_createCaseFirst');

/**
 * Converts the first character of `string` to upper case.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category String
 * @param {string} [string=''] The string to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.upperFirst('fred');
 * // => 'Fred'
 *
 * _.upperFirst('FRED');
 * // => 'FRED'
 */
var upperFirst = createCaseFirst('toUpperCase');

module.exports = upperFirst;

},{"./_createCaseFirst":75}],185:[function(require,module,exports){
var baseValues = require('./_baseValues'),
    keys = require('./keys');

/**
 * Creates an array of the own enumerable string keyed property values of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property values.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.values(new Foo);
 * // => [1, 2] (iteration order is not guaranteed)
 *
 * _.values('hi');
 * // => ['h', 'i']
 */
function values(object) {
  return object == null ? [] : baseValues(object, keys(object));
}

module.exports = values;

},{"./_baseValues":57,"./keys":167}],186:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],187:[function(require,module,exports){
'use strict';

function RavenConfigError(message) {
    this.name = 'RavenConfigError';
    this.message = message;
}
RavenConfigError.prototype = new Error();
RavenConfigError.prototype.constructor = RavenConfigError;

module.exports = RavenConfigError;

},{}],188:[function(require,module,exports){
'use strict';

var wrapMethod = function(console, level, callback) {
    var originalConsoleLevel = console[level];
    var originalConsole = console;

    if (!(level in console)) {
        return;
    }

    var sentryLevel = level === 'warn'
        ? 'warning'
        : level;

    console[level] = function () {
        var args = [].slice.call(arguments);

        var msg = '' + args.join(' ');
        var data = {level: sentryLevel, logger: 'console', extra: {'arguments': args}};
        callback && callback(msg, data);

        // this fails for some browsers. :(
        if (originalConsoleLevel) {
            // IE9 doesn't allow calling apply on console functions directly
            // See: https://stackoverflow.com/questions/5472938/does-ie9-support-console-log-and-is-it-a-real-function#answer-5473193
            Function.prototype.apply.call(
                originalConsoleLevel,
                originalConsole,
                args
            );
        }
    };
};

module.exports = {
    wrapMethod: wrapMethod
};

},{}],189:[function(require,module,exports){
(function (global){
/*global XDomainRequest:false, __DEV__:false*/
'use strict';

var TraceKit = require('../vendor/TraceKit/tracekit');
var stringify = require('../vendor/json-stringify-safe/stringify');
var RavenConfigError = require('./configError');
var utils = require('./utils');

var isError = utils.isError,
    isObject = utils.isObject;

var wrapConsoleMethod = require('./console').wrapMethod;

var dsnKeys = 'source protocol user pass host port path'.split(' '),
    dsnPattern = /^(?:(\w+):)?\/\/(?:(\w+)(:\w+)?@)?([\w\.-]+)(?::(\d+))?(\/.*)/;

function now() {
    return +new Date();
}

// This is to be defensive in environments where window does not exist (see https://github.com/getsentry/raven-js/pull/785)
var _window = typeof window !== 'undefined' ? window
            : typeof global !== 'undefined' ? global
            : typeof self !== 'undefined' ? self
            : {};
var _document = _window.document;
var _navigator = _window.navigator;


function keepOriginalCallback(original, callback) {
    return isFunction(callback) ?
    function (data) { return callback(data, original) } :
    callback;
}

// First, check for JSON support
// If there is no JSON, we no-op the core features of Raven
// since JSON is required to encode the payload
function Raven() {
    this._hasJSON = !!(typeof JSON === 'object' && JSON.stringify);
    // Raven can run in contexts where there's no document (react-native)
    this._hasDocument = !isUndefined(_document);
    this._hasNavigator = !isUndefined(_navigator);
    this._lastCapturedException = null;
    this._lastData = null;
    this._lastEventId = null;
    this._globalServer = null;
    this._globalKey = null;
    this._globalProject = null;
    this._globalContext = {};
    this._globalOptions = {
        logger: 'javascript',
        ignoreErrors: [],
        ignoreUrls: [],
        whitelistUrls: [],
        includePaths: [],
        crossOrigin: 'anonymous',
        collectWindowErrors: true,
        maxMessageLength: 0,

        // By default, truncates URL values to 250 chars
        maxUrlLength: 250,
        stackTraceLimit: 50,
        autoBreadcrumbs: true,
        instrument: true,
        sampleRate: 1
    };
    this._ignoreOnError = 0;
    this._isRavenInstalled = false;
    this._originalErrorStackTraceLimit = Error.stackTraceLimit;
    // capture references to window.console *and* all its methods first
    // before the console plugin has a chance to monkey patch
    this._originalConsole = _window.console || {};
    this._originalConsoleMethods = {};
    this._plugins = [];
    this._startTime = now();
    this._wrappedBuiltIns = [];
    this._breadcrumbs = [];
    this._lastCapturedEvent = null;
    this._keypressTimeout;
    this._location = _window.location;
    this._lastHref = this._location && this._location.href;
    this._resetBackoff();

    for (var method in this._originalConsole) {  // eslint-disable-line guard-for-in
      this._originalConsoleMethods[method] = this._originalConsole[method];
    }
}

/*
 * The core Raven singleton
 *
 * @this {Raven}
 */

Raven.prototype = {
    // Hardcode version string so that raven source can be loaded directly via
    // webpack (using a build step causes webpack #1617). Grunt verifies that
    // this value matches package.json during build.
    //   See: https://github.com/getsentry/raven-js/issues/465
    VERSION: '3.17.0',

    debug: false,

    TraceKit: TraceKit, // alias to TraceKit

    /*
     * Configure Raven with a DSN and extra options
     *
     * @param {string} dsn The public Sentry DSN
     * @param {object} options Optional set of of global options [optional]
     * @return {Raven}
     */
    config: function(dsn, options) {
        var self = this;

        if (self._globalServer) {
                this._logDebug('error', 'Error: Raven has already been configured');
            return self;
        }
        if (!dsn) return self;

        var globalOptions = self._globalOptions;

        // merge in options
        if (options) {
            each(options, function(key, value){
                // tags and extra are special and need to be put into context
                if (key === 'tags' || key === 'extra' || key === 'user') {
                    self._globalContext[key] = value;
                } else {
                    globalOptions[key] = value;
                }
            });
        }

        self.setDSN(dsn);

        // "Script error." is hard coded into browsers for errors that it can't read.
        // this is the result of a script being pulled in from an external domain and CORS.
        globalOptions.ignoreErrors.push(/^Script error\.?$/);
        globalOptions.ignoreErrors.push(/^Javascript error: Script error\.? on line 0$/);

        // join regexp rules into one big rule
        globalOptions.ignoreErrors = joinRegExp(globalOptions.ignoreErrors);
        globalOptions.ignoreUrls = globalOptions.ignoreUrls.length ? joinRegExp(globalOptions.ignoreUrls) : false;
        globalOptions.whitelistUrls = globalOptions.whitelistUrls.length ? joinRegExp(globalOptions.whitelistUrls) : false;
        globalOptions.includePaths = joinRegExp(globalOptions.includePaths);
        globalOptions.maxBreadcrumbs = Math.max(0, Math.min(globalOptions.maxBreadcrumbs || 100, 100)); // default and hard limit is 100

        var autoBreadcrumbDefaults = {
            xhr: true,
            console: true,
            dom: true,
            location: true
        };

        var autoBreadcrumbs = globalOptions.autoBreadcrumbs;
        if ({}.toString.call(autoBreadcrumbs) === '[object Object]') {
            autoBreadcrumbs = objectMerge(autoBreadcrumbDefaults, autoBreadcrumbs);
        } else if (autoBreadcrumbs !== false) {
            autoBreadcrumbs = autoBreadcrumbDefaults;
        }
        globalOptions.autoBreadcrumbs = autoBreadcrumbs;

        var instrumentDefaults = {
            tryCatch: true
        };

        var instrument = globalOptions.instrument;
        if ({}.toString.call(instrument) === '[object Object]') {
            instrument = objectMerge(instrumentDefaults, instrument);
        } else if (instrument !== false) {
            instrument = instrumentDefaults;
        }
        globalOptions.instrument = instrument;

        TraceKit.collectWindowErrors = !!globalOptions.collectWindowErrors;

        // return for chaining
        return self;
    },

    /*
     * Installs a global window.onerror error handler
     * to capture and report uncaught exceptions.
     * At this point, install() is required to be called due
     * to the way TraceKit is set up.
     *
     * @return {Raven}
     */
    install: function() {
        var self = this;
        if (self.isSetup() && !self._isRavenInstalled) {
            TraceKit.report.subscribe(function () {
                self._handleOnErrorStackInfo.apply(self, arguments);
            });
            if (self._globalOptions.instrument && self._globalOptions.instrument.tryCatch) {
              self._instrumentTryCatch();
            }

            if (self._globalOptions.autoBreadcrumbs)
                self._instrumentBreadcrumbs();

            // Install all of the plugins
            self._drainPlugins();

            self._isRavenInstalled = true;
        }

        Error.stackTraceLimit = self._globalOptions.stackTraceLimit;
        return this;
    },

    /*
     * Set the DSN (can be called multiple time unlike config)
     *
     * @param {string} dsn The public Sentry DSN
     */
    setDSN: function(dsn) {
        var self = this,
            uri = self._parseDSN(dsn),
          lastSlash = uri.path.lastIndexOf('/'),
          path = uri.path.substr(1, lastSlash);

        self._dsn = dsn;
        self._globalKey = uri.user;
        self._globalSecret = uri.pass && uri.pass.substr(1);
        self._globalProject = uri.path.substr(lastSlash + 1);

        self._globalServer = self._getGlobalServer(uri);

        self._globalEndpoint = self._globalServer +
            '/' + path + 'api/' + self._globalProject + '/store/';

        // Reset backoff state since we may be pointing at a
        // new project/server
        this._resetBackoff();
    },

    /*
     * Wrap code within a context so Raven can capture errors
     * reliably across domains that is executed immediately.
     *
     * @param {object} options A specific set of options for this context [optional]
     * @param {function} func The callback to be immediately executed within the context
     * @param {array} args An array of arguments to be called with the callback [optional]
     */
    context: function(options, func, args) {
        if (isFunction(options)) {
            args = func || [];
            func = options;
            options = undefined;
        }

        return this.wrap(options, func).apply(this, args);
    },

    /*
     * Wrap code within a context and returns back a new function to be executed
     *
     * @param {object} options A specific set of options for this context [optional]
     * @param {function} func The function to be wrapped in a new context
     * @param {function} func A function to call before the try/catch wrapper [optional, private]
     * @return {function} The newly wrapped functions with a context
     */
    wrap: function(options, func, _before) {
        var self = this;
        // 1 argument has been passed, and it's not a function
        // so just return it
        if (isUndefined(func) && !isFunction(options)) {
            return options;
        }

        // options is optional
        if (isFunction(options)) {
            func = options;
            options = undefined;
        }

        // At this point, we've passed along 2 arguments, and the second one
        // is not a function either, so we'll just return the second argument.
        if (!isFunction(func)) {
            return func;
        }

        // We don't wanna wrap it twice!
        try {
            if (func.__raven__) {
                return func;
            }

            // If this has already been wrapped in the past, return that
            if (func.__raven_wrapper__ ){
                return func.__raven_wrapper__ ;
            }
        } catch (e) {
            // Just accessing custom props in some Selenium environments
            // can cause a "Permission denied" exception (see raven-js#495).
            // Bail on wrapping and return the function as-is (defers to window.onerror).
            return func;
        }

        function wrapped() {
            var args = [], i = arguments.length,
                deep = !options || options && options.deep !== false;

            if (_before && isFunction(_before)) {
                _before.apply(this, arguments);
            }

            // Recursively wrap all of a function's arguments that are
            // functions themselves.
            while(i--) args[i] = deep ? self.wrap(options, arguments[i]) : arguments[i];

            try {
                // Attempt to invoke user-land function
                // NOTE: If you are a Sentry user, and you are seeing this stack frame, it
                //       means Raven caught an error invoking your application code. This is
                //       expected behavior and NOT indicative of a bug with Raven.js.
                return func.apply(this, args);
            } catch(e) {
                self._ignoreNextOnError();
                self.captureException(e, options);
                throw e;
            }
        }

        // copy over properties of the old function
        for (var property in func) {
            if (hasKey(func, property)) {
                wrapped[property] = func[property];
            }
        }
        wrapped.prototype = func.prototype;

        func.__raven_wrapper__ = wrapped;
        // Signal that this function has been wrapped already
        // for both debugging and to prevent it to being wrapped twice
        wrapped.__raven__ = true;
        wrapped.__inner__ = func;

        return wrapped;
    },

    /*
     * Uninstalls the global error handler.
     *
     * @return {Raven}
     */
    uninstall: function() {
        TraceKit.report.uninstall();

        this._restoreBuiltIns();

        Error.stackTraceLimit = this._originalErrorStackTraceLimit;
        this._isRavenInstalled = false;

        return this;
    },

    /*
     * Manually capture an exception and send it over to Sentry
     *
     * @param {error} ex An exception to be logged
     * @param {object} options A specific set of options for this error [optional]
     * @return {Raven}
     */
    captureException: function(ex, options) {
        // If not an Error is passed through, recall as a message instead
        if (!isError(ex)) {
            return this.captureMessage(ex, objectMerge({
                trimHeadFrames: 1,
                stacktrace: true // if we fall back to captureMessage, default to attempting a new trace
            }, options));
        }

        // Store the raw exception object for potential debugging and introspection
        this._lastCapturedException = ex;

        // TraceKit.report will re-raise any exception passed to it,
        // which means you have to wrap it in try/catch. Instead, we
        // can wrap it here and only re-raise if TraceKit.report
        // raises an exception different from the one we asked to
        // report on.
        try {
            var stack = TraceKit.computeStackTrace(ex);
            this._handleStackInfo(stack, options);
        } catch(ex1) {
            if(ex !== ex1) {
                throw ex1;
            }
        }

        return this;
    },

    /*
     * Manually send a message to Sentry
     *
     * @param {string} msg A plain message to be captured in Sentry
     * @param {object} options A specific set of options for this message [optional]
     * @return {Raven}
     */
    captureMessage: function(msg, options) {
        // config() automagically converts ignoreErrors from a list to a RegExp so we need to test for an
        // early call; we'll error on the side of logging anything called before configuration since it's
        // probably something you should see:
        if (!!this._globalOptions.ignoreErrors.test && this._globalOptions.ignoreErrors.test(msg)) {
            return;
        }

        options = options || {};

        var data = objectMerge({
            message: msg + ''  // Make sure it's actually a string
        }, options);

        if (this._globalOptions.stacktrace || (options && options.stacktrace)) {
            var ex;
            // Generate a "synthetic" stack trace from this point.
            // NOTE: If you are a Sentry user, and you are seeing this stack frame, it is NOT indicative
            //       of a bug with Raven.js. Sentry generates synthetic traces either by configuration,
            //       or if it catches a thrown object without a "stack" property.
            try {
                throw new Error(msg);
            } catch (ex1) {
                ex = ex1;
            }

            // null exception name so `Error` isn't prefixed to msg
            ex.name = null;

            options = objectMerge({
                // fingerprint on msg, not stack trace (legacy behavior, could be
                // revisited)
                fingerprint: msg,
                // since we know this is a synthetic trace, the top N-most frames
                // MUST be from Raven.js, so mark them as in_app later by setting
                // trimHeadFrames
                trimHeadFrames: (options.trimHeadFrames || 0) + 1
            }, options);

            var stack = TraceKit.computeStackTrace(ex);
            var frames = this._prepareFrames(stack, options);
            data.stacktrace = {
                // Sentry expects frames oldest to newest
                frames: frames.reverse()
            }
        }

        // Fire away!
        this._send(data);

        return this;
    },

    captureBreadcrumb: function (obj) {
        var crumb = objectMerge({
            timestamp: now() / 1000
        }, obj);

        if (isFunction(this._globalOptions.breadcrumbCallback)) {
            var result = this._globalOptions.breadcrumbCallback(crumb);

            if (isObject(result) && !isEmptyObject(result)) {
                crumb = result;
            } else if (result === false) {
                return this;
            }
        }

        this._breadcrumbs.push(crumb);
        if (this._breadcrumbs.length > this._globalOptions.maxBreadcrumbs) {
            this._breadcrumbs.shift();
        }
        return this;
    },

    addPlugin: function(plugin /*arg1, arg2, ... argN*/) {
        var pluginArgs = [].slice.call(arguments, 1);

        this._plugins.push([plugin, pluginArgs]);
        if (this._isRavenInstalled) {
            this._drainPlugins();
        }

        return this;
    },

    /*
     * Set/clear a user to be sent along with the payload.
     *
     * @param {object} user An object representing user data [optional]
     * @return {Raven}
     */
    setUserContext: function(user) {
        // Intentionally do not merge here since that's an unexpected behavior.
        this._globalContext.user = user;

        return this;
    },

    /*
     * Merge extra attributes to be sent along with the payload.
     *
     * @param {object} extra An object representing extra data [optional]
     * @return {Raven}
     */
    setExtraContext: function(extra) {
        this._mergeContext('extra', extra);

        return this;
    },

    /*
     * Merge tags to be sent along with the payload.
     *
     * @param {object} tags An object representing tags [optional]
     * @return {Raven}
     */
    setTagsContext: function(tags) {
        this._mergeContext('tags', tags);

        return this;
    },

    /*
     * Clear all of the context.
     *
     * @return {Raven}
     */
    clearContext: function() {
        this._globalContext = {};

        return this;
    },

    /*
     * Get a copy of the current context. This cannot be mutated.
     *
     * @return {object} copy of context
     */
    getContext: function() {
        // lol javascript
        return JSON.parse(stringify(this._globalContext));
    },


    /*
     * Set environment of application
     *
     * @param {string} environment Typically something like 'production'.
     * @return {Raven}
     */
    setEnvironment: function(environment) {
        this._globalOptions.environment = environment;

        return this;
    },

    /*
     * Set release version of application
     *
     * @param {string} release Typically something like a git SHA to identify version
     * @return {Raven}
     */
    setRelease: function(release) {
        this._globalOptions.release = release;

        return this;
    },

    /*
     * Set the dataCallback option
     *
     * @param {function} callback The callback to run which allows the
     *                            data blob to be mutated before sending
     * @return {Raven}
     */
    setDataCallback: function(callback) {
        var original = this._globalOptions.dataCallback;
        this._globalOptions.dataCallback =
          keepOriginalCallback(original, callback);
        return this;
    },

    /*
     * Set the breadcrumbCallback option
     *
     * @param {function} callback The callback to run which allows filtering
     *                            or mutating breadcrumbs
     * @return {Raven}
     */
    setBreadcrumbCallback: function(callback) {
        var original = this._globalOptions.breadcrumbCallback;
        this._globalOptions.breadcrumbCallback =
          keepOriginalCallback(original, callback);
        return this;
    },

    /*
     * Set the shouldSendCallback option
     *
     * @param {function} callback The callback to run which allows
     *                            introspecting the blob before sending
     * @return {Raven}
     */
    setShouldSendCallback: function(callback) {
        var original = this._globalOptions.shouldSendCallback;
        this._globalOptions.shouldSendCallback =
          keepOriginalCallback(original, callback);
        return this;
    },

    /**
     * Override the default HTTP transport mechanism that transmits data
     * to the Sentry server.
     *
     * @param {function} transport Function invoked instead of the default
     *                             `makeRequest` handler.
     *
     * @return {Raven}
     */
    setTransport: function(transport) {
        this._globalOptions.transport = transport;

        return this;
    },

    /*
     * Get the latest raw exception that was captured by Raven.
     *
     * @return {error}
     */
    lastException: function() {
        return this._lastCapturedException;
    },

    /*
     * Get the last event id
     *
     * @return {string}
     */
    lastEventId: function() {
        return this._lastEventId;
    },

    /*
     * Determine if Raven is setup and ready to go.
     *
     * @return {boolean}
     */
    isSetup: function() {
        if (!this._hasJSON) return false;  // needs JSON support
        if (!this._globalServer) {
            if (!this.ravenNotConfiguredError) {
              this.ravenNotConfiguredError = true;
              this._logDebug('error', 'Error: Raven has not been configured.');
            }
            return false;
        }
        return true;
    },

    afterLoad: function () {
        // TODO: remove window dependence?

        // Attempt to initialize Raven on load
        var RavenConfig = _window.RavenConfig;
        if (RavenConfig) {
            this.config(RavenConfig.dsn, RavenConfig.config).install();
        }
    },

    showReportDialog: function (options) {
        if (!_document) // doesn't work without a document (React native)
            return;

        options = options || {};

        var lastEventId = options.eventId || this.lastEventId();
        if (!lastEventId) {
            throw new RavenConfigError('Missing eventId');
        }

        var dsn = options.dsn || this._dsn;
        if (!dsn) {
            throw new RavenConfigError('Missing DSN');
        }

        var encode = encodeURIComponent;
        var qs = '';
        qs += '?eventId=' + encode(lastEventId);
        qs += '&dsn=' + encode(dsn);

        var user = options.user || this._globalContext.user;
        if (user) {
            if (user.name)  qs += '&name=' + encode(user.name);
            if (user.email) qs += '&email=' + encode(user.email);
        }

        var globalServer = this._getGlobalServer(this._parseDSN(dsn));

        var script = _document.createElement('script');
        script.async = true;
        script.src = globalServer + '/api/embed/error-page/' + qs;
        (_document.head || _document.body).appendChild(script);
    },

    /**** Private functions ****/
    _ignoreNextOnError: function () {
        var self = this;
        this._ignoreOnError += 1;
        setTimeout(function () {
            // onerror should trigger before setTimeout
            self._ignoreOnError -= 1;
        });
    },

    _triggerEvent: function(eventType, options) {
        // NOTE: `event` is a native browser thing, so let's avoid conflicting wiht it
        var evt, key;

        if (!this._hasDocument)
            return;

        options = options || {};

        eventType = 'raven' + eventType.substr(0,1).toUpperCase() + eventType.substr(1);

        if (_document.createEvent) {
            evt = _document.createEvent('HTMLEvents');
            evt.initEvent(eventType, true, true);
        } else {
            evt = _document.createEventObject();
            evt.eventType = eventType;
        }

        for (key in options) if (hasKey(options, key)) {
            evt[key] = options[key];
        }

        if (_document.createEvent) {
            // IE9 if standards
            _document.dispatchEvent(evt);
        } else {
            // IE8 regardless of Quirks or Standards
            // IE9 if quirks
            try {
                _document.fireEvent('on' + evt.eventType.toLowerCase(), evt);
            } catch(e) {
                // Do nothing
            }
        }
    },

    /**
     * Wraps addEventListener to capture UI breadcrumbs
     * @param evtName the event name (e.g. "click")
     * @returns {Function}
     * @private
     */
    _breadcrumbEventHandler: function(evtName) {
        var self = this;
        return function (evt) {
            // reset keypress timeout; e.g. triggering a 'click' after
            // a 'keypress' will reset the keypress debounce so that a new
            // set of keypresses can be recorded
            self._keypressTimeout = null;

            // It's possible this handler might trigger multiple times for the same
            // event (e.g. event propagation through node ancestors). Ignore if we've
            // already captured the event.
            if (self._lastCapturedEvent === evt)
                return;

            self._lastCapturedEvent = evt;

            // try/catch both:
            // - accessing evt.target (see getsentry/raven-js#838, #768)
            // - `htmlTreeAsString` because it's complex, and just accessing the DOM incorrectly
            //   can throw an exception in some circumstances.
            var target;
            try {
                target = htmlTreeAsString(evt.target);
            } catch (e) {
                target = '<unknown>';
            }

            self.captureBreadcrumb({
                category: 'ui.' + evtName, // e.g. ui.click, ui.input
                message: target
            });
        };
    },

    /**
     * Wraps addEventListener to capture keypress UI events
     * @returns {Function}
     * @private
     */
    _keypressEventHandler: function() {
        var self = this,
            debounceDuration = 1000; // milliseconds

        // TODO: if somehow user switches keypress target before
        //       debounce timeout is triggered, we will only capture
        //       a single breadcrumb from the FIRST target (acceptable?)
        return function (evt) {
            var target;
            try {
                target = evt.target;
            } catch (e) {
                // just accessing event properties can throw an exception in some rare circumstances
                // see: https://github.com/getsentry/raven-js/issues/838
                return;
            }
            var tagName = target && target.tagName;

            // only consider keypress events on actual input elements
            // this will disregard keypresses targeting body (e.g. tabbing
            // through elements, hotkeys, etc)
            if (!tagName || tagName !== 'INPUT' && tagName !== 'TEXTAREA' && !target.isContentEditable)
                return;

            // record first keypress in a series, but ignore subsequent
            // keypresses until debounce clears
            var timeout = self._keypressTimeout;
            if (!timeout) {
                self._breadcrumbEventHandler('input')(evt);
            }
            clearTimeout(timeout);
            self._keypressTimeout = setTimeout(function () {
                self._keypressTimeout = null;
            }, debounceDuration);
        };
    },

    /**
     * Captures a breadcrumb of type "navigation", normalizing input URLs
     * @param to the originating URL
     * @param from the target URL
     * @private
     */
    _captureUrlChange: function(from, to) {
        var parsedLoc = parseUrl(this._location.href);
        var parsedTo = parseUrl(to);
        var parsedFrom = parseUrl(from);

        // because onpopstate only tells you the "new" (to) value of location.href, and
        // not the previous (from) value, we need to track the value of the current URL
        // state ourselves
        this._lastHref = to;

        // Use only the path component of the URL if the URL matches the current
        // document (almost all the time when using pushState)
        if (parsedLoc.protocol === parsedTo.protocol && parsedLoc.host === parsedTo.host)
            to = parsedTo.relative;
        if (parsedLoc.protocol === parsedFrom.protocol && parsedLoc.host === parsedFrom.host)
            from = parsedFrom.relative;

        this.captureBreadcrumb({
            category: 'navigation',
            data: {
                to: to,
                from: from
            }
        });
    },

    /**
     * Wrap timer functions and event targets to catch errors and provide
     * better metadata.
     */
    _instrumentTryCatch: function() {
        var self = this;

        var wrappedBuiltIns = self._wrappedBuiltIns;

        function wrapTimeFn(orig) {
            return function (fn, t) { // preserve arity
                // Make a copy of the arguments to prevent deoptimization
                // https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#32-leaking-arguments
                var args = new Array(arguments.length);
                for(var i = 0; i < args.length; ++i) {
                    args[i] = arguments[i];
                }
                var originalCallback = args[0];
                if (isFunction(originalCallback)) {
                    args[0] = self.wrap(originalCallback);
                }

                // IE < 9 doesn't support .call/.apply on setInterval/setTimeout, but it
                // also supports only two arguments and doesn't care what this is, so we
                // can just call the original function directly.
                if (orig.apply) {
                    return orig.apply(this, args);
                } else {
                    return orig(args[0], args[1]);
                }
            };
        }

        var autoBreadcrumbs = this._globalOptions.autoBreadcrumbs;

        function wrapEventTarget(global) {
            var proto = _window[global] && _window[global].prototype;
            if (proto && proto.hasOwnProperty && proto.hasOwnProperty('addEventListener')) {
                fill(proto, 'addEventListener', function(orig) {
                    return function (evtName, fn, capture, secure) { // preserve arity
                        try {
                            if (fn && fn.handleEvent) {
                                fn.handleEvent = self.wrap(fn.handleEvent);
                            }
                        } catch (err) {
                            // can sometimes get 'Permission denied to access property "handle Event'
                        }

                        // More breadcrumb DOM capture ... done here and not in `_instrumentBreadcrumbs`
                        // so that we don't have more than one wrapper function
                        var before,
                            clickHandler,
                            keypressHandler;

                        if (autoBreadcrumbs && autoBreadcrumbs.dom && (global === 'EventTarget' || global === 'Node')) {
                            // NOTE: generating multiple handlers per addEventListener invocation, should
                            //       revisit and verify we can just use one (almost certainly)
                            clickHandler = self._breadcrumbEventHandler('click');
                            keypressHandler = self._keypressEventHandler();
                            before = function (evt) {
                                // need to intercept every DOM event in `before` argument, in case that
                                // same wrapped method is re-used for different events (e.g. mousemove THEN click)
                                // see #724
                                if (!evt) return;

                                var eventType;
                                try {
                                    eventType = evt.type
                                } catch (e) {
                                    // just accessing event properties can throw an exception in some rare circumstances
                                    // see: https://github.com/getsentry/raven-js/issues/838
                                    return;
                                }
                                if (eventType === 'click')
                                    return clickHandler(evt);
                                else if (eventType === 'keypress')
                                    return keypressHandler(evt);
                            };
                        }
                        return orig.call(this, evtName, self.wrap(fn, undefined, before), capture, secure);
                    };
                }, wrappedBuiltIns);
                fill(proto, 'removeEventListener', function (orig) {
                    return function (evt, fn, capture, secure) {
                        try {
                            fn = fn && (fn.__raven_wrapper__ ? fn.__raven_wrapper__  : fn);
                        } catch (e) {
                            // ignore, accessing __raven_wrapper__ will throw in some Selenium environments
                        }
                        return orig.call(this, evt, fn, capture, secure);
                    };
                }, wrappedBuiltIns);
            }
        }

        fill(_window, 'setTimeout', wrapTimeFn, wrappedBuiltIns);
        fill(_window, 'setInterval', wrapTimeFn, wrappedBuiltIns);
        if (_window.requestAnimationFrame) {
            fill(_window, 'requestAnimationFrame', function (orig) {
                return function (cb) {
                    return orig(self.wrap(cb));
                };
            }, wrappedBuiltIns);
        }

        // event targets borrowed from bugsnag-js:
        // https://github.com/bugsnag/bugsnag-js/blob/master/src/bugsnag.js#L666
        var eventTargets = ['EventTarget', 'Window', 'Node', 'ApplicationCache', 'AudioTrackList', 'ChannelMergerNode', 'CryptoOperation', 'EventSource', 'FileReader', 'HTMLUnknownElement', 'IDBDatabase', 'IDBRequest', 'IDBTransaction', 'KeyOperation', 'MediaController', 'MessagePort', 'ModalWindow', 'Notification', 'SVGElementInstance', 'Screen', 'TextTrack', 'TextTrackCue', 'TextTrackList', 'WebSocket', 'WebSocketWorker', 'Worker', 'XMLHttpRequest', 'XMLHttpRequestEventTarget', 'XMLHttpRequestUpload'];
        for (var i = 0; i < eventTargets.length; i++) {
            wrapEventTarget(eventTargets[i]);
        }
    },


    /**
     * Instrument browser built-ins w/ breadcrumb capturing
     *  - XMLHttpRequests
     *  - DOM interactions (click/typing)
     *  - window.location changes
     *  - console
     *
     * Can be disabled or individually configured via the `autoBreadcrumbs` config option
     */
    _instrumentBreadcrumbs: function () {
        var self = this;
        var autoBreadcrumbs = this._globalOptions.autoBreadcrumbs;

        var wrappedBuiltIns = self._wrappedBuiltIns;

        function wrapProp(prop, xhr) {
            if (prop in xhr && isFunction(xhr[prop])) {
                fill(xhr, prop, function (orig) {
                    return self.wrap(orig);
                }); // intentionally don't track filled methods on XHR instances
            }
        }

        if (autoBreadcrumbs.xhr && 'XMLHttpRequest' in _window) {
            var xhrproto = XMLHttpRequest.prototype;
            fill(xhrproto, 'open', function(origOpen) {
                return function (method, url) { // preserve arity

                    // if Sentry key appears in URL, don't capture
                    if (isString(url) && url.indexOf(self._globalKey) === -1) {
                        this.__raven_xhr = {
                            method: method,
                            url: url,
                            status_code: null
                        };
                    }

                    return origOpen.apply(this, arguments);
                };
            }, wrappedBuiltIns);

            fill(xhrproto, 'send', function(origSend) {
                return function (data) { // preserve arity
                    var xhr = this;

                    function onreadystatechangeHandler() {
                        if (xhr.__raven_xhr && (xhr.readyState === 1 || xhr.readyState === 4)) {
                            try {
                                // touching statusCode in some platforms throws
                                // an exception
                                xhr.__raven_xhr.status_code = xhr.status;
                            } catch (e) { /* do nothing */ }
                            self.captureBreadcrumb({
                                type: 'http',
                                category: 'xhr',
                                data: xhr.__raven_xhr
                            });
                        }
                    }

                    var props = ['onload', 'onerror', 'onprogress'];
                    for (var j = 0; j < props.length; j++) {
                        wrapProp(props[j], xhr);
                    }

                    if ('onreadystatechange' in xhr && isFunction(xhr.onreadystatechange)) {
                        fill(xhr, 'onreadystatechange', function (orig) {
                            return self.wrap(orig, undefined, onreadystatechangeHandler);
                        } /* intentionally don't track this instrumentation */);
                    } else {
                        // if onreadystatechange wasn't actually set by the page on this xhr, we
                        // are free to set our own and capture the breadcrumb
                        xhr.onreadystatechange = onreadystatechangeHandler;
                    }

                    return origSend.apply(this, arguments);
                };
            }, wrappedBuiltIns);
        }

        if (autoBreadcrumbs.xhr && 'fetch' in _window) {
            fill(_window, 'fetch', function(origFetch) {
                return function (fn, t) { // preserve arity
                    // Make a copy of the arguments to prevent deoptimization
                    // https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#32-leaking-arguments
                    var args = new Array(arguments.length);
                    for (var i = 0; i < args.length; ++i) {
                        args[i] = arguments[i];
                    }

                    var fetchInput = args[0];
                    var method = 'GET';
                    var url;

                    if (typeof fetchInput === 'string') {
                        url = fetchInput;
                    } else {
                        url = fetchInput.url;
                        if (fetchInput.method) {
                            method = fetchInput.method;
                        }
                    }

                    if (args[1] && args[1].method) {
                        method = args[1].method;
                    }

                    var fetchData = {
                        method: method,
                        url: url,
                        status_code: null
                    };

                    self.captureBreadcrumb({
                        type: 'http',
                        category: 'fetch',
                        data: fetchData
                    });

                    return origFetch.apply(this, args).then(function (response) {
                        fetchData.status_code = response.status;

                        return response;
                    });
                };
            }, wrappedBuiltIns);
        }

        // Capture breadcrumbs from any click that is unhandled / bubbled up all the way
        // to the document. Do this before we instrument addEventListener.
        if (autoBreadcrumbs.dom && this._hasDocument) {
            if (_document.addEventListener) {
                _document.addEventListener('click', self._breadcrumbEventHandler('click'), false);
                _document.addEventListener('keypress', self._keypressEventHandler(), false);
            }
            else {
                // IE8 Compatibility
                _document.attachEvent('onclick', self._breadcrumbEventHandler('click'));
                _document.attachEvent('onkeypress', self._keypressEventHandler());
            }
        }

        // record navigation (URL) changes
        // NOTE: in Chrome App environment, touching history.pushState, *even inside
        //       a try/catch block*, will cause Chrome to output an error to console.error
        // borrowed from: https://github.com/angular/angular.js/pull/13945/files
        var chrome = _window.chrome;
        var isChromePackagedApp = chrome && chrome.app && chrome.app.runtime;
        var hasPushState = !isChromePackagedApp && _window.history && history.pushState;
        if (autoBreadcrumbs.location && hasPushState) {
            // TODO: remove onpopstate handler on uninstall()
            var oldOnPopState = _window.onpopstate;
            _window.onpopstate = function () {
                var currentHref = self._location.href;
                self._captureUrlChange(self._lastHref, currentHref);

                if (oldOnPopState) {
                    return oldOnPopState.apply(this, arguments);
                }
            };

            fill(history, 'pushState', function (origPushState) {
                // note history.pushState.length is 0; intentionally not declaring
                // params to preserve 0 arity
                return function (/* state, title, url */) {
                    var url = arguments.length > 2 ? arguments[2] : undefined;

                    // url argument is optional
                    if (url) {
                        // coerce to string (this is what pushState does)
                        self._captureUrlChange(self._lastHref, url + '');
                    }

                    return origPushState.apply(this, arguments);
                };
            }, wrappedBuiltIns);
        }

        if (autoBreadcrumbs.console && 'console' in _window && console.log) {
            // console
            var consoleMethodCallback = function (msg, data) {
                self.captureBreadcrumb({
                    message: msg,
                    level: data.level,
                    category: 'console'
                });
            };

            each(['debug', 'info', 'warn', 'error', 'log'], function (_, level) {
                wrapConsoleMethod(console, level, consoleMethodCallback);
            });
        }

    },

    _restoreBuiltIns: function () {
        // restore any wrapped builtins
        var builtin;
        while (this._wrappedBuiltIns.length) {
            builtin = this._wrappedBuiltIns.shift();

            var obj = builtin[0],
              name = builtin[1],
              orig = builtin[2];

            obj[name] = orig;
        }
    },

    _drainPlugins: function() {
        var self = this;

        // FIX ME TODO
        each(this._plugins, function(_, plugin) {
            var installer = plugin[0];
            var args = plugin[1];
            installer.apply(self, [self].concat(args));
        });
    },

    _parseDSN: function(str) {
        var m = dsnPattern.exec(str),
            dsn = {},
            i = 7;

        try {
            while (i--) dsn[dsnKeys[i]] = m[i] || '';
        } catch(e) {
            throw new RavenConfigError('Invalid DSN: ' + str);
        }

        if (dsn.pass && !this._globalOptions.allowSecretKey) {
            throw new RavenConfigError('Do not specify your secret key in the DSN. See: http://bit.ly/raven-secret-key');
        }

        return dsn;
    },

    _getGlobalServer: function(uri) {
        // assemble the endpoint from the uri pieces
        var globalServer = '//' + uri.host +
            (uri.port ? ':' + uri.port : '');

        if (uri.protocol) {
            globalServer = uri.protocol + ':' + globalServer;
        }
        return globalServer;
    },

    _handleOnErrorStackInfo: function() {
        // if we are intentionally ignoring errors via onerror, bail out
        if (!this._ignoreOnError) {
            this._handleStackInfo.apply(this, arguments);
        }
    },

    _handleStackInfo: function(stackInfo, options) {
        var frames = this._prepareFrames(stackInfo, options);

        this._triggerEvent('handle', {
            stackInfo: stackInfo,
            options: options
        });

        this._processException(
            stackInfo.name,
            stackInfo.message,
            stackInfo.url,
            stackInfo.lineno,
            frames,
            options
        );
    },

    _prepareFrames: function(stackInfo, options) {
        var self = this;
        var frames = [];
        if (stackInfo.stack && stackInfo.stack.length) {
            each(stackInfo.stack, function(i, stack) {
                var frame = self._normalizeFrame(stack);
                if (frame) {
                    frames.push(frame);
                }
            });

            // e.g. frames captured via captureMessage throw
            if (options && options.trimHeadFrames) {
                for (var j = 0; j < options.trimHeadFrames && j < frames.length; j++) {
                    frames[j].in_app = false;
                }
            }
        }
        frames = frames.slice(0, this._globalOptions.stackTraceLimit);
        return frames;
    },


    _normalizeFrame: function(frame) {
        if (!frame.url) return;

        // normalize the frames data
        var normalized = {
            filename:   frame.url,
            lineno:     frame.line,
            colno:      frame.column,
            'function': frame.func || '?'
        };

        normalized.in_app = !( // determine if an exception came from outside of our app
            // first we check the global includePaths list.
            !!this._globalOptions.includePaths.test && !this._globalOptions.includePaths.test(normalized.filename) ||
            // Now we check for fun, if the function name is Raven or TraceKit
            /(Raven|TraceKit)\./.test(normalized['function']) ||
            // finally, we do a last ditch effort and check for raven.min.js
            /raven\.(min\.)?js$/.test(normalized.filename)
        );

        return normalized;
    },

    _processException: function(type, message, fileurl, lineno, frames, options) {
        var stacktrace;
        if (!!this._globalOptions.ignoreErrors.test && this._globalOptions.ignoreErrors.test(message)) return;

        message += '';

        if (frames && frames.length) {
            fileurl = frames[0].filename || fileurl;
            // Sentry expects frames oldest to newest
            // and JS sends them as newest to oldest
            frames.reverse();
            stacktrace = {frames: frames};
        } else if (fileurl) {
            stacktrace = {
                frames: [{
                    filename: fileurl,
                    lineno: lineno,
                    in_app: true
                }]
            };
        }

        if (!!this._globalOptions.ignoreUrls.test && this._globalOptions.ignoreUrls.test(fileurl)) return;
        if (!!this._globalOptions.whitelistUrls.test && !this._globalOptions.whitelistUrls.test(fileurl)) return;

        var data = objectMerge({
            // sentry.interfaces.Exception
            exception: {
                values: [{
                    type: type,
                    value: message,
                    stacktrace: stacktrace
                }]
            },
            culprit: fileurl
        }, options);

        // Fire away!
        this._send(data);
    },

    _trimPacket: function(data) {
        // For now, we only want to truncate the two different messages
        // but this could/should be expanded to just trim everything
        var max = this._globalOptions.maxMessageLength;
        if (data.message) {
            data.message = truncate(data.message, max);
        }
        if (data.exception) {
            var exception = data.exception.values[0];
            exception.value = truncate(exception.value, max);
        }

        var request = data.request;
        if (request) {
            if (request.url) {
                request.url = truncate(request.url, this._globalOptions.maxUrlLength);
            }
            if (request.Referer) {
                request.Referer = truncate(request.Referer, this._globalOptions.maxUrlLength);
            }
        }

        if (data.breadcrumbs && data.breadcrumbs.values)
            this._trimBreadcrumbs(data.breadcrumbs);

        return data;
    },

    /**
     * Truncate breadcrumb values (right now just URLs)
     */
    _trimBreadcrumbs: function (breadcrumbs) {
        // known breadcrumb properties with urls
        // TODO: also consider arbitrary prop values that start with (https?)?://
        var urlProps = ['to', 'from', 'url'],
            urlProp,
            crumb,
            data;

        for (var i = 0; i < breadcrumbs.values.length; ++i) {
            crumb = breadcrumbs.values[i];
            if (!crumb.hasOwnProperty('data') || !isObject(crumb.data) || objectFrozen(crumb.data))
                continue;

            data = objectMerge({}, crumb.data);
            for (var j = 0; j < urlProps.length; ++j) {
                urlProp = urlProps[j];
                if (data.hasOwnProperty(urlProp)) {
                    data[urlProp] = truncate(data[urlProp], this._globalOptions.maxUrlLength);
                }
            }
            breadcrumbs.values[i].data = data;
        }
    },

    _getHttpData: function() {
        if (!this._hasNavigator && !this._hasDocument) return;
        var httpData = {};

        if (this._hasNavigator && _navigator.userAgent) {
            httpData.headers = {
              'User-Agent': navigator.userAgent
            };
        }

        if (this._hasDocument) {
            if (_document.location && _document.location.href) {
                httpData.url = _document.location.href;
            }
            if (_document.referrer) {
                if (!httpData.headers) httpData.headers = {};
                httpData.headers.Referer = _document.referrer;
            }
        }

        return httpData;
    },

    _resetBackoff: function() {
        this._backoffDuration = 0;
        this._backoffStart = null;
    },

    _shouldBackoff: function() {
        return this._backoffDuration && now() - this._backoffStart < this._backoffDuration;
    },

    /**
     * Returns true if the in-process data payload matches the signature
     * of the previously-sent data
     *
     * NOTE: This has to be done at this level because TraceKit can generate
     *       data from window.onerror WITHOUT an exception object (IE8, IE9,
     *       other old browsers). This can take the form of an "exception"
     *       data object with a single frame (derived from the onerror args).
     */
    _isRepeatData: function (current) {
        var last = this._lastData;

        if (!last ||
            current.message !== last.message || // defined for captureMessage
            current.culprit !== last.culprit)   // defined for captureException/onerror
            return false;

        // Stacktrace interface (i.e. from captureMessage)
        if (current.stacktrace || last.stacktrace) {
            return isSameStacktrace(current.stacktrace, last.stacktrace);
        }
        // Exception interface (i.e. from captureException/onerror)
        else if (current.exception || last.exception) {
            return isSameException(current.exception, last.exception);
        }

        return true;
    },

    _setBackoffState: function(request) {
        // If we are already in a backoff state, don't change anything
        if (this._shouldBackoff()) {
            return;
        }

        var status = request.status;

        // 400 - project_id doesn't exist or some other fatal
        // 401 - invalid/revoked dsn
        // 429 - too many requests
        if (!(status === 400 || status === 401 || status === 429))
            return;

        var retry;
        try {
            // If Retry-After is not in Access-Control-Expose-Headers, most
            // browsers will throw an exception trying to access it
            retry = request.getResponseHeader('Retry-After');
            retry = parseInt(retry, 10) * 1000; // Retry-After is returned in seconds
        } catch (e) {
            /* eslint no-empty:0 */
        }


        this._backoffDuration = retry
            // If Sentry server returned a Retry-After value, use it
            ? retry
            // Otherwise, double the last backoff duration (starts at 1 sec)
            : this._backoffDuration * 2 || 1000;

        this._backoffStart = now();
    },

    _send: function(data) {
        var globalOptions = this._globalOptions;

        var baseData = {
            project: this._globalProject,
            logger: globalOptions.logger,
            platform: 'javascript'
        }, httpData = this._getHttpData();

        if (httpData) {
            baseData.request = httpData;
        }

        // HACK: delete `trimHeadFrames` to prevent from appearing in outbound payload
        if (data.trimHeadFrames) delete data.trimHeadFrames;

        data = objectMerge(baseData, data);

        // Merge in the tags and extra separately since objectMerge doesn't handle a deep merge
        data.tags = objectMerge(objectMerge({}, this._globalContext.tags), data.tags);
        data.extra = objectMerge(objectMerge({}, this._globalContext.extra), data.extra);

        // Send along our own collected metadata with extra
        data.extra['session:duration'] = now() - this._startTime;

        if (this._breadcrumbs && this._breadcrumbs.length > 0) {
            // intentionally make shallow copy so that additions
            // to breadcrumbs aren't accidentally sent in this request
            data.breadcrumbs = {
                values: [].slice.call(this._breadcrumbs, 0)
            };
        }

        // If there are no tags/extra, strip the key from the payload alltogther.
        if (isEmptyObject(data.tags)) delete data.tags;

        if (this._globalContext.user) {
            // sentry.interfaces.User
            data.user = this._globalContext.user;
        }

        // Include the environment if it's defined in globalOptions
        if (globalOptions.environment) data.environment = globalOptions.environment;

        // Include the release if it's defined in globalOptions
        if (globalOptions.release) data.release = globalOptions.release;

        // Include server_name if it's defined in globalOptions
        if (globalOptions.serverName) data.server_name = globalOptions.serverName;

        if (isFunction(globalOptions.dataCallback)) {
            data = globalOptions.dataCallback(data) || data;
        }

        // Why??????????
        if (!data || isEmptyObject(data)) {
            return;
        }

        // Check if the request should be filtered or not
        if (isFunction(globalOptions.shouldSendCallback) && !globalOptions.shouldSendCallback(data)) {
            return;
        }

        // Backoff state: Sentry server previously responded w/ an error (e.g. 429 - too many requests),
        // so drop requests until "cool-off" period has elapsed.
        if (this._shouldBackoff()) {
            this._logDebug('warn', 'Raven dropped error due to backoff: ', data);
            return;
        }

        if (typeof globalOptions.sampleRate === 'number') {
            if (Math.random() < globalOptions.sampleRate) {
                this._sendProcessedPayload(data);
            }
        } else {
            this._sendProcessedPayload(data);
        }
    },

    _getUuid: function () {
      return uuid4();
    },

    _sendProcessedPayload: function(data, callback) {
        var self = this;
        var globalOptions = this._globalOptions;

        if (!this.isSetup()) return;

        // Send along an event_id if not explicitly passed.
        // This event_id can be used to reference the error within Sentry itself.
        // Set lastEventId after we know the error should actually be sent
        this._lastEventId = data.event_id || (data.event_id = this._getUuid());

        // Try and clean up the packet before sending by truncating long values
        data = this._trimPacket(data);

        // ideally duplicate error testing should occur *before* dataCallback/shouldSendCallback,
        // but this would require copying an un-truncated copy of the data packet, which can be
        // arbitrarily deep (extra_data) -- could be worthwhile? will revisit
        if (!this._globalOptions.allowDuplicates && this._isRepeatData(data)) {
            this._logDebug('warn', 'Raven dropped repeat event: ', data);
            return;
        }

        // Store outbound payload after trim
        this._lastData = data;

        this._logDebug('debug', 'Raven about to send:', data);

        var auth = {
            sentry_version: '7',
            sentry_client: 'raven-js/' + this.VERSION,
            sentry_key: this._globalKey
        };
        if (this._globalSecret) {
            auth.sentry_secret = this._globalSecret;
        }

        var exception = data.exception && data.exception.values[0];
        this.captureBreadcrumb({
            category: 'sentry',
            message: exception
                ? (exception.type ? exception.type + ': ' : '') + exception.value
                : data.message,
            event_id: data.event_id,
            level: data.level || 'error' // presume error unless specified
        });

        var url = this._globalEndpoint;
        (globalOptions.transport || this._makeRequest).call(this, {
            url: url,
            auth: auth,
            data: data,
            options: globalOptions,
            onSuccess: function success() {
                self._resetBackoff();

                self._triggerEvent('success', {
                    data: data,
                    src: url
                });
                callback && callback();
            },
            onError: function failure(error) {
                self._logDebug('error', 'Raven transport failed to send: ', error);

                if (error.request) {
                    self._setBackoffState(error.request);
                }

                self._triggerEvent('failure', {
                    data: data,
                    src: url
                });
                error = error || new Error('Raven send failed (no additional details provided)');
                callback && callback(error);
            }
        });
    },

    _makeRequest: function(opts) {
        var request = new XMLHttpRequest();

        // if browser doesn't support CORS (e.g. IE7), we are out of luck
        var hasCORS =
            'withCredentials' in request ||
            typeof XDomainRequest !== 'undefined';

        if (!hasCORS) return;

        var url = opts.url;

        if ('withCredentials' in request) {
            request.onreadystatechange = function () {
                if (request.readyState !== 4) {
                    return;
                } else if (request.status === 200) {
                    opts.onSuccess && opts.onSuccess();
                } else if (opts.onError) {
                    var err = new Error('Sentry error code: ' + request.status);
                    err.request = request;
                    opts.onError(err);
                }
            };
        } else {
            request = new XDomainRequest();
            // xdomainrequest cannot go http -> https (or vice versa),
            // so always use protocol relative
            url = url.replace(/^https?:/, '');

            // onreadystatechange not supported by XDomainRequest
            if (opts.onSuccess) {
                request.onload = opts.onSuccess;
            }
            if (opts.onError) {
                request.onerror = function () {
                    var err = new Error('Sentry error code: XDomainRequest');
                    err.request = request;
                    opts.onError(err);
                }
            }
        }

        // NOTE: auth is intentionally sent as part of query string (NOT as custom
        //       HTTP header) so as to avoid preflight CORS requests
        request.open('POST', url + '?' + urlencode(opts.auth));
        request.send(stringify(opts.data));
    },

    _logDebug: function(level) {
        if (this._originalConsoleMethods[level] && this.debug) {
            // In IE<10 console methods do not have their own 'apply' method
            Function.prototype.apply.call(
                this._originalConsoleMethods[level],
                this._originalConsole,
                [].slice.call(arguments, 1)
            );
        }
    },

    _mergeContext: function(key, context) {
        if (isUndefined(context)) {
            delete this._globalContext[key];
        } else {
            this._globalContext[key] = objectMerge(this._globalContext[key] || {}, context);
        }
    }
};

/*------------------------------------------------
 * utils
 *
 * conditionally exported for test via Raven.utils
 =================================================
 */
var objectPrototype = Object.prototype;

function isUndefined(what) {
    return what === void 0;
}

function isFunction(what) {
    return typeof what === 'function';
}

function isString(what) {
    return objectPrototype.toString.call(what) === '[object String]';
}


function isEmptyObject(what) {
    for (var _ in what) return false;  // eslint-disable-line guard-for-in, no-unused-vars
    return true;
}

function each(obj, callback) {
    var i, j;

    if (isUndefined(obj.length)) {
        for (i in obj) {
            if (hasKey(obj, i)) {
                callback.call(null, i, obj[i]);
            }
        }
    } else {
        j = obj.length;
        if (j) {
            for (i = 0; i < j; i++) {
                callback.call(null, i, obj[i]);
            }
        }
    }
}

function objectMerge(obj1, obj2) {
    if (!obj2) {
        return obj1;
    }
    each(obj2, function(key, value){
        obj1[key] = value;
    });
    return obj1;
}

/**
 * This function is only used for react-native.
 * react-native freezes object that have already been sent over the
 * js bridge. We need this function in order to check if the object is frozen.
 * So it's ok that objectFrozen returns false if Object.isFrozen is not
 * supported because it's not relevant for other "platforms". See related issue:
 * https://github.com/getsentry/react-native-sentry/issues/57
 */
function objectFrozen(obj) {
    if (!Object.isFrozen) {
        return false;
    }
    return Object.isFrozen(obj);
}

function truncate(str, max) {
    return !max || str.length <= max ? str : str.substr(0, max) + '\u2026';
}

/**
 * hasKey, a better form of hasOwnProperty
 * Example: hasKey(MainHostObject, property) === true/false
 *
 * @param {Object} host object to check property
 * @param {string} key to check
 */
function hasKey(object, key) {
    return objectPrototype.hasOwnProperty.call(object, key);
}

function joinRegExp(patterns) {
    // Combine an array of regular expressions and strings into one large regexp
    // Be mad.
    var sources = [],
        i = 0, len = patterns.length,
        pattern;

    for (; i < len; i++) {
        pattern = patterns[i];
        if (isString(pattern)) {
            // If it's a string, we need to escape it
            // Taken from: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions
            sources.push(pattern.replace(/([.*+?^=!:${}()|\[\]\/\\])/g, '\\$1'));
        } else if (pattern && pattern.source) {
            // If it's a regexp already, we want to extract the source
            sources.push(pattern.source);
        }
        // Intentionally skip other cases
    }
    return new RegExp(sources.join('|'), 'i');
}

function urlencode(o) {
    var pairs = [];
    each(o, function(key, value) {
        pairs.push(encodeURIComponent(key) + '=' + encodeURIComponent(value));
    });
    return pairs.join('&');
}

// borrowed from https://tools.ietf.org/html/rfc3986#appendix-B
// intentionally using regex and not <a/> href parsing trick because React Native and other
// environments where DOM might not be available
function parseUrl(url) {
    var match = url.match(/^(([^:\/?#]+):)?(\/\/([^\/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?$/);
    if (!match) return {};

    // coerce to undefined values to empty string so we don't get 'undefined'
    var query = match[6] || '';
    var fragment = match[8] || '';
    return {
        protocol: match[2],
        host: match[4],
        path: match[5],
        relative: match[5] + query + fragment // everything minus origin
    };
}
function uuid4() {
    var crypto = _window.crypto || _window.msCrypto;

    if (!isUndefined(crypto) && crypto.getRandomValues) {
        // Use window.crypto API if available
        var arr = new Uint16Array(8);
        crypto.getRandomValues(arr);

        // set 4 in byte 7
        arr[3] = arr[3] & 0xFFF | 0x4000;
        // set 2 most significant bits of byte 9 to '10'
        arr[4] = arr[4] & 0x3FFF | 0x8000;

        var pad = function(num) {
            var v = num.toString(16);
            while (v.length < 4) {
                v = '0' + v;
            }
            return v;
        };

        return pad(arr[0]) + pad(arr[1]) + pad(arr[2]) + pad(arr[3]) + pad(arr[4]) +
        pad(arr[5]) + pad(arr[6]) + pad(arr[7]);
    } else {
        // http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/2117523#2117523
        return 'xxxxxxxxxxxx4xxxyxxxxxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
            var r = Math.random()*16|0,
                v = c === 'x' ? r : r&0x3|0x8;
            return v.toString(16);
        });
    }
}

/**
 * Given a child DOM element, returns a query-selector statement describing that
 * and its ancestors
 * e.g. [HTMLElement] => body > div > input#foo.btn[name=baz]
 * @param elem
 * @returns {string}
 */
function htmlTreeAsString(elem) {
    /* eslint no-extra-parens:0*/
    var MAX_TRAVERSE_HEIGHT = 5,
        MAX_OUTPUT_LEN = 80,
        out = [],
        height = 0,
        len = 0,
        separator = ' > ',
        sepLength = separator.length,
        nextStr;

    while (elem && height++ < MAX_TRAVERSE_HEIGHT) {

        nextStr = htmlElementAsString(elem);
        // bail out if
        // - nextStr is the 'html' element
        // - the length of the string that would be created exceeds MAX_OUTPUT_LEN
        //   (ignore this limit if we are on the first iteration)
        if (nextStr === 'html' || height > 1 && len + (out.length * sepLength) + nextStr.length >= MAX_OUTPUT_LEN) {
            break;
        }

        out.push(nextStr);

        len += nextStr.length;
        elem = elem.parentNode;
    }

    return out.reverse().join(separator);
}

/**
 * Returns a simple, query-selector representation of a DOM element
 * e.g. [HTMLElement] => input#foo.btn[name=baz]
 * @param HTMLElement
 * @returns {string}
 */
function htmlElementAsString(elem) {
    var out = [],
        className,
        classes,
        key,
        attr,
        i;

    if (!elem || !elem.tagName) {
        return '';
    }

    out.push(elem.tagName.toLowerCase());
    if (elem.id) {
        out.push('#' + elem.id);
    }

    className = elem.className;
    if (className && isString(className)) {
        classes = className.split(/\s+/);
        for (i = 0; i < classes.length; i++) {
            out.push('.' + classes[i]);
        }
    }
    var attrWhitelist = ['type', 'name', 'title', 'alt'];
    for (i = 0; i < attrWhitelist.length; i++) {
        key = attrWhitelist[i];
        attr = elem.getAttribute(key);
        if (attr) {
            out.push('[' + key + '="' + attr + '"]');
        }
    }
    return out.join('');
}

/**
 * Returns true if either a OR b is truthy, but not both
 */
function isOnlyOneTruthy(a, b) {
    return !!(!!a ^ !!b);
}

/**
 * Returns true if the two input exception interfaces have the same content
 */
function isSameException(ex1, ex2) {
    if (isOnlyOneTruthy(ex1, ex2))
        return false;

    ex1 = ex1.values[0];
    ex2 = ex2.values[0];

    if (ex1.type !== ex2.type ||
        ex1.value !== ex2.value)
        return false;

    return isSameStacktrace(ex1.stacktrace, ex2.stacktrace);
}

/**
 * Returns true if the two input stack trace interfaces have the same content
 */
function isSameStacktrace(stack1, stack2) {
    if (isOnlyOneTruthy(stack1, stack2))
        return false;

    var frames1 = stack1.frames;
    var frames2 = stack2.frames;

    // Exit early if frame count differs
    if (frames1.length !== frames2.length)
        return false;

    // Iterate through every frame; bail out if anything differs
    var a, b;
    for (var i = 0; i < frames1.length; i++) {
        a = frames1[i];
        b = frames2[i];
        if (a.filename !== b.filename ||
            a.lineno !== b.lineno ||
            a.colno !== b.colno ||
            a['function'] !== b['function'])
            return false;
    }
    return true;
}

/**
 * Polyfill a method
 * @param obj object e.g. `document`
 * @param name method name present on object e.g. `addEventListener`
 * @param replacement replacement function
 * @param track {optional} record instrumentation to an array
 */
function fill(obj, name, replacement, track) {
    var orig = obj[name];
    obj[name] = replacement(orig);
    if (track) {
        track.push([obj, name, orig]);
    }
}

if (typeof __DEV__ !== 'undefined' && __DEV__) {
    Raven.utils = {
        isUndefined: isUndefined,
        isFunction: isFunction,
        isString: isString,
        isObject: isObject,
        isEmptyObject: isEmptyObject,
        isError: isError,
        each: each,
        objectMerge: objectMerge,
        truncate: truncate,
        hasKey: hasKey,
        joinRegExp: joinRegExp,
        urlencode: urlencode,
        uuid4: uuid4,
        htmlTreeAsString: htmlTreeAsString,
        htmlElementAsString: htmlElementAsString,
        parseUrl: parseUrl,
        fill: fill
    };
};

// Deprecations
Raven.prototype.setUser = Raven.prototype.setUserContext;
Raven.prototype.setReleaseContext = Raven.prototype.setRelease;

module.exports = Raven;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../vendor/TraceKit/tracekit":192,"../vendor/json-stringify-safe/stringify":193,"./configError":187,"./console":188,"./utils":191}],190:[function(require,module,exports){
(function (global){
/**
 * Enforces a single instance of the Raven client, and the
 * main entry point for Raven. If you are a consumer of the
 * Raven library, you SHOULD load this file (vs raven.js).
 **/

'use strict';

var RavenConstructor = require('./raven');

// This is to be defensive in environments where window does not exist (see https://github.com/getsentry/raven-js/pull/785)
var _window = typeof window !== 'undefined' ? window
            : typeof global !== 'undefined' ? global
            : typeof self !== 'undefined' ? self
            : {};
var _Raven = _window.Raven;

var Raven = new RavenConstructor();

/*
 * Allow multiple versions of Raven to be installed.
 * Strip Raven from the global context and returns the instance.
 *
 * @return {Raven}
 */
Raven.noConflict = function () {
  _window.Raven = _Raven;
  return Raven;
};

Raven.afterLoad();

module.exports = Raven;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./raven":189}],191:[function(require,module,exports){
'use strict';

function isObject(what) {
    return typeof what === 'object' && what !== null;
}

// Yanked from https://git.io/vS8DV re-used under CC0
// with some tiny modifications
function isError(value) {
  switch ({}.toString.call(value)) {
    case '[object Error]': return true;
    case '[object Exception]': return true;
    case '[object DOMException]': return true;
    default: return value instanceof Error;
  }
}

function wrappedCallback(callback) {
    function dataCallback(data, original) {
      var normalizedData = callback(data) || data;
      if (original) {
          return original(normalizedData) || normalizedData;
      }
      return normalizedData;
    }

    return dataCallback;
}

module.exports = {
    isObject: isObject,
    isError: isError,
    wrappedCallback: wrappedCallback
};

},{}],192:[function(require,module,exports){
(function (global){
'use strict';

var utils = require('../../src/utils');

/*
 TraceKit - Cross brower stack traces

 This was originally forked from github.com/occ/TraceKit, but has since been
 largely re-written and is now maintained as part of raven-js.  Tests for
 this are in test/vendor.

 MIT license
*/

var TraceKit = {
    collectWindowErrors: true,
    debug: false
};

// This is to be defensive in environments where window does not exist (see https://github.com/getsentry/raven-js/pull/785)
var _window = typeof window !== 'undefined' ? window
            : typeof global !== 'undefined' ? global
            : typeof self !== 'undefined' ? self
            : {};

// global reference to slice
var _slice = [].slice;
var UNKNOWN_FUNCTION = '?';

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error#Error_types
var ERROR_TYPES_RE = /^(?:[Uu]ncaught (?:exception: )?)?(?:((?:Eval|Internal|Range|Reference|Syntax|Type|URI|)Error): )?(.*)$/;

function getLocationHref() {
    if (typeof document === 'undefined' || typeof document.location === 'undefined')
        return '';

    return document.location.href;
}


/**
 * TraceKit.report: cross-browser processing of unhandled exceptions
 *
 * Syntax:
 *   TraceKit.report.subscribe(function(stackInfo) { ... })
 *   TraceKit.report.unsubscribe(function(stackInfo) { ... })
 *   TraceKit.report(exception)
 *   try { ...code... } catch(ex) { TraceKit.report(ex); }
 *
 * Supports:
 *   - Firefox: full stack trace with line numbers, plus column number
 *              on top frame; column number is not guaranteed
 *   - Opera:   full stack trace with line and column numbers
 *   - Chrome:  full stack trace with line and column numbers
 *   - Safari:  line and column number for the top frame only; some frames
 *              may be missing, and column number is not guaranteed
 *   - IE:      line and column number for the top frame only; some frames
 *              may be missing, and column number is not guaranteed
 *
 * In theory, TraceKit should work on all of the following versions:
 *   - IE5.5+ (only 8.0 tested)
 *   - Firefox 0.9+ (only 3.5+ tested)
 *   - Opera 7+ (only 10.50 tested; versions 9 and earlier may require
 *     Exceptions Have Stacktrace to be enabled in opera:config)
 *   - Safari 3+ (only 4+ tested)
 *   - Chrome 1+ (only 5+ tested)
 *   - Konqueror 3.5+ (untested)
 *
 * Requires TraceKit.computeStackTrace.
 *
 * Tries to catch all unhandled exceptions and report them to the
 * subscribed handlers. Please note that TraceKit.report will rethrow the
 * exception. This is REQUIRED in order to get a useful stack trace in IE.
 * If the exception does not reach the top of the browser, you will only
 * get a stack trace from the point where TraceKit.report was called.
 *
 * Handlers receive a stackInfo object as described in the
 * TraceKit.computeStackTrace docs.
 */
TraceKit.report = (function reportModuleWrapper() {
    var handlers = [],
        lastArgs = null,
        lastException = null,
        lastExceptionStack = null;

    /**
     * Add a crash handler.
     * @param {Function} handler
     */
    function subscribe(handler) {
        installGlobalHandler();
        handlers.push(handler);
    }

    /**
     * Remove a crash handler.
     * @param {Function} handler
     */
    function unsubscribe(handler) {
        for (var i = handlers.length - 1; i >= 0; --i) {
            if (handlers[i] === handler) {
                handlers.splice(i, 1);
            }
        }
    }

    /**
     * Remove all crash handlers.
     */
    function unsubscribeAll() {
        uninstallGlobalHandler();
        handlers = [];
    }

    /**
     * Dispatch stack information to all handlers.
     * @param {Object.<string, *>} stack
     */
    function notifyHandlers(stack, isWindowError) {
        var exception = null;
        if (isWindowError && !TraceKit.collectWindowErrors) {
          return;
        }
        for (var i in handlers) {
            if (handlers.hasOwnProperty(i)) {
                try {
                    handlers[i].apply(null, [stack].concat(_slice.call(arguments, 2)));
                } catch (inner) {
                    exception = inner;
                }
            }
        }

        if (exception) {
            throw exception;
        }
    }

    var _oldOnerrorHandler, _onErrorHandlerInstalled;

    /**
     * Ensures all global unhandled exceptions are recorded.
     * Supported by Gecko and IE.
     * @param {string} message Error message.
     * @param {string} url URL of script that generated the exception.
     * @param {(number|string)} lineNo The line number at which the error
     * occurred.
     * @param {?(number|string)} colNo The column number at which the error
     * occurred.
     * @param {?Error} ex The actual Error object.
     */
    function traceKitWindowOnError(message, url, lineNo, colNo, ex) {
        var stack = null;

        if (lastExceptionStack) {
            TraceKit.computeStackTrace.augmentStackTraceWithInitialElement(lastExceptionStack, url, lineNo, message);
            processLastException();
        } else if (ex && utils.isError(ex)) {
            // non-string `ex` arg; attempt to extract stack trace

            // New chrome and blink send along a real error object
            // Let's just report that like a normal error.
            // See: https://mikewest.org/2013/08/debugging-runtime-errors-with-window-onerror
            stack = TraceKit.computeStackTrace(ex);
            notifyHandlers(stack, true);
        } else {
            var location = {
                'url': url,
                'line': lineNo,
                'column': colNo
            };

            var name = undefined;
            var msg = message; // must be new var or will modify original `arguments`
            var groups;
            if ({}.toString.call(message) === '[object String]') {
                var groups = message.match(ERROR_TYPES_RE);
                if (groups) {
                    name = groups[1];
                    msg = groups[2];
                }
            }

            location.func = UNKNOWN_FUNCTION;

            stack = {
                'name': name,
                'message': msg,
                'url': getLocationHref(),
                'stack': [location]
            };
            notifyHandlers(stack, true);
        }

        if (_oldOnerrorHandler) {
            return _oldOnerrorHandler.apply(this, arguments);
        }

        return false;
    }

    function installGlobalHandler ()
    {
        if (_onErrorHandlerInstalled) {
            return;
        }
        _oldOnerrorHandler = _window.onerror;
        _window.onerror = traceKitWindowOnError;
        _onErrorHandlerInstalled = true;
    }

    function uninstallGlobalHandler ()
    {
        if (!_onErrorHandlerInstalled) {
            return;
        }
        _window.onerror = _oldOnerrorHandler;
        _onErrorHandlerInstalled = false;
        _oldOnerrorHandler = undefined;
    }

    function processLastException() {
        var _lastExceptionStack = lastExceptionStack,
            _lastArgs = lastArgs;
        lastArgs = null;
        lastExceptionStack = null;
        lastException = null;
        notifyHandlers.apply(null, [_lastExceptionStack, false].concat(_lastArgs));
    }

    /**
     * Reports an unhandled Error to TraceKit.
     * @param {Error} ex
     * @param {?boolean} rethrow If false, do not re-throw the exception.
     * Only used for window.onerror to not cause an infinite loop of
     * rethrowing.
     */
    function report(ex, rethrow) {
        var args = _slice.call(arguments, 1);
        if (lastExceptionStack) {
            if (lastException === ex) {
                return; // already caught by an inner catch block, ignore
            } else {
              processLastException();
            }
        }

        var stack = TraceKit.computeStackTrace(ex);
        lastExceptionStack = stack;
        lastException = ex;
        lastArgs = args;

        // If the stack trace is incomplete, wait for 2 seconds for
        // slow slow IE to see if onerror occurs or not before reporting
        // this exception; otherwise, we will end up with an incomplete
        // stack trace
        setTimeout(function () {
            if (lastException === ex) {
                processLastException();
            }
        }, (stack.incomplete ? 2000 : 0));

        if (rethrow !== false) {
            throw ex; // re-throw to propagate to the top level (and cause window.onerror)
        }
    }

    report.subscribe = subscribe;
    report.unsubscribe = unsubscribe;
    report.uninstall = unsubscribeAll;
    return report;
}());

/**
 * TraceKit.computeStackTrace: cross-browser stack traces in JavaScript
 *
 * Syntax:
 *   s = TraceKit.computeStackTrace(exception) // consider using TraceKit.report instead (see below)
 * Returns:
 *   s.name              - exception name
 *   s.message           - exception message
 *   s.stack[i].url      - JavaScript or HTML file URL
 *   s.stack[i].func     - function name, or empty for anonymous functions (if guessing did not work)
 *   s.stack[i].args     - arguments passed to the function, if known
 *   s.stack[i].line     - line number, if known
 *   s.stack[i].column   - column number, if known
 *
 * Supports:
 *   - Firefox:  full stack trace with line numbers and unreliable column
 *               number on top frame
 *   - Opera 10: full stack trace with line and column numbers
 *   - Opera 9-: full stack trace with line numbers
 *   - Chrome:   full stack trace with line and column numbers
 *   - Safari:   line and column number for the topmost stacktrace element
 *               only
 *   - IE:       no line numbers whatsoever
 *
 * Tries to guess names of anonymous functions by looking for assignments
 * in the source code. In IE and Safari, we have to guess source file names
 * by searching for function bodies inside all page scripts. This will not
 * work for scripts that are loaded cross-domain.
 * Here be dragons: some function names may be guessed incorrectly, and
 * duplicate functions may be mismatched.
 *
 * TraceKit.computeStackTrace should only be used for tracing purposes.
 * Logging of unhandled exceptions should be done with TraceKit.report,
 * which builds on top of TraceKit.computeStackTrace and provides better
 * IE support by utilizing the window.onerror event to retrieve information
 * about the top of the stack.
 *
 * Note: In IE and Safari, no stack trace is recorded on the Error object,
 * so computeStackTrace instead walks its *own* chain of callers.
 * This means that:
 *  * in Safari, some methods may be missing from the stack trace;
 *  * in IE, the topmost function in the stack trace will always be the
 *    caller of computeStackTrace.
 *
 * This is okay for tracing (because you are likely to be calling
 * computeStackTrace from the function you want to be the topmost element
 * of the stack trace anyway), but not okay for logging unhandled
 * exceptions (because your catch block will likely be far away from the
 * inner function that actually caused the exception).
 *
 */
TraceKit.computeStackTrace = (function computeStackTraceWrapper() {
    // Contents of Exception in various browsers.
    //
    // SAFARI:
    // ex.message = Can't find variable: qq
    // ex.line = 59
    // ex.sourceId = 580238192
    // ex.sourceURL = http://...
    // ex.expressionBeginOffset = 96
    // ex.expressionCaretOffset = 98
    // ex.expressionEndOffset = 98
    // ex.name = ReferenceError
    //
    // FIREFOX:
    // ex.message = qq is not defined
    // ex.fileName = http://...
    // ex.lineNumber = 59
    // ex.columnNumber = 69
    // ex.stack = ...stack trace... (see the example below)
    // ex.name = ReferenceError
    //
    // CHROME:
    // ex.message = qq is not defined
    // ex.name = ReferenceError
    // ex.type = not_defined
    // ex.arguments = ['aa']
    // ex.stack = ...stack trace...
    //
    // INTERNET EXPLORER:
    // ex.message = ...
    // ex.name = ReferenceError
    //
    // OPERA:
    // ex.message = ...message... (see the example below)
    // ex.name = ReferenceError
    // ex.opera#sourceloc = 11  (pretty much useless, duplicates the info in ex.message)
    // ex.stacktrace = n/a; see 'opera:config#UserPrefs|Exceptions Have Stacktrace'

    /**
     * Computes stack trace information from the stack property.
     * Chrome and Gecko use this property.
     * @param {Error} ex
     * @return {?Object.<string, *>} Stack trace information.
     */
    function computeStackTraceFromStackProp(ex) {
        if (typeof ex.stack === 'undefined' || !ex.stack) return;

        var chrome = /^\s*at (.*?) ?\(((?:file|https?|blob|chrome-extension|native|eval|webpack|<anonymous>|\/).*?)(?::(\d+))?(?::(\d+))?\)?\s*$/i,
            gecko = /^\s*(.*?)(?:\((.*?)\))?(?:^|@)((?:file|https?|blob|chrome|webpack|resource|\[native).*?|[^@]*bundle)(?::(\d+))?(?::(\d+))?\s*$/i,
            winjs = /^\s*at (?:((?:\[object object\])?.+) )?\(?((?:file|ms-appx|https?|webpack|blob):.*?):(\d+)(?::(\d+))?\)?\s*$/i,

            // Used to additionally parse URL/line/column from eval frames
            geckoEval = /(\S+) line (\d+)(?: > eval line \d+)* > eval/i,
            chromeEval = /\((\S*)(?::(\d+))(?::(\d+))\)/,

            lines = ex.stack.split('\n'),
            stack = [],
            submatch,
            parts,
            element,
            reference = /^(.*) is undefined$/.exec(ex.message);

        for (var i = 0, j = lines.length; i < j; ++i) {
            if ((parts = chrome.exec(lines[i]))) {
                var isNative = parts[2] && parts[2].indexOf('native') === 0; // start of line
                var isEval = parts[2] && parts[2].indexOf('eval') === 0; // start of line
                if (isEval && (submatch = chromeEval.exec(parts[2]))) {
                    // throw out eval line/column and use top-most line/column number
                    parts[2] = submatch[1]; // url
                    parts[3] = submatch[2]; // line
                    parts[4] = submatch[3]; // column
                }
                element = {
                    'url': !isNative ? parts[2] : null,
                    'func': parts[1] || UNKNOWN_FUNCTION,
                    'args': isNative ? [parts[2]] : [],
                    'line': parts[3] ? +parts[3] : null,
                    'column': parts[4] ? +parts[4] : null
                };
            } else if ( parts = winjs.exec(lines[i]) ) {
                element = {
                    'url': parts[2],
                    'func': parts[1] || UNKNOWN_FUNCTION,
                    'args': [],
                    'line': +parts[3],
                    'column': parts[4] ? +parts[4] : null
                };
            } else if ((parts = gecko.exec(lines[i]))) {
                var isEval = parts[3] && parts[3].indexOf(' > eval') > -1;
                if (isEval && (submatch = geckoEval.exec(parts[3]))) {
                    // throw out eval line/column and use top-most line number
                    parts[3] = submatch[1];
                    parts[4] = submatch[2];
                    parts[5] = null; // no column when eval
                } else if (i === 0 && !parts[5] && typeof ex.columnNumber !== 'undefined') {
                    // FireFox uses this awesome columnNumber property for its top frame
                    // Also note, Firefox's column number is 0-based and everything else expects 1-based,
                    // so adding 1
                    // NOTE: this hack doesn't work if top-most frame is eval
                    stack[0].column = ex.columnNumber + 1;
                }
                element = {
                    'url': parts[3],
                    'func': parts[1] || UNKNOWN_FUNCTION,
                    'args': parts[2] ? parts[2].split(',') : [],
                    'line': parts[4] ? +parts[4] : null,
                    'column': parts[5] ? +parts[5] : null
                };
            } else {
                continue;
            }

            if (!element.func && element.line) {
                element.func = UNKNOWN_FUNCTION;
            }

            stack.push(element);
        }

        if (!stack.length) {
            return null;
        }

        return {
            'name': ex.name,
            'message': ex.message,
            'url': getLocationHref(),
            'stack': stack
        };
    }

    /**
     * Adds information about the first frame to incomplete stack traces.
     * Safari and IE require this to get complete data on the first frame.
     * @param {Object.<string, *>} stackInfo Stack trace information from
     * one of the compute* methods.
     * @param {string} url The URL of the script that caused an error.
     * @param {(number|string)} lineNo The line number of the script that
     * caused an error.
     * @param {string=} message The error generated by the browser, which
     * hopefully contains the name of the object that caused the error.
     * @return {boolean} Whether or not the stack information was
     * augmented.
     */
    function augmentStackTraceWithInitialElement(stackInfo, url, lineNo, message) {
        var initial = {
            'url': url,
            'line': lineNo
        };

        if (initial.url && initial.line) {
            stackInfo.incomplete = false;

            if (!initial.func) {
                initial.func = UNKNOWN_FUNCTION;
            }

            if (stackInfo.stack.length > 0) {
                if (stackInfo.stack[0].url === initial.url) {
                    if (stackInfo.stack[0].line === initial.line) {
                        return false; // already in stack trace
                    } else if (!stackInfo.stack[0].line && stackInfo.stack[0].func === initial.func) {
                        stackInfo.stack[0].line = initial.line;
                        return false;
                    }
                }
            }

            stackInfo.stack.unshift(initial);
            stackInfo.partial = true;
            return true;
        } else {
            stackInfo.incomplete = true;
        }

        return false;
    }

    /**
     * Computes stack trace information by walking the arguments.caller
     * chain at the time the exception occurred. This will cause earlier
     * frames to be missed but is the only way to get any stack trace in
     * Safari and IE. The top frame is restored by
     * {@link augmentStackTraceWithInitialElement}.
     * @param {Error} ex
     * @return {?Object.<string, *>} Stack trace information.
     */
    function computeStackTraceByWalkingCallerChain(ex, depth) {
        var functionName = /function\s+([_$a-zA-Z\xA0-\uFFFF][_$a-zA-Z0-9\xA0-\uFFFF]*)?\s*\(/i,
            stack = [],
            funcs = {},
            recursion = false,
            parts,
            item,
            source;

        for (var curr = computeStackTraceByWalkingCallerChain.caller; curr && !recursion; curr = curr.caller) {
            if (curr === computeStackTrace || curr === TraceKit.report) {
                // console.log('skipping internal function');
                continue;
            }

            item = {
                'url': null,
                'func': UNKNOWN_FUNCTION,
                'line': null,
                'column': null
            };

            if (curr.name) {
                item.func = curr.name;
            } else if ((parts = functionName.exec(curr.toString()))) {
                item.func = parts[1];
            }

            if (typeof item.func === 'undefined') {
              try {
                item.func = parts.input.substring(0, parts.input.indexOf('{'));
              } catch (e) { }
            }

            if (funcs['' + curr]) {
                recursion = true;
            }else{
                funcs['' + curr] = true;
            }

            stack.push(item);
        }

        if (depth) {
            // console.log('depth is ' + depth);
            // console.log('stack is ' + stack.length);
            stack.splice(0, depth);
        }

        var result = {
            'name': ex.name,
            'message': ex.message,
            'url': getLocationHref(),
            'stack': stack
        };
        augmentStackTraceWithInitialElement(result, ex.sourceURL || ex.fileName, ex.line || ex.lineNumber, ex.message || ex.description);
        return result;
    }

    /**
     * Computes a stack trace for an exception.
     * @param {Error} ex
     * @param {(string|number)=} depth
     */
    function computeStackTrace(ex, depth) {
        var stack = null;
        depth = (depth == null ? 0 : +depth);

        try {
            stack = computeStackTraceFromStackProp(ex);
            if (stack) {
                return stack;
            }
        } catch (e) {
            if (TraceKit.debug) {
                throw e;
            }
        }

        try {
            stack = computeStackTraceByWalkingCallerChain(ex, depth + 1);
            if (stack) {
                return stack;
            }
        } catch (e) {
            if (TraceKit.debug) {
                throw e;
            }
        }
        return {
            'name': ex.name,
            'message': ex.message,
            'url': getLocationHref()
        };
    }

    computeStackTrace.augmentStackTraceWithInitialElement = augmentStackTraceWithInitialElement;
    computeStackTrace.computeStackTraceFromStackProp = computeStackTraceFromStackProp;

    return computeStackTrace;
}());

module.exports = TraceKit;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../src/utils":191}],193:[function(require,module,exports){
'use strict';

/*
 json-stringify-safe
 Like JSON.stringify, but doesn't throw on circular references.

 Originally forked from https://github.com/isaacs/json-stringify-safe
 version 5.0.1 on 3/8/2017 and modified for IE8 compatibility.
 Tests for this are in test/vendor.

 ISC license: https://github.com/isaacs/json-stringify-safe/blob/master/LICENSE
*/

exports = module.exports = stringify
exports.getSerialize = serializer

function indexOf(haystack, needle) {
  for (var i = 0; i < haystack.length; ++i) {
    if (haystack[i] === needle) return i;
  }
  return -1;
}

function stringify(obj, replacer, spaces, cycleReplacer) {
  return JSON.stringify(obj, serializer(replacer, cycleReplacer), spaces)
}

function serializer(replacer, cycleReplacer) {
  var stack = [], keys = []

  if (cycleReplacer == null) cycleReplacer = function(key, value) {
    if (stack[0] === value) return '[Circular ~]'
    return '[Circular ~.' + keys.slice(0, indexOf(stack, value)).join('.') + ']'
  }

  return function(key, value) {
    if (stack.length > 0) {
      var thisPos = indexOf(stack, this);
      ~thisPos ? stack.splice(thisPos + 1) : stack.push(this)
      ~thisPos ? keys.splice(thisPos, Infinity, key) : keys.push(key)
      if (~indexOf(stack, value)) value = cycleReplacer.call(this, key, value)
    }
    else stack.push(value)

    return replacer == null ? value : replacer.call(this, key, value)
  }
}

},{}],194:[function(require,module,exports){
 /* eslint-env node */
'use strict';

// SDP helpers.
var SDPUtils = {};

// Generate an alphanumeric identifier for cname or mids.
// TODO: use UUIDs instead? https://gist.github.com/jed/982883
SDPUtils.generateIdentifier = function() {
  return Math.random().toString(36).substr(2, 10);
};

// The RTCP CNAME used by all peerconnections from the same JS.
SDPUtils.localCName = SDPUtils.generateIdentifier();

// Splits SDP into lines, dealing with both CRLF and LF.
SDPUtils.splitLines = function(blob) {
  return blob.trim().split('\n').map(function(line) {
    return line.trim();
  });
};
// Splits SDP into sessionpart and mediasections. Ensures CRLF.
SDPUtils.splitSections = function(blob) {
  var parts = blob.split('\nm=');
  return parts.map(function(part, index) {
    return (index > 0 ? 'm=' + part : part).trim() + '\r\n';
  });
};

// Returns lines that start with a certain prefix.
SDPUtils.matchPrefix = function(blob, prefix) {
  return SDPUtils.splitLines(blob).filter(function(line) {
    return line.indexOf(prefix) === 0;
  });
};

// Parses an ICE candidate line. Sample input:
// candidate:702786350 2 udp 41819902 8.8.8.8 60769 typ relay raddr 8.8.8.8
// rport 55996"
SDPUtils.parseCandidate = function(line) {
  var parts;
  // Parse both variants.
  if (line.indexOf('a=candidate:') === 0) {
    parts = line.substring(12).split(' ');
  } else {
    parts = line.substring(10).split(' ');
  }

  var candidate = {
    foundation: parts[0],
    component: parseInt(parts[1], 10),
    protocol: parts[2].toLowerCase(),
    priority: parseInt(parts[3], 10),
    ip: parts[4],
    port: parseInt(parts[5], 10),
    // skip parts[6] == 'typ'
    type: parts[7]
  };

  for (var i = 8; i < parts.length; i += 2) {
    switch (parts[i]) {
      case 'raddr':
        candidate.relatedAddress = parts[i + 1];
        break;
      case 'rport':
        candidate.relatedPort = parseInt(parts[i + 1], 10);
        break;
      case 'tcptype':
        candidate.tcpType = parts[i + 1];
        break;
      default: // extension handling, in particular ufrag
        candidate[parts[i]] = parts[i + 1];
        break;
    }
  }
  return candidate;
};

// Translates a candidate object into SDP candidate attribute.
SDPUtils.writeCandidate = function(candidate) {
  var sdp = [];
  sdp.push(candidate.foundation);
  sdp.push(candidate.component);
  sdp.push(candidate.protocol.toUpperCase());
  sdp.push(candidate.priority);
  sdp.push(candidate.ip);
  sdp.push(candidate.port);

  var type = candidate.type;
  sdp.push('typ');
  sdp.push(type);
  if (type !== 'host' && candidate.relatedAddress &&
      candidate.relatedPort) {
    sdp.push('raddr');
    sdp.push(candidate.relatedAddress); // was: relAddr
    sdp.push('rport');
    sdp.push(candidate.relatedPort); // was: relPort
  }
  if (candidate.tcpType && candidate.protocol.toLowerCase() === 'tcp') {
    sdp.push('tcptype');
    sdp.push(candidate.tcpType);
  }
  if (candidate.ufrag) {
    sdp.push('ufrag');
    sdp.push(candidate.ufrag);
  }
  return 'candidate:' + sdp.join(' ');
};

// Parses an ice-options line, returns an array of option tags.
// a=ice-options:foo bar
SDPUtils.parseIceOptions = function(line) {
  return line.substr(14).split(' ');
}

// Parses an rtpmap line, returns RTCRtpCoddecParameters. Sample input:
// a=rtpmap:111 opus/48000/2
SDPUtils.parseRtpMap = function(line) {
  var parts = line.substr(9).split(' ');
  var parsed = {
    payloadType: parseInt(parts.shift(), 10) // was: id
  };

  parts = parts[0].split('/');

  parsed.name = parts[0];
  parsed.clockRate = parseInt(parts[1], 10); // was: clockrate
  // was: channels
  parsed.numChannels = parts.length === 3 ? parseInt(parts[2], 10) : 1;
  return parsed;
};

// Generate an a=rtpmap line from RTCRtpCodecCapability or
// RTCRtpCodecParameters.
SDPUtils.writeRtpMap = function(codec) {
  var pt = codec.payloadType;
  if (codec.preferredPayloadType !== undefined) {
    pt = codec.preferredPayloadType;
  }
  return 'a=rtpmap:' + pt + ' ' + codec.name + '/' + codec.clockRate +
      (codec.numChannels !== 1 ? '/' + codec.numChannels : '') + '\r\n';
};

// Parses an a=extmap line (headerextension from RFC 5285). Sample input:
// a=extmap:2 urn:ietf:params:rtp-hdrext:toffset
// a=extmap:2/sendonly urn:ietf:params:rtp-hdrext:toffset
SDPUtils.parseExtmap = function(line) {
  var parts = line.substr(9).split(' ');
  return {
    id: parseInt(parts[0], 10),
    direction: parts[0].indexOf('/') > 0 ? parts[0].split('/')[1] : 'sendrecv',
    uri: parts[1]
  };
};

// Generates a=extmap line from RTCRtpHeaderExtensionParameters or
// RTCRtpHeaderExtension.
SDPUtils.writeExtmap = function(headerExtension) {
  return 'a=extmap:' + (headerExtension.id || headerExtension.preferredId) +
      (headerExtension.direction && headerExtension.direction !== 'sendrecv'
          ? '/' + headerExtension.direction
          : '') +
      ' ' + headerExtension.uri + '\r\n';
};

// Parses an ftmp line, returns dictionary. Sample input:
// a=fmtp:96 vbr=on;cng=on
// Also deals with vbr=on; cng=on
SDPUtils.parseFmtp = function(line) {
  var parsed = {};
  var kv;
  var parts = line.substr(line.indexOf(' ') + 1).split(';');
  for (var j = 0; j < parts.length; j++) {
    kv = parts[j].trim().split('=');
    parsed[kv[0].trim()] = kv[1];
  }
  return parsed;
};

// Generates an a=ftmp line from RTCRtpCodecCapability or RTCRtpCodecParameters.
SDPUtils.writeFmtp = function(codec) {
  var line = '';
  var pt = codec.payloadType;
  if (codec.preferredPayloadType !== undefined) {
    pt = codec.preferredPayloadType;
  }
  if (codec.parameters && Object.keys(codec.parameters).length) {
    var params = [];
    Object.keys(codec.parameters).forEach(function(param) {
      params.push(param + '=' + codec.parameters[param]);
    });
    line += 'a=fmtp:' + pt + ' ' + params.join(';') + '\r\n';
  }
  return line;
};

// Parses an rtcp-fb line, returns RTCPRtcpFeedback object. Sample input:
// a=rtcp-fb:98 nack rpsi
SDPUtils.parseRtcpFb = function(line) {
  var parts = line.substr(line.indexOf(' ') + 1).split(' ');
  return {
    type: parts.shift(),
    parameter: parts.join(' ')
  };
};
// Generate a=rtcp-fb lines from RTCRtpCodecCapability or RTCRtpCodecParameters.
SDPUtils.writeRtcpFb = function(codec) {
  var lines = '';
  var pt = codec.payloadType;
  if (codec.preferredPayloadType !== undefined) {
    pt = codec.preferredPayloadType;
  }
  if (codec.rtcpFeedback && codec.rtcpFeedback.length) {
    // FIXME: special handling for trr-int?
    codec.rtcpFeedback.forEach(function(fb) {
      lines += 'a=rtcp-fb:' + pt + ' ' + fb.type +
      (fb.parameter && fb.parameter.length ? ' ' + fb.parameter : '') +
          '\r\n';
    });
  }
  return lines;
};

// Parses an RFC 5576 ssrc media attribute. Sample input:
// a=ssrc:3735928559 cname:something
SDPUtils.parseSsrcMedia = function(line) {
  var sp = line.indexOf(' ');
  var parts = {
    ssrc: parseInt(line.substr(7, sp - 7), 10)
  };
  var colon = line.indexOf(':', sp);
  if (colon > -1) {
    parts.attribute = line.substr(sp + 1, colon - sp - 1);
    parts.value = line.substr(colon + 1);
  } else {
    parts.attribute = line.substr(sp + 1);
  }
  return parts;
};

// Extracts the MID (RFC 5888) from a media section.
// returns the MID or undefined if no mid line was found.
SDPUtils.getMid = function(mediaSection) {
  var mid = SDPUtils.matchPrefix(mediaSection, 'a=mid:')[0];
  if (mid) {
    return mid.substr(6);
  }
}

SDPUtils.parseFingerprint = function(line) {
  var parts = line.substr(14).split(' ');
  return {
    algorithm: parts[0].toLowerCase(), // algorithm is case-sensitive in Edge.
    value: parts[1]
  };
};

// Extracts DTLS parameters from SDP media section or sessionpart.
// FIXME: for consistency with other functions this should only
//   get the fingerprint line as input. See also getIceParameters.
SDPUtils.getDtlsParameters = function(mediaSection, sessionpart) {
  var lines = SDPUtils.matchPrefix(mediaSection + sessionpart,
      'a=fingerprint:');
  // Note: a=setup line is ignored since we use the 'auto' role.
  // Note2: 'algorithm' is not case sensitive except in Edge.
  return {
    role: 'auto',
    fingerprints: lines.map(SDPUtils.parseFingerprint)
  };
};

// Serializes DTLS parameters to SDP.
SDPUtils.writeDtlsParameters = function(params, setupType) {
  var sdp = 'a=setup:' + setupType + '\r\n';
  params.fingerprints.forEach(function(fp) {
    sdp += 'a=fingerprint:' + fp.algorithm + ' ' + fp.value + '\r\n';
  });
  return sdp;
};
// Parses ICE information from SDP media section or sessionpart.
// FIXME: for consistency with other functions this should only
//   get the ice-ufrag and ice-pwd lines as input.
SDPUtils.getIceParameters = function(mediaSection, sessionpart) {
  var lines = SDPUtils.splitLines(mediaSection);
  // Search in session part, too.
  lines = lines.concat(SDPUtils.splitLines(sessionpart));
  var iceParameters = {
    usernameFragment: lines.filter(function(line) {
      return line.indexOf('a=ice-ufrag:') === 0;
    })[0].substr(12),
    password: lines.filter(function(line) {
      return line.indexOf('a=ice-pwd:') === 0;
    })[0].substr(10)
  };
  return iceParameters;
};

// Serializes ICE parameters to SDP.
SDPUtils.writeIceParameters = function(params) {
  return 'a=ice-ufrag:' + params.usernameFragment + '\r\n' +
      'a=ice-pwd:' + params.password + '\r\n';
};

// Parses the SDP media section and returns RTCRtpParameters.
SDPUtils.parseRtpParameters = function(mediaSection) {
  var description = {
    codecs: [],
    headerExtensions: [],
    fecMechanisms: [],
    rtcp: []
  };
  var lines = SDPUtils.splitLines(mediaSection);
  var mline = lines[0].split(' ');
  for (var i = 3; i < mline.length; i++) { // find all codecs from mline[3..]
    var pt = mline[i];
    var rtpmapline = SDPUtils.matchPrefix(
        mediaSection, 'a=rtpmap:' + pt + ' ')[0];
    if (rtpmapline) {
      var codec = SDPUtils.parseRtpMap(rtpmapline);
      var fmtps = SDPUtils.matchPrefix(
          mediaSection, 'a=fmtp:' + pt + ' ');
      // Only the first a=fmtp:<pt> is considered.
      codec.parameters = fmtps.length ? SDPUtils.parseFmtp(fmtps[0]) : {};
      codec.rtcpFeedback = SDPUtils.matchPrefix(
          mediaSection, 'a=rtcp-fb:' + pt + ' ')
        .map(SDPUtils.parseRtcpFb);
      description.codecs.push(codec);
      // parse FEC mechanisms from rtpmap lines.
      switch (codec.name.toUpperCase()) {
        case 'RED':
        case 'ULPFEC':
          description.fecMechanisms.push(codec.name.toUpperCase());
          break;
        default: // only RED and ULPFEC are recognized as FEC mechanisms.
          break;
      }
    }
  }
  SDPUtils.matchPrefix(mediaSection, 'a=extmap:').forEach(function(line) {
    description.headerExtensions.push(SDPUtils.parseExtmap(line));
  });
  // FIXME: parse rtcp.
  return description;
};

// Generates parts of the SDP media section describing the capabilities /
// parameters.
SDPUtils.writeRtpDescription = function(kind, caps) {
  var sdp = '';

  // Build the mline.
  sdp += 'm=' + kind + ' ';
  sdp += caps.codecs.length > 0 ? '9' : '0'; // reject if no codecs.
  sdp += ' UDP/TLS/RTP/SAVPF ';
  sdp += caps.codecs.map(function(codec) {
    if (codec.preferredPayloadType !== undefined) {
      return codec.preferredPayloadType;
    }
    return codec.payloadType;
  }).join(' ') + '\r\n';

  sdp += 'c=IN IP4 0.0.0.0\r\n';
  sdp += 'a=rtcp:9 IN IP4 0.0.0.0\r\n';

  // Add a=rtpmap lines for each codec. Also fmtp and rtcp-fb.
  caps.codecs.forEach(function(codec) {
    sdp += SDPUtils.writeRtpMap(codec);
    sdp += SDPUtils.writeFmtp(codec);
    sdp += SDPUtils.writeRtcpFb(codec);
  });
  var maxptime = 0;
  caps.codecs.forEach(function(codec) {
    if (codec.maxptime > maxptime) {
      maxptime = codec.maxptime;
    }
  });
  if (maxptime > 0) {
    sdp += 'a=maxptime:' + maxptime + '\r\n';
  }
  sdp += 'a=rtcp-mux\r\n';

  caps.headerExtensions.forEach(function(extension) {
    sdp += SDPUtils.writeExtmap(extension);
  });
  // FIXME: write fecMechanisms.
  return sdp;
};

// Parses the SDP media section and returns an array of
// RTCRtpEncodingParameters.
SDPUtils.parseRtpEncodingParameters = function(mediaSection) {
  var encodingParameters = [];
  var description = SDPUtils.parseRtpParameters(mediaSection);
  var hasRed = description.fecMechanisms.indexOf('RED') !== -1;
  var hasUlpfec = description.fecMechanisms.indexOf('ULPFEC') !== -1;

  // filter a=ssrc:... cname:, ignore PlanB-msid
  var ssrcs = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')
  .map(function(line) {
    return SDPUtils.parseSsrcMedia(line);
  })
  .filter(function(parts) {
    return parts.attribute === 'cname';
  });
  var primarySsrc = ssrcs.length > 0 && ssrcs[0].ssrc;
  var secondarySsrc;

  var flows = SDPUtils.matchPrefix(mediaSection, 'a=ssrc-group:FID')
  .map(function(line) {
    var parts = line.split(' ');
    parts.shift();
    return parts.map(function(part) {
      return parseInt(part, 10);
    });
  });
  if (flows.length > 0 && flows[0].length > 1 && flows[0][0] === primarySsrc) {
    secondarySsrc = flows[0][1];
  }

  description.codecs.forEach(function(codec) {
    if (codec.name.toUpperCase() === 'RTX' && codec.parameters.apt) {
      var encParam = {
        ssrc: primarySsrc,
        codecPayloadType: parseInt(codec.parameters.apt, 10),
        rtx: {
          ssrc: secondarySsrc
        }
      };
      encodingParameters.push(encParam);
      if (hasRed) {
        encParam = JSON.parse(JSON.stringify(encParam));
        encParam.fec = {
          ssrc: secondarySsrc,
          mechanism: hasUlpfec ? 'red+ulpfec' : 'red'
        };
        encodingParameters.push(encParam);
      }
    }
  });
  if (encodingParameters.length === 0 && primarySsrc) {
    encodingParameters.push({
      ssrc: primarySsrc
    });
  }

  // we support both b=AS and b=TIAS but interpret AS as TIAS.
  var bandwidth = SDPUtils.matchPrefix(mediaSection, 'b=');
  if (bandwidth.length) {
    if (bandwidth[0].indexOf('b=TIAS:') === 0) {
      bandwidth = parseInt(bandwidth[0].substr(7), 10);
    } else if (bandwidth[0].indexOf('b=AS:') === 0) {
      // use formula from JSEP to convert b=AS to TIAS value.
      bandwidth = parseInt(bandwidth[0].substr(5), 10) * 1000 * 0.95
          - (50 * 40 * 8);
    } else {
      bandwidth = undefined;
    }
    encodingParameters.forEach(function(params) {
      params.maxBitrate = bandwidth;
    });
  }
  return encodingParameters;
};

// parses http://draft.ortc.org/#rtcrtcpparameters*
SDPUtils.parseRtcpParameters = function(mediaSection) {
  var rtcpParameters = {};

  var cname;
  // Gets the first SSRC. Note that with RTX there might be multiple
  // SSRCs.
  var remoteSsrc = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')
      .map(function(line) {
        return SDPUtils.parseSsrcMedia(line);
      })
      .filter(function(obj) {
        return obj.attribute === 'cname';
      })[0];
  if (remoteSsrc) {
    rtcpParameters.cname = remoteSsrc.value;
    rtcpParameters.ssrc = remoteSsrc.ssrc;
  }

  // Edge uses the compound attribute instead of reducedSize
  // compound is !reducedSize
  var rsize = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-rsize');
  rtcpParameters.reducedSize = rsize.length > 0;
  rtcpParameters.compound = rsize.length === 0;

  // parses the rtcp-mux attrbute.
  // Note that Edge does not support unmuxed RTCP.
  var mux = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-mux');
  rtcpParameters.mux = mux.length > 0;

  return rtcpParameters;
};

// parses either a=msid: or a=ssrc:... msid lines and returns
// the id of the MediaStream and MediaStreamTrack.
SDPUtils.parseMsid = function(mediaSection) {
  var parts;
  var spec = SDPUtils.matchPrefix(mediaSection, 'a=msid:');
  if (spec.length === 1) {
    parts = spec[0].substr(7).split(' ');
    return {stream: parts[0], track: parts[1]};
  }
  var planB = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')
  .map(function(line) {
    return SDPUtils.parseSsrcMedia(line);
  })
  .filter(function(parts) {
    return parts.attribute === 'msid';
  });
  if (planB.length > 0) {
    parts = planB[0].value.split(' ');
    return {stream: parts[0], track: parts[1]};
  }
};

// Generate a session ID for SDP.
// https://tools.ietf.org/html/draft-ietf-rtcweb-jsep-20#section-5.2.1
// recommends using a cryptographically random +ve 64-bit value
// but right now this should be acceptable and within the right range
SDPUtils.generateSessionId = function() {
  return Math.random().toString().substr(2, 21);
};

// Write boilder plate for start of SDP
// sessId argument is optional - if not supplied it will
// be generated randomly
// sessVersion is optional and defaults to 2
SDPUtils.writeSessionBoilerplate = function(sessId, sessVer) {
  var sessionId;
  var version = sessVer !== undefined ? sessVer : 2;
  if (sessId) {
    sessionId = sessId;
  } else {
    sessionId = SDPUtils.generateSessionId();
  }
  // FIXME: sess-id should be an NTP timestamp.
  return 'v=0\r\n' +
      'o=thisisadapterortc ' + sessionId + ' ' + version + ' IN IP4 127.0.0.1\r\n' +
      's=-\r\n' +
      't=0 0\r\n';
};

SDPUtils.writeMediaSection = function(transceiver, caps, type, stream) {
  var sdp = SDPUtils.writeRtpDescription(transceiver.kind, caps);

  // Map ICE parameters (ufrag, pwd) to SDP.
  sdp += SDPUtils.writeIceParameters(
      transceiver.iceGatherer.getLocalParameters());

  // Map DTLS parameters to SDP.
  sdp += SDPUtils.writeDtlsParameters(
      transceiver.dtlsTransport.getLocalParameters(),
      type === 'offer' ? 'actpass' : 'active');

  sdp += 'a=mid:' + transceiver.mid + '\r\n';

  if (transceiver.direction) {
    sdp += 'a=' + transceiver.direction + '\r\n';
  } else if (transceiver.rtpSender && transceiver.rtpReceiver) {
    sdp += 'a=sendrecv\r\n';
  } else if (transceiver.rtpSender) {
    sdp += 'a=sendonly\r\n';
  } else if (transceiver.rtpReceiver) {
    sdp += 'a=recvonly\r\n';
  } else {
    sdp += 'a=inactive\r\n';
  }

  if (transceiver.rtpSender) {
    // spec.
    var msid = 'msid:' + stream.id + ' ' +
        transceiver.rtpSender.track.id + '\r\n';
    sdp += 'a=' + msid;

    // for Chrome.
    sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc +
        ' ' + msid;
    if (transceiver.sendEncodingParameters[0].rtx) {
      sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc +
          ' ' + msid;
      sdp += 'a=ssrc-group:FID ' +
          transceiver.sendEncodingParameters[0].ssrc + ' ' +
          transceiver.sendEncodingParameters[0].rtx.ssrc +
          '\r\n';
    }
  }
  // FIXME: this should be written by writeRtpDescription.
  sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc +
      ' cname:' + SDPUtils.localCName + '\r\n';
  if (transceiver.rtpSender && transceiver.sendEncodingParameters[0].rtx) {
    sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc +
        ' cname:' + SDPUtils.localCName + '\r\n';
  }
  return sdp;
};

// Gets the direction from the mediaSection or the sessionpart.
SDPUtils.getDirection = function(mediaSection, sessionpart) {
  // Look for sendrecv, sendonly, recvonly, inactive, default to sendrecv.
  var lines = SDPUtils.splitLines(mediaSection);
  for (var i = 0; i < lines.length; i++) {
    switch (lines[i]) {
      case 'a=sendrecv':
      case 'a=sendonly':
      case 'a=recvonly':
      case 'a=inactive':
        return lines[i].substr(2);
      default:
        // FIXME: What should happen here?
    }
  }
  if (sessionpart) {
    return SDPUtils.getDirection(sessionpart);
  }
  return 'sendrecv';
};

SDPUtils.getKind = function(mediaSection) {
  var lines = SDPUtils.splitLines(mediaSection);
  var mline = lines[0].split(' ');
  return mline[0].substr(2);
};

SDPUtils.isRejected = function(mediaSection) {
  return mediaSection.split(' ', 2)[1] === '0';
};

// Expose public methods.
module.exports = SDPUtils;

},{}],195:[function(require,module,exports){
// This is free and unencumbered software released into the public domain.
// See LICENSE.md for more information.

var encoding = require("./lib/encoding.js");

module.exports = {
  TextEncoder: encoding.TextEncoder,
  TextDecoder: encoding.TextDecoder,
};

},{"./lib/encoding.js":196}],196:[function(require,module,exports){
// This is free and unencumbered software released into the public domain.
// See LICENSE.md for more information.

/**
 * @fileoverview Global |this| required for resolving indexes in node.
 * @suppress {globalThis}
 */
(function(global) {
  'use strict';

  //
  // Utilities
  //

  /**
   * @param {number} a The number to test.
   * @param {number} min The minimum value in the range, inclusive.
   * @param {number} max The maximum value in the range, inclusive.
   * @return {boolean} True if a >= min and a <= max.
   */
  function inRange(a, min, max) {
    return min <= a && a <= max;
  }

  /**
   * @param {!Array.<*>} array The array to check.
   * @param {*} item The item to look for in the array.
   * @return {boolean} True if the item appears in the array.
   */
  function includes(array, item) {
    return array.indexOf(item) !== -1;
  }

  var floor = Math.floor;

  /**
   * @param {*} o
   * @return {Object}
   */
  function ToDictionary(o) {
    if (o === undefined) return {};
    if (o === Object(o)) return o;
    throw TypeError('Could not convert argument to dictionary');
  }

  /**
   * @param {string} string Input string of UTF-16 code units.
   * @return {!Array.<number>} Code points.
   */
  function stringToCodePoints(string) {
    // https://heycam.github.io/webidl/#dfn-obtain-unicode

    // 1. Let S be the DOMString value.
    var s = String(string);

    // 2. Let n be the length of S.
    var n = s.length;

    // 3. Initialize i to 0.
    var i = 0;

    // 4. Initialize U to be an empty sequence of Unicode characters.
    var u = [];

    // 5. While i < n:
    while (i < n) {

      // 1. Let c be the code unit in S at index i.
      var c = s.charCodeAt(i);

      // 2. Depending on the value of c:

      // c < 0xD800 or c > 0xDFFF
      if (c < 0xD800 || c > 0xDFFF) {
        // Append to U the Unicode character with code point c.
        u.push(c);
      }

      // 0xDC00  c  0xDFFF
      else if (0xDC00 <= c && c <= 0xDFFF) {
        // Append to U a U+FFFD REPLACEMENT CHARACTER.
        u.push(0xFFFD);
      }

      // 0xD800  c  0xDBFF
      else if (0xD800 <= c && c <= 0xDBFF) {
        // 1. If i = n1, then append to U a U+FFFD REPLACEMENT
        // CHARACTER.
        if (i === n - 1) {
          u.push(0xFFFD);
        }
        // 2. Otherwise, i < n1:
        else {
          // 1. Let d be the code unit in S at index i+1.
          var d = s.charCodeAt(i + 1);

          // 2. If 0xDC00  d  0xDFFF, then:
          if (0xDC00 <= d && d <= 0xDFFF) {
            // 1. Let a be c & 0x3FF.
            var a = c & 0x3FF;

            // 2. Let b be d & 0x3FF.
            var b = d & 0x3FF;

            // 3. Append to U the Unicode character with code point
            // 2^16+2^10*a+b.
            u.push(0x10000 + (a << 10) + b);

            // 4. Set i to i+1.
            i += 1;
          }

          // 3. Otherwise, d < 0xDC00 or d > 0xDFFF. Append to U a
          // U+FFFD REPLACEMENT CHARACTER.
          else  {
            u.push(0xFFFD);
          }
        }
      }

      // 3. Set i to i+1.
      i += 1;
    }

    // 6. Return U.
    return u;
  }

  /**
   * @param {!Array.<number>} code_points Array of code points.
   * @return {string} string String of UTF-16 code units.
   */
  function codePointsToString(code_points) {
    var s = '';
    for (var i = 0; i < code_points.length; ++i) {
      var cp = code_points[i];
      if (cp <= 0xFFFF) {
        s += String.fromCharCode(cp);
      } else {
        cp -= 0x10000;
        s += String.fromCharCode((cp >> 10) + 0xD800,
                                 (cp & 0x3FF) + 0xDC00);
      }
    }
    return s;
  }


  //
  // Implementation of Encoding specification
  // https://encoding.spec.whatwg.org/
  //

  //
  // 4. Terminology
  //

  /**
   * An ASCII byte is a byte in the range 0x00 to 0x7F, inclusive.
   * @param {number} a The number to test.
   * @return {boolean} True if a is in the range 0x00 to 0x7F, inclusive.
   */
  function isASCIIByte(a) {
    return 0x00 <= a && a <= 0x7F;
  }

  /**
   * An ASCII code point is a code point in the range U+0000 to
   * U+007F, inclusive.
   */
  var isASCIICodePoint = isASCIIByte;


  /**
   * End-of-stream is a special token that signifies no more tokens
   * are in the stream.
   * @const
   */ var end_of_stream = -1;

  /**
   * A stream represents an ordered sequence of tokens.
   *
   * @constructor
   * @param {!(Array.<number>|Uint8Array)} tokens Array of tokens that provide
   * the stream.
   */
  function Stream(tokens) {
    /** @type {!Array.<number>} */
    this.tokens = [].slice.call(tokens);
    // Reversed as push/pop is more efficient than shift/unshift.
    this.tokens.reverse();
  }

  Stream.prototype = {
    /**
     * @return {boolean} True if end-of-stream has been hit.
     */
    endOfStream: function() {
      return !this.tokens.length;
    },

    /**
     * When a token is read from a stream, the first token in the
     * stream must be returned and subsequently removed, and
     * end-of-stream must be returned otherwise.
     *
     * @return {number} Get the next token from the stream, or
     * end_of_stream.
     */
     read: function() {
      if (!this.tokens.length)
        return end_of_stream;
       return this.tokens.pop();
     },

    /**
     * When one or more tokens are prepended to a stream, those tokens
     * must be inserted, in given order, before the first token in the
     * stream.
     *
     * @param {(number|!Array.<number>)} token The token(s) to prepend to the
     * stream.
     */
    prepend: function(token) {
      if (Array.isArray(token)) {
        var tokens = /**@type {!Array.<number>}*/(token);
        while (tokens.length)
          this.tokens.push(tokens.pop());
      } else {
        this.tokens.push(token);
      }
    },

    /**
     * When one or more tokens are pushed to a stream, those tokens
     * must be inserted, in given order, after the last token in the
     * stream.
     *
     * @param {(number|!Array.<number>)} token The tokens(s) to push to the
     * stream.
     */
    push: function(token) {
      if (Array.isArray(token)) {
        var tokens = /**@type {!Array.<number>}*/(token);
        while (tokens.length)
          this.tokens.unshift(tokens.shift());
      } else {
        this.tokens.unshift(token);
      }
    }
  };

  //
  // 5. Encodings
  //

  // 5.1 Encoders and decoders

  /** @const */
  var finished = -1;

  /**
   * @param {boolean} fatal If true, decoding errors raise an exception.
   * @param {number=} opt_code_point Override the standard fallback code point.
   * @return {number} The code point to insert on a decoding error.
   */
  function decoderError(fatal, opt_code_point) {
    if (fatal)
      throw TypeError('Decoder error');
    return opt_code_point || 0xFFFD;
  }

  /**
   * @param {number} code_point The code point that could not be encoded.
   * @return {number} Always throws, no value is actually returned.
   */
  function encoderError(code_point) {
    throw TypeError('The code point ' + code_point + ' could not be encoded.');
  }

  /** @interface */
  function Decoder() {}
  Decoder.prototype = {
    /**
     * @param {Stream} stream The stream of bytes being decoded.
     * @param {number} bite The next byte read from the stream.
     * @return {?(number|!Array.<number>)} The next code point(s)
     *     decoded, or null if not enough data exists in the input
     *     stream to decode a complete code point, or |finished|.
     */
    handler: function(stream, bite) {}
  };

  /** @interface */
  function Encoder() {}
  Encoder.prototype = {
    /**
     * @param {Stream} stream The stream of code points being encoded.
     * @param {number} code_point Next code point read from the stream.
     * @return {(number|!Array.<number>)} Byte(s) to emit, or |finished|.
     */
    handler: function(stream, code_point) {}
  };

  // 5.2 Names and labels

  // TODO: Define @typedef for Encoding: {name:string,labels:Array.<string>}
  // https://github.com/google/closure-compiler/issues/247

  /**
   * @param {string} label The encoding label.
   * @return {?{name:string,labels:Array.<string>}}
   */
  function getEncoding(label) {
    // 1. Remove any leading and trailing ASCII whitespace from label.
    label = String(label).trim().toLowerCase();

    // 2. If label is an ASCII case-insensitive match for any of the
    // labels listed in the table below, return the corresponding
    // encoding, and failure otherwise.
    if (Object.prototype.hasOwnProperty.call(label_to_encoding, label)) {
      return label_to_encoding[label];
    }
    return null;
  }

  /**
   * Encodings table: https://encoding.spec.whatwg.org/encodings.json
   * @const
   * @type {!Array.<{
   *          heading: string,
   *          encodings: Array.<{name:string,labels:Array.<string>}>
   *        }>}
   */
  var encodings = [
    {
      "encodings": [
        {
          "labels": [
            "unicode-1-1-utf-8",
            "utf-8",
            "utf8"
          ],
          "name": "UTF-8"
        }
      ],
      "heading": "The Encoding"
    },
    {
      "encodings": [
        {
          "labels": [
            "866",
            "cp866",
            "csibm866",
            "ibm866"
          ],
          "name": "IBM866"
        },
        {
          "labels": [
            "csisolatin2",
            "iso-8859-2",
            "iso-ir-101",
            "iso8859-2",
            "iso88592",
            "iso_8859-2",
            "iso_8859-2:1987",
            "l2",
            "latin2"
          ],
          "name": "ISO-8859-2"
        },
        {
          "labels": [
            "csisolatin3",
            "iso-8859-3",
            "iso-ir-109",
            "iso8859-3",
            "iso88593",
            "iso_8859-3",
            "iso_8859-3:1988",
            "l3",
            "latin3"
          ],
          "name": "ISO-8859-3"
        },
        {
          "labels": [
            "csisolatin4",
            "iso-8859-4",
            "iso-ir-110",
            "iso8859-4",
            "iso88594",
            "iso_8859-4",
            "iso_8859-4:1988",
            "l4",
            "latin4"
          ],
          "name": "ISO-8859-4"
        },
        {
          "labels": [
            "csisolatincyrillic",
            "cyrillic",
            "iso-8859-5",
            "iso-ir-144",
            "iso8859-5",
            "iso88595",
            "iso_8859-5",
            "iso_8859-5:1988"
          ],
          "name": "ISO-8859-5"
        },
        {
          "labels": [
            "arabic",
            "asmo-708",
            "csiso88596e",
            "csiso88596i",
            "csisolatinarabic",
            "ecma-114",
            "iso-8859-6",
            "iso-8859-6-e",
            "iso-8859-6-i",
            "iso-ir-127",
            "iso8859-6",
            "iso88596",
            "iso_8859-6",
            "iso_8859-6:1987"
          ],
          "name": "ISO-8859-6"
        },
        {
          "labels": [
            "csisolatingreek",
            "ecma-118",
            "elot_928",
            "greek",
            "greek8",
            "iso-8859-7",
            "iso-ir-126",
            "iso8859-7",
            "iso88597",
            "iso_8859-7",
            "iso_8859-7:1987",
            "sun_eu_greek"
          ],
          "name": "ISO-8859-7"
        },
        {
          "labels": [
            "csiso88598e",
            "csisolatinhebrew",
            "hebrew",
            "iso-8859-8",
            "iso-8859-8-e",
            "iso-ir-138",
            "iso8859-8",
            "iso88598",
            "iso_8859-8",
            "iso_8859-8:1988",
            "visual"
          ],
          "name": "ISO-8859-8"
        },
        {
          "labels": [
            "csiso88598i",
            "iso-8859-8-i",
            "logical"
          ],
          "name": "ISO-8859-8-I"
        },
        {
          "labels": [
            "csisolatin6",
            "iso-8859-10",
            "iso-ir-157",
            "iso8859-10",
            "iso885910",
            "l6",
            "latin6"
          ],
          "name": "ISO-8859-10"
        },
        {
          "labels": [
            "iso-8859-13",
            "iso8859-13",
            "iso885913"
          ],
          "name": "ISO-8859-13"
        },
        {
          "labels": [
            "iso-8859-14",
            "iso8859-14",
            "iso885914"
          ],
          "name": "ISO-8859-14"
        },
        {
          "labels": [
            "csisolatin9",
            "iso-8859-15",
            "iso8859-15",
            "iso885915",
            "iso_8859-15",
            "l9"
          ],
          "name": "ISO-8859-15"
        },
        {
          "labels": [
            "iso-8859-16"
          ],
          "name": "ISO-8859-16"
        },
        {
          "labels": [
            "cskoi8r",
            "koi",
            "koi8",
            "koi8-r",
            "koi8_r"
          ],
          "name": "KOI8-R"
        },
        {
          "labels": [
            "koi8-ru",
            "koi8-u"
          ],
          "name": "KOI8-U"
        },
        {
          "labels": [
            "csmacintosh",
            "mac",
            "macintosh",
            "x-mac-roman"
          ],
          "name": "macintosh"
        },
        {
          "labels": [
            "dos-874",
            "iso-8859-11",
            "iso8859-11",
            "iso885911",
            "tis-620",
            "windows-874"
          ],
          "name": "windows-874"
        },
        {
          "labels": [
            "cp1250",
            "windows-1250",
            "x-cp1250"
          ],
          "name": "windows-1250"
        },
        {
          "labels": [
            "cp1251",
            "windows-1251",
            "x-cp1251"
          ],
          "name": "windows-1251"
        },
        {
          "labels": [
            "ansi_x3.4-1968",
            "ascii",
            "cp1252",
            "cp819",
            "csisolatin1",
            "ibm819",
            "iso-8859-1",
            "iso-ir-100",
            "iso8859-1",
            "iso88591",
            "iso_8859-1",
            "iso_8859-1:1987",
            "l1",
            "latin1",
            "us-ascii",
            "windows-1252",
            "x-cp1252"
          ],
          "name": "windows-1252"
        },
        {
          "labels": [
            "cp1253",
            "windows-1253",
            "x-cp1253"
          ],
          "name": "windows-1253"
        },
        {
          "labels": [
            "cp1254",
            "csisolatin5",
            "iso-8859-9",
            "iso-ir-148",
            "iso8859-9",
            "iso88599",
            "iso_8859-9",
            "iso_8859-9:1989",
            "l5",
            "latin5",
            "windows-1254",
            "x-cp1254"
          ],
          "name": "windows-1254"
        },
        {
          "labels": [
            "cp1255",
            "windows-1255",
            "x-cp1255"
          ],
          "name": "windows-1255"
        },
        {
          "labels": [
            "cp1256",
            "windows-1256",
            "x-cp1256"
          ],
          "name": "windows-1256"
        },
        {
          "labels": [
            "cp1257",
            "windows-1257",
            "x-cp1257"
          ],
          "name": "windows-1257"
        },
        {
          "labels": [
            "cp1258",
            "windows-1258",
            "x-cp1258"
          ],
          "name": "windows-1258"
        },
        {
          "labels": [
            "x-mac-cyrillic",
            "x-mac-ukrainian"
          ],
          "name": "x-mac-cyrillic"
        }
      ],
      "heading": "Legacy single-byte encodings"
    },
    {
      "encodings": [
        {
          "labels": [
            "chinese",
            "csgb2312",
            "csiso58gb231280",
            "gb2312",
            "gb_2312",
            "gb_2312-80",
            "gbk",
            "iso-ir-58",
            "x-gbk"
          ],
          "name": "GBK"
        },
        {
          "labels": [
            "gb18030"
          ],
          "name": "gb18030"
        }
      ],
      "heading": "Legacy multi-byte Chinese (simplified) encodings"
    },
    {
      "encodings": [
        {
          "labels": [
            "big5",
            "big5-hkscs",
            "cn-big5",
            "csbig5",
            "x-x-big5"
          ],
          "name": "Big5"
        }
      ],
      "heading": "Legacy multi-byte Chinese (traditional) encodings"
    },
    {
      "encodings": [
        {
          "labels": [
            "cseucpkdfmtjapanese",
            "euc-jp",
            "x-euc-jp"
          ],
          "name": "EUC-JP"
        },
        {
          "labels": [
            "csiso2022jp",
            "iso-2022-jp"
          ],
          "name": "ISO-2022-JP"
        },
        {
          "labels": [
            "csshiftjis",
            "ms932",
            "ms_kanji",
            "shift-jis",
            "shift_jis",
            "sjis",
            "windows-31j",
            "x-sjis"
          ],
          "name": "Shift_JIS"
        }
      ],
      "heading": "Legacy multi-byte Japanese encodings"
    },
    {
      "encodings": [
        {
          "labels": [
            "cseuckr",
            "csksc56011987",
            "euc-kr",
            "iso-ir-149",
            "korean",
            "ks_c_5601-1987",
            "ks_c_5601-1989",
            "ksc5601",
            "ksc_5601",
            "windows-949"
          ],
          "name": "EUC-KR"
        }
      ],
      "heading": "Legacy multi-byte Korean encodings"
    },
    {
      "encodings": [
        {
          "labels": [
            "csiso2022kr",
            "hz-gb-2312",
            "iso-2022-cn",
            "iso-2022-cn-ext",
            "iso-2022-kr"
          ],
          "name": "replacement"
        },
        {
          "labels": [
            "utf-16be"
          ],
          "name": "UTF-16BE"
        },
        {
          "labels": [
            "utf-16",
            "utf-16le"
          ],
          "name": "UTF-16LE"
        },
        {
          "labels": [
            "x-user-defined"
          ],
          "name": "x-user-defined"
        }
      ],
      "heading": "Legacy miscellaneous encodings"
    }
  ];

  // Label to encoding registry.
  /** @type {Object.<string,{name:string,labels:Array.<string>}>} */
  var label_to_encoding = {};
  encodings.forEach(function(category) {
    category.encodings.forEach(function(encoding) {
      encoding.labels.forEach(function(label) {
        label_to_encoding[label] = encoding;
      });
    });
  });

  // Registry of of encoder/decoder factories, by encoding name.
  /** @type {Object.<string, function({fatal:boolean}): Encoder>} */
  var encoders = {};
  /** @type {Object.<string, function({fatal:boolean}): Decoder>} */
  var decoders = {};

  //
  // 6. Indexes
  //

  /**
   * @param {number} pointer The |pointer| to search for.
   * @param {(!Array.<?number>|undefined)} index The |index| to search within.
   * @return {?number} The code point corresponding to |pointer| in |index|,
   *     or null if |code point| is not in |index|.
   */
  function indexCodePointFor(pointer, index) {
    if (!index) return null;
    return index[pointer] || null;
  }

  /**
   * @param {number} code_point The |code point| to search for.
   * @param {!Array.<?number>} index The |index| to search within.
   * @return {?number} The first pointer corresponding to |code point| in
   *     |index|, or null if |code point| is not in |index|.
   */
  function indexPointerFor(code_point, index) {
    var pointer = index.indexOf(code_point);
    return pointer === -1 ? null : pointer;
  }

  /**
   * @param {string} name Name of the index.
   * @return {(!Array.<number>|!Array.<Array.<number>>)}
   *  */
  function index(name) {
    if (!('encoding-indexes' in global)) {
      throw Error("Indexes missing." +
                  " Did you forget to include encoding-indexes.js first?");
    }
    return global['encoding-indexes'][name];
  }

  /**
   * @param {number} pointer The |pointer| to search for in the gb18030 index.
   * @return {?number} The code point corresponding to |pointer| in |index|,
   *     or null if |code point| is not in the gb18030 index.
   */
  function indexGB18030RangesCodePointFor(pointer) {
    // 1. If pointer is greater than 39419 and less than 189000, or
    // pointer is greater than 1237575, return null.
    if ((pointer > 39419 && pointer < 189000) || (pointer > 1237575))
      return null;

    // 2. If pointer is 7457, return code point U+E7C7.
    if (pointer === 7457) return 0xE7C7;

    // 3. Let offset be the last pointer in index gb18030 ranges that
    // is equal to or less than pointer and let code point offset be
    // its corresponding code point.
    var offset = 0;
    var code_point_offset = 0;
    var idx = index('gb18030-ranges');
    var i;
    for (i = 0; i < idx.length; ++i) {
      /** @type {!Array.<number>} */
      var entry = idx[i];
      if (entry[0] <= pointer) {
        offset = entry[0];
        code_point_offset = entry[1];
      } else {
        break;
      }
    }

    // 4. Return a code point whose value is code point offset +
    // pointer  offset.
    return code_point_offset + pointer - offset;
  }

  /**
   * @param {number} code_point The |code point| to locate in the gb18030 index.
   * @return {number} The first pointer corresponding to |code point| in the
   *     gb18030 index.
   */
  function indexGB18030RangesPointerFor(code_point) {
    // 1. If code point is U+E7C7, return pointer 7457.
    if (code_point === 0xE7C7) return 7457;

    // 2. Let offset be the last code point in index gb18030 ranges
    // that is equal to or less than code point and let pointer offset
    // be its corresponding pointer.
    var offset = 0;
    var pointer_offset = 0;
    var idx = index('gb18030-ranges');
    var i;
    for (i = 0; i < idx.length; ++i) {
      /** @type {!Array.<number>} */
      var entry = idx[i];
      if (entry[1] <= code_point) {
        offset = entry[1];
        pointer_offset = entry[0];
      } else {
        break;
      }
    }

    // 3. Return a pointer whose value is pointer offset + code point
    //  offset.
    return pointer_offset + code_point - offset;
  }

  /**
   * @param {number} code_point The |code_point| to search for in the Shift_JIS
   *     index.
   * @return {?number} The code point corresponding to |pointer| in |index|,
   *     or null if |code point| is not in the Shift_JIS index.
   */
  function indexShiftJISPointerFor(code_point) {
    // 1. Let index be index jis0208 excluding all entries whose
    // pointer is in the range 8272 to 8835, inclusive.
    shift_jis_index = shift_jis_index ||
      index('jis0208').map(function(code_point, pointer) {
        return inRange(pointer, 8272, 8835) ? null : code_point;
      });
    var index_ = shift_jis_index;

    // 2. Return the index pointer for code point in index.
    return index_.indexOf(code_point);
  }
  var shift_jis_index;

  /**
   * @param {number} code_point The |code_point| to search for in the big5
   *     index.
   * @return {?number} The code point corresponding to |pointer| in |index|,
   *     or null if |code point| is not in the big5 index.
   */
  function indexBig5PointerFor(code_point) {
    // 1. Let index be index Big5 excluding all entries whose pointer
    big5_index_no_hkscs = big5_index_no_hkscs ||
      index('big5').map(function(code_point, pointer) {
        return (pointer < (0xA1 - 0x81) * 157) ? null : code_point;
      });
    var index_ = big5_index_no_hkscs;

    // 2. If code point is U+2550, U+255E, U+2561, U+256A, U+5341, or
    // U+5345, return the last pointer corresponding to code point in
    // index.
    if (code_point === 0x2550 || code_point === 0x255E ||
        code_point === 0x2561 || code_point === 0x256A ||
        code_point === 0x5341 || code_point === 0x5345) {
      return index_.lastIndexOf(code_point);
    }

    // 3. Return the index pointer for code point in index.
    return indexPointerFor(code_point, index_);
  }
  var big5_index_no_hkscs;

  //
  // 8. API
  //

  /** @const */ var DEFAULT_ENCODING = 'utf-8';

  // 8.1 Interface TextDecoder

  /**
   * @constructor
   * @param {string=} label The label of the encoding;
   *     defaults to 'utf-8'.
   * @param {Object=} options
   */
  function TextDecoder(label, options) {
    // Web IDL conventions
    if (!(this instanceof TextDecoder))
      throw TypeError('Called as a function. Did you forget \'new\'?');
    label = label !== undefined ? String(label) : DEFAULT_ENCODING;
    options = ToDictionary(options);

    // A TextDecoder object has an associated encoding, decoder,
    // stream, ignore BOM flag (initially unset), BOM seen flag
    // (initially unset), error mode (initially replacement), and do
    // not flush flag (initially unset).

    /** @private */
    this._encoding = null;
    /** @private @type {?Decoder} */
    this._decoder = null;
    /** @private @type {boolean} */
    this._ignoreBOM = false;
    /** @private @type {boolean} */
    this._BOMseen = false;
    /** @private @type {string} */
    this._error_mode = 'replacement';
    /** @private @type {boolean} */
    this._do_not_flush = false;


    // 1. Let encoding be the result of getting an encoding from
    // label.
    var encoding = getEncoding(label);

    // 2. If encoding is failure or replacement, throw a RangeError.
    if (encoding === null || encoding.name === 'replacement')
      throw RangeError('Unknown encoding: ' + label);
    if (!decoders[encoding.name]) {
      throw Error('Decoder not present.' +
                  ' Did you forget to include encoding-indexes.js first?');
    }

    // 3. Let dec be a new TextDecoder object.
    var dec = this;

    // 4. Set dec's encoding to encoding.
    dec._encoding = encoding;

    // 5. If options's fatal member is true, set dec's error mode to
    // fatal.
    if (Boolean(options['fatal']))
      dec._error_mode = 'fatal';

    // 6. If options's ignoreBOM member is true, set dec's ignore BOM
    // flag.
    if (Boolean(options['ignoreBOM']))
      dec._ignoreBOM = true;

    // For pre-ES5 runtimes:
    if (!Object.defineProperty) {
      this.encoding = dec._encoding.name.toLowerCase();
      this.fatal = dec._error_mode === 'fatal';
      this.ignoreBOM = dec._ignoreBOM;
    }

    // 7. Return dec.
    return dec;
  }

  if (Object.defineProperty) {
    // The encoding attribute's getter must return encoding's name.
    Object.defineProperty(TextDecoder.prototype, 'encoding', {
      /** @this {TextDecoder} */
      get: function() { return this._encoding.name.toLowerCase(); }
    });

    // The fatal attribute's getter must return true if error mode
    // is fatal, and false otherwise.
    Object.defineProperty(TextDecoder.prototype, 'fatal', {
      /** @this {TextDecoder} */
      get: function() { return this._error_mode === 'fatal'; }
    });

    // The ignoreBOM attribute's getter must return true if ignore
    // BOM flag is set, and false otherwise.
    Object.defineProperty(TextDecoder.prototype, 'ignoreBOM', {
      /** @this {TextDecoder} */
      get: function() { return this._ignoreBOM; }
    });
  }

  /**
   * @param {BufferSource=} input The buffer of bytes to decode.
   * @param {Object=} options
   * @return {string} The decoded string.
   */
  TextDecoder.prototype.decode = function decode(input, options) {
    var bytes;
    if (typeof input === 'object' && input instanceof ArrayBuffer) {
      bytes = new Uint8Array(input);
    } else if (typeof input === 'object' && 'buffer' in input &&
               input.buffer instanceof ArrayBuffer) {
      bytes = new Uint8Array(input.buffer,
                             input.byteOffset,
                             input.byteLength);
    } else {
      bytes = new Uint8Array(0);
    }

    options = ToDictionary(options);

    // 1. If the do not flush flag is unset, set decoder to a new
    // encoding's decoder, set stream to a new stream, and unset the
    // BOM seen flag.
    if (!this._do_not_flush) {
      this._decoder = decoders[this._encoding.name]({
        fatal: this._error_mode === 'fatal'});
      this._BOMseen = false;
    }

    // 2. If options's stream is true, set the do not flush flag, and
    // unset the do not flush flag otherwise.
    this._do_not_flush = Boolean(options['stream']);

    // 3. If input is given, push a copy of input to stream.
    // TODO: Align with spec algorithm - maintain stream on instance.
    var input_stream = new Stream(bytes);

    // 4. Let output be a new stream.
    var output = [];

    /** @type {?(number|!Array.<number>)} */
    var result;

    // 5. While true:
    while (true) {
      // 1. Let token be the result of reading from stream.
      var token = input_stream.read();

      // 2. If token is end-of-stream and the do not flush flag is
      // set, return output, serialized.
      // TODO: Align with spec algorithm.
      if (token === end_of_stream)
        break;

      // 3. Otherwise, run these subsubsteps:

      // 1. Let result be the result of processing token for decoder,
      // stream, output, and error mode.
      result = this._decoder.handler(input_stream, token);

      // 2. If result is finished, return output, serialized.
      if (result === finished)
        break;

      if (result !== null) {
        if (Array.isArray(result))
          output.push.apply(output, /**@type {!Array.<number>}*/(result));
        else
          output.push(result);
      }

      // 3. Otherwise, if result is error, throw a TypeError.
      // (Thrown in handler)

      // 4. Otherwise, do nothing.
    }
    // TODO: Align with spec algorithm.
    if (!this._do_not_flush) {
      do {
        result = this._decoder.handler(input_stream, input_stream.read());
        if (result === finished)
          break;
        if (result === null)
          continue;
        if (Array.isArray(result))
          output.push.apply(output, /**@type {!Array.<number>}*/(result));
        else
          output.push(result);
      } while (!input_stream.endOfStream());
      this._decoder = null;
    }

    // A TextDecoder object also has an associated serialize stream
    // algorithm...
    /**
     * @param {!Array.<number>} stream
     * @return {string}
     * @this {TextDecoder}
     */
    function serializeStream(stream) {
      // 1. Let token be the result of reading from stream.
      // (Done in-place on array, rather than as a stream)

      // 2. If encoding is UTF-8, UTF-16BE, or UTF-16LE, and ignore
      // BOM flag and BOM seen flag are unset, run these subsubsteps:
      if (includes(['UTF-8', 'UTF-16LE', 'UTF-16BE'], this._encoding.name) &&
          !this._ignoreBOM && !this._BOMseen) {
        if (stream.length > 0 && stream[0] === 0xFEFF) {
          // 1. If token is U+FEFF, set BOM seen flag.
          this._BOMseen = true;
          stream.shift();
        } else if (stream.length > 0) {
          // 2. Otherwise, if token is not end-of-stream, set BOM seen
          // flag and append token to stream.
          this._BOMseen = true;
        } else {
          // 3. Otherwise, if token is not end-of-stream, append token
          // to output.
          // (no-op)
        }
      }
      // 4. Otherwise, return output.
      return codePointsToString(stream);
    }

    return serializeStream.call(this, output);
  };

  // 8.2 Interface TextEncoder

  /**
   * @constructor
   * @param {string=} label The label of the encoding. NONSTANDARD.
   * @param {Object=} options NONSTANDARD.
   */
  function TextEncoder(label, options) {
    // Web IDL conventions
    if (!(this instanceof TextEncoder))
      throw TypeError('Called as a function. Did you forget \'new\'?');
    options = ToDictionary(options);

    // A TextEncoder object has an associated encoding and encoder.

    /** @private */
    this._encoding = null;
    /** @private @type {?Encoder} */
    this._encoder = null;

    // Non-standard
    /** @private @type {boolean} */
    this._do_not_flush = false;
    /** @private @type {string} */
    this._fatal = Boolean(options['fatal']) ? 'fatal' : 'replacement';

    // 1. Let enc be a new TextEncoder object.
    var enc = this;

    // 2. Set enc's encoding to UTF-8's encoder.
    if (Boolean(options['NONSTANDARD_allowLegacyEncoding'])) {
      // NONSTANDARD behavior.
      label = label !== undefined ? String(label) : DEFAULT_ENCODING;
      var encoding = getEncoding(label);
      if (encoding === null || encoding.name === 'replacement')
        throw RangeError('Unknown encoding: ' + label);
      if (!encoders[encoding.name]) {
        throw Error('Encoder not present.' +
                    ' Did you forget to include encoding-indexes.js first?');
      }
      enc._encoding = encoding;
    } else {
      // Standard behavior.
      enc._encoding = getEncoding('utf-8');

      if (label !== undefined && 'console' in global) {
        console.warn('TextEncoder constructor called with encoding label, '
                     + 'which is ignored.');
      }
    }

    // For pre-ES5 runtimes:
    if (!Object.defineProperty)
      this.encoding = enc._encoding.name.toLowerCase();

    // 3. Return enc.
    return enc;
  }

  if (Object.defineProperty) {
    // The encoding attribute's getter must return encoding's name.
    Object.defineProperty(TextEncoder.prototype, 'encoding', {
      /** @this {TextEncoder} */
      get: function() { return this._encoding.name.toLowerCase(); }
    });
  }

  /**
   * @param {string=} opt_string The string to encode.
   * @param {Object=} options
   * @return {!Uint8Array} Encoded bytes, as a Uint8Array.
   */
  TextEncoder.prototype.encode = function encode(opt_string, options) {
    opt_string = opt_string === undefined ? '' : String(opt_string);
    options = ToDictionary(options);

    // NOTE: This option is nonstandard. None of the encodings
    // permitted for encoding (i.e. UTF-8, UTF-16) are stateful when
    // the input is a USVString so streaming is not necessary.
    if (!this._do_not_flush)
      this._encoder = encoders[this._encoding.name]({
        fatal: this._fatal === 'fatal'});
    this._do_not_flush = Boolean(options['stream']);

    // 1. Convert input to a stream.
    var input = new Stream(stringToCodePoints(opt_string));

    // 2. Let output be a new stream
    var output = [];

    /** @type {?(number|!Array.<number>)} */
    var result;
    // 3. While true, run these substeps:
    while (true) {
      // 1. Let token be the result of reading from input.
      var token = input.read();
      if (token === end_of_stream)
        break;
      // 2. Let result be the result of processing token for encoder,
      // input, output.
      result = this._encoder.handler(input, token);
      if (result === finished)
        break;
      if (Array.isArray(result))
        output.push.apply(output, /**@type {!Array.<number>}*/(result));
      else
        output.push(result);
    }
    // TODO: Align with spec algorithm.
    if (!this._do_not_flush) {
      while (true) {
        result = this._encoder.handler(input, input.read());
        if (result === finished)
          break;
        if (Array.isArray(result))
          output.push.apply(output, /**@type {!Array.<number>}*/(result));
        else
          output.push(result);
      }
      this._encoder = null;
    }
    // 3. If result is finished, convert output into a byte sequence,
    // and then return a Uint8Array object wrapping an ArrayBuffer
    // containing output.
    return new Uint8Array(output);
  };


  //
  // 9. The encoding
  //

  // 9.1 utf-8

  // 9.1.1 utf-8 decoder
  /**
   * @constructor
   * @implements {Decoder}
   * @param {{fatal: boolean}} options
   */
  function UTF8Decoder(options) {
    var fatal = options.fatal;

    // utf-8's decoder's has an associated utf-8 code point, utf-8
    // bytes seen, and utf-8 bytes needed (all initially 0), a utf-8
    // lower boundary (initially 0x80), and a utf-8 upper boundary
    // (initially 0xBF).
    var /** @type {number} */ utf8_code_point = 0,
        /** @type {number} */ utf8_bytes_seen = 0,
        /** @type {number} */ utf8_bytes_needed = 0,
        /** @type {number} */ utf8_lower_boundary = 0x80,
        /** @type {number} */ utf8_upper_boundary = 0xBF;

    /**
     * @param {Stream} stream The stream of bytes being decoded.
     * @param {number} bite The next byte read from the stream.
     * @return {?(number|!Array.<number>)} The next code point(s)
     *     decoded, or null if not enough data exists in the input
     *     stream to decode a complete code point.
     */
    this.handler = function(stream, bite) {
      // 1. If byte is end-of-stream and utf-8 bytes needed is not 0,
      // set utf-8 bytes needed to 0 and return error.
      if (bite === end_of_stream && utf8_bytes_needed !== 0) {
        utf8_bytes_needed = 0;
        return decoderError(fatal);
      }

      // 2. If byte is end-of-stream, return finished.
      if (bite === end_of_stream)
        return finished;

      // 3. If utf-8 bytes needed is 0, based on byte:
      if (utf8_bytes_needed === 0) {

        // 0x00 to 0x7F
        if (inRange(bite, 0x00, 0x7F)) {
          // Return a code point whose value is byte.
          return bite;
        }

        // 0xC2 to 0xDF
        else if (inRange(bite, 0xC2, 0xDF)) {
          // 1. Set utf-8 bytes needed to 1.
          utf8_bytes_needed = 1;

          // 2. Set UTF-8 code point to byte & 0x1F.
          utf8_code_point = bite & 0x1F;
        }

        // 0xE0 to 0xEF
        else if (inRange(bite, 0xE0, 0xEF)) {
          // 1. If byte is 0xE0, set utf-8 lower boundary to 0xA0.
          if (bite === 0xE0)
            utf8_lower_boundary = 0xA0;
          // 2. If byte is 0xED, set utf-8 upper boundary to 0x9F.
          if (bite === 0xED)
            utf8_upper_boundary = 0x9F;
          // 3. Set utf-8 bytes needed to 2.
          utf8_bytes_needed = 2;
          // 4. Set UTF-8 code point to byte & 0xF.
          utf8_code_point = bite & 0xF;
        }

        // 0xF0 to 0xF4
        else if (inRange(bite, 0xF0, 0xF4)) {
          // 1. If byte is 0xF0, set utf-8 lower boundary to 0x90.
          if (bite === 0xF0)
            utf8_lower_boundary = 0x90;
          // 2. If byte is 0xF4, set utf-8 upper boundary to 0x8F.
          if (bite === 0xF4)
            utf8_upper_boundary = 0x8F;
          // 3. Set utf-8 bytes needed to 3.
          utf8_bytes_needed = 3;
          // 4. Set UTF-8 code point to byte & 0x7.
          utf8_code_point = bite & 0x7;
        }

        // Otherwise
        else {
          // Return error.
          return decoderError(fatal);
        }

        // Return continue.
        return null;
      }

      // 4. If byte is not in the range utf-8 lower boundary to utf-8
      // upper boundary, inclusive, run these substeps:
      if (!inRange(bite, utf8_lower_boundary, utf8_upper_boundary)) {

        // 1. Set utf-8 code point, utf-8 bytes needed, and utf-8
        // bytes seen to 0, set utf-8 lower boundary to 0x80, and set
        // utf-8 upper boundary to 0xBF.
        utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0;
        utf8_lower_boundary = 0x80;
        utf8_upper_boundary = 0xBF;

        // 2. Prepend byte to stream.
        stream.prepend(bite);

        // 3. Return error.
        return decoderError(fatal);
      }

      // 5. Set utf-8 lower boundary to 0x80 and utf-8 upper boundary
      // to 0xBF.
      utf8_lower_boundary = 0x80;
      utf8_upper_boundary = 0xBF;

      // 6. Set UTF-8 code point to (UTF-8 code point << 6) | (byte &
      // 0x3F)
      utf8_code_point = (utf8_code_point << 6) | (bite & 0x3F);

      // 7. Increase utf-8 bytes seen by one.
      utf8_bytes_seen += 1;

      // 8. If utf-8 bytes seen is not equal to utf-8 bytes needed,
      // continue.
      if (utf8_bytes_seen !== utf8_bytes_needed)
        return null;

      // 9. Let code point be utf-8 code point.
      var code_point = utf8_code_point;

      // 10. Set utf-8 code point, utf-8 bytes needed, and utf-8 bytes
      // seen to 0.
      utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0;

      // 11. Return a code point whose value is code point.
      return code_point;
    };
  }

  // 9.1.2 utf-8 encoder
  /**
   * @constructor
   * @implements {Encoder}
   * @param {{fatal: boolean}} options
   */
  function UTF8Encoder(options) {
    var fatal = options.fatal;
    /**
     * @param {Stream} stream Input stream.
     * @param {number} code_point Next code point read from the stream.
     * @return {(number|!Array.<number>)} Byte(s) to emit.
     */
    this.handler = function(stream, code_point) {
      // 1. If code point is end-of-stream, return finished.
      if (code_point === end_of_stream)
        return finished;

      // 2. If code point is an ASCII code point, return a byte whose
      // value is code point.
      if (isASCIICodePoint(code_point))
        return code_point;

      // 3. Set count and offset based on the range code point is in:
      var count, offset;
      // U+0080 to U+07FF, inclusive:
      if (inRange(code_point, 0x0080, 0x07FF)) {
        // 1 and 0xC0
        count = 1;
        offset = 0xC0;
      }
      // U+0800 to U+FFFF, inclusive:
      else if (inRange(code_point, 0x0800, 0xFFFF)) {
        // 2 and 0xE0
        count = 2;
        offset = 0xE0;
      }
      // U+10000 to U+10FFFF, inclusive:
      else if (inRange(code_point, 0x10000, 0x10FFFF)) {
        // 3 and 0xF0
        count = 3;
        offset = 0xF0;
      }

      // 4. Let bytes be a byte sequence whose first byte is (code
      // point >> (6  count)) + offset.
      var bytes = [(code_point >> (6 * count)) + offset];

      // 5. Run these substeps while count is greater than 0:
      while (count > 0) {

        // 1. Set temp to code point >> (6  (count  1)).
        var temp = code_point >> (6 * (count - 1));

        // 2. Append to bytes 0x80 | (temp & 0x3F).
        bytes.push(0x80 | (temp & 0x3F));

        // 3. Decrease count by one.
        count -= 1;
      }

      // 6. Return bytes bytes, in order.
      return bytes;
    };
  }

  /** @param {{fatal: boolean}} options */
  encoders['UTF-8'] = function(options) {
    return new UTF8Encoder(options);
  };
  /** @param {{fatal: boolean}} options */
  decoders['UTF-8'] = function(options) {
    return new UTF8Decoder(options);
  };

  //
  // 10. Legacy single-byte encodings
  //

  // 10.1 single-byte decoder
  /**
   * @constructor
   * @implements {Decoder}
   * @param {!Array.<number>} index The encoding index.
   * @param {{fatal: boolean}} options
   */
  function SingleByteDecoder(index, options) {
    var fatal = options.fatal;
    /**
     * @param {Stream} stream The stream of bytes being decoded.
     * @param {number} bite The next byte read from the stream.
     * @return {?(number|!Array.<number>)} The next code point(s)
     *     decoded, or null if not enough data exists in the input
     *     stream to decode a complete code point.
     */
    this.handler = function(stream, bite) {
      // 1. If byte is end-of-stream, return finished.
      if (bite === end_of_stream)
        return finished;

      // 2. If byte is an ASCII byte, return a code point whose value
      // is byte.
      if (isASCIIByte(bite))
        return bite;

      // 3. Let code point be the index code point for byte  0x80 in
      // index single-byte.
      var code_point = index[bite - 0x80];

      // 4. If code point is null, return error.
      if (code_point === null)
        return decoderError(fatal);

      // 5. Return a code point whose value is code point.
      return code_point;
    };
  }

  // 10.2 single-byte encoder
  /**
   * @constructor
   * @implements {Encoder}
   * @param {!Array.<?number>} index The encoding index.
   * @param {{fatal: boolean}} options
   */
  function SingleByteEncoder(index, options) {
    var fatal = options.fatal;
    /**
     * @param {Stream} stream Input stream.
     * @param {number} code_point Next code point read from the stream.
     * @return {(number|!Array.<number>)} Byte(s) to emit.
     */
    this.handler = function(stream, code_point) {
      // 1. If code point is end-of-stream, return finished.
      if (code_point === end_of_stream)
        return finished;

      // 2. If code point is an ASCII code point, return a byte whose
      // value is code point.
      if (isASCIICodePoint(code_point))
        return code_point;

      // 3. Let pointer be the index pointer for code point in index
      // single-byte.
      var pointer = indexPointerFor(code_point, index);

      // 4. If pointer is null, return error with code point.
      if (pointer === null)
        encoderError(code_point);

      // 5. Return a byte whose value is pointer + 0x80.
      return pointer + 0x80;
    };
  }

  (function() {
    if (!('encoding-indexes' in global))
      return;
    encodings.forEach(function(category) {
      if (category.heading !== 'Legacy single-byte encodings')
        return;
      category.encodings.forEach(function(encoding) {
        var name = encoding.name;
        var idx = index(name.toLowerCase());
        /** @param {{fatal: boolean}} options */
        decoders[name] = function(options) {
          return new SingleByteDecoder(idx, options);
        };
        /** @param {{fatal: boolean}} options */
        encoders[name] = function(options) {
          return new SingleByteEncoder(idx, options);
        };
      });
    });
  }());

  //
  // 11. Legacy multi-byte Chinese (simplified) encodings
  //

  // 11.1 gbk

  // 11.1.1 gbk decoder
  // gbk's decoder is gb18030's decoder.
  /** @param {{fatal: boolean}} options */
  decoders['GBK'] = function(options) {
    return new GB18030Decoder(options);
  };

  // 11.1.2 gbk encoder
  // gbk's encoder is gb18030's encoder with its gbk flag set.
  /** @param {{fatal: boolean}} options */
  encoders['GBK'] = function(options) {
    return new GB18030Encoder(options, true);
  };

  // 11.2 gb18030

  // 11.2.1 gb18030 decoder
  /**
   * @constructor
   * @implements {Decoder}
   * @param {{fatal: boolean}} options
   */
  function GB18030Decoder(options) {
    var fatal = options.fatal;
    // gb18030's decoder has an associated gb18030 first, gb18030
    // second, and gb18030 third (all initially 0x00).
    var /** @type {number} */ gb18030_first = 0x00,
        /** @type {number} */ gb18030_second = 0x00,
        /** @type {number} */ gb18030_third = 0x00;
    /**
     * @param {Stream} stream The stream of bytes being decoded.
     * @param {number} bite The next byte read from the stream.
     * @return {?(number|!Array.<number>)} The next code point(s)
     *     decoded, or null if not enough data exists in the input
     *     stream to decode a complete code point.
     */
    this.handler = function(stream, bite) {
      // 1. If byte is end-of-stream and gb18030 first, gb18030
      // second, and gb18030 third are 0x00, return finished.
      if (bite === end_of_stream && gb18030_first === 0x00 &&
          gb18030_second === 0x00 && gb18030_third === 0x00) {
        return finished;
      }
      // 2. If byte is end-of-stream, and gb18030 first, gb18030
      // second, or gb18030 third is not 0x00, set gb18030 first,
      // gb18030 second, and gb18030 third to 0x00, and return error.
      if (bite === end_of_stream &&
          (gb18030_first !== 0x00 || gb18030_second !== 0x00 ||
           gb18030_third !== 0x00)) {
        gb18030_first = 0x00;
        gb18030_second = 0x00;
        gb18030_third = 0x00;
        decoderError(fatal);
      }
      var code_point;
      // 3. If gb18030 third is not 0x00, run these substeps:
      if (gb18030_third !== 0x00) {
        // 1. Let code point be null.
        code_point = null;
        // 2. If byte is in the range 0x30 to 0x39, inclusive, set
        // code point to the index gb18030 ranges code point for
        // (((gb18030 first  0x81)  10 + gb18030 second  0x30) 
        // 126 + gb18030 third  0x81)  10 + byte  0x30.
        if (inRange(bite, 0x30, 0x39)) {
          code_point = indexGB18030RangesCodePointFor(
              (((gb18030_first - 0x81) * 10 + gb18030_second - 0x30) * 126 +
               gb18030_third - 0x81) * 10 + bite - 0x30);
        }

        // 3. Let buffer be a byte sequence consisting of gb18030
        // second, gb18030 third, and byte, in order.
        var buffer = [gb18030_second, gb18030_third, bite];

        // 4. Set gb18030 first, gb18030 second, and gb18030 third to
        // 0x00.
        gb18030_first = 0x00;
        gb18030_second = 0x00;
        gb18030_third = 0x00;

        // 5. If code point is null, prepend buffer to stream and
        // return error.
        if (code_point === null) {
          stream.prepend(buffer);
          return decoderError(fatal);
        }

        // 6. Return a code point whose value is code point.
        return code_point;
      }

      // 4. If gb18030 second is not 0x00, run these substeps:
      if (gb18030_second !== 0x00) {

        // 1. If byte is in the range 0x81 to 0xFE, inclusive, set
        // gb18030 third to byte and return continue.
        if (inRange(bite, 0x81, 0xFE)) {
          gb18030_third = bite;
          return null;
        }

        // 2. Prepend gb18030 second followed by byte to stream, set
        // gb18030 first and gb18030 second to 0x00, and return error.
        stream.prepend([gb18030_second, bite]);
        gb18030_first = 0x00;
        gb18030_second = 0x00;
        return decoderError(fatal);
      }

      // 5. If gb18030 first is not 0x00, run these substeps:
      if (gb18030_first !== 0x00) {

        // 1. If byte is in the range 0x30 to 0x39, inclusive, set
        // gb18030 second to byte and return continue.
        if (inRange(bite, 0x30, 0x39)) {
          gb18030_second = bite;
          return null;
        }

        // 2. Let lead be gb18030 first, let pointer be null, and set
        // gb18030 first to 0x00.
        var lead = gb18030_first;
        var pointer = null;
        gb18030_first = 0x00;

        // 3. Let offset be 0x40 if byte is less than 0x7F and 0x41
        // otherwise.
        var offset = bite < 0x7F ? 0x40 : 0x41;

        // 4. If byte is in the range 0x40 to 0x7E, inclusive, or 0x80
        // to 0xFE, inclusive, set pointer to (lead  0x81)  190 +
        // (byte  offset).
        if (inRange(bite, 0x40, 0x7E) || inRange(bite, 0x80, 0xFE))
          pointer = (lead - 0x81) * 190 + (bite - offset);

        // 5. Let code point be null if pointer is null and the index
        // code point for pointer in index gb18030 otherwise.
        code_point = pointer === null ? null :
            indexCodePointFor(pointer, index('gb18030'));

        // 6. If code point is null and byte is an ASCII byte, prepend
        // byte to stream.
        if (code_point === null && isASCIIByte(bite))
          stream.prepend(bite);

        // 7. If code point is null, return error.
        if (code_point === null)
          return decoderError(fatal);

        // 8. Return a code point whose value is code point.
        return code_point;
      }

      // 6. If byte is an ASCII byte, return a code point whose value
      // is byte.
      if (isASCIIByte(bite))
        return bite;

      // 7. If byte is 0x80, return code point U+20AC.
      if (bite === 0x80)
        return 0x20AC;

      // 8. If byte is in the range 0x81 to 0xFE, inclusive, set
      // gb18030 first to byte and return continue.
      if (inRange(bite, 0x81, 0xFE)) {
        gb18030_first = bite;
        return null;
      }

      // 9. Return error.
      return decoderError(fatal);
    };
  }

  // 11.2.2 gb18030 encoder
  /**
   * @constructor
   * @implements {Encoder}
   * @param {{fatal: boolean}} options
   * @param {boolean=} gbk_flag
   */
  function GB18030Encoder(options, gbk_flag) {
    var fatal = options.fatal;
    // gb18030's decoder has an associated gbk flag (initially unset).
    /**
     * @param {Stream} stream Input stream.
     * @param {number} code_point Next code point read from the stream.
     * @return {(number|!Array.<number>)} Byte(s) to emit.
     */
    this.handler = function(stream, code_point) {
      // 1. If code point is end-of-stream, return finished.
      if (code_point === end_of_stream)
        return finished;

      // 2. If code point is an ASCII code point, return a byte whose
      // value is code point.
      if (isASCIICodePoint(code_point))
        return code_point;

      // 3. If code point is U+E5E5, return error with code point.
      if (code_point === 0xE5E5)
        return encoderError(code_point);

      // 4. If the gbk flag is set and code point is U+20AC, return
      // byte 0x80.
      if (gbk_flag && code_point === 0x20AC)
        return 0x80;

      // 5. Let pointer be the index pointer for code point in index
      // gb18030.
      var pointer = indexPointerFor(code_point, index('gb18030'));

      // 6. If pointer is not null, run these substeps:
      if (pointer !== null) {

        // 1. Let lead be floor(pointer / 190) + 0x81.
        var lead = floor(pointer / 190) + 0x81;

        // 2. Let trail be pointer % 190.
        var trail = pointer % 190;

        // 3. Let offset be 0x40 if trail is less than 0x3F and 0x41 otherwise.
        var offset = trail < 0x3F ? 0x40 : 0x41;

        // 4. Return two bytes whose values are lead and trail + offset.
        return [lead, trail + offset];
      }

      // 7. If gbk flag is set, return error with code point.
      if (gbk_flag)
        return encoderError(code_point);

      // 8. Set pointer to the index gb18030 ranges pointer for code
      // point.
      pointer = indexGB18030RangesPointerFor(code_point);

      // 9. Let byte1 be floor(pointer / 10 / 126 / 10).
      var byte1 = floor(pointer / 10 / 126 / 10);

      // 10. Set pointer to pointer  byte1  10  126  10.
      pointer = pointer - byte1 * 10 * 126 * 10;

      // 11. Let byte2 be floor(pointer / 10 / 126).
      var byte2 = floor(pointer / 10 / 126);

      // 12. Set pointer to pointer  byte2  10  126.
      pointer = pointer - byte2 * 10 * 126;

      // 13. Let byte3 be floor(pointer / 10).
      var byte3 = floor(pointer / 10);

      // 14. Let byte4 be pointer  byte3  10.
      var byte4 = pointer - byte3 * 10;

      // 15. Return four bytes whose values are byte1 + 0x81, byte2 +
      // 0x30, byte3 + 0x81, byte4 + 0x30.
      return [byte1 + 0x81,
              byte2 + 0x30,
              byte3 + 0x81,
              byte4 + 0x30];
    };
  }

  /** @param {{fatal: boolean}} options */
  encoders['gb18030'] = function(options) {
    return new GB18030Encoder(options);
  };
  /** @param {{fatal: boolean}} options */
  decoders['gb18030'] = function(options) {
    return new GB18030Decoder(options);
  };


  //
  // 12. Legacy multi-byte Chinese (traditional) encodings
  //

  // 12.1 Big5

  // 12.1.1 Big5 decoder
  /**
   * @constructor
   * @implements {Decoder}
   * @param {{fatal: boolean}} options
   */
  function Big5Decoder(options) {
    var fatal = options.fatal;
    // Big5's decoder has an associated Big5 lead (initially 0x00).
    var /** @type {number} */ Big5_lead = 0x00;

    /**
     * @param {Stream} stream The stream of bytes being decoded.
     * @param {number} bite The next byte read from the stream.
     * @return {?(number|!Array.<number>)} The next code point(s)
     *     decoded, or null if not enough data exists in the input
     *     stream to decode a complete code point.
     */
    this.handler = function(stream, bite) {
      // 1. If byte is end-of-stream and Big5 lead is not 0x00, set
      // Big5 lead to 0x00 and return error.
      if (bite === end_of_stream && Big5_lead !== 0x00) {
        Big5_lead = 0x00;
        return decoderError(fatal);
      }

      // 2. If byte is end-of-stream and Big5 lead is 0x00, return
      // finished.
      if (bite === end_of_stream && Big5_lead === 0x00)
        return finished;

      // 3. If Big5 lead is not 0x00, let lead be Big5 lead, let
      // pointer be null, set Big5 lead to 0x00, and then run these
      // substeps:
      if (Big5_lead !== 0x00) {
        var lead = Big5_lead;
        var pointer = null;
        Big5_lead = 0x00;

        // 1. Let offset be 0x40 if byte is less than 0x7F and 0x62
        // otherwise.
        var offset = bite < 0x7F ? 0x40 : 0x62;

        // 2. If byte is in the range 0x40 to 0x7E, inclusive, or 0xA1
        // to 0xFE, inclusive, set pointer to (lead  0x81)  157 +
        // (byte  offset).
        if (inRange(bite, 0x40, 0x7E) || inRange(bite, 0xA1, 0xFE))
          pointer = (lead - 0x81) * 157 + (bite - offset);

        // 3. If there is a row in the table below whose first column
        // is pointer, return the two code points listed in its second
        // column
        // Pointer | Code points
        // --------+--------------
        // 1133    | U+00CA U+0304
        // 1135    | U+00CA U+030C
        // 1164    | U+00EA U+0304
        // 1166    | U+00EA U+030C
        switch (pointer) {
          case 1133: return [0x00CA, 0x0304];
          case 1135: return [0x00CA, 0x030C];
          case 1164: return [0x00EA, 0x0304];
          case 1166: return [0x00EA, 0x030C];
        }

        // 4. Let code point be null if pointer is null and the index
        // code point for pointer in index Big5 otherwise.
        var code_point = (pointer === null) ? null :
            indexCodePointFor(pointer, index('big5'));

        // 5. If code point is null and byte is an ASCII byte, prepend
        // byte to stream.
        if (code_point === null && isASCIIByte(bite))
          stream.prepend(bite);

        // 6. If code point is null, return error.
        if (code_point === null)
          return decoderError(fatal);

        // 7. Return a code point whose value is code point.
        return code_point;
      }

      // 4. If byte is an ASCII byte, return a code point whose value
      // is byte.
      if (isASCIIByte(bite))
        return bite;

      // 5. If byte is in the range 0x81 to 0xFE, inclusive, set Big5
      // lead to byte and return continue.
      if (inRange(bite, 0x81, 0xFE)) {
        Big5_lead = bite;
        return null;
      }

      // 6. Return error.
      return decoderError(fatal);
    };
  }

  // 12.1.2 Big5 encoder
  /**
   * @constructor
   * @implements {Encoder}
   * @param {{fatal: boolean}} options
   */
  function Big5Encoder(options) {
    var fatal = options.fatal;
    /**
     * @param {Stream} stream Input stream.
     * @param {number} code_point Next code point read from the stream.
     * @return {(number|!Array.<number>)} Byte(s) to emit.
     */
    this.handler = function(stream, code_point) {
      // 1. If code point is end-of-stream, return finished.
      if (code_point === end_of_stream)
        return finished;

      // 2. If code point is an ASCII code point, return a byte whose
      // value is code point.
      if (isASCIICodePoint(code_point))
        return code_point;

      // 3. Let pointer be the index Big5 pointer for code point.
      var pointer = indexBig5PointerFor(code_point);

      // 4. If pointer is null, return error with code point.
      if (pointer === null)
        return encoderError(code_point);

      // 5. Let lead be floor(pointer / 157) + 0x81.
      var lead = floor(pointer / 157) + 0x81;

      // 6. If lead is less than 0xA1, return error with code point.
      if (lead < 0xA1)
        return encoderError(code_point);

      // 7. Let trail be pointer % 157.
      var trail = pointer % 157;

      // 8. Let offset be 0x40 if trail is less than 0x3F and 0x62
      // otherwise.
      var offset = trail < 0x3F ? 0x40 : 0x62;

      // Return two bytes whose values are lead and trail + offset.
      return [lead, trail + offset];
    };
  }

  /** @param {{fatal: boolean}} options */
  encoders['Big5'] = function(options) {
    return new Big5Encoder(options);
  };
  /** @param {{fatal: boolean}} options */
  decoders['Big5'] = function(options) {
    return new Big5Decoder(options);
  };


  //
  // 13. Legacy multi-byte Japanese encodings
  //

  // 13.1 euc-jp

  // 13.1.1 euc-jp decoder
  /**
   * @constructor
   * @implements {Decoder}
   * @param {{fatal: boolean}} options
   */
  function EUCJPDecoder(options) {
    var fatal = options.fatal;

    // euc-jp's decoder has an associated euc-jp jis0212 flag
    // (initially unset) and euc-jp lead (initially 0x00).
    var /** @type {boolean} */ eucjp_jis0212_flag = false,
        /** @type {number} */ eucjp_lead = 0x00;

    /**
     * @param {Stream} stream The stream of bytes being decoded.
     * @param {number} bite The next byte read from the stream.
     * @return {?(number|!Array.<number>)} The next code point(s)
     *     decoded, or null if not enough data exists in the input
     *     stream to decode a complete code point.
     */
    this.handler = function(stream, bite) {
      // 1. If byte is end-of-stream and euc-jp lead is not 0x00, set
      // euc-jp lead to 0x00, and return error.
      if (bite === end_of_stream && eucjp_lead !== 0x00) {
        eucjp_lead = 0x00;
        return decoderError(fatal);
      }

      // 2. If byte is end-of-stream and euc-jp lead is 0x00, return
      // finished.
      if (bite === end_of_stream && eucjp_lead === 0x00)
        return finished;

      // 3. If euc-jp lead is 0x8E and byte is in the range 0xA1 to
      // 0xDF, inclusive, set euc-jp lead to 0x00 and return a code
      // point whose value is 0xFF61  0xA1 + byte.
      if (eucjp_lead === 0x8E && inRange(bite, 0xA1, 0xDF)) {
        eucjp_lead = 0x00;
        return 0xFF61 - 0xA1 + bite;
      }

      // 4. If euc-jp lead is 0x8F and byte is in the range 0xA1 to
      // 0xFE, inclusive, set the euc-jp jis0212 flag, set euc-jp lead
      // to byte, and return continue.
      if (eucjp_lead === 0x8F && inRange(bite, 0xA1, 0xFE)) {
        eucjp_jis0212_flag = true;
        eucjp_lead = bite;
        return null;
      }

      // 5. If euc-jp lead is not 0x00, let lead be euc-jp lead, set
      // euc-jp lead to 0x00, and run these substeps:
      if (eucjp_lead !== 0x00) {
        var lead = eucjp_lead;
        eucjp_lead = 0x00;

        // 1. Let code point be null.
        var code_point = null;

        // 2. If lead and byte are both in the range 0xA1 to 0xFE,
        // inclusive, set code point to the index code point for (lead
        //  0xA1)  94 + byte  0xA1 in index jis0208 if the euc-jp
        // jis0212 flag is unset and in index jis0212 otherwise.
        if (inRange(lead, 0xA1, 0xFE) && inRange(bite, 0xA1, 0xFE)) {
          code_point = indexCodePointFor(
            (lead - 0xA1) * 94 + (bite - 0xA1),
            index(!eucjp_jis0212_flag ? 'jis0208' : 'jis0212'));
        }

        // 3. Unset the euc-jp jis0212 flag.
        eucjp_jis0212_flag = false;

        // 4. If byte is not in the range 0xA1 to 0xFE, inclusive,
        // prepend byte to stream.
        if (!inRange(bite, 0xA1, 0xFE))
          stream.prepend(bite);

        // 5. If code point is null, return error.
        if (code_point === null)
          return decoderError(fatal);

        // 6. Return a code point whose value is code point.
        return code_point;
      }

      // 6. If byte is an ASCII byte, return a code point whose value
      // is byte.
      if (isASCIIByte(bite))
        return bite;

      // 7. If byte is 0x8E, 0x8F, or in the range 0xA1 to 0xFE,
      // inclusive, set euc-jp lead to byte and return continue.
      if (bite === 0x8E || bite === 0x8F || inRange(bite, 0xA1, 0xFE)) {
        eucjp_lead = bite;
        return null;
      }

      // 8. Return error.
      return decoderError(fatal);
    };
  }

  // 13.1.2 euc-jp encoder
  /**
   * @constructor
   * @implements {Encoder}
   * @param {{fatal: boolean}} options
   */
  function EUCJPEncoder(options) {
    var fatal = options.fatal;
    /**
     * @param {Stream} stream Input stream.
     * @param {number} code_point Next code point read from the stream.
     * @return {(number|!Array.<number>)} Byte(s) to emit.
     */
    this.handler = function(stream, code_point) {
      // 1. If code point is end-of-stream, return finished.
      if (code_point === end_of_stream)
        return finished;

      // 2. If code point is an ASCII code point, return a byte whose
      // value is code point.
      if (isASCIICodePoint(code_point))
        return code_point;

      // 3. If code point is U+00A5, return byte 0x5C.
      if (code_point === 0x00A5)
        return 0x5C;

      // 4. If code point is U+203E, return byte 0x7E.
      if (code_point === 0x203E)
        return 0x7E;

      // 5. If code point is in the range U+FF61 to U+FF9F, inclusive,
      // return two bytes whose values are 0x8E and code point 
      // 0xFF61 + 0xA1.
      if (inRange(code_point, 0xFF61, 0xFF9F))
        return [0x8E, code_point - 0xFF61 + 0xA1];

      // 6. If code point is U+2212, set it to U+FF0D.
      if (code_point === 0x2212)
        code_point = 0xFF0D;

      // 7. Let pointer be the index pointer for code point in index
      // jis0208.
      var pointer = indexPointerFor(code_point, index('jis0208'));

      // 8. If pointer is null, return error with code point.
      if (pointer === null)
        return encoderError(code_point);

      // 9. Let lead be floor(pointer / 94) + 0xA1.
      var lead = floor(pointer / 94) + 0xA1;

      // 10. Let trail be pointer % 94 + 0xA1.
      var trail = pointer % 94 + 0xA1;

      // 11. Return two bytes whose values are lead and trail.
      return [lead, trail];
    };
  }

  /** @param {{fatal: boolean}} options */
  encoders['EUC-JP'] = function(options) {
    return new EUCJPEncoder(options);
  };
  /** @param {{fatal: boolean}} options */
  decoders['EUC-JP'] = function(options) {
    return new EUCJPDecoder(options);
  };

  // 13.2 iso-2022-jp

  // 13.2.1 iso-2022-jp decoder
  /**
   * @constructor
   * @implements {Decoder}
   * @param {{fatal: boolean}} options
   */
  function ISO2022JPDecoder(options) {
    var fatal = options.fatal;
    /** @enum */
    var states = {
      ASCII: 0,
      Roman: 1,
      Katakana: 2,
      LeadByte: 3,
      TrailByte: 4,
      EscapeStart: 5,
      Escape: 6
    };
    // iso-2022-jp's decoder has an associated iso-2022-jp decoder
    // state (initially ASCII), iso-2022-jp decoder output state
    // (initially ASCII), iso-2022-jp lead (initially 0x00), and
    // iso-2022-jp output flag (initially unset).
    var /** @type {number} */ iso2022jp_decoder_state = states.ASCII,
        /** @type {number} */ iso2022jp_decoder_output_state = states.ASCII,
        /** @type {number} */ iso2022jp_lead = 0x00,
        /** @type {boolean} */ iso2022jp_output_flag = false;
    /**
     * @param {Stream} stream The stream of bytes being decoded.
     * @param {number} bite The next byte read from the stream.
     * @return {?(number|!Array.<number>)} The next code point(s)
     *     decoded, or null if not enough data exists in the input
     *     stream to decode a complete code point.
     */
    this.handler = function(stream, bite) {
      // switching on iso-2022-jp decoder state:
      switch (iso2022jp_decoder_state) {
      default:
      case states.ASCII:
        // ASCII
        // Based on byte:

        // 0x1B
        if (bite === 0x1B) {
          // Set iso-2022-jp decoder state to escape start and return
          // continue.
          iso2022jp_decoder_state = states.EscapeStart;
          return null;
        }

        // 0x00 to 0x7F, excluding 0x0E, 0x0F, and 0x1B
        if (inRange(bite, 0x00, 0x7F) && bite !== 0x0E
            && bite !== 0x0F && bite !== 0x1B) {
          // Unset the iso-2022-jp output flag and return a code point
          // whose value is byte.
          iso2022jp_output_flag = false;
          return bite;
        }

        // end-of-stream
        if (bite === end_of_stream) {
          // Return finished.
          return finished;
        }

        // Otherwise
        // Unset the iso-2022-jp output flag and return error.
        iso2022jp_output_flag = false;
        return decoderError(fatal);

      case states.Roman:
        // Roman
        // Based on byte:

        // 0x1B
        if (bite === 0x1B) {
          // Set iso-2022-jp decoder state to escape start and return
          // continue.
          iso2022jp_decoder_state = states.EscapeStart;
          return null;
        }

        // 0x5C
        if (bite === 0x5C) {
          // Unset the iso-2022-jp output flag and return code point
          // U+00A5.
          iso2022jp_output_flag = false;
          return 0x00A5;
        }

        // 0x7E
        if (bite === 0x7E) {
          // Unset the iso-2022-jp output flag and return code point
          // U+203E.
          iso2022jp_output_flag = false;
          return 0x203E;
        }

        // 0x00 to 0x7F, excluding 0x0E, 0x0F, 0x1B, 0x5C, and 0x7E
        if (inRange(bite, 0x00, 0x7F) && bite !== 0x0E && bite !== 0x0F
            && bite !== 0x1B && bite !== 0x5C && bite !== 0x7E) {
          // Unset the iso-2022-jp output flag and return a code point
          // whose value is byte.
          iso2022jp_output_flag = false;
          return bite;
        }

        // end-of-stream
        if (bite === end_of_stream) {
          // Return finished.
          return finished;
        }

        // Otherwise
        // Unset the iso-2022-jp output flag and return error.
        iso2022jp_output_flag = false;
        return decoderError(fatal);

      case states.Katakana:
        // Katakana
        // Based on byte:

        // 0x1B
        if (bite === 0x1B) {
          // Set iso-2022-jp decoder state to escape start and return
          // continue.
          iso2022jp_decoder_state = states.EscapeStart;
          return null;
        }

        // 0x21 to 0x5F
        if (inRange(bite, 0x21, 0x5F)) {
          // Unset the iso-2022-jp output flag and return a code point
          // whose value is 0xFF61  0x21 + byte.
          iso2022jp_output_flag = false;
          return 0xFF61 - 0x21 + bite;
        }

        // end-of-stream
        if (bite === end_of_stream) {
          // Return finished.
          return finished;
        }

        // Otherwise
        // Unset the iso-2022-jp output flag and return error.
        iso2022jp_output_flag = false;
        return decoderError(fatal);

      case states.LeadByte:
        // Lead byte
        // Based on byte:

        // 0x1B
        if (bite === 0x1B) {
          // Set iso-2022-jp decoder state to escape start and return
          // continue.
          iso2022jp_decoder_state = states.EscapeStart;
          return null;
        }

        // 0x21 to 0x7E
        if (inRange(bite, 0x21, 0x7E)) {
          // Unset the iso-2022-jp output flag, set iso-2022-jp lead
          // to byte, iso-2022-jp decoder state to trail byte, and
          // return continue.
          iso2022jp_output_flag = false;
          iso2022jp_lead = bite;
          iso2022jp_decoder_state = states.TrailByte;
          return null;
        }

        // end-of-stream
        if (bite === end_of_stream) {
          // Return finished.
          return finished;
        }

        // Otherwise
        // Unset the iso-2022-jp output flag and return error.
        iso2022jp_output_flag = false;
        return decoderError(fatal);

      case states.TrailByte:
        // Trail byte
        // Based on byte:

        // 0x1B
        if (bite === 0x1B) {
          // Set iso-2022-jp decoder state to escape start and return
          // continue.
          iso2022jp_decoder_state = states.EscapeStart;
          return decoderError(fatal);
        }

        // 0x21 to 0x7E
        if (inRange(bite, 0x21, 0x7E)) {
          // 1. Set the iso-2022-jp decoder state to lead byte.
          iso2022jp_decoder_state = states.LeadByte;

          // 2. Let pointer be (iso-2022-jp lead  0x21)  94 + byte  0x21.
          var pointer = (iso2022jp_lead - 0x21) * 94 + bite - 0x21;

          // 3. Let code point be the index code point for pointer in
          // index jis0208.
          var code_point = indexCodePointFor(pointer, index('jis0208'));

          // 4. If code point is null, return error.
          if (code_point === null)
            return decoderError(fatal);

          // 5. Return a code point whose value is code point.
          return code_point;
        }

        // end-of-stream
        if (bite === end_of_stream) {
          // Set the iso-2022-jp decoder state to lead byte, prepend
          // byte to stream, and return error.
          iso2022jp_decoder_state = states.LeadByte;
          stream.prepend(bite);
          return decoderError(fatal);
        }

        // Otherwise
        // Set iso-2022-jp decoder state to lead byte and return
        // error.
        iso2022jp_decoder_state = states.LeadByte;
        return decoderError(fatal);

      case states.EscapeStart:
        // Escape start

        // 1. If byte is either 0x24 or 0x28, set iso-2022-jp lead to
        // byte, iso-2022-jp decoder state to escape, and return
        // continue.
        if (bite === 0x24 || bite === 0x28) {
          iso2022jp_lead = bite;
          iso2022jp_decoder_state = states.Escape;
          return null;
        }

        // 2. Prepend byte to stream.
        stream.prepend(bite);

        // 3. Unset the iso-2022-jp output flag, set iso-2022-jp
        // decoder state to iso-2022-jp decoder output state, and
        // return error.
        iso2022jp_output_flag = false;
        iso2022jp_decoder_state = iso2022jp_decoder_output_state;
        return decoderError(fatal);

      case states.Escape:
        // Escape

        // 1. Let lead be iso-2022-jp lead and set iso-2022-jp lead to
        // 0x00.
        var lead = iso2022jp_lead;
        iso2022jp_lead = 0x00;

        // 2. Let state be null.
        var state = null;

        // 3. If lead is 0x28 and byte is 0x42, set state to ASCII.
        if (lead === 0x28 && bite === 0x42)
          state = states.ASCII;

        // 4. If lead is 0x28 and byte is 0x4A, set state to Roman.
        if (lead === 0x28 && bite === 0x4A)
          state = states.Roman;

        // 5. If lead is 0x28 and byte is 0x49, set state to Katakana.
        if (lead === 0x28 && bite === 0x49)
          state = states.Katakana;

        // 6. If lead is 0x24 and byte is either 0x40 or 0x42, set
        // state to lead byte.
        if (lead === 0x24 && (bite === 0x40 || bite === 0x42))
          state = states.LeadByte;

        // 7. If state is non-null, run these substeps:
        if (state !== null) {
          // 1. Set iso-2022-jp decoder state and iso-2022-jp decoder
          // output state to states.
          iso2022jp_decoder_state = iso2022jp_decoder_state = state;

          // 2. Let output flag be the iso-2022-jp output flag.
          var output_flag = iso2022jp_output_flag;

          // 3. Set the iso-2022-jp output flag.
          iso2022jp_output_flag = true;

          // 4. Return continue, if output flag is unset, and error
          // otherwise.
          return !output_flag ? null : decoderError(fatal);
        }

        // 8. Prepend lead and byte to stream.
        stream.prepend([lead, bite]);

        // 9. Unset the iso-2022-jp output flag, set iso-2022-jp
        // decoder state to iso-2022-jp decoder output state and
        // return error.
        iso2022jp_output_flag = false;
        iso2022jp_decoder_state = iso2022jp_decoder_output_state;
        return decoderError(fatal);
      }
    };
  }

  // 13.2.2 iso-2022-jp encoder
  /**
   * @constructor
   * @implements {Encoder}
   * @param {{fatal: boolean}} options
   */
  function ISO2022JPEncoder(options) {
    var fatal = options.fatal;
    // iso-2022-jp's encoder has an associated iso-2022-jp encoder
    // state which is one of ASCII, Roman, and jis0208 (initially
    // ASCII).
    /** @enum */
    var states = {
      ASCII: 0,
      Roman: 1,
      jis0208: 2
    };
    var /** @type {number} */ iso2022jp_state = states.ASCII;
    /**
     * @param {Stream} stream Input stream.
     * @param {number} code_point Next code point read from the stream.
     * @return {(number|!Array.<number>)} Byte(s) to emit.
     */
    this.handler = function(stream, code_point) {
      // 1. If code point is end-of-stream and iso-2022-jp encoder
      // state is not ASCII, prepend code point to stream, set
      // iso-2022-jp encoder state to ASCII, and return three bytes
      // 0x1B 0x28 0x42.
      if (code_point === end_of_stream &&
          iso2022jp_state !== states.ASCII) {
        stream.prepend(code_point);
        iso2022jp_state = states.ASCII;
        return [0x1B, 0x28, 0x42];
      }

      // 2. If code point is end-of-stream and iso-2022-jp encoder
      // state is ASCII, return finished.
      if (code_point === end_of_stream && iso2022jp_state === states.ASCII)
        return finished;

      // 3. If ISO-2022-JP encoder state is ASCII or Roman, and code
      // point is U+000E, U+000F, or U+001B, return error with U+FFFD.
      if ((iso2022jp_state === states.ASCII ||
           iso2022jp_state === states.Roman) &&
          (code_point === 0x000E || code_point === 0x000F ||
           code_point === 0x001B)) {
        return encoderError(0xFFFD);
      }

      // 4. If iso-2022-jp encoder state is ASCII and code point is an
      // ASCII code point, return a byte whose value is code point.
      if (iso2022jp_state === states.ASCII &&
          isASCIICodePoint(code_point))
        return code_point;

      // 5. If iso-2022-jp encoder state is Roman and code point is an
      // ASCII code point, excluding U+005C and U+007E, or is U+00A5
      // or U+203E, run these substeps:
      if (iso2022jp_state === states.Roman &&
          ((isASCIICodePoint(code_point) &&
           code_point !== 0x005C && code_point !== 0x007E) ||
          (code_point == 0x00A5 || code_point == 0x203E))) {

        // 1. If code point is an ASCII code point, return a byte
        // whose value is code point.
        if (isASCIICodePoint(code_point))
          return code_point;

        // 2. If code point is U+00A5, return byte 0x5C.
        if (code_point === 0x00A5)
          return 0x5C;

        // 3. If code point is U+203E, return byte 0x7E.
        if (code_point === 0x203E)
          return 0x7E;
      }

      // 6. If code point is an ASCII code point, and iso-2022-jp
      // encoder state is not ASCII, prepend code point to stream, set
      // iso-2022-jp encoder state to ASCII, and return three bytes
      // 0x1B 0x28 0x42.
      if (isASCIICodePoint(code_point) &&
          iso2022jp_state !== states.ASCII) {
        stream.prepend(code_point);
        iso2022jp_state = states.ASCII;
        return [0x1B, 0x28, 0x42];
      }

      // 7. If code point is either U+00A5 or U+203E, and iso-2022-jp
      // encoder state is not Roman, prepend code point to stream, set
      // iso-2022-jp encoder state to Roman, and return three bytes
      // 0x1B 0x28 0x4A.
      if ((code_point === 0x00A5 || code_point === 0x203E) &&
          iso2022jp_state !== states.Roman) {
        stream.prepend(code_point);
        iso2022jp_state = states.Roman;
        return [0x1B, 0x28, 0x4A];
      }

      // 8. If code point is U+2212, set it to U+FF0D.
      if (code_point === 0x2212)
        code_point = 0xFF0D;

      // 9. Let pointer be the index pointer for code point in index
      // jis0208.
      var pointer = indexPointerFor(code_point, index('jis0208'));

      // 10. If pointer is null, return error with code point.
      if (pointer === null)
        return encoderError(code_point);

      // 11. If iso-2022-jp encoder state is not jis0208, prepend code
      // point to stream, set iso-2022-jp encoder state to jis0208,
      // and return three bytes 0x1B 0x24 0x42.
      if (iso2022jp_state !== states.jis0208) {
        stream.prepend(code_point);
        iso2022jp_state = states.jis0208;
        return [0x1B, 0x24, 0x42];
      }

      // 12. Let lead be floor(pointer / 94) + 0x21.
      var lead = floor(pointer / 94) + 0x21;

      // 13. Let trail be pointer % 94 + 0x21.
      var trail = pointer % 94 + 0x21;

      // 14. Return two bytes whose values are lead and trail.
      return [lead, trail];
    };
  }

  /** @param {{fatal: boolean}} options */
  encoders['ISO-2022-JP'] = function(options) {
    return new ISO2022JPEncoder(options);
  };
  /** @param {{fatal: boolean}} options */
  decoders['ISO-2022-JP'] = function(options) {
    return new ISO2022JPDecoder(options);
  };

  // 13.3 Shift_JIS

  // 13.3.1 Shift_JIS decoder
  /**
   * @constructor
   * @implements {Decoder}
   * @param {{fatal: boolean}} options
   */
  function ShiftJISDecoder(options) {
    var fatal = options.fatal;
    // Shift_JIS's decoder has an associated Shift_JIS lead (initially
    // 0x00).
    var /** @type {number} */ Shift_JIS_lead = 0x00;
    /**
     * @param {Stream} stream The stream of bytes being decoded.
     * @param {number} bite The next byte read from the stream.
     * @return {?(number|!Array.<number>)} The next code point(s)
     *     decoded, or null if not enough data exists in the input
     *     stream to decode a complete code point.
     */
    this.handler = function(stream, bite) {
      // 1. If byte is end-of-stream and Shift_JIS lead is not 0x00,
      // set Shift_JIS lead to 0x00 and return error.
      if (bite === end_of_stream && Shift_JIS_lead !== 0x00) {
        Shift_JIS_lead = 0x00;
        return decoderError(fatal);
      }

      // 2. If byte is end-of-stream and Shift_JIS lead is 0x00,
      // return finished.
      if (bite === end_of_stream && Shift_JIS_lead === 0x00)
        return finished;

      // 3. If Shift_JIS lead is not 0x00, let lead be Shift_JIS lead,
      // let pointer be null, set Shift_JIS lead to 0x00, and then run
      // these substeps:
      if (Shift_JIS_lead !== 0x00) {
        var lead = Shift_JIS_lead;
        var pointer = null;
        Shift_JIS_lead = 0x00;

        // 1. Let offset be 0x40, if byte is less than 0x7F, and 0x41
        // otherwise.
        var offset = (bite < 0x7F) ? 0x40 : 0x41;

        // 2. Let lead offset be 0x81, if lead is less than 0xA0, and
        // 0xC1 otherwise.
        var lead_offset = (lead < 0xA0) ? 0x81 : 0xC1;

        // 3. If byte is in the range 0x40 to 0x7E, inclusive, or 0x80
        // to 0xFC, inclusive, set pointer to (lead  lead offset) 
        // 188 + byte  offset.
        if (inRange(bite, 0x40, 0x7E) || inRange(bite, 0x80, 0xFC))
          pointer = (lead - lead_offset) * 188 + bite - offset;

        // 4. If pointer is in the range 8836 to 10715, inclusive,
        // return a code point whose value is 0xE000  8836 + pointer.
        if (inRange(pointer, 8836, 10715))
          return 0xE000 - 8836 + pointer;

        // 5. Let code point be null, if pointer is null, and the
        // index code point for pointer in index jis0208 otherwise.
        var code_point = (pointer === null) ? null :
              indexCodePointFor(pointer, index('jis0208'));

        // 6. If code point is null and byte is an ASCII byte, prepend
        // byte to stream.
        if (code_point === null && isASCIIByte(bite))
          stream.prepend(bite);

        // 7. If code point is null, return error.
        if (code_point === null)
          return decoderError(fatal);

        // 8. Return a code point whose value is code point.
        return code_point;
      }

      // 4. If byte is an ASCII byte or 0x80, return a code point
      // whose value is byte.
      if (isASCIIByte(bite) || bite === 0x80)
        return bite;

      // 5. If byte is in the range 0xA1 to 0xDF, inclusive, return a
      // code point whose value is 0xFF61  0xA1 + byte.
      if (inRange(bite, 0xA1, 0xDF))
        return 0xFF61 - 0xA1 + bite;

      // 6. If byte is in the range 0x81 to 0x9F, inclusive, or 0xE0
      // to 0xFC, inclusive, set Shift_JIS lead to byte and return
      // continue.
      if (inRange(bite, 0x81, 0x9F) || inRange(bite, 0xE0, 0xFC)) {
        Shift_JIS_lead = bite;
        return null;
      }

      // 7. Return error.
      return decoderError(fatal);
    };
  }

  // 13.3.2 Shift_JIS encoder
  /**
   * @constructor
   * @implements {Encoder}
   * @param {{fatal: boolean}} options
   */
  function ShiftJISEncoder(options) {
    var fatal = options.fatal;
    /**
     * @param {Stream} stream Input stream.
     * @param {number} code_point Next code point read from the stream.
     * @return {(number|!Array.<number>)} Byte(s) to emit.
     */
    this.handler = function(stream, code_point) {
      // 1. If code point is end-of-stream, return finished.
      if (code_point === end_of_stream)
        return finished;

      // 2. If code point is an ASCII code point or U+0080, return a
      // byte whose value is code point.
      if (isASCIICodePoint(code_point) || code_point === 0x0080)
        return code_point;

      // 3. If code point is U+00A5, return byte 0x5C.
      if (code_point === 0x00A5)
        return 0x5C;

      // 4. If code point is U+203E, return byte 0x7E.
      if (code_point === 0x203E)
        return 0x7E;

      // 5. If code point is in the range U+FF61 to U+FF9F, inclusive,
      // return a byte whose value is code point  0xFF61 + 0xA1.
      if (inRange(code_point, 0xFF61, 0xFF9F))
        return code_point - 0xFF61 + 0xA1;

      // 6. If code point is U+2212, set it to U+FF0D.
      if (code_point === 0x2212)
        code_point = 0xFF0D;

      // 7. Let pointer be the index Shift_JIS pointer for code point.
      var pointer = indexShiftJISPointerFor(code_point);

      // 8. If pointer is null, return error with code point.
      if (pointer === null)
        return encoderError(code_point);

      // 9. Let lead be floor(pointer / 188).
      var lead = floor(pointer / 188);

      // 10. Let lead offset be 0x81, if lead is less than 0x1F, and
      // 0xC1 otherwise.
      var lead_offset = (lead < 0x1F) ? 0x81 : 0xC1;

      // 11. Let trail be pointer % 188.
      var trail = pointer % 188;

      // 12. Let offset be 0x40, if trail is less than 0x3F, and 0x41
      // otherwise.
      var offset = (trail < 0x3F) ? 0x40 : 0x41;

      // 13. Return two bytes whose values are lead + lead offset and
      // trail + offset.
      return [lead + lead_offset, trail + offset];
    };
  }

  /** @param {{fatal: boolean}} options */
  encoders['Shift_JIS'] = function(options) {
    return new ShiftJISEncoder(options);
  };
  /** @param {{fatal: boolean}} options */
  decoders['Shift_JIS'] = function(options) {
    return new ShiftJISDecoder(options);
  };

  //
  // 14. Legacy multi-byte Korean encodings
  //

  // 14.1 euc-kr

  // 14.1.1 euc-kr decoder
  /**
   * @constructor
   * @implements {Decoder}
   * @param {{fatal: boolean}} options
   */
  function EUCKRDecoder(options) {
    var fatal = options.fatal;

    // euc-kr's decoder has an associated euc-kr lead (initially 0x00).
    var /** @type {number} */ euckr_lead = 0x00;
    /**
     * @param {Stream} stream The stream of bytes being decoded.
     * @param {number} bite The next byte read from the stream.
     * @return {?(number|!Array.<number>)} The next code point(s)
     *     decoded, or null if not enough data exists in the input
     *     stream to decode a complete code point.
     */
    this.handler = function(stream, bite) {
      // 1. If byte is end-of-stream and euc-kr lead is not 0x00, set
      // euc-kr lead to 0x00 and return error.
      if (bite === end_of_stream && euckr_lead !== 0) {
        euckr_lead = 0x00;
        return decoderError(fatal);
      }

      // 2. If byte is end-of-stream and euc-kr lead is 0x00, return
      // finished.
      if (bite === end_of_stream && euckr_lead === 0)
        return finished;

      // 3. If euc-kr lead is not 0x00, let lead be euc-kr lead, let
      // pointer be null, set euc-kr lead to 0x00, and then run these
      // substeps:
      if (euckr_lead !== 0x00) {
        var lead = euckr_lead;
        var pointer = null;
        euckr_lead = 0x00;

        // 1. If byte is in the range 0x41 to 0xFE, inclusive, set
        // pointer to (lead  0x81)  190 + (byte  0x41).
        if (inRange(bite, 0x41, 0xFE))
          pointer = (lead - 0x81) * 190 + (bite - 0x41);

        // 2. Let code point be null, if pointer is null, and the
        // index code point for pointer in index euc-kr otherwise.
        var code_point = (pointer === null)
              ? null : indexCodePointFor(pointer, index('euc-kr'));

        // 3. If code point is null and byte is an ASCII byte, prepend
        // byte to stream.
        if (pointer === null && isASCIIByte(bite))
          stream.prepend(bite);

        // 4. If code point is null, return error.
        if (code_point === null)
          return decoderError(fatal);

        // 5. Return a code point whose value is code point.
        return code_point;
      }

      // 4. If byte is an ASCII byte, return a code point whose value
      // is byte.
      if (isASCIIByte(bite))
        return bite;

      // 5. If byte is in the range 0x81 to 0xFE, inclusive, set
      // euc-kr lead to byte and return continue.
      if (inRange(bite, 0x81, 0xFE)) {
        euckr_lead = bite;
        return null;
      }

      // 6. Return error.
      return decoderError(fatal);
    };
  }

  // 14.1.2 euc-kr encoder
  /**
   * @constructor
   * @implements {Encoder}
   * @param {{fatal: boolean}} options
   */
  function EUCKREncoder(options) {
    var fatal = options.fatal;
    /**
     * @param {Stream} stream Input stream.
     * @param {number} code_point Next code point read from the stream.
     * @return {(number|!Array.<number>)} Byte(s) to emit.
     */
    this.handler = function(stream, code_point) {
      // 1. If code point is end-of-stream, return finished.
      if (code_point === end_of_stream)
        return finished;

      // 2. If code point is an ASCII code point, return a byte whose
      // value is code point.
      if (isASCIICodePoint(code_point))
        return code_point;

      // 3. Let pointer be the index pointer for code point in index
      // euc-kr.
      var pointer = indexPointerFor(code_point, index('euc-kr'));

      // 4. If pointer is null, return error with code point.
      if (pointer === null)
        return encoderError(code_point);

      // 5. Let lead be floor(pointer / 190) + 0x81.
      var lead = floor(pointer / 190) + 0x81;

      // 6. Let trail be pointer % 190 + 0x41.
      var trail = (pointer % 190) + 0x41;

      // 7. Return two bytes whose values are lead and trail.
      return [lead, trail];
    };
  }

  /** @param {{fatal: boolean}} options */
  encoders['EUC-KR'] = function(options) {
    return new EUCKREncoder(options);
  };
  /** @param {{fatal: boolean}} options */
  decoders['EUC-KR'] = function(options) {
    return new EUCKRDecoder(options);
  };


  //
  // 15. Legacy miscellaneous encodings
  //

  // 15.1 replacement

  // Not needed - API throws RangeError

  // 15.2 Common infrastructure for utf-16be and utf-16le

  /**
   * @param {number} code_unit
   * @param {boolean} utf16be
   * @return {!Array.<number>} bytes
   */
  function convertCodeUnitToBytes(code_unit, utf16be) {
    // 1. Let byte1 be code unit >> 8.
    var byte1 = code_unit >> 8;

    // 2. Let byte2 be code unit & 0x00FF.
    var byte2 = code_unit & 0x00FF;

    // 3. Then return the bytes in order:
        // utf-16be flag is set: byte1, then byte2.
    if (utf16be)
      return [byte1, byte2];
    // utf-16be flag is unset: byte2, then byte1.
    return [byte2, byte1];
  }

  // 15.2.1 shared utf-16 decoder
  /**
   * @constructor
   * @implements {Decoder}
   * @param {boolean} utf16_be True if big-endian, false if little-endian.
   * @param {{fatal: boolean}} options
   */
  function UTF16Decoder(utf16_be, options) {
    var fatal = options.fatal;
    var /** @type {?number} */ utf16_lead_byte = null,
        /** @type {?number} */ utf16_lead_surrogate = null;
    /**
     * @param {Stream} stream The stream of bytes being decoded.
     * @param {number} bite The next byte read from the stream.
     * @return {?(number|!Array.<number>)} The next code point(s)
     *     decoded, or null if not enough data exists in the input
     *     stream to decode a complete code point.
     */
    this.handler = function(stream, bite) {
      // 1. If byte is end-of-stream and either utf-16 lead byte or
      // utf-16 lead surrogate is not null, set utf-16 lead byte and
      // utf-16 lead surrogate to null, and return error.
      if (bite === end_of_stream && (utf16_lead_byte !== null ||
                                utf16_lead_surrogate !== null)) {
        return decoderError(fatal);
      }

      // 2. If byte is end-of-stream and utf-16 lead byte and utf-16
      // lead surrogate are null, return finished.
      if (bite === end_of_stream && utf16_lead_byte === null &&
          utf16_lead_surrogate === null) {
        return finished;
      }

      // 3. If utf-16 lead byte is null, set utf-16 lead byte to byte
      // and return continue.
      if (utf16_lead_byte === null) {
        utf16_lead_byte = bite;
        return null;
      }

      // 4. Let code unit be the result of:
      var code_unit;
      if (utf16_be) {
        // utf-16be decoder flag is set
        //   (utf-16 lead byte << 8) + byte.
        code_unit = (utf16_lead_byte << 8) + bite;
      } else {
        // utf-16be decoder flag is unset
        //   (byte << 8) + utf-16 lead byte.
        code_unit = (bite << 8) + utf16_lead_byte;
      }
      // Then set utf-16 lead byte to null.
      utf16_lead_byte = null;

      // 5. If utf-16 lead surrogate is not null, let lead surrogate
      // be utf-16 lead surrogate, set utf-16 lead surrogate to null,
      // and then run these substeps:
      if (utf16_lead_surrogate !== null) {
        var lead_surrogate = utf16_lead_surrogate;
        utf16_lead_surrogate = null;

        // 1. If code unit is in the range U+DC00 to U+DFFF,
        // inclusive, return a code point whose value is 0x10000 +
        // ((lead surrogate  0xD800) << 10) + (code unit  0xDC00).
        if (inRange(code_unit, 0xDC00, 0xDFFF)) {
          return 0x10000 + (lead_surrogate - 0xD800) * 0x400 +
              (code_unit - 0xDC00);
        }

        // 2. Prepend the sequence resulting of converting code unit
        // to bytes using utf-16be decoder flag to stream and return
        // error.
        stream.prepend(convertCodeUnitToBytes(code_unit, utf16_be));
        return decoderError(fatal);
      }

      // 6. If code unit is in the range U+D800 to U+DBFF, inclusive,
      // set utf-16 lead surrogate to code unit and return continue.
      if (inRange(code_unit, 0xD800, 0xDBFF)) {
        utf16_lead_surrogate = code_unit;
        return null;
      }

      // 7. If code unit is in the range U+DC00 to U+DFFF, inclusive,
      // return error.
      if (inRange(code_unit, 0xDC00, 0xDFFF))
        return decoderError(fatal);

      // 8. Return code point code unit.
      return code_unit;
    };
  }

  // 15.2.2 shared utf-16 encoder
  /**
   * @constructor
   * @implements {Encoder}
   * @param {boolean} utf16_be True if big-endian, false if little-endian.
   * @param {{fatal: boolean}} options
   */
  function UTF16Encoder(utf16_be, options) {
    var fatal = options.fatal;
    /**
     * @param {Stream} stream Input stream.
     * @param {number} code_point Next code point read from the stream.
     * @return {(number|!Array.<number>)} Byte(s) to emit.
     */
    this.handler = function(stream, code_point) {
      // 1. If code point is end-of-stream, return finished.
      if (code_point === end_of_stream)
        return finished;

      // 2. If code point is in the range U+0000 to U+FFFF, inclusive,
      // return the sequence resulting of converting code point to
      // bytes using utf-16be encoder flag.
      if (inRange(code_point, 0x0000, 0xFFFF))
        return convertCodeUnitToBytes(code_point, utf16_be);

      // 3. Let lead be ((code point  0x10000) >> 10) + 0xD800,
      // converted to bytes using utf-16be encoder flag.
      var lead = convertCodeUnitToBytes(
        ((code_point - 0x10000) >> 10) + 0xD800, utf16_be);

      // 4. Let trail be ((code point  0x10000) & 0x3FF) + 0xDC00,
      // converted to bytes using utf-16be encoder flag.
      var trail = convertCodeUnitToBytes(
        ((code_point - 0x10000) & 0x3FF) + 0xDC00, utf16_be);

      // 5. Return a byte sequence of lead followed by trail.
      return lead.concat(trail);
    };
  }

  // 15.3 utf-16be
  // 15.3.1 utf-16be decoder
  /** @param {{fatal: boolean}} options */
  encoders['UTF-16BE'] = function(options) {
    return new UTF16Encoder(true, options);
  };
  // 15.3.2 utf-16be encoder
  /** @param {{fatal: boolean}} options */
  decoders['UTF-16BE'] = function(options) {
    return new UTF16Decoder(true, options);
  };

  // 15.4 utf-16le
  // 15.4.1 utf-16le decoder
  /** @param {{fatal: boolean}} options */
  encoders['UTF-16LE'] = function(options) {
    return new UTF16Encoder(false, options);
  };
  // 15.4.2 utf-16le encoder
  /** @param {{fatal: boolean}} options */
  decoders['UTF-16LE'] = function(options) {
    return new UTF16Decoder(false, options);
  };

  // 15.5 x-user-defined

  // 15.5.1 x-user-defined decoder
  /**
   * @constructor
   * @implements {Decoder}
   * @param {{fatal: boolean}} options
   */
  function XUserDefinedDecoder(options) {
    var fatal = options.fatal;
    /**
     * @param {Stream} stream The stream of bytes being decoded.
     * @param {number} bite The next byte read from the stream.
     * @return {?(number|!Array.<number>)} The next code point(s)
     *     decoded, or null if not enough data exists in the input
     *     stream to decode a complete code point.
     */
    this.handler = function(stream, bite) {
      // 1. If byte is end-of-stream, return finished.
      if (bite === end_of_stream)
        return finished;

      // 2. If byte is an ASCII byte, return a code point whose value
      // is byte.
      if (isASCIIByte(bite))
        return bite;

      // 3. Return a code point whose value is 0xF780 + byte  0x80.
      return 0xF780 + bite - 0x80;
    };
  }

  // 15.5.2 x-user-defined encoder
  /**
   * @constructor
   * @implements {Encoder}
   * @param {{fatal: boolean}} options
   */
  function XUserDefinedEncoder(options) {
    var fatal = options.fatal;
    /**
     * @param {Stream} stream Input stream.
     * @param {number} code_point Next code point read from the stream.
     * @return {(number|!Array.<number>)} Byte(s) to emit.
     */
    this.handler = function(stream, code_point) {
      // 1.If code point is end-of-stream, return finished.
      if (code_point === end_of_stream)
        return finished;

      // 2. If code point is an ASCII code point, return a byte whose
      // value is code point.
      if (isASCIICodePoint(code_point))
        return code_point;

      // 3. If code point is in the range U+F780 to U+F7FF, inclusive,
      // return a byte whose value is code point  0xF780 + 0x80.
      if (inRange(code_point, 0xF780, 0xF7FF))
        return code_point - 0xF780 + 0x80;

      // 4. Return error with code point.
      return encoderError(code_point);
    };
  }

  /** @param {{fatal: boolean}} options */
  encoders['x-user-defined'] = function(options) {
    return new XUserDefinedEncoder(options);
  };
  /** @param {{fatal: boolean}} options */
  decoders['x-user-defined'] = function(options) {
    return new XUserDefinedDecoder(options);
  };

  if (!global['TextEncoder'])
    global['TextEncoder'] = TextEncoder;
  if (!global['TextDecoder'])
    global['TextDecoder'] = TextDecoder;

  if (typeof module !== "undefined" && module.exports) {
    module.exports = {
      TextEncoder: global['TextEncoder'],
      TextDecoder: global['TextDecoder'],
      EncodingIndexes: global["encoding-indexes"]
    };
  }

// For strict environments where `this` inside the global scope
// is `undefined`, take a pure object instead
}(this || {}));
},{}],197:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],198:[function(require,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],199:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./support/isBuffer":198,"_process":186,"inherits":197}],200:[function(require,module,exports){
var v1 = require('./v1');
var v4 = require('./v4');

var uuid = v4;
uuid.v1 = v1;
uuid.v4 = v4;

module.exports = uuid;

},{"./v1":203,"./v4":204}],201:[function(require,module,exports){
/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */
var byteToHex = [];
for (var i = 0; i < 256; ++i) {
  byteToHex[i] = (i + 0x100).toString(16).substr(1);
}

function bytesToUuid(buf, offset) {
  var i = offset || 0;
  var bth = byteToHex;
  return bth[buf[i++]] + bth[buf[i++]] +
          bth[buf[i++]] + bth[buf[i++]] + '-' +
          bth[buf[i++]] + bth[buf[i++]] + '-' +
          bth[buf[i++]] + bth[buf[i++]] + '-' +
          bth[buf[i++]] + bth[buf[i++]] + '-' +
          bth[buf[i++]] + bth[buf[i++]] +
          bth[buf[i++]] + bth[buf[i++]] +
          bth[buf[i++]] + bth[buf[i++]];
}

module.exports = bytesToUuid;

},{}],202:[function(require,module,exports){
(function (global){
// Unique ID creation requires a high quality random # generator.  In the
// browser this is a little complicated due to unknown quality of Math.random()
// and inconsistent support for the `crypto` API.  We do the best we can via
// feature-detection
var rng;

var crypto = global.crypto || global.msCrypto; // for IE 11
if (crypto && crypto.getRandomValues) {
  // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto
  var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef
  rng = function whatwgRNG() {
    crypto.getRandomValues(rnds8);
    return rnds8;
  };
}

if (!rng) {
  // Math.random()-based (RNG)
  //
  // If all else fails, use Math.random().  It's fast, but is of unspecified
  // quality.
  var rnds = new Array(16);
  rng = function() {
    for (var i = 0, r; i < 16; i++) {
      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;
      rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
    }

    return rnds;
  };
}

module.exports = rng;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],203:[function(require,module,exports){
var rng = require('./lib/rng');
var bytesToUuid = require('./lib/bytesToUuid');

// **`v1()` - Generate time-based UUID**
//
// Inspired by https://github.com/LiosK/UUID.js
// and http://docs.python.org/library/uuid.html

// random #'s we need to init node and clockseq
var _seedBytes = rng();

// Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
var _nodeId = [
  _seedBytes[0] | 0x01,
  _seedBytes[1], _seedBytes[2], _seedBytes[3], _seedBytes[4], _seedBytes[5]
];

// Per 4.2.2, randomize (14 bit) clockseq
var _clockseq = (_seedBytes[6] << 8 | _seedBytes[7]) & 0x3fff;

// Previous uuid creation time
var _lastMSecs = 0, _lastNSecs = 0;

// See https://github.com/broofa/node-uuid for API details
function v1(options, buf, offset) {
  var i = buf && offset || 0;
  var b = buf || [];

  options = options || {};

  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;

  // UUID timestamps are 100 nano-second units since the Gregorian epoch,
  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.
  var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime();

  // Per 4.2.1.2, use count of uuid's generated during the current clock
  // cycle to simulate higher resolution clock
  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;

  // Time since last uuid creation (in msecs)
  var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;

  // Per 4.2.1.2, Bump clockseq on clock regression
  if (dt < 0 && options.clockseq === undefined) {
    clockseq = clockseq + 1 & 0x3fff;
  }

  // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
  // time interval
  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
    nsecs = 0;
  }

  // Per 4.2.1.2 Throw error if too many uuids are requested
  if (nsecs >= 10000) {
    throw new Error('uuid.v1(): Can\'t create more than 10M uuids/sec');
  }

  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq;

  // Per 4.1.4 - Convert from unix epoch to Gregorian epoch
  msecs += 12219292800000;

  // `time_low`
  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
  b[i++] = tl >>> 24 & 0xff;
  b[i++] = tl >>> 16 & 0xff;
  b[i++] = tl >>> 8 & 0xff;
  b[i++] = tl & 0xff;

  // `time_mid`
  var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;
  b[i++] = tmh >>> 8 & 0xff;
  b[i++] = tmh & 0xff;

  // `time_high_and_version`
  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version
  b[i++] = tmh >>> 16 & 0xff;

  // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)
  b[i++] = clockseq >>> 8 | 0x80;

  // `clock_seq_low`
  b[i++] = clockseq & 0xff;

  // `node`
  var node = options.node || _nodeId;
  for (var n = 0; n < 6; ++n) {
    b[i + n] = node[n];
  }

  return buf ? buf : bytesToUuid(b);
}

module.exports = v1;

},{"./lib/bytesToUuid":201,"./lib/rng":202}],204:[function(require,module,exports){
var rng = require('./lib/rng');
var bytesToUuid = require('./lib/bytesToUuid');

function v4(options, buf, offset) {
  var i = buf && offset || 0;

  if (typeof(options) == 'string') {
    buf = options == 'binary' ? new Array(16) : null;
    options = null;
  }
  options = options || {};

  var rnds = options.random || (options.rng || rng)();

  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
  rnds[6] = (rnds[6] & 0x0f) | 0x40;
  rnds[8] = (rnds[8] & 0x3f) | 0x80;

  // Copy bytes to buffer, if provided
  if (buf) {
    for (var ii = 0; ii < 16; ++ii) {
      buf[i + ii] = rnds[ii];
    }
  }

  return buf || bytesToUuid(rnds);
}

module.exports = v4;

},{"./lib/bytesToUuid":201,"./lib/rng":202}],205:[function(require,module,exports){
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
 /* eslint-env node */

'use strict';

// Shimming starts here.
module.exports = function(dependencies, opts) {
  var window = dependencies && dependencies.window;

  var options = {
    shimChrome: true,
    shimFirefox: true,
    shimEdge: true,
    shimSafari: true,
  };

  for (var key in opts) {
    if (hasOwnProperty.call(opts, key)) {
      options[key] = opts[key];
    }
  }

  // Utils.
  var utils = require('./utils');
  var logging = utils.log;
  var browserDetails = utils.detectBrowser(window);

  // Export to the adapter global object visible in the browser.
  var adapter = {
    browserDetails: browserDetails,
    extractVersion: utils.extractVersion,
    disableLog: utils.disableLog,
    disableWarnings: utils.disableWarnings
  };

  // Uncomment the line below if you want logging to occur, including logging
  // for the switch statement below. Can also be turned on in the browser via
  // adapter.disableLog(false), but then logging from the switch statement below
  // will not appear.
  // require('./utils').disableLog(false);

  // Browser shims.
  var chromeShim = require('./chrome/chrome_shim') || null;
  var edgeShim = require('./edge/edge_shim') || null;
  var firefoxShim = require('./firefox/firefox_shim') || null;
  var safariShim = require('./safari/safari_shim') || null;

  // Shim browser if found.
  switch (browserDetails.browser) {
    case 'chrome':
      if (!chromeShim || !chromeShim.shimPeerConnection ||
          !options.shimChrome) {
        logging('Chrome shim is not included in this adapter release.');
        return adapter;
      }
      logging('adapter.js shimming chrome.');
      // Export to the adapter global object visible in the browser.
      adapter.browserShim = chromeShim;

      chromeShim.shimGetUserMedia(window);
      chromeShim.shimMediaStream(window);
      utils.shimCreateObjectURL(window);
      chromeShim.shimSourceObject(window);
      chromeShim.shimPeerConnection(window);
      chromeShim.shimOnTrack(window);
      chromeShim.shimAddTrackRemoveTrack(window);
      chromeShim.shimGetSendersWithDtmf(window);
      break;
    case 'firefox':
      if (!firefoxShim || !firefoxShim.shimPeerConnection ||
          !options.shimFirefox) {
        logging('Firefox shim is not included in this adapter release.');
        return adapter;
      }
      logging('adapter.js shimming firefox.');
      // Export to the adapter global object visible in the browser.
      adapter.browserShim = firefoxShim;

      firefoxShim.shimGetUserMedia(window);
      utils.shimCreateObjectURL(window);
      firefoxShim.shimSourceObject(window);
      firefoxShim.shimPeerConnection(window);
      firefoxShim.shimOnTrack(window);
      break;
    case 'edge':
      if (!edgeShim || !edgeShim.shimPeerConnection || !options.shimEdge) {
        logging('MS edge shim is not included in this adapter release.');
        return adapter;
      }
      logging('adapter.js shimming edge.');
      // Export to the adapter global object visible in the browser.
      adapter.browserShim = edgeShim;

      edgeShim.shimGetUserMedia(window);
      utils.shimCreateObjectURL(window);
      edgeShim.shimPeerConnection(window);
      edgeShim.shimReplaceTrack(window);
      break;
    case 'safari':
      if (!safariShim || !options.shimSafari) {
        logging('Safari shim is not included in this adapter release.');
        return adapter;
      }
      logging('adapter.js shimming safari.');
      // Export to the adapter global object visible in the browser.
      adapter.browserShim = safariShim;
      // shim window.URL.createObjectURL Safari (technical preview)
      utils.shimCreateObjectURL(window);
      safariShim.shimRTCIceServerUrls(window);
      safariShim.shimCallbacksAPI(window);
      safariShim.shimLocalStreamsAPI(window);
      safariShim.shimRemoteStreamsAPI(window);
      safariShim.shimGetUserMedia(window);
      break;
    default:
      logging('Unsupported browser!');
      break;
  }

  return adapter;
};

},{"./chrome/chrome_shim":206,"./edge/edge_shim":208,"./firefox/firefox_shim":211,"./safari/safari_shim":213,"./utils":214}],206:[function(require,module,exports){

/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
 /* eslint-env node */
'use strict';
var utils = require('../utils.js');
var logging = utils.log;

var chromeShim = {
  shimMediaStream: function(window) {
    window.MediaStream = window.MediaStream || window.webkitMediaStream;
  },

  shimOnTrack: function(window) {
    if (typeof window === 'object' && window.RTCPeerConnection && !('ontrack' in
        window.RTCPeerConnection.prototype)) {
      Object.defineProperty(window.RTCPeerConnection.prototype, 'ontrack', {
        get: function() {
          return this._ontrack;
        },
        set: function(f) {
          if (this._ontrack) {
            this.removeEventListener('track', this._ontrack);
          }
          this.addEventListener('track', this._ontrack = f);
        }
      });
      var origSetRemoteDescription =
          window.RTCPeerConnection.prototype.setRemoteDescription;
      window.RTCPeerConnection.prototype.setRemoteDescription = function() {
        var pc = this;
        if (!pc._ontrackpoly) {
          pc._ontrackpoly = function(e) {
            // onaddstream does not fire when a track is added to an existing
            // stream. But stream.onaddtrack is implemented so we use that.
            e.stream.addEventListener('addtrack', function(te) {
              var receiver;
              if (window.RTCPeerConnection.prototype.getReceivers) {
                receiver = pc.getReceivers().find(function(r) {
                  return r.track.id === te.track.id;
                });
              } else {
                receiver = {track: te.track};
              }

              var event = new Event('track');
              event.track = te.track;
              event.receiver = receiver;
              event.streams = [e.stream];
              pc.dispatchEvent(event);
            });
            e.stream.getTracks().forEach(function(track) {
              var receiver;
              if (window.RTCPeerConnection.prototype.getReceivers) {
                receiver = pc.getReceivers().find(function(r) {
                  return r.track.id === track.id;
                });
              } else {
                receiver = {track: track};
              }
              var event = new Event('track');
              event.track = track;
              event.receiver = receiver;
              event.streams = [e.stream];
              pc.dispatchEvent(event);
            });
          };
          pc.addEventListener('addstream', pc._ontrackpoly);
        }
        return origSetRemoteDescription.apply(pc, arguments);
      };
    }
  },

  shimGetSendersWithDtmf: function(window) {
    // Overrides addTrack/removeTrack, depends on shimAddTrackRemoveTrack.
    if (typeof window === 'object' && window.RTCPeerConnection &&
        !('getSenders' in window.RTCPeerConnection.prototype) &&
        'createDTMFSender' in window.RTCPeerConnection.prototype) {
      var shimSenderWithDtmf = function(pc, track) {
        return {
          track: track,
          get dtmf() {
            if (this._dtmf === undefined) {
              if (track.kind === 'audio') {
                this._dtmf = pc.createDTMFSender(track);
              } else {
                this._dtmf = null;
              }
            }
            return this._dtmf;
          },
          _pc: pc
        };
      };

      // augment addTrack when getSenders is not available.
      if (!window.RTCPeerConnection.prototype.getSenders) {
        window.RTCPeerConnection.prototype.getSenders = function() {
          this._senders = this._senders || [];
          return this._senders.slice(); // return a copy of the internal state.
        };
        var origAddTrack = window.RTCPeerConnection.prototype.addTrack;
        window.RTCPeerConnection.prototype.addTrack = function(track, stream) {
          var pc = this;
          var sender = origAddTrack.apply(pc, arguments);
          if (!sender) {
            sender = shimSenderWithDtmf(pc, track);
            pc._senders.push(sender);
          }
          return sender;
        };

        var origRemoveTrack = window.RTCPeerConnection.prototype.removeTrack;
        window.RTCPeerConnection.prototype.removeTrack = function(sender) {
          var pc = this;
          origRemoveTrack.apply(pc, arguments);
          var idx = pc._senders.indexOf(sender);
          if (idx !== -1) {
            pc._senders.splice(idx, 1);
          }
        };
      }
      var origAddStream = window.RTCPeerConnection.prototype.addStream;
      window.RTCPeerConnection.prototype.addStream = function(stream) {
        var pc = this;
        pc._senders = pc._senders || [];
        origAddStream.apply(pc, [stream]);
        stream.getTracks().forEach(function(track) {
          pc._senders.push(shimSenderWithDtmf(pc, track));
        });
      };

      var origRemoveStream = window.RTCPeerConnection.prototype.removeStream;
      window.RTCPeerConnection.prototype.removeStream = function(stream) {
        var pc = this;
        pc._senders = pc._senders || [];
        origRemoveStream.apply(pc, [(pc._streams[stream.id] || stream)]);

        stream.getTracks().forEach(function(track) {
          var sender = pc._senders.find(function(s) {
            return s.track === track;
          });
          if (sender) {
            pc._senders.splice(pc._senders.indexOf(sender), 1); // remove sender
          }
        });
      };
    } else if (typeof window === 'object' && window.RTCPeerConnection &&
               'getSenders' in window.RTCPeerConnection.prototype &&
               'createDTMFSender' in window.RTCPeerConnection.prototype &&
               window.RTCRtpSender &&
               !('dtmf' in window.RTCRtpSender.prototype)) {
      var origGetSenders = window.RTCPeerConnection.prototype.getSenders;
      window.RTCPeerConnection.prototype.getSenders = function() {
        var pc = this;
        var senders = origGetSenders.apply(pc, []);
        senders.forEach(function(sender) {
          sender._pc = pc;
        });
        return senders;
      };

      Object.defineProperty(window.RTCRtpSender.prototype, 'dtmf', {
        get: function() {
          if (this._dtmf === undefined) {
            if (this.track.kind === 'audio') {
              this._dtmf = this._pc.createDTMFSender(this.track);
            } else {
              this._dtmf = null;
            }
          }
          return this._dtmf;
        }
      });
    }
  },

  shimSourceObject: function(window) {
    var URL = window && window.URL;

    if (typeof window === 'object') {
      if (window.HTMLMediaElement &&
        !('srcObject' in window.HTMLMediaElement.prototype)) {
        // Shim the srcObject property, once, when HTMLMediaElement is found.
        Object.defineProperty(window.HTMLMediaElement.prototype, 'srcObject', {
          get: function() {
            return this._srcObject;
          },
          set: function(stream) {
            var self = this;
            // Use _srcObject as a private property for this shim
            this._srcObject = stream;
            if (this.src) {
              URL.revokeObjectURL(this.src);
            }

            if (!stream) {
              this.src = '';
              return undefined;
            }
            this.src = URL.createObjectURL(stream);
            // We need to recreate the blob url when a track is added or
            // removed. Doing it manually since we want to avoid a recursion.
            stream.addEventListener('addtrack', function() {
              if (self.src) {
                URL.revokeObjectURL(self.src);
              }
              self.src = URL.createObjectURL(stream);
            });
            stream.addEventListener('removetrack', function() {
              if (self.src) {
                URL.revokeObjectURL(self.src);
              }
              self.src = URL.createObjectURL(stream);
            });
          }
        });
      }
    }
  },

  shimAddTrackRemoveTrack: function(window) {
    // shim addTrack and removeTrack.
    if (window.RTCPeerConnection.prototype.addTrack) {
      return;
    }

    // also shim pc.getLocalStreams when addTrack is shimmed
    // to return the original streams.
    var origGetLocalStreams = window.RTCPeerConnection.prototype
        .getLocalStreams;
    window.RTCPeerConnection.prototype.getLocalStreams = function() {
      var self = this;
      var nativeStreams = origGetLocalStreams.apply(this);
      self._reverseStreams = self._reverseStreams || {};
      return nativeStreams.map(function(stream) {
        return self._reverseStreams[stream.id];
      });
    };

    var origAddStream = window.RTCPeerConnection.prototype.addStream;
    window.RTCPeerConnection.prototype.addStream = function(stream) {
      var pc = this;
      pc._streams = pc._streams || {};
      pc._reverseStreams = pc._reverseStreams || {};

      stream.getTracks().forEach(function(track) {
        var alreadyExists = pc.getSenders().find(function(s) {
          return s.track === track;
        });
        if (alreadyExists) {
          throw new DOMException('Track already exists.',
              'InvalidAccessError');
        }
      });
      // Add identity mapping for consistency with addTrack.
      // Unless this is being used with a stream from addTrack.
      if (!pc._reverseStreams[stream.id]) {
        var newStream = new window.MediaStream(stream.getTracks());
        pc._streams[stream.id] = newStream;
        pc._reverseStreams[newStream.id] = stream;
        stream = newStream;
      }
      origAddStream.apply(pc, [stream]);
    };

    var origRemoveStream = window.RTCPeerConnection.prototype.removeStream;
    window.RTCPeerConnection.prototype.removeStream = function(stream) {
      var pc = this;
      pc._streams = pc._streams || {};
      pc._reverseStreams = pc._reverseStreams || {};

      origRemoveStream.apply(pc, [(pc._streams[stream.id] || stream)]);
      delete pc._reverseStreams[(pc._streams[stream.id] ?
          pc._streams[stream.id].id : stream.id)];
      delete pc._streams[stream.id];
    };

    window.RTCPeerConnection.prototype.addTrack = function(track, stream) {
      var pc = this;
      if (pc.signalingState === 'closed') {
        throw new DOMException(
          'The RTCPeerConnection\'s signalingState is \'closed\'.',
          'InvalidStateError');
      }
      var streams = [].slice.call(arguments, 1);
      if (streams.length !== 1 ||
          !streams[0].getTracks().find(function(t) {
            return t === track;
          })) {
        // this is not fully correct but all we can manage without
        // [[associated MediaStreams]] internal slot.
        throw new DOMException(
          'The adapter.js addTrack polyfill only supports a single ' +
          ' stream which is associated with the specified track.',
          'NotSupportedError');
      }

      var alreadyExists = pc.getSenders().find(function(s) {
        return s.track === track;
      });
      if (alreadyExists) {
        throw new DOMException('Track already exists.',
            'InvalidAccessError');
      }

      pc._streams = pc._streams || {};
      pc._reverseStreams = pc._reverseStreams || {};
      var oldStream = pc._streams[stream.id];
      if (oldStream) {
        // this is using odd Chrome behaviour, use with caution:
        // https://bugs.chromium.org/p/webrtc/issues/detail?id=7815
        // Note: we rely on the high-level addTrack/dtmf shim to
        // create the sender with a dtmf sender.
        oldStream.addTrack(track);
        pc.dispatchEvent(new Event('negotiationneeded'));
      } else {
        var newStream = new window.MediaStream([track]);
        pc._streams[stream.id] = newStream;
        pc._reverseStreams[newStream.id] = stream;
        pc.addStream(newStream);
      }
      return pc.getSenders().find(function(s) {
        return s.track === track;
      });
    };

    window.RTCPeerConnection.prototype.removeTrack = function(sender) {
      var pc = this;
      if (pc.signalingState === 'closed') {
        throw new DOMException(
          'The RTCPeerConnection\'s signalingState is \'closed\'.',
          'InvalidStateError');
      }
      var isLocal = sender._pc === pc;
      if (!isLocal) {
        throw new DOMException('Sender was not created by this connection.',
            'InvalidAccessError');
      }

      // Search for the native stream the senders track belongs to.
      pc._streams = pc._streams || {};
      var stream;
      Object.keys(pc._streams).forEach(function(streamid) {
        var hasTrack = pc._streams[streamid].getTracks().find(function(track) {
          return sender.track === track;
        });
        if (hasTrack) {
          stream = pc._streams[streamid];
        }
      });

      if (stream) {
        if (stream.getTracks().length === 1) {
          // if this is the last track of the stream, remove the stream. This
          // takes care of any shimmed _senders.
          pc.removeStream(stream);
        } else {
          // relying on the same odd chrome behaviour as above.
          stream.removeTrack(sender.track);
        }
        pc.dispatchEvent(new Event('negotiationneeded'));
      }
    };
  },

  shimPeerConnection: function(window) {
    var browserDetails = utils.detectBrowser(window);

    // The RTCPeerConnection object.
    if (!window.RTCPeerConnection) {
      window.RTCPeerConnection = function(pcConfig, pcConstraints) {
        // Translate iceTransportPolicy to iceTransports,
        // see https://code.google.com/p/webrtc/issues/detail?id=4869
        // this was fixed in M56 along with unprefixing RTCPeerConnection.
        logging('PeerConnection');
        if (pcConfig && pcConfig.iceTransportPolicy) {
          pcConfig.iceTransports = pcConfig.iceTransportPolicy;
        }

        return new window.webkitRTCPeerConnection(pcConfig, pcConstraints);
      };
      window.RTCPeerConnection.prototype =
          window.webkitRTCPeerConnection.prototype;
      // wrap static methods. Currently just generateCertificate.
      if (window.webkitRTCPeerConnection.generateCertificate) {
        Object.defineProperty(window.RTCPeerConnection, 'generateCertificate', {
          get: function() {
            return window.webkitRTCPeerConnection.generateCertificate;
          }
        });
      }
    } else {
      // migrate from non-spec RTCIceServer.url to RTCIceServer.urls
      var OrigPeerConnection = window.RTCPeerConnection;
      window.RTCPeerConnection = function(pcConfig, pcConstraints) {
        if (pcConfig && pcConfig.iceServers) {
          var newIceServers = [];
          for (var i = 0; i < pcConfig.iceServers.length; i++) {
            var server = pcConfig.iceServers[i];
            if (!server.hasOwnProperty('urls') &&
                server.hasOwnProperty('url')) {
              console.warn('RTCIceServer.url is deprecated! Use urls instead.');
              server = JSON.parse(JSON.stringify(server));
              server.urls = server.url;
              newIceServers.push(server);
            } else {
              newIceServers.push(pcConfig.iceServers[i]);
            }
          }
          pcConfig.iceServers = newIceServers;
        }
        return new OrigPeerConnection(pcConfig, pcConstraints);
      };
      window.RTCPeerConnection.prototype = OrigPeerConnection.prototype;
      // wrap static methods. Currently just generateCertificate.
      Object.defineProperty(window.RTCPeerConnection, 'generateCertificate', {
        get: function() {
          return OrigPeerConnection.generateCertificate;
        }
      });
    }

    var origGetStats = window.RTCPeerConnection.prototype.getStats;
    window.RTCPeerConnection.prototype.getStats = function(selector,
        successCallback, errorCallback) {
      var self = this;
      var args = arguments;

      // If selector is a function then we are in the old style stats so just
      // pass back the original getStats format to avoid breaking old users.
      if (arguments.length > 0 && typeof selector === 'function') {
        return origGetStats.apply(this, arguments);
      }

      // When spec-style getStats is supported, return those when called with
      // either no arguments or the selector argument is null.
      if (origGetStats.length === 0 && (arguments.length === 0 ||
          typeof arguments[0] !== 'function')) {
        return origGetStats.apply(this, []);
      }

      var fixChromeStats_ = function(response) {
        var standardReport = {};
        var reports = response.result();
        reports.forEach(function(report) {
          var standardStats = {
            id: report.id,
            timestamp: report.timestamp,
            type: {
              localcandidate: 'local-candidate',
              remotecandidate: 'remote-candidate'
            }[report.type] || report.type
          };
          report.names().forEach(function(name) {
            standardStats[name] = report.stat(name);
          });
          standardReport[standardStats.id] = standardStats;
        });

        return standardReport;
      };

      // shim getStats with maplike support
      var makeMapStats = function(stats) {
        return new Map(Object.keys(stats).map(function(key) {
          return [key, stats[key]];
        }));
      };

      if (arguments.length >= 2) {
        var successCallbackWrapper_ = function(response) {
          args[1](makeMapStats(fixChromeStats_(response)));
        };

        return origGetStats.apply(this, [successCallbackWrapper_,
          arguments[0]]);
      }

      // promise-support
      return new Promise(function(resolve, reject) {
        origGetStats.apply(self, [
          function(response) {
            resolve(makeMapStats(fixChromeStats_(response)));
          }, reject]);
      }).then(successCallback, errorCallback);
    };

    // add promise support -- natively available in Chrome 51
    if (browserDetails.version < 51) {
      ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate']
          .forEach(function(method) {
            var nativeMethod = window.RTCPeerConnection.prototype[method];
            window.RTCPeerConnection.prototype[method] = function() {
              var args = arguments;
              var self = this;
              var promise = new Promise(function(resolve, reject) {
                nativeMethod.apply(self, [args[0], resolve, reject]);
              });
              if (args.length < 2) {
                return promise;
              }
              return promise.then(function() {
                args[1].apply(null, []);
              },
              function(err) {
                if (args.length >= 3) {
                  args[2].apply(null, [err]);
                }
              });
            };
          });
    }

    // promise support for createOffer and createAnswer. Available (without
    // bugs) since M52: crbug/619289
    if (browserDetails.version < 52) {
      ['createOffer', 'createAnswer'].forEach(function(method) {
        var nativeMethod = window.RTCPeerConnection.prototype[method];
        window.RTCPeerConnection.prototype[method] = function() {
          var self = this;
          if (arguments.length < 1 || (arguments.length === 1 &&
              typeof arguments[0] === 'object')) {
            var opts = arguments.length === 1 ? arguments[0] : undefined;
            return new Promise(function(resolve, reject) {
              nativeMethod.apply(self, [resolve, reject, opts]);
            });
          }
          return nativeMethod.apply(this, arguments);
        };
      });
    }

    // shim implicit creation of RTCSessionDescription/RTCIceCandidate
    ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate']
        .forEach(function(method) {
          var nativeMethod = window.RTCPeerConnection.prototype[method];
          window.RTCPeerConnection.prototype[method] = function() {
            arguments[0] = new ((method === 'addIceCandidate') ?
                window.RTCIceCandidate :
                window.RTCSessionDescription)(arguments[0]);
            return nativeMethod.apply(this, arguments);
          };
        });

    // support for addIceCandidate(null or undefined)
    var nativeAddIceCandidate =
        window.RTCPeerConnection.prototype.addIceCandidate;
    window.RTCPeerConnection.prototype.addIceCandidate = function() {
      if (!arguments[0]) {
        if (arguments[1]) {
          arguments[1].apply(null);
        }
        return Promise.resolve();
      }
      return nativeAddIceCandidate.apply(this, arguments);
    };
  }
};


// Expose public methods.
module.exports = {
  shimMediaStream: chromeShim.shimMediaStream,
  shimOnTrack: chromeShim.shimOnTrack,
  shimAddTrackRemoveTrack: chromeShim.shimAddTrackRemoveTrack,
  shimGetSendersWithDtmf: chromeShim.shimGetSendersWithDtmf,
  shimSourceObject: chromeShim.shimSourceObject,
  shimPeerConnection: chromeShim.shimPeerConnection,
  shimGetUserMedia: require('./getusermedia')
};

},{"../utils.js":214,"./getusermedia":207}],207:[function(require,module,exports){
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
 /* eslint-env node */
'use strict';
var utils = require('../utils.js');
var logging = utils.log;

// Expose public methods.
module.exports = function(window) {
  var browserDetails = utils.detectBrowser(window);
  var navigator = window && window.navigator;

  var constraintsToChrome_ = function(c) {
    if (typeof c !== 'object' || c.mandatory || c.optional) {
      return c;
    }
    var cc = {};
    Object.keys(c).forEach(function(key) {
      if (key === 'require' || key === 'advanced' || key === 'mediaSource') {
        return;
      }
      var r = (typeof c[key] === 'object') ? c[key] : {ideal: c[key]};
      if (r.exact !== undefined && typeof r.exact === 'number') {
        r.min = r.max = r.exact;
      }
      var oldname_ = function(prefix, name) {
        if (prefix) {
          return prefix + name.charAt(0).toUpperCase() + name.slice(1);
        }
        return (name === 'deviceId') ? 'sourceId' : name;
      };
      if (r.ideal !== undefined) {
        cc.optional = cc.optional || [];
        var oc = {};
        if (typeof r.ideal === 'number') {
          oc[oldname_('min', key)] = r.ideal;
          cc.optional.push(oc);
          oc = {};
          oc[oldname_('max', key)] = r.ideal;
          cc.optional.push(oc);
        } else {
          oc[oldname_('', key)] = r.ideal;
          cc.optional.push(oc);
        }
      }
      if (r.exact !== undefined && typeof r.exact !== 'number') {
        cc.mandatory = cc.mandatory || {};
        cc.mandatory[oldname_('', key)] = r.exact;
      } else {
        ['min', 'max'].forEach(function(mix) {
          if (r[mix] !== undefined) {
            cc.mandatory = cc.mandatory || {};
            cc.mandatory[oldname_(mix, key)] = r[mix];
          }
        });
      }
    });
    if (c.advanced) {
      cc.optional = (cc.optional || []).concat(c.advanced);
    }
    return cc;
  };

  var shimConstraints_ = function(constraints, func) {
    constraints = JSON.parse(JSON.stringify(constraints));
    if (constraints && typeof constraints.audio === 'object') {
      var remap = function(obj, a, b) {
        if (a in obj && !(b in obj)) {
          obj[b] = obj[a];
          delete obj[a];
        }
      };
      constraints = JSON.parse(JSON.stringify(constraints));
      remap(constraints.audio, 'autoGainControl', 'googAutoGainControl');
      remap(constraints.audio, 'noiseSuppression', 'googNoiseSuppression');
      constraints.audio = constraintsToChrome_(constraints.audio);
    }
    if (constraints && typeof constraints.video === 'object') {
      // Shim facingMode for mobile & surface pro.
      var face = constraints.video.facingMode;
      face = face && ((typeof face === 'object') ? face : {ideal: face});
      var getSupportedFacingModeLies = browserDetails.version < 61;

      if ((face && (face.exact === 'user' || face.exact === 'environment' ||
                    face.ideal === 'user' || face.ideal === 'environment')) &&
          !(navigator.mediaDevices.getSupportedConstraints &&
            navigator.mediaDevices.getSupportedConstraints().facingMode &&
            !getSupportedFacingModeLies)) {
        delete constraints.video.facingMode;
        var matches;
        if (face.exact === 'environment' || face.ideal === 'environment') {
          matches = ['back', 'rear'];
        } else if (face.exact === 'user' || face.ideal === 'user') {
          matches = ['front'];
        }
        if (matches) {
          // Look for matches in label, or use last cam for back (typical).
          return navigator.mediaDevices.enumerateDevices()
          .then(function(devices) {
            devices = devices.filter(function(d) {
              return d.kind === 'videoinput';
            });
            var dev = devices.find(function(d) {
              return matches.some(function(match) {
                return d.label.toLowerCase().indexOf(match) !== -1;
              });
            });
            if (!dev && devices.length && matches.indexOf('back') !== -1) {
              dev = devices[devices.length - 1]; // more likely the back cam
            }
            if (dev) {
              constraints.video.deviceId = face.exact ? {exact: dev.deviceId} :
                                                        {ideal: dev.deviceId};
            }
            constraints.video = constraintsToChrome_(constraints.video);
            logging('chrome: ' + JSON.stringify(constraints));
            return func(constraints);
          });
        }
      }
      constraints.video = constraintsToChrome_(constraints.video);
    }
    logging('chrome: ' + JSON.stringify(constraints));
    return func(constraints);
  };

  var shimError_ = function(e) {
    return {
      name: {
        PermissionDeniedError: 'NotAllowedError',
        InvalidStateError: 'NotReadableError',
        DevicesNotFoundError: 'NotFoundError',
        ConstraintNotSatisfiedError: 'OverconstrainedError',
        TrackStartError: 'NotReadableError',
        MediaDeviceFailedDueToShutdown: 'NotReadableError',
        MediaDeviceKillSwitchOn: 'NotReadableError'
      }[e.name] || e.name,
      message: e.message,
      constraint: e.constraintName,
      toString: function() {
        return this.name + (this.message && ': ') + this.message;
      }
    };
  };

  var getUserMedia_ = function(constraints, onSuccess, onError) {
    shimConstraints_(constraints, function(c) {
      navigator.webkitGetUserMedia(c, onSuccess, function(e) {
        onError(shimError_(e));
      });
    });
  };

  navigator.getUserMedia = getUserMedia_;

  // Returns the result of getUserMedia as a Promise.
  var getUserMediaPromise_ = function(constraints) {
    return new Promise(function(resolve, reject) {
      navigator.getUserMedia(constraints, resolve, reject);
    });
  };

  if (!navigator.mediaDevices) {
    navigator.mediaDevices = {
      getUserMedia: getUserMediaPromise_,
      enumerateDevices: function() {
        return new Promise(function(resolve) {
          var kinds = {audio: 'audioinput', video: 'videoinput'};
          return window.MediaStreamTrack.getSources(function(devices) {
            resolve(devices.map(function(device) {
              return {label: device.label,
                kind: kinds[device.kind],
                deviceId: device.id,
                groupId: ''};
            }));
          });
        });
      },
      getSupportedConstraints: function() {
        return {
          deviceId: true, echoCancellation: true, facingMode: true,
          frameRate: true, height: true, width: true
        };
      }
    };
  }

  // A shim for getUserMedia method on the mediaDevices object.
  // TODO(KaptenJansson) remove once implemented in Chrome stable.
  if (!navigator.mediaDevices.getUserMedia) {
    navigator.mediaDevices.getUserMedia = function(constraints) {
      return getUserMediaPromise_(constraints);
    };
  } else {
    // Even though Chrome 45 has navigator.mediaDevices and a getUserMedia
    // function which returns a Promise, it does not accept spec-style
    // constraints.
    var origGetUserMedia = navigator.mediaDevices.getUserMedia.
        bind(navigator.mediaDevices);
    navigator.mediaDevices.getUserMedia = function(cs) {
      return shimConstraints_(cs, function(c) {
        return origGetUserMedia(c).then(function(stream) {
          if (c.audio && !stream.getAudioTracks().length ||
              c.video && !stream.getVideoTracks().length) {
            stream.getTracks().forEach(function(track) {
              track.stop();
            });
            throw new DOMException('', 'NotFoundError');
          }
          return stream;
        }, function(e) {
          return Promise.reject(shimError_(e));
        });
      });
    };
  }

  // Dummy devicechange event methods.
  // TODO(KaptenJansson) remove once implemented in Chrome stable.
  if (typeof navigator.mediaDevices.addEventListener === 'undefined') {
    navigator.mediaDevices.addEventListener = function() {
      logging('Dummy mediaDevices.addEventListener called.');
    };
  }
  if (typeof navigator.mediaDevices.removeEventListener === 'undefined') {
    navigator.mediaDevices.removeEventListener = function() {
      logging('Dummy mediaDevices.removeEventListener called.');
    };
  }
};

},{"../utils.js":214}],208:[function(require,module,exports){
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
 /* eslint-env node */
'use strict';

var utils = require('../utils');
var shimRTCPeerConnection = require('./rtcpeerconnection_shim');

module.exports = {
  shimGetUserMedia: require('./getusermedia'),
  shimPeerConnection: function(window) {
    var browserDetails = utils.detectBrowser(window);

    if (window.RTCIceGatherer) {
      // ORTC defines an RTCIceCandidate object but no constructor.
      // Not implemented in Edge.
      if (!window.RTCIceCandidate) {
        window.RTCIceCandidate = function(args) {
          return args;
        };
      }
      // ORTC does not have a session description object but
      // other browsers (i.e. Chrome) that will support both PC and ORTC
      // in the future might have this defined already.
      if (!window.RTCSessionDescription) {
        window.RTCSessionDescription = function(args) {
          return args;
        };
      }
      // this adds an additional event listener to MediaStrackTrack that signals
      // when a tracks enabled property was changed. Workaround for a bug in
      // addStream, see below. No longer required in 15025+
      if (browserDetails.version < 15025) {
        var origMSTEnabled = Object.getOwnPropertyDescriptor(
            window.MediaStreamTrack.prototype, 'enabled');
        Object.defineProperty(window.MediaStreamTrack.prototype, 'enabled', {
          set: function(value) {
            origMSTEnabled.set.call(this, value);
            var ev = new Event('enabled');
            ev.enabled = value;
            this.dispatchEvent(ev);
          }
        });
      }
    }

    // ORTC defines the DTMF sender a bit different.
    // https://github.com/w3c/ortc/issues/714
    if (window.RTCRtpSender && !('dtmf' in window.RTCRtpSender.prototype)) {
      Object.defineProperty(window.RTCRtpSender.prototype, 'dtmf', {
        get: function() {
          if (this._dtmf === undefined) {
            if (this.track.kind === 'audio') {
              this._dtmf = new window.RTCDtmfSender(this);
            } else if (this.track.kind === 'video') {
              this._dtmf = null;
            }
          }
          return this._dtmf;
        }
      });
    }

    window.RTCPeerConnection =
        shimRTCPeerConnection(window, browserDetails.version);
  },
  shimReplaceTrack: function(window) {
    // ORTC has replaceTrack -- https://github.com/w3c/ortc/issues/614
    if (window.RTCRtpSender &&
        !('replaceTrack' in window.RTCRtpSender.prototype)) {
      window.RTCRtpSender.prototype.replaceTrack =
          window.RTCRtpSender.prototype.setTrack;
    }
  }
};

},{"../utils":214,"./getusermedia":209,"./rtcpeerconnection_shim":210}],209:[function(require,module,exports){
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
 /* eslint-env node */
'use strict';

// Expose public methods.
module.exports = function(window) {
  var navigator = window && window.navigator;

  var shimError_ = function(e) {
    return {
      name: {PermissionDeniedError: 'NotAllowedError'}[e.name] || e.name,
      message: e.message,
      constraint: e.constraint,
      toString: function() {
        return this.name;
      }
    };
  };

  // getUserMedia error shim.
  var origGetUserMedia = navigator.mediaDevices.getUserMedia.
      bind(navigator.mediaDevices);
  navigator.mediaDevices.getUserMedia = function(c) {
    return origGetUserMedia(c).catch(function(e) {
      return Promise.reject(shimError_(e));
    });
  };
};

},{}],210:[function(require,module,exports){
/*
 *  Copyright (c) 2017 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
 /* eslint-env node */
'use strict';

var SDPUtils = require('sdp');

// sort tracks such that they follow an a-v-a-v...
// pattern.
function sortTracks(tracks) {
  var audioTracks = tracks.filter(function(track) {
    return track.kind === 'audio';
  });
  var videoTracks = tracks.filter(function(track) {
    return track.kind === 'video';
  });
  tracks = [];
  while (audioTracks.length || videoTracks.length) {
    if (audioTracks.length) {
      tracks.push(audioTracks.shift());
    }
    if (videoTracks.length) {
      tracks.push(videoTracks.shift());
    }
  }
  return tracks;
}

// Edge does not like
// 1) stun:
// 2) turn: that does not have all of turn:host:port?transport=udp
// 3) turn: with ipv6 addresses
// 4) turn: occurring muliple times
function filterIceServers(iceServers, edgeVersion) {
  var hasTurn = false;
  iceServers = JSON.parse(JSON.stringify(iceServers));
  return iceServers.filter(function(server) {
    if (server && (server.urls || server.url)) {
      var urls = server.urls || server.url;
      if (server.url && !server.urls) {
        console.warn('RTCIceServer.url is deprecated! Use urls instead.');
      }
      var isString = typeof urls === 'string';
      if (isString) {
        urls = [urls];
      }
      urls = urls.filter(function(url) {
        var validTurn = url.indexOf('turn:') === 0 &&
            url.indexOf('transport=udp') !== -1 &&
            url.indexOf('turn:[') === -1 &&
            !hasTurn;

        if (validTurn) {
          hasTurn = true;
          return true;
        }
        return url.indexOf('stun:') === 0 && edgeVersion >= 14393;
      });

      delete server.url;
      server.urls = isString ? urls[0] : urls;
      return !!urls.length;
    }
    return false;
  });
}

// Determines the intersection of local and remote capabilities.
function getCommonCapabilities(localCapabilities, remoteCapabilities) {
  var commonCapabilities = {
    codecs: [],
    headerExtensions: [],
    fecMechanisms: []
  };

  var findCodecByPayloadType = function(pt, codecs) {
    pt = parseInt(pt, 10);
    for (var i = 0; i < codecs.length; i++) {
      if (codecs[i].payloadType === pt ||
          codecs[i].preferredPayloadType === pt) {
        return codecs[i];
      }
    }
  };

  var rtxCapabilityMatches = function(lRtx, rRtx, lCodecs, rCodecs) {
    var lCodec = findCodecByPayloadType(lRtx.parameters.apt, lCodecs);
    var rCodec = findCodecByPayloadType(rRtx.parameters.apt, rCodecs);
    return lCodec && rCodec &&
        lCodec.name.toLowerCase() === rCodec.name.toLowerCase();
  };

  localCapabilities.codecs.forEach(function(lCodec) {
    for (var i = 0; i < remoteCapabilities.codecs.length; i++) {
      var rCodec = remoteCapabilities.codecs[i];
      if (lCodec.name.toLowerCase() === rCodec.name.toLowerCase() &&
          lCodec.clockRate === rCodec.clockRate) {
        if (lCodec.name.toLowerCase() === 'rtx' &&
            lCodec.parameters && rCodec.parameters.apt) {
          // for RTX we need to find the local rtx that has a apt
          // which points to the same local codec as the remote one.
          if (!rtxCapabilityMatches(lCodec, rCodec,
              localCapabilities.codecs, remoteCapabilities.codecs)) {
            continue;
          }
        }
        rCodec = JSON.parse(JSON.stringify(rCodec)); // deepcopy
        // number of channels is the highest common number of channels
        rCodec.numChannels = Math.min(lCodec.numChannels,
            rCodec.numChannels);
        // push rCodec so we reply with offerer payload type
        commonCapabilities.codecs.push(rCodec);

        // determine common feedback mechanisms
        rCodec.rtcpFeedback = rCodec.rtcpFeedback.filter(function(fb) {
          for (var j = 0; j < lCodec.rtcpFeedback.length; j++) {
            if (lCodec.rtcpFeedback[j].type === fb.type &&
                lCodec.rtcpFeedback[j].parameter === fb.parameter) {
              return true;
            }
          }
          return false;
        });
        // FIXME: also need to determine .parameters
        //  see https://github.com/openpeer/ortc/issues/569
        break;
      }
    }
  });

  localCapabilities.headerExtensions.forEach(function(lHeaderExtension) {
    for (var i = 0; i < remoteCapabilities.headerExtensions.length;
         i++) {
      var rHeaderExtension = remoteCapabilities.headerExtensions[i];
      if (lHeaderExtension.uri === rHeaderExtension.uri) {
        commonCapabilities.headerExtensions.push(rHeaderExtension);
        break;
      }
    }
  });

  // FIXME: fecMechanisms
  return commonCapabilities;
}

// is action=setLocalDescription with type allowed in signalingState
function isActionAllowedInSignalingState(action, type, signalingState) {
  return {
    offer: {
      setLocalDescription: ['stable', 'have-local-offer'],
      setRemoteDescription: ['stable', 'have-remote-offer']
    },
    answer: {
      setLocalDescription: ['have-remote-offer', 'have-local-pranswer'],
      setRemoteDescription: ['have-local-offer', 'have-remote-pranswer']
    }
  }[type][action].indexOf(signalingState) !== -1;
}

module.exports = function(window, edgeVersion) {
  var RTCPeerConnection = function(config) {
    var self = this;

    var _eventTarget = document.createDocumentFragment();
    ['addEventListener', 'removeEventListener', 'dispatchEvent']
        .forEach(function(method) {
          self[method] = _eventTarget[method].bind(_eventTarget);
        });

    this.needNegotiation = false;

    this.onicecandidate = null;
    this.onaddstream = null;
    this.ontrack = null;
    this.onremovestream = null;
    this.onsignalingstatechange = null;
    this.oniceconnectionstatechange = null;
    this.onicegatheringstatechange = null;
    this.onnegotiationneeded = null;
    this.ondatachannel = null;
    this.canTrickleIceCandidates = null;

    this.localStreams = [];
    this.remoteStreams = [];
    this.getLocalStreams = function() {
      return self.localStreams;
    };
    this.getRemoteStreams = function() {
      return self.remoteStreams;
    };

    this.localDescription = new window.RTCSessionDescription({
      type: '',
      sdp: ''
    });
    this.remoteDescription = new window.RTCSessionDescription({
      type: '',
      sdp: ''
    });
    this.signalingState = 'stable';
    this.iceConnectionState = 'new';
    this.iceGatheringState = 'new';

    this.iceOptions = {
      gatherPolicy: 'all',
      iceServers: []
    };
    if (config && config.iceTransportPolicy) {
      switch (config.iceTransportPolicy) {
        case 'all':
        case 'relay':
          this.iceOptions.gatherPolicy = config.iceTransportPolicy;
          break;
        default:
          // don't set iceTransportPolicy.
          break;
      }
    }
    this.usingBundle = config && config.bundlePolicy === 'max-bundle';

    if (config && config.iceServers) {
      this.iceOptions.iceServers = filterIceServers(config.iceServers,
          edgeVersion);
    }
    this._config = config || {};

    // per-track iceGathers, iceTransports, dtlsTransports, rtpSenders, ...
    // everything that is needed to describe a SDP m-line.
    this.transceivers = [];

    // since the iceGatherer is currently created in createOffer but we
    // must not emit candidates until after setLocalDescription we buffer
    // them in this array.
    this._localIceCandidatesBuffer = [];

    this._sdpSessionId = SDPUtils.generateSessionId();
  };

  RTCPeerConnection.prototype._emitGatheringStateChange = function() {
    var event = new Event('icegatheringstatechange');
    this.dispatchEvent(event);
    if (this.onicegatheringstatechange !== null) {
      this.onicegatheringstatechange(event);
    }
  };

  RTCPeerConnection.prototype._emitBufferedCandidates = function() {
    var self = this;
    var sections = SDPUtils.splitSections(self.localDescription.sdp);
    // FIXME: need to apply ice candidates in a way which is async but
    // in-order
    this._localIceCandidatesBuffer.forEach(function(event) {
      var end = !event.candidate || Object.keys(event.candidate).length === 0;
      if (end) {
        for (var j = 1; j < sections.length; j++) {
          if (sections[j].indexOf('\r\na=end-of-candidates\r\n') === -1) {
            sections[j] += 'a=end-of-candidates\r\n';
          }
        }
      } else {
        sections[event.candidate.sdpMLineIndex + 1] +=
            'a=' + event.candidate.candidate + '\r\n';
      }
      self.localDescription.sdp = sections.join('');
      self.dispatchEvent(event);
      if (self.onicecandidate !== null) {
        self.onicecandidate(event);
      }
      if (!event.candidate && self.iceGatheringState !== 'complete') {
        var complete = self.transceivers.every(function(transceiver) {
          return transceiver.iceGatherer &&
              transceiver.iceGatherer.state === 'completed';
        });
        if (complete && self.iceGatheringStateChange !== 'complete') {
          self.iceGatheringState = 'complete';
          self._emitGatheringStateChange();
        }
      }
    });
    this._localIceCandidatesBuffer = [];
  };

  RTCPeerConnection.prototype.getConfiguration = function() {
    return this._config;
  };

  // internal helper to create a transceiver object.
  // (whih is not yet the same as the WebRTC 1.0 transceiver)
  RTCPeerConnection.prototype._createTransceiver = function(kind) {
    var hasBundleTransport = this.transceivers.length > 0;
    var transceiver = {
      track: null,
      iceGatherer: null,
      iceTransport: null,
      dtlsTransport: null,
      localCapabilities: null,
      remoteCapabilities: null,
      rtpSender: null,
      rtpReceiver: null,
      kind: kind,
      mid: null,
      sendEncodingParameters: null,
      recvEncodingParameters: null,
      stream: null,
      wantReceive: true
    };
    if (this.usingBundle && hasBundleTransport) {
      transceiver.iceTransport = this.transceivers[0].iceTransport;
      transceiver.dtlsTransport = this.transceivers[0].dtlsTransport;
    } else {
      var transports = this._createIceAndDtlsTransports();
      transceiver.iceTransport = transports.iceTransport;
      transceiver.dtlsTransport = transports.dtlsTransport;
    }
    this.transceivers.push(transceiver);
    return transceiver;
  };

  RTCPeerConnection.prototype.addTrack = function(track, stream) {
    var transceiver;
    for (var i = 0; i < this.transceivers.length; i++) {
      if (!this.transceivers[i].track &&
          this.transceivers[i].kind === track.kind) {
        transceiver = this.transceivers[i];
      }
    }
    if (!transceiver) {
      transceiver = this._createTransceiver(track.kind);
    }

    transceiver.track = track;
    transceiver.stream = stream;
    transceiver.rtpSender = new window.RTCRtpSender(track,
        transceiver.dtlsTransport);

    this._maybeFireNegotiationNeeded();
    return transceiver.rtpSender;
  };

  RTCPeerConnection.prototype.addStream = function(stream) {
    var self = this;
    if (edgeVersion >= 15025) {
      this.localStreams.push(stream);
      stream.getTracks().forEach(function(track) {
        self.addTrack(track, stream);
      });
    } else {
      // Clone is necessary for local demos mostly, attaching directly
      // to two different senders does not work (build 10547).
      // Fixed in 15025 (or earlier)
      var clonedStream = stream.clone();
      stream.getTracks().forEach(function(track, idx) {
        var clonedTrack = clonedStream.getTracks()[idx];
        track.addEventListener('enabled', function(event) {
          clonedTrack.enabled = event.enabled;
        });
      });
      clonedStream.getTracks().forEach(function(track) {
        self.addTrack(track, clonedStream);
      });
      this.localStreams.push(clonedStream);
    }
    this._maybeFireNegotiationNeeded();
  };

  RTCPeerConnection.prototype.removeStream = function(stream) {
    var idx = this.localStreams.indexOf(stream);
    if (idx > -1) {
      this.localStreams.splice(idx, 1);
      this._maybeFireNegotiationNeeded();
    }
  };

  RTCPeerConnection.prototype.getSenders = function() {
    return this.transceivers.filter(function(transceiver) {
      return !!transceiver.rtpSender;
    })
    .map(function(transceiver) {
      return transceiver.rtpSender;
    });
  };

  RTCPeerConnection.prototype.getReceivers = function() {
    return this.transceivers.filter(function(transceiver) {
      return !!transceiver.rtpReceiver;
    })
    .map(function(transceiver) {
      return transceiver.rtpReceiver;
    });
  };

  // Create ICE gatherer and hook it up.
  RTCPeerConnection.prototype._createIceGatherer = function(mid,
      sdpMLineIndex) {
    var self = this;
    var iceGatherer = new window.RTCIceGatherer(self.iceOptions);
    iceGatherer.onlocalcandidate = function(evt) {
      var event = new Event('icecandidate');
      event.candidate = {sdpMid: mid, sdpMLineIndex: sdpMLineIndex};

      var cand = evt.candidate;
      var end = !cand || Object.keys(cand).length === 0;
      // Edge emits an empty object for RTCIceCandidateComplete
      if (end) {
        // polyfill since RTCIceGatherer.state is not implemented in
        // Edge 10547 yet.
        if (iceGatherer.state === undefined) {
          iceGatherer.state = 'completed';
        }
      } else {
        // RTCIceCandidate doesn't have a component, needs to be added
        cand.component = 1;
        event.candidate.candidate = SDPUtils.writeCandidate(cand);
      }

      // update local description.
      var sections = SDPUtils.splitSections(self.localDescription.sdp);
      if (!end) {
        sections[event.candidate.sdpMLineIndex + 1] +=
            'a=' + event.candidate.candidate + '\r\n';
      } else {
        sections[event.candidate.sdpMLineIndex + 1] +=
            'a=end-of-candidates\r\n';
      }
      self.localDescription.sdp = sections.join('');
      var transceivers = self._pendingOffer ? self._pendingOffer :
          self.transceivers;
      var complete = transceivers.every(function(transceiver) {
        return transceiver.iceGatherer &&
            transceiver.iceGatherer.state === 'completed';
      });

      // Emit candidate if localDescription is set.
      // Also emits null candidate when all gatherers are complete.
      switch (self.iceGatheringState) {
        case 'new':
          if (!end) {
            self._localIceCandidatesBuffer.push(event);
          }
          if (end && complete) {
            self._localIceCandidatesBuffer.push(
                new Event('icecandidate'));
          }
          break;
        case 'gathering':
          self._emitBufferedCandidates();
          if (!end) {
            self.dispatchEvent(event);
            if (self.onicecandidate !== null) {
              self.onicecandidate(event);
            }
          }
          if (complete) {
            self.dispatchEvent(new Event('icecandidate'));
            if (self.onicecandidate !== null) {
              self.onicecandidate(new Event('icecandidate'));
            }
            self.iceGatheringState = 'complete';
            self._emitGatheringStateChange();
          }
          break;
        case 'complete':
          // should not happen... currently!
          break;
        default: // no-op.
          break;
      }
    };
    return iceGatherer;
  };

  // Create ICE transport and DTLS transport.
  RTCPeerConnection.prototype._createIceAndDtlsTransports = function() {
    var self = this;
    var iceTransport = new window.RTCIceTransport(null);
    iceTransport.onicestatechange = function() {
      self._updateConnectionState();
    };

    var dtlsTransport = new window.RTCDtlsTransport(iceTransport);
    dtlsTransport.ondtlsstatechange = function() {
      self._updateConnectionState();
    };
    dtlsTransport.onerror = function() {
      // onerror does not set state to failed by itself.
      Object.defineProperty(dtlsTransport, 'state',
          {value: 'failed', writable: true});
      self._updateConnectionState();
    };

    return {
      iceTransport: iceTransport,
      dtlsTransport: dtlsTransport
    };
  };

  // Destroy ICE gatherer, ICE transport and DTLS transport.
  // Without triggering the callbacks.
  RTCPeerConnection.prototype._disposeIceAndDtlsTransports = function(
      sdpMLineIndex) {
    var iceGatherer = this.transceivers[sdpMLineIndex].iceGatherer;
    if (iceGatherer) {
      delete iceGatherer.onlocalcandidate;
      delete this.transceivers[sdpMLineIndex].iceGatherer;
    }
    var iceTransport = this.transceivers[sdpMLineIndex].iceTransport;
    if (iceTransport) {
      delete iceTransport.onicestatechange;
      delete this.transceivers[sdpMLineIndex].iceTransport;
    }
    var dtlsTransport = this.transceivers[sdpMLineIndex].dtlsTransport;
    if (dtlsTransport) {
      delete dtlsTransport.ondtlsstatechange;
      delete dtlsTransport.onerror;
      delete this.transceivers[sdpMLineIndex].dtlsTransport;
    }
  };

  // Start the RTP Sender and Receiver for a transceiver.
  RTCPeerConnection.prototype._transceive = function(transceiver,
      send, recv) {
    var params = getCommonCapabilities(transceiver.localCapabilities,
        transceiver.remoteCapabilities);
    if (send && transceiver.rtpSender) {
      params.encodings = transceiver.sendEncodingParameters;
      params.rtcp = {
        cname: SDPUtils.localCName,
        compound: transceiver.rtcpParameters.compound
      };
      if (transceiver.recvEncodingParameters.length) {
        params.rtcp.ssrc = transceiver.recvEncodingParameters[0].ssrc;
      }
      transceiver.rtpSender.send(params);
    }
    if (recv && transceiver.rtpReceiver) {
      // remove RTX field in Edge 14942
      if (transceiver.kind === 'video'
          && transceiver.recvEncodingParameters
          && edgeVersion < 15019) {
        transceiver.recvEncodingParameters.forEach(function(p) {
          delete p.rtx;
        });
      }
      params.encodings = transceiver.recvEncodingParameters;
      params.rtcp = {
        cname: transceiver.rtcpParameters.cname,
        compound: transceiver.rtcpParameters.compound
      };
      if (transceiver.sendEncodingParameters.length) {
        params.rtcp.ssrc = transceiver.sendEncodingParameters[0].ssrc;
      }
      transceiver.rtpReceiver.receive(params);
    }
  };

  RTCPeerConnection.prototype.setLocalDescription = function(description) {
    var self = this;

    if (!isActionAllowedInSignalingState('setLocalDescription',
        description.type, this.signalingState)) {
      var e = new Error('Can not set local ' + description.type +
          ' in state ' + this.signalingState);
      e.name = 'InvalidStateError';
      if (arguments.length > 2 && typeof arguments[2] === 'function') {
        window.setTimeout(arguments[2], 0, e);
      }
      return Promise.reject(e);
    }

    var sections;
    var sessionpart;
    if (description.type === 'offer') {
      // FIXME: What was the purpose of this empty if statement?
      // if (!this._pendingOffer) {
      // } else {
      if (this._pendingOffer) {
        // VERY limited support for SDP munging. Limited to:
        // * changing the order of codecs
        sections = SDPUtils.splitSections(description.sdp);
        sessionpart = sections.shift();
        sections.forEach(function(mediaSection, sdpMLineIndex) {
          var caps = SDPUtils.parseRtpParameters(mediaSection);
          self._pendingOffer[sdpMLineIndex].localCapabilities = caps;
        });
        this.transceivers = this._pendingOffer;
        delete this._pendingOffer;
      }
    } else if (description.type === 'answer') {
      sections = SDPUtils.splitSections(self.remoteDescription.sdp);
      sessionpart = sections.shift();
      var isIceLite = SDPUtils.matchPrefix(sessionpart,
          'a=ice-lite').length > 0;
      sections.forEach(function(mediaSection, sdpMLineIndex) {
        var transceiver = self.transceivers[sdpMLineIndex];
        var iceGatherer = transceiver.iceGatherer;
        var iceTransport = transceiver.iceTransport;
        var dtlsTransport = transceiver.dtlsTransport;
        var localCapabilities = transceiver.localCapabilities;
        var remoteCapabilities = transceiver.remoteCapabilities;

        var rejected = SDPUtils.isRejected(mediaSection);

        if (!rejected && !transceiver.isDatachannel) {
          var remoteIceParameters = SDPUtils.getIceParameters(
              mediaSection, sessionpart);
          var remoteDtlsParameters = SDPUtils.getDtlsParameters(
              mediaSection, sessionpart);
          if (isIceLite) {
            remoteDtlsParameters.role = 'server';
          }

          if (!self.usingBundle || sdpMLineIndex === 0) {
            iceTransport.start(iceGatherer, remoteIceParameters,
                isIceLite ? 'controlling' : 'controlled');
            dtlsTransport.start(remoteDtlsParameters);
          }

          // Calculate intersection of capabilities.
          var params = getCommonCapabilities(localCapabilities,
              remoteCapabilities);

          // Start the RTCRtpSender. The RTCRtpReceiver for this
          // transceiver has already been started in setRemoteDescription.
          self._transceive(transceiver,
              params.codecs.length > 0,
              false);
        }
      });
    }

    this.localDescription = {
      type: description.type,
      sdp: description.sdp
    };
    switch (description.type) {
      case 'offer':
        this._updateSignalingState('have-local-offer');
        break;
      case 'answer':
        this._updateSignalingState('stable');
        break;
      default:
        throw new TypeError('unsupported type "' + description.type +
            '"');
    }

    // If a success callback was provided, emit ICE candidates after it
    // has been executed. Otherwise, emit callback after the Promise is
    // resolved.
    var hasCallback = arguments.length > 1 &&
      typeof arguments[1] === 'function';
    if (hasCallback) {
      var cb = arguments[1];
      window.setTimeout(function() {
        cb();
        if (self.iceGatheringState === 'new') {
          self.iceGatheringState = 'gathering';
          self._emitGatheringStateChange();
        }
        self._emitBufferedCandidates();
      }, 0);
    }
    var p = Promise.resolve();
    p.then(function() {
      if (!hasCallback) {
        if (self.iceGatheringState === 'new') {
          self.iceGatheringState = 'gathering';
          self._emitGatheringStateChange();
        }
        // Usually candidates will be emitted earlier.
        window.setTimeout(self._emitBufferedCandidates.bind(self), 500);
      }
    });
    return p;
  };

  RTCPeerConnection.prototype.setRemoteDescription = function(description) {
    var self = this;

    if (!isActionAllowedInSignalingState('setRemoteDescription',
        description.type, this.signalingState)) {
      var e = new Error('Can not set remote ' + description.type +
          ' in state ' + this.signalingState);
      e.name = 'InvalidStateError';
      if (arguments.length > 2 && typeof arguments[2] === 'function') {
        window.setTimeout(arguments[2], 0, e);
      }
      return Promise.reject(e);
    }

    var streams = {};
    var receiverList = [];
    var sections = SDPUtils.splitSections(description.sdp);
    var sessionpart = sections.shift();
    var isIceLite = SDPUtils.matchPrefix(sessionpart,
        'a=ice-lite').length > 0;
    var usingBundle = SDPUtils.matchPrefix(sessionpart,
        'a=group:BUNDLE ').length > 0;
    this.usingBundle = usingBundle;
    var iceOptions = SDPUtils.matchPrefix(sessionpart,
        'a=ice-options:')[0];
    if (iceOptions) {
      this.canTrickleIceCandidates = iceOptions.substr(14).split(' ')
          .indexOf('trickle') >= 0;
    } else {
      this.canTrickleIceCandidates = false;
    }

    sections.forEach(function(mediaSection, sdpMLineIndex) {
      var lines = SDPUtils.splitLines(mediaSection);
      var kind = SDPUtils.getKind(mediaSection);
      var rejected = SDPUtils.isRejected(mediaSection);
      var protocol = lines[0].substr(2).split(' ')[2];

      var direction = SDPUtils.getDirection(mediaSection, sessionpart);
      var remoteMsid = SDPUtils.parseMsid(mediaSection);

      var mid = SDPUtils.getMid(mediaSection) || SDPUtils.generateIdentifier();

      // Reject datachannels which are not implemented yet.
      if (kind === 'application' && protocol === 'DTLS/SCTP') {
        self.transceivers[sdpMLineIndex] = {
          mid: mid,
          isDatachannel: true
        };
        return;
      }

      var transceiver;
      var iceGatherer;
      var iceTransport;
      var dtlsTransport;
      var rtpReceiver;
      var sendEncodingParameters;
      var recvEncodingParameters;
      var localCapabilities;

      var track;
      // FIXME: ensure the mediaSection has rtcp-mux set.
      var remoteCapabilities = SDPUtils.parseRtpParameters(mediaSection);
      var remoteIceParameters;
      var remoteDtlsParameters;
      if (!rejected) {
        remoteIceParameters = SDPUtils.getIceParameters(mediaSection,
            sessionpart);
        remoteDtlsParameters = SDPUtils.getDtlsParameters(mediaSection,
            sessionpart);
        remoteDtlsParameters.role = 'client';
      }
      recvEncodingParameters =
          SDPUtils.parseRtpEncodingParameters(mediaSection);

      var rtcpParameters = SDPUtils.parseRtcpParameters(mediaSection);

      var isComplete = SDPUtils.matchPrefix(mediaSection,
          'a=end-of-candidates', sessionpart).length > 0;
      var cands = SDPUtils.matchPrefix(mediaSection, 'a=candidate:')
          .map(function(cand) {
            return SDPUtils.parseCandidate(cand);
          })
          .filter(function(cand) {
            return cand.component === '1' || cand.component === 1;
          });

      // Check if we can use BUNDLE and dispose transports.
      if ((description.type === 'offer' || description.type === 'answer') &&
          !rejected && usingBundle && sdpMLineIndex > 0 &&
          self.transceivers[sdpMLineIndex]) {
        self._disposeIceAndDtlsTransports(sdpMLineIndex);
        self.transceivers[sdpMLineIndex].iceGatherer =
            self.transceivers[0].iceGatherer;
        self.transceivers[sdpMLineIndex].iceTransport =
            self.transceivers[0].iceTransport;
        self.transceivers[sdpMLineIndex].dtlsTransport =
            self.transceivers[0].dtlsTransport;
        if (self.transceivers[sdpMLineIndex].rtpSender) {
          self.transceivers[sdpMLineIndex].rtpSender.setTransport(
              self.transceivers[0].dtlsTransport);
        }
        if (self.transceivers[sdpMLineIndex].rtpReceiver) {
          self.transceivers[sdpMLineIndex].rtpReceiver.setTransport(
              self.transceivers[0].dtlsTransport);
        }
      }
      if (description.type === 'offer' && !rejected) {
        transceiver = self.transceivers[sdpMLineIndex] ||
            self._createTransceiver(kind);
        transceiver.mid = mid;

        if (!transceiver.iceGatherer) {
          transceiver.iceGatherer = usingBundle && sdpMLineIndex > 0 ?
              self.transceivers[0].iceGatherer :
              self._createIceGatherer(mid, sdpMLineIndex);
        }

        if (isComplete && cands.length &&
            (!usingBundle || sdpMLineIndex === 0)) {
          transceiver.iceTransport.setRemoteCandidates(cands);
        }

        localCapabilities = window.RTCRtpReceiver.getCapabilities(kind);

        // filter RTX until additional stuff needed for RTX is implemented
        // in adapter.js
        if (edgeVersion < 15019) {
          localCapabilities.codecs = localCapabilities.codecs.filter(
              function(codec) {
                return codec.name !== 'rtx';
              });
        }

        sendEncodingParameters = [{
          ssrc: (2 * sdpMLineIndex + 2) * 1001
        }];

        if (direction === 'sendrecv' || direction === 'sendonly') {
          rtpReceiver = new window.RTCRtpReceiver(transceiver.dtlsTransport,
              kind);

          track = rtpReceiver.track;
          // FIXME: does not work with Plan B.
          if (remoteMsid) {
            if (!streams[remoteMsid.stream]) {
              streams[remoteMsid.stream] = new window.MediaStream();
              Object.defineProperty(streams[remoteMsid.stream], 'id', {
                get: function() {
                  return remoteMsid.stream;
                }
              });
            }
            Object.defineProperty(track, 'id', {
              get: function() {
                return remoteMsid.track;
              }
            });
            streams[remoteMsid.stream].addTrack(track);
            receiverList.push([track, rtpReceiver,
              streams[remoteMsid.stream]]);
          } else {
            if (!streams.default) {
              streams.default = new window.MediaStream();
            }
            streams.default.addTrack(track);
            receiverList.push([track, rtpReceiver, streams.default]);
          }
        }

        transceiver.localCapabilities = localCapabilities;
        transceiver.remoteCapabilities = remoteCapabilities;
        transceiver.rtpReceiver = rtpReceiver;
        transceiver.rtcpParameters = rtcpParameters;
        transceiver.sendEncodingParameters = sendEncodingParameters;
        transceiver.recvEncodingParameters = recvEncodingParameters;

        // Start the RTCRtpReceiver now. The RTPSender is started in
        // setLocalDescription.
        self._transceive(self.transceivers[sdpMLineIndex],
            false,
            direction === 'sendrecv' || direction === 'sendonly');
      } else if (description.type === 'answer' && !rejected) {
        transceiver = self.transceivers[sdpMLineIndex];
        iceGatherer = transceiver.iceGatherer;
        iceTransport = transceiver.iceTransport;
        dtlsTransport = transceiver.dtlsTransport;
        rtpReceiver = transceiver.rtpReceiver;
        sendEncodingParameters = transceiver.sendEncodingParameters;
        localCapabilities = transceiver.localCapabilities;

        self.transceivers[sdpMLineIndex].recvEncodingParameters =
            recvEncodingParameters;
        self.transceivers[sdpMLineIndex].remoteCapabilities =
            remoteCapabilities;
        self.transceivers[sdpMLineIndex].rtcpParameters = rtcpParameters;

        if (!usingBundle || sdpMLineIndex === 0) {
          if ((isIceLite || isComplete) && cands.length) {
            iceTransport.setRemoteCandidates(cands);
          }
          iceTransport.start(iceGatherer, remoteIceParameters,
              'controlling');
          dtlsTransport.start(remoteDtlsParameters);
        }

        self._transceive(transceiver,
            direction === 'sendrecv' || direction === 'recvonly',
            direction === 'sendrecv' || direction === 'sendonly');

        if (rtpReceiver &&
            (direction === 'sendrecv' || direction === 'sendonly')) {
          track = rtpReceiver.track;
          if (remoteMsid) {
            if (!streams[remoteMsid.stream]) {
              streams[remoteMsid.stream] = new window.MediaStream();
            }
            streams[remoteMsid.stream].addTrack(track);
            receiverList.push([track, rtpReceiver, streams[remoteMsid.stream]]);
          } else {
            if (!streams.default) {
              streams.default = new window.MediaStream();
            }
            streams.default.addTrack(track);
            receiverList.push([track, rtpReceiver, streams.default]);
          }
        } else {
          // FIXME: actually the receiver should be created later.
          delete transceiver.rtpReceiver;
        }
      }
    });

    this.remoteDescription = {
      type: description.type,
      sdp: description.sdp
    };
    switch (description.type) {
      case 'offer':
        this._updateSignalingState('have-remote-offer');
        break;
      case 'answer':
        this._updateSignalingState('stable');
        break;
      default:
        throw new TypeError('unsupported type "' + description.type +
            '"');
    }
    Object.keys(streams).forEach(function(sid) {
      var stream = streams[sid];
      if (stream.getTracks().length) {
        self.remoteStreams.push(stream);
        var event = new Event('addstream');
        event.stream = stream;
        self.dispatchEvent(event);
        if (self.onaddstream !== null) {
          window.setTimeout(function() {
            self.onaddstream(event);
          }, 0);
        }

        receiverList.forEach(function(item) {
          var track = item[0];
          var receiver = item[1];
          if (stream.id !== item[2].id) {
            return;
          }
          var trackEvent = new Event('track');
          trackEvent.track = track;
          trackEvent.receiver = receiver;
          trackEvent.streams = [stream];
          self.dispatchEvent(trackEvent);
          if (self.ontrack !== null) {
            window.setTimeout(function() {
              self.ontrack(trackEvent);
            }, 0);
          }
        });
      }
    });

    // check whether addIceCandidate({}) was called within four seconds after
    // setRemoteDescription.
    window.setTimeout(function() {
      if (!(self && self.transceivers)) {
        return;
      }
      self.transceivers.forEach(function(transceiver) {
        if (transceiver.iceTransport &&
            transceiver.iceTransport.state === 'new' &&
            transceiver.iceTransport.getRemoteCandidates().length > 0) {
          console.warn('Timeout for addRemoteCandidate. Consider sending ' +
              'an end-of-candidates notification');
          transceiver.iceTransport.addRemoteCandidate({});
        }
      });
    }, 4000);

    if (arguments.length > 1 && typeof arguments[1] === 'function') {
      window.setTimeout(arguments[1], 0);
    }
    return Promise.resolve();
  };

  RTCPeerConnection.prototype.close = function() {
    this.transceivers.forEach(function(transceiver) {
      /* not yet
      if (transceiver.iceGatherer) {
        transceiver.iceGatherer.close();
      }
      */
      if (transceiver.iceTransport) {
        transceiver.iceTransport.stop();
      }
      if (transceiver.dtlsTransport) {
        transceiver.dtlsTransport.stop();
      }
      if (transceiver.rtpSender) {
        transceiver.rtpSender.stop();
      }
      if (transceiver.rtpReceiver) {
        transceiver.rtpReceiver.stop();
      }
    });
    // FIXME: clean up tracks, local streams, remote streams, etc
    this._updateSignalingState('closed');
  };

  // Update the signaling state.
  RTCPeerConnection.prototype._updateSignalingState = function(newState) {
    this.signalingState = newState;
    var event = new Event('signalingstatechange');
    this.dispatchEvent(event);
    if (this.onsignalingstatechange !== null) {
      this.onsignalingstatechange(event);
    }
  };

  // Determine whether to fire the negotiationneeded event.
  RTCPeerConnection.prototype._maybeFireNegotiationNeeded = function() {
    var self = this;
    if (this.signalingState !== 'stable' || this.needNegotiation === true) {
      return;
    }
    this.needNegotiation = true;
    window.setTimeout(function() {
      if (self.needNegotiation === false) {
        return;
      }
      self.needNegotiation = false;
      var event = new Event('negotiationneeded');
      self.dispatchEvent(event);
      if (self.onnegotiationneeded !== null) {
        self.onnegotiationneeded(event);
      }
    }, 0);
  };

  // Update the connection state.
  RTCPeerConnection.prototype._updateConnectionState = function() {
    var self = this;
    var newState;
    var states = {
      'new': 0,
      closed: 0,
      connecting: 0,
      checking: 0,
      connected: 0,
      completed: 0,
      disconnected: 0,
      failed: 0
    };
    this.transceivers.forEach(function(transceiver) {
      states[transceiver.iceTransport.state]++;
      states[transceiver.dtlsTransport.state]++;
    });
    // ICETransport.completed and connected are the same for this purpose.
    states.connected += states.completed;

    newState = 'new';
    if (states.failed > 0) {
      newState = 'failed';
    } else if (states.connecting > 0 || states.checking > 0) {
      newState = 'connecting';
    } else if (states.disconnected > 0) {
      newState = 'disconnected';
    } else if (states.new > 0) {
      newState = 'new';
    } else if (states.connected > 0 || states.completed > 0) {
      newState = 'connected';
    }

    if (newState !== self.iceConnectionState) {
      self.iceConnectionState = newState;
      var event = new Event('iceconnectionstatechange');
      this.dispatchEvent(event);
      if (this.oniceconnectionstatechange !== null) {
        this.oniceconnectionstatechange(event);
      }
    }
  };

  RTCPeerConnection.prototype.createOffer = function() {
    var self = this;
    if (this._pendingOffer) {
      throw new Error('createOffer called while there is a pending offer.');
    }
    var offerOptions;
    if (arguments.length === 1 && typeof arguments[0] !== 'function') {
      offerOptions = arguments[0];
    } else if (arguments.length === 3) {
      offerOptions = arguments[2];
    }

    var numAudioTracks = this.transceivers.filter(function(t) {
      return t.kind === 'audio';
    }).length;
    var numVideoTracks = this.transceivers.filter(function(t) {
      return t.kind === 'video';
    }).length;

    // Determine number of audio and video tracks we need to send/recv.
    if (offerOptions) {
      // Reject Chrome legacy constraints.
      if (offerOptions.mandatory || offerOptions.optional) {
        throw new TypeError(
            'Legacy mandatory/optional constraints not supported.');
      }
      if (offerOptions.offerToReceiveAudio !== undefined) {
        if (offerOptions.offerToReceiveAudio === true) {
          numAudioTracks = 1;
        } else if (offerOptions.offerToReceiveAudio === false) {
          numAudioTracks = 0;
        } else {
          numAudioTracks = offerOptions.offerToReceiveAudio;
        }
      }
      if (offerOptions.offerToReceiveVideo !== undefined) {
        if (offerOptions.offerToReceiveVideo === true) {
          numVideoTracks = 1;
        } else if (offerOptions.offerToReceiveVideo === false) {
          numVideoTracks = 0;
        } else {
          numVideoTracks = offerOptions.offerToReceiveVideo;
        }
      }
    }

    this.transceivers.forEach(function(transceiver) {
      if (transceiver.kind === 'audio') {
        numAudioTracks--;
        if (numAudioTracks < 0) {
          transceiver.wantReceive = false;
        }
      } else if (transceiver.kind === 'video') {
        numVideoTracks--;
        if (numVideoTracks < 0) {
          transceiver.wantReceive = false;
        }
      }
    });

    // Create M-lines for recvonly streams.
    while (numAudioTracks > 0 || numVideoTracks > 0) {
      if (numAudioTracks > 0) {
        this._createTransceiver('audio');
        numAudioTracks--;
      }
      if (numVideoTracks > 0) {
        this._createTransceiver('video');
        numVideoTracks--;
      }
    }
    // reorder tracks
    var transceivers = sortTracks(this.transceivers);

    var sdp = SDPUtils.writeSessionBoilerplate(this._sdpSessionId);
    transceivers.forEach(function(transceiver, sdpMLineIndex) {
      // For each track, create an ice gatherer, ice transport,
      // dtls transport, potentially rtpsender and rtpreceiver.
      var track = transceiver.track;
      var kind = transceiver.kind;
      var mid = SDPUtils.generateIdentifier();
      transceiver.mid = mid;

      if (!transceiver.iceGatherer) {
        transceiver.iceGatherer = self.usingBundle && sdpMLineIndex > 0 ?
            transceivers[0].iceGatherer :
            self._createIceGatherer(mid, sdpMLineIndex);
      }

      var localCapabilities = window.RTCRtpSender.getCapabilities(kind);
      // filter RTX until additional stuff needed for RTX is implemented
      // in adapter.js
      if (edgeVersion < 15019) {
        localCapabilities.codecs = localCapabilities.codecs.filter(
            function(codec) {
              return codec.name !== 'rtx';
            });
      }
      localCapabilities.codecs.forEach(function(codec) {
        // work around https://bugs.chromium.org/p/webrtc/issues/detail?id=6552
        // by adding level-asymmetry-allowed=1
        if (codec.name === 'H264' &&
            codec.parameters['level-asymmetry-allowed'] === undefined) {
          codec.parameters['level-asymmetry-allowed'] = '1';
        }
      });

      // generate an ssrc now, to be used later in rtpSender.send
      var sendEncodingParameters = [{
        ssrc: (2 * sdpMLineIndex + 1) * 1001
      }];
      if (track) {
        // add RTX
        if (edgeVersion >= 15019 && kind === 'video') {
          sendEncodingParameters[0].rtx = {
            ssrc: (2 * sdpMLineIndex + 1) * 1001 + 1
          };
        }
      }

      if (transceiver.wantReceive) {
        transceiver.rtpReceiver = new window.RTCRtpReceiver(
          transceiver.dtlsTransport,
          kind
        );
      }

      transceiver.localCapabilities = localCapabilities;
      transceiver.sendEncodingParameters = sendEncodingParameters;
    });

    // always offer BUNDLE and dispose on return if not supported.
    if (this._config.bundlePolicy !== 'max-compat') {
      sdp += 'a=group:BUNDLE ' + transceivers.map(function(t) {
        return t.mid;
      }).join(' ') + '\r\n';
    }
    sdp += 'a=ice-options:trickle\r\n';

    transceivers.forEach(function(transceiver, sdpMLineIndex) {
      sdp += SDPUtils.writeMediaSection(transceiver,
          transceiver.localCapabilities, 'offer', transceiver.stream);
      sdp += 'a=rtcp-rsize\r\n';
    });

    this._pendingOffer = transceivers;
    var desc = new window.RTCSessionDescription({
      type: 'offer',
      sdp: sdp
    });
    if (arguments.length && typeof arguments[0] === 'function') {
      window.setTimeout(arguments[0], 0, desc);
    }
    return Promise.resolve(desc);
  };

  RTCPeerConnection.prototype.createAnswer = function() {
    var sdp = SDPUtils.writeSessionBoilerplate(this._sdpSessionId);
    if (this.usingBundle) {
      sdp += 'a=group:BUNDLE ' + this.transceivers.map(function(t) {
        return t.mid;
      }).join(' ') + '\r\n';
    }
    this.transceivers.forEach(function(transceiver, sdpMLineIndex) {
      if (transceiver.isDatachannel) {
        sdp += 'm=application 0 DTLS/SCTP 5000\r\n' +
            'c=IN IP4 0.0.0.0\r\n' +
            'a=mid:' + transceiver.mid + '\r\n';
        return;
      }

      // FIXME: look at direction.
      if (transceiver.stream) {
        var localTrack;
        if (transceiver.kind === 'audio') {
          localTrack = transceiver.stream.getAudioTracks()[0];
        } else if (transceiver.kind === 'video') {
          localTrack = transceiver.stream.getVideoTracks()[0];
        }
        if (localTrack) {
          // add RTX
          if (edgeVersion >= 15019 && transceiver.kind === 'video') {
            transceiver.sendEncodingParameters[0].rtx = {
              ssrc: (2 * sdpMLineIndex + 2) * 1001 + 1
            };
          }
        }
      }

      // Calculate intersection of capabilities.
      var commonCapabilities = getCommonCapabilities(
          transceiver.localCapabilities,
          transceiver.remoteCapabilities);

      var hasRtx = commonCapabilities.codecs.filter(function(c) {
        return c.name.toLowerCase() === 'rtx';
      }).length;
      if (!hasRtx && transceiver.sendEncodingParameters[0].rtx) {
        delete transceiver.sendEncodingParameters[0].rtx;
      }

      sdp += SDPUtils.writeMediaSection(transceiver, commonCapabilities,
          'answer', transceiver.stream);
      if (transceiver.rtcpParameters &&
          transceiver.rtcpParameters.reducedSize) {
        sdp += 'a=rtcp-rsize\r\n';
      }
    });

    var desc = new window.RTCSessionDescription({
      type: 'answer',
      sdp: sdp
    });
    if (arguments.length && typeof arguments[0] === 'function') {
      window.setTimeout(arguments[0], 0, desc);
    }
    return Promise.resolve(desc);
  };

  RTCPeerConnection.prototype.addIceCandidate = function(candidate) {
    if (!candidate) {
      for (var j = 0; j < this.transceivers.length; j++) {
        this.transceivers[j].iceTransport.addRemoteCandidate({});
        if (this.usingBundle) {
          return Promise.resolve();
        }
      }
    } else {
      var mLineIndex = candidate.sdpMLineIndex;
      if (candidate.sdpMid) {
        for (var i = 0; i < this.transceivers.length; i++) {
          if (this.transceivers[i].mid === candidate.sdpMid) {
            mLineIndex = i;
            break;
          }
        }
      }
      var transceiver = this.transceivers[mLineIndex];
      if (transceiver) {
        var cand = Object.keys(candidate.candidate).length > 0 ?
            SDPUtils.parseCandidate(candidate.candidate) : {};
        // Ignore Chrome's invalid candidates since Edge does not like them.
        if (cand.protocol === 'tcp' && (cand.port === 0 || cand.port === 9)) {
          return Promise.resolve();
        }
        // Ignore RTCP candidates, we assume RTCP-MUX.
        if (cand.component &&
            !(cand.component === '1' || cand.component === 1)) {
          return Promise.resolve();
        }
        transceiver.iceTransport.addRemoteCandidate(cand);

        // update the remoteDescription.
        var sections = SDPUtils.splitSections(this.remoteDescription.sdp);
        sections[mLineIndex + 1] += (cand.type ? candidate.candidate.trim()
            : 'a=end-of-candidates') + '\r\n';
        this.remoteDescription.sdp = sections.join('');
      }
    }
    if (arguments.length > 1 && typeof arguments[1] === 'function') {
      window.setTimeout(arguments[1], 0);
    }
    return Promise.resolve();
  };

  RTCPeerConnection.prototype.getStats = function() {
    var promises = [];
    this.transceivers.forEach(function(transceiver) {
      ['rtpSender', 'rtpReceiver', 'iceGatherer', 'iceTransport',
        'dtlsTransport'].forEach(function(method) {
          if (transceiver[method]) {
            promises.push(transceiver[method].getStats());
          }
        });
    });
    var cb = arguments.length > 1 && typeof arguments[1] === 'function' &&
        arguments[1];
    var fixStatsType = function(stat) {
      return {
        inboundrtp: 'inbound-rtp',
        outboundrtp: 'outbound-rtp',
        candidatepair: 'candidate-pair',
        localcandidate: 'local-candidate',
        remotecandidate: 'remote-candidate'
      }[stat.type] || stat.type;
    };
    return new Promise(function(resolve) {
      // shim getStats with maplike support
      var results = new Map();
      Promise.all(promises).then(function(res) {
        res.forEach(function(result) {
          Object.keys(result).forEach(function(id) {
            result[id].type = fixStatsType(result[id]);
            results.set(id, result[id]);
          });
        });
        if (cb) {
          window.setTimeout(cb, 0, results);
        }
        resolve(results);
      });
    });
  };
  return RTCPeerConnection;
};

},{"sdp":194}],211:[function(require,module,exports){
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
 /* eslint-env node */
'use strict';

var utils = require('../utils');

var firefoxShim = {
  shimOnTrack: function(window) {
    if (typeof window === 'object' && window.RTCPeerConnection && !('ontrack' in
        window.RTCPeerConnection.prototype)) {
      Object.defineProperty(window.RTCPeerConnection.prototype, 'ontrack', {
        get: function() {
          return this._ontrack;
        },
        set: function(f) {
          if (this._ontrack) {
            this.removeEventListener('track', this._ontrack);
            this.removeEventListener('addstream', this._ontrackpoly);
          }
          this.addEventListener('track', this._ontrack = f);
          this.addEventListener('addstream', this._ontrackpoly = function(e) {
            e.stream.getTracks().forEach(function(track) {
              var event = new Event('track');
              event.track = track;
              event.receiver = {track: track};
              event.streams = [e.stream];
              this.dispatchEvent(event);
            }.bind(this));
          }.bind(this));
        }
      });
    }
  },

  shimSourceObject: function(window) {
    // Firefox has supported mozSrcObject since FF22, unprefixed in 42.
    if (typeof window === 'object') {
      if (window.HTMLMediaElement &&
        !('srcObject' in window.HTMLMediaElement.prototype)) {
        // Shim the srcObject property, once, when HTMLMediaElement is found.
        Object.defineProperty(window.HTMLMediaElement.prototype, 'srcObject', {
          get: function() {
            return this.mozSrcObject;
          },
          set: function(stream) {
            this.mozSrcObject = stream;
          }
        });
      }
    }
  },

  shimPeerConnection: function(window) {
    var browserDetails = utils.detectBrowser(window);

    if (typeof window !== 'object' || !(window.RTCPeerConnection ||
        window.mozRTCPeerConnection)) {
      return; // probably media.peerconnection.enabled=false in about:config
    }
    // The RTCPeerConnection object.
    if (!window.RTCPeerConnection) {
      window.RTCPeerConnection = function(pcConfig, pcConstraints) {
        if (browserDetails.version < 38) {
          // .urls is not supported in FF < 38.
          // create RTCIceServers with a single url.
          if (pcConfig && pcConfig.iceServers) {
            var newIceServers = [];
            for (var i = 0; i < pcConfig.iceServers.length; i++) {
              var server = pcConfig.iceServers[i];
              if (server.hasOwnProperty('urls')) {
                for (var j = 0; j < server.urls.length; j++) {
                  var newServer = {
                    url: server.urls[j]
                  };
                  if (server.urls[j].indexOf('turn') === 0) {
                    newServer.username = server.username;
                    newServer.credential = server.credential;
                  }
                  newIceServers.push(newServer);
                }
              } else {
                newIceServers.push(pcConfig.iceServers[i]);
              }
            }
            pcConfig.iceServers = newIceServers;
          }
        }
        return new window.mozRTCPeerConnection(pcConfig, pcConstraints);
      };
      window.RTCPeerConnection.prototype =
          window.mozRTCPeerConnection.prototype;

      // wrap static methods. Currently just generateCertificate.
      if (window.mozRTCPeerConnection.generateCertificate) {
        Object.defineProperty(window.RTCPeerConnection, 'generateCertificate', {
          get: function() {
            return window.mozRTCPeerConnection.generateCertificate;
          }
        });
      }

      window.RTCSessionDescription = window.mozRTCSessionDescription;
      window.RTCIceCandidate = window.mozRTCIceCandidate;
    }

    // shim away need for obsolete RTCIceCandidate/RTCSessionDescription.
    ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate']
        .forEach(function(method) {
          var nativeMethod = window.RTCPeerConnection.prototype[method];
          window.RTCPeerConnection.prototype[method] = function() {
            arguments[0] = new ((method === 'addIceCandidate') ?
                window.RTCIceCandidate :
                window.RTCSessionDescription)(arguments[0]);
            return nativeMethod.apply(this, arguments);
          };
        });

    // support for addIceCandidate(null or undefined)
    var nativeAddIceCandidate =
        window.RTCPeerConnection.prototype.addIceCandidate;
    window.RTCPeerConnection.prototype.addIceCandidate = function() {
      if (!arguments[0]) {
        if (arguments[1]) {
          arguments[1].apply(null);
        }
        return Promise.resolve();
      }
      return nativeAddIceCandidate.apply(this, arguments);
    };

    // shim getStats with maplike support
    var makeMapStats = function(stats) {
      var map = new Map();
      Object.keys(stats).forEach(function(key) {
        map.set(key, stats[key]);
        map[key] = stats[key];
      });
      return map;
    };

    var modernStatsTypes = {
      inboundrtp: 'inbound-rtp',
      outboundrtp: 'outbound-rtp',
      candidatepair: 'candidate-pair',
      localcandidate: 'local-candidate',
      remotecandidate: 'remote-candidate'
    };

    var nativeGetStats = window.RTCPeerConnection.prototype.getStats;
    window.RTCPeerConnection.prototype.getStats = function(
      selector,
      onSucc,
      onErr
    ) {
      return nativeGetStats.apply(this, [selector || null])
        .then(function(stats) {
          if (browserDetails.version < 48) {
            stats = makeMapStats(stats);
          }
          if (browserDetails.version < 53 && !onSucc) {
            // Shim only promise getStats with spec-hyphens in type names
            // Leave callback version alone; misc old uses of forEach before Map
            try {
              stats.forEach(function(stat) {
                stat.type = modernStatsTypes[stat.type] || stat.type;
              });
            } catch (e) {
              if (e.name !== 'TypeError') {
                throw e;
              }
              // Avoid TypeError: "type" is read-only, in old versions. 34-43ish
              stats.forEach(function(stat, i) {
                stats.set(i, Object.assign({}, stat, {
                  type: modernStatsTypes[stat.type] || stat.type
                }));
              });
            }
          }
          return stats;
        })
        .then(onSucc, onErr);
    };
  }
};

// Expose public methods.
module.exports = {
  shimOnTrack: firefoxShim.shimOnTrack,
  shimSourceObject: firefoxShim.shimSourceObject,
  shimPeerConnection: firefoxShim.shimPeerConnection,
  shimGetUserMedia: require('./getusermedia')
};

},{"../utils":214,"./getusermedia":212}],212:[function(require,module,exports){
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
 /* eslint-env node */
'use strict';

var utils = require('../utils');
var logging = utils.log;

// Expose public methods.
module.exports = function(window) {
  var browserDetails = utils.detectBrowser(window);
  var navigator = window && window.navigator;
  var MediaStreamTrack = window && window.MediaStreamTrack;

  var shimError_ = function(e) {
    return {
      name: {
        InternalError: 'NotReadableError',
        NotSupportedError: 'TypeError',
        PermissionDeniedError: 'NotAllowedError',
        SecurityError: 'NotAllowedError'
      }[e.name] || e.name,
      message: {
        'The operation is insecure.': 'The request is not allowed by the ' +
        'user agent or the platform in the current context.'
      }[e.message] || e.message,
      constraint: e.constraint,
      toString: function() {
        return this.name + (this.message && ': ') + this.message;
      }
    };
  };

  // getUserMedia constraints shim.
  var getUserMedia_ = function(constraints, onSuccess, onError) {
    var constraintsToFF37_ = function(c) {
      if (typeof c !== 'object' || c.require) {
        return c;
      }
      var require = [];
      Object.keys(c).forEach(function(key) {
        if (key === 'require' || key === 'advanced' || key === 'mediaSource') {
          return;
        }
        var r = c[key] = (typeof c[key] === 'object') ?
            c[key] : {ideal: c[key]};
        if (r.min !== undefined ||
            r.max !== undefined || r.exact !== undefined) {
          require.push(key);
        }
        if (r.exact !== undefined) {
          if (typeof r.exact === 'number') {
            r. min = r.max = r.exact;
          } else {
            c[key] = r.exact;
          }
          delete r.exact;
        }
        if (r.ideal !== undefined) {
          c.advanced = c.advanced || [];
          var oc = {};
          if (typeof r.ideal === 'number') {
            oc[key] = {min: r.ideal, max: r.ideal};
          } else {
            oc[key] = r.ideal;
          }
          c.advanced.push(oc);
          delete r.ideal;
          if (!Object.keys(r).length) {
            delete c[key];
          }
        }
      });
      if (require.length) {
        c.require = require;
      }
      return c;
    };
    constraints = JSON.parse(JSON.stringify(constraints));
    if (browserDetails.version < 38) {
      logging('spec: ' + JSON.stringify(constraints));
      if (constraints.audio) {
        constraints.audio = constraintsToFF37_(constraints.audio);
      }
      if (constraints.video) {
        constraints.video = constraintsToFF37_(constraints.video);
      }
      logging('ff37: ' + JSON.stringify(constraints));
    }
    return navigator.mozGetUserMedia(constraints, onSuccess, function(e) {
      onError(shimError_(e));
    });
  };

  // Returns the result of getUserMedia as a Promise.
  var getUserMediaPromise_ = function(constraints) {
    return new Promise(function(resolve, reject) {
      getUserMedia_(constraints, resolve, reject);
    });
  };

  // Shim for mediaDevices on older versions.
  if (!navigator.mediaDevices) {
    navigator.mediaDevices = {getUserMedia: getUserMediaPromise_,
      addEventListener: function() { },
      removeEventListener: function() { }
    };
  }
  navigator.mediaDevices.enumerateDevices =
      navigator.mediaDevices.enumerateDevices || function() {
        return new Promise(function(resolve) {
          var infos = [
            {kind: 'audioinput', deviceId: 'default', label: '', groupId: ''},
            {kind: 'videoinput', deviceId: 'default', label: '', groupId: ''}
          ];
          resolve(infos);
        });
      };

  if (browserDetails.version < 41) {
    // Work around http://bugzil.la/1169665
    var orgEnumerateDevices =
        navigator.mediaDevices.enumerateDevices.bind(navigator.mediaDevices);
    navigator.mediaDevices.enumerateDevices = function() {
      return orgEnumerateDevices().then(undefined, function(e) {
        if (e.name === 'NotFoundError') {
          return [];
        }
        throw e;
      });
    };
  }
  if (browserDetails.version < 49) {
    var origGetUserMedia = navigator.mediaDevices.getUserMedia.
        bind(navigator.mediaDevices);
    navigator.mediaDevices.getUserMedia = function(c) {
      return origGetUserMedia(c).then(function(stream) {
        // Work around https://bugzil.la/802326
        if (c.audio && !stream.getAudioTracks().length ||
            c.video && !stream.getVideoTracks().length) {
          stream.getTracks().forEach(function(track) {
            track.stop();
          });
          throw new DOMException('The object can not be found here.',
                                 'NotFoundError');
        }
        return stream;
      }, function(e) {
        return Promise.reject(shimError_(e));
      });
    };
  }
  if (!(browserDetails.version > 55 &&
      'autoGainControl' in navigator.mediaDevices.getSupportedConstraints())) {
    var remap = function(obj, a, b) {
      if (a in obj && !(b in obj)) {
        obj[b] = obj[a];
        delete obj[a];
      }
    };

    var nativeGetUserMedia = navigator.mediaDevices.getUserMedia.
        bind(navigator.mediaDevices);
    navigator.mediaDevices.getUserMedia = function(c) {
      if (typeof c === 'object' && typeof c.audio === 'object') {
        c = JSON.parse(JSON.stringify(c));
        remap(c.audio, 'autoGainControl', 'mozAutoGainControl');
        remap(c.audio, 'noiseSuppression', 'mozNoiseSuppression');
      }
      return nativeGetUserMedia(c);
    };

    if (MediaStreamTrack && MediaStreamTrack.prototype.getSettings) {
      var nativeGetSettings = MediaStreamTrack.prototype.getSettings;
      MediaStreamTrack.prototype.getSettings = function() {
        var obj = nativeGetSettings.apply(this, arguments);
        remap(obj, 'mozAutoGainControl', 'autoGainControl');
        remap(obj, 'mozNoiseSuppression', 'noiseSuppression');
        return obj;
      };
    }

    if (MediaStreamTrack && MediaStreamTrack.prototype.applyConstraints) {
      var nativeApplyConstraints = MediaStreamTrack.prototype.applyConstraints;
      MediaStreamTrack.prototype.applyConstraints = function(c) {
        if (this.kind === 'audio' && typeof c === 'object') {
          c = JSON.parse(JSON.stringify(c));
          remap(c, 'autoGainControl', 'mozAutoGainControl');
          remap(c, 'noiseSuppression', 'mozNoiseSuppression');
        }
        return nativeApplyConstraints.apply(this, [c]);
      };
    }
  }
  navigator.getUserMedia = function(constraints, onSuccess, onError) {
    if (browserDetails.version < 44) {
      return getUserMedia_(constraints, onSuccess, onError);
    }
    // Replace Firefox 44+'s deprecation warning with unprefixed version.
    console.warn('navigator.getUserMedia has been replaced by ' +
                 'navigator.mediaDevices.getUserMedia');
    navigator.mediaDevices.getUserMedia(constraints).then(onSuccess, onError);
  };
};

},{"../utils":214}],213:[function(require,module,exports){
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
'use strict';
var utils = require('../utils');

var safariShim = {
  // TODO: DrAlex, should be here, double check against LayoutTests

  // TODO: once the back-end for the mac port is done, add.
  // TODO: check for webkitGTK+
  // shimPeerConnection: function() { },

  shimLocalStreamsAPI: function(window) {
    if (typeof window !== 'object' || !window.RTCPeerConnection) {
      return;
    }
    if (!('getLocalStreams' in window.RTCPeerConnection.prototype)) {
      window.RTCPeerConnection.prototype.getLocalStreams = function() {
        if (!this._localStreams) {
          this._localStreams = [];
        }
        return this._localStreams;
      };
    }
    if (!('getStreamById' in window.RTCPeerConnection.prototype)) {
      window.RTCPeerConnection.prototype.getStreamById = function(id) {
        var result = null;
        if (this._localStreams) {
          this._localStreams.forEach(function(stream) {
            if (stream.id === id) {
              result = stream;
            }
          });
        }
        if (this._remoteStreams) {
          this._remoteStreams.forEach(function(stream) {
            if (stream.id === id) {
              result = stream;
            }
          });
        }
        return result;
      };
    }
    if (!('addStream' in window.RTCPeerConnection.prototype)) {
      var _addTrack = window.RTCPeerConnection.prototype.addTrack;
      window.RTCPeerConnection.prototype.addStream = function(stream) {
        if (!this._localStreams) {
          this._localStreams = [];
        }
        if (this._localStreams.indexOf(stream) === -1) {
          this._localStreams.push(stream);
        }
        var self = this;
        stream.getTracks().forEach(function(track) {
          _addTrack.call(self, track, stream);
        });
      };

      window.RTCPeerConnection.prototype.addTrack = function(track, stream) {
        if (stream) {
          if (!this._localStreams) {
            this._localStreams = [stream];
          } else if (this._localStreams.indexOf(stream) === -1) {
            this._localStreams.push(stream);
          }
        }
        _addTrack.call(this, track, stream);
      };
    }
    if (!('removeStream' in window.RTCPeerConnection.prototype)) {
      window.RTCPeerConnection.prototype.removeStream = function(stream) {
        if (!this._localStreams) {
          this._localStreams = [];
        }
        var index = this._localStreams.indexOf(stream);
        if (index === -1) {
          return;
        }
        this._localStreams.splice(index, 1);
        var self = this;
        var tracks = stream.getTracks();
        this.getSenders().forEach(function(sender) {
          if (tracks.indexOf(sender.track) !== -1) {
            self.removeTrack(sender);
          }
        });
      };
    }
  },
  shimRemoteStreamsAPI: function(window) {
    if (typeof window !== 'object' || !window.RTCPeerConnection) {
      return;
    }
    if (!('getRemoteStreams' in window.RTCPeerConnection.prototype)) {
      window.RTCPeerConnection.prototype.getRemoteStreams = function() {
        return this._remoteStreams ? this._remoteStreams : [];
      };
    }
    if (!('onaddstream' in window.RTCPeerConnection.prototype)) {
      Object.defineProperty(window.RTCPeerConnection.prototype, 'onaddstream', {
        get: function() {
          return this._onaddstream;
        },
        set: function(f) {
          if (this._onaddstream) {
            this.removeEventListener('addstream', this._onaddstream);
            this.removeEventListener('track', this._onaddstreampoly);
          }
          this.addEventListener('addstream', this._onaddstream = f);
          this.addEventListener('track', this._onaddstreampoly = function(e) {
            var stream = e.streams[0];
            if (!this._remoteStreams) {
              this._remoteStreams = [];
            }
            if (this._remoteStreams.indexOf(stream) >= 0) {
              return;
            }
            this._remoteStreams.push(stream);
            var event = new Event('addstream');
            event.stream = e.streams[0];
            this.dispatchEvent(event);
          }.bind(this));
        }
      });
    }
  },
  shimCallbacksAPI: function(window) {
    if (typeof window !== 'object' || !window.RTCPeerConnection) {
      return;
    }
    var prototype = window.RTCPeerConnection.prototype;
    var createOffer = prototype.createOffer;
    var createAnswer = prototype.createAnswer;
    var setLocalDescription = prototype.setLocalDescription;
    var setRemoteDescription = prototype.setRemoteDescription;
    var addIceCandidate = prototype.addIceCandidate;

    prototype.createOffer = function(successCallback, failureCallback) {
      var options = (arguments.length >= 2) ? arguments[2] : arguments[0];
      var promise = createOffer.apply(this, [options]);
      if (!failureCallback) {
        return promise;
      }
      promise.then(successCallback, failureCallback);
      return Promise.resolve();
    };

    prototype.createAnswer = function(successCallback, failureCallback) {
      var options = (arguments.length >= 2) ? arguments[2] : arguments[0];
      var promise = createAnswer.apply(this, [options]);
      if (!failureCallback) {
        return promise;
      }
      promise.then(successCallback, failureCallback);
      return Promise.resolve();
    };

    var withCallback = function(description, successCallback, failureCallback) {
      var promise = setLocalDescription.apply(this, [description]);
      if (!failureCallback) {
        return promise;
      }
      promise.then(successCallback, failureCallback);
      return Promise.resolve();
    };
    prototype.setLocalDescription = withCallback;

    withCallback = function(description, successCallback, failureCallback) {
      var promise = setRemoteDescription.apply(this, [description]);
      if (!failureCallback) {
        return promise;
      }
      promise.then(successCallback, failureCallback);
      return Promise.resolve();
    };
    prototype.setRemoteDescription = withCallback;

    withCallback = function(candidate, successCallback, failureCallback) {
      var promise = addIceCandidate.apply(this, [candidate]);
      if (!failureCallback) {
        return promise;
      }
      promise.then(successCallback, failureCallback);
      return Promise.resolve();
    };
    prototype.addIceCandidate = withCallback;
  },
  shimGetUserMedia: function(window) {
    var navigator = window && window.navigator;

    if (!navigator.getUserMedia) {
      if (navigator.webkitGetUserMedia) {
        navigator.getUserMedia = navigator.webkitGetUserMedia.bind(navigator);
      } else if (navigator.mediaDevices &&
          navigator.mediaDevices.getUserMedia) {
        navigator.getUserMedia = function(constraints, cb, errcb) {
          navigator.mediaDevices.getUserMedia(constraints)
          .then(cb, errcb);
        }.bind(navigator);
      }
    }
  },
  shimRTCIceServerUrls: function(window) {
    // migrate from non-spec RTCIceServer.url to RTCIceServer.urls
    var OrigPeerConnection = window.RTCPeerConnection;
    window.RTCPeerConnection = function(pcConfig, pcConstraints) {
      if (pcConfig && pcConfig.iceServers) {
        var newIceServers = [];
        for (var i = 0; i < pcConfig.iceServers.length; i++) {
          var server = pcConfig.iceServers[i];
          if (!server.hasOwnProperty('urls') &&
              server.hasOwnProperty('url')) {
            utils.deprecated('RTCIceServer.url', 'RTCIceServer.urls');
            server = JSON.parse(JSON.stringify(server));
            server.urls = server.url;
            delete server.url;
            newIceServers.push(server);
          } else {
            newIceServers.push(pcConfig.iceServers[i]);
          }
        }
        pcConfig.iceServers = newIceServers;
      }
      return new OrigPeerConnection(pcConfig, pcConstraints);
    };
    window.RTCPeerConnection.prototype = OrigPeerConnection.prototype;
    // wrap static methods. Currently just generateCertificate.
    Object.defineProperty(window.RTCPeerConnection, 'generateCertificate', {
      get: function() {
        return OrigPeerConnection.generateCertificate;
      }
    });
  }
};

// Expose public methods.
module.exports = {
  shimCallbacksAPI: safariShim.shimCallbacksAPI,
  shimLocalStreamsAPI: safariShim.shimLocalStreamsAPI,
  shimRemoteStreamsAPI: safariShim.shimRemoteStreamsAPI,
  shimGetUserMedia: safariShim.shimGetUserMedia,
  shimRTCIceServerUrls: safariShim.shimRTCIceServerUrls
  // TODO
  // shimPeerConnection: safariShim.shimPeerConnection
};

},{"../utils":214}],214:[function(require,module,exports){
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
 /* eslint-env node */
'use strict';

var logDisabled_ = true;
var deprecationWarnings_ = true;

// Utility methods.
var utils = {
  disableLog: function(bool) {
    if (typeof bool !== 'boolean') {
      return new Error('Argument type: ' + typeof bool +
          '. Please use a boolean.');
    }
    logDisabled_ = bool;
    return (bool) ? 'adapter.js logging disabled' :
        'adapter.js logging enabled';
  },

  /**
   * Disable or enable deprecation warnings
   * @param {!boolean} bool set to true to disable warnings.
   */
  disableWarnings: function(bool) {
    if (typeof bool !== 'boolean') {
      return new Error('Argument type: ' + typeof bool +
          '. Please use a boolean.');
    }
    deprecationWarnings_ = !bool;
    return 'adapter.js deprecation warnings ' + (bool ? 'disabled' : 'enabled');
  },

  log: function() {
    if (typeof window === 'object') {
      if (logDisabled_) {
        return;
      }
      if (typeof console !== 'undefined' && typeof console.log === 'function') {
        console.log.apply(console, arguments);
      }
    }
  },

  /**
   * Shows a deprecation warning suggesting the modern and spec-compatible API.
   */
  deprecated: function(oldMethod, newMethod) {
    if (!deprecationWarnings_) {
      return;
    }
    console.warn(oldMethod + ' is deprecated, please use ' + newMethod +
        ' instead.');
  },

  /**
   * Extract browser version out of the provided user agent string.
   *
   * @param {!string} uastring userAgent string.
   * @param {!string} expr Regular expression used as match criteria.
   * @param {!number} pos position in the version string to be returned.
   * @return {!number} browser version.
   */
  extractVersion: function(uastring, expr, pos) {
    var match = uastring.match(expr);
    return match && match.length >= pos && parseInt(match[pos], 10);
  },

  /**
   * Browser detector.
   *
   * @return {object} result containing browser and version
   *     properties.
   */
  detectBrowser: function(window) {
    var navigator = window && window.navigator;

    // Returned result object.
    var result = {};
    result.browser = null;
    result.version = null;

    // Fail early if it's not a browser
    if (typeof window === 'undefined' || !window.navigator) {
      result.browser = 'Not a browser.';
      return result;
    }

    // Firefox.
    if (navigator.mozGetUserMedia) {
      result.browser = 'firefox';
      result.version = this.extractVersion(navigator.userAgent,
          /Firefox\/(\d+)\./, 1);
    } else if (navigator.webkitGetUserMedia) {
      // Chrome, Chromium, Webview, Opera, all use the chrome shim for now
      if (window.webkitRTCPeerConnection) {
        result.browser = 'chrome';
        result.version = this.extractVersion(navigator.userAgent,
          /Chrom(e|ium)\/(\d+)\./, 2);
      } else { // Safari (in an unpublished version) or unknown webkit-based.
        if (navigator.userAgent.match(/Version\/(\d+).(\d+)/)) {
          result.browser = 'safari';
          result.version = this.extractVersion(navigator.userAgent,
            /AppleWebKit\/(\d+)\./, 1);
        } else { // unknown webkit-based browser.
          result.browser = 'Unsupported webkit-based browser ' +
              'with GUM support but no WebRTC support.';
          return result;
        }
      }
    } else if (navigator.mediaDevices &&
        navigator.userAgent.match(/Edge\/(\d+).(\d+)$/)) { // Edge.
      result.browser = 'edge';
      result.version = this.extractVersion(navigator.userAgent,
          /Edge\/(\d+).(\d+)$/, 2);
    } else if (navigator.mediaDevices &&
        navigator.userAgent.match(/AppleWebKit\/(\d+)\./)) {
        // Safari, with webkitGetUserMedia removed.
      result.browser = 'safari';
      result.version = this.extractVersion(navigator.userAgent,
          /AppleWebKit\/(\d+)\./, 1);
    } else { // Default fallthrough: not supported.
      result.browser = 'Not a supported browser.';
      return result;
    }

    return result;
  },

  // shimCreateObjectURL must be called before shimSourceObject to avoid loop.

  shimCreateObjectURL: function(window) {
    var URL = window && window.URL;

    if (!(typeof window === 'object' && window.HTMLMediaElement &&
          'srcObject' in window.HTMLMediaElement.prototype)) {
      // Only shim CreateObjectURL using srcObject if srcObject exists.
      return undefined;
    }

    var nativeCreateObjectURL = URL.createObjectURL.bind(URL);
    var nativeRevokeObjectURL = URL.revokeObjectURL.bind(URL);
    var streams = new Map(), newId = 0;

    URL.createObjectURL = function(stream) {
      if ('getTracks' in stream) {
        var url = 'polyblob:' + (++newId);
        streams.set(url, stream);
        utils.deprecated('URL.createObjectURL(stream)',
            'elem.srcObject = stream');
        return url;
      }
      return nativeCreateObjectURL(stream);
    };
    URL.revokeObjectURL = function(url) {
      nativeRevokeObjectURL(url);
      streams.delete(url);
    };

    var dsc = Object.getOwnPropertyDescriptor(window.HTMLMediaElement.prototype,
                                              'src');
    Object.defineProperty(window.HTMLMediaElement.prototype, 'src', {
      get: function() {
        return dsc.get.apply(this);
      },
      set: function(url) {
        this.srcObject = streams.get(url) || null;
        return dsc.set.apply(this, [url]);
      }
    });

    var nativeSetAttribute = window.HTMLMediaElement.prototype.setAttribute;
    window.HTMLMediaElement.prototype.setAttribute = function() {
      if (arguments.length === 2 &&
          ('' + arguments[0]).toLowerCase() === 'src') {
        this.srcObject = streams.get(arguments[1]) || null;
      }
      return nativeSetAttribute.apply(this, arguments);
    };
  }
};

// Export.
module.exports = {
  log: utils.log,
  deprecated: utils.deprecated,
  disableLog: utils.disableLog,
  disableWarnings: utils.disableWarnings,
  extractVersion: utils.extractVersion,
  shimCreateObjectURL: utils.shimCreateObjectURL,
  detectBrowser: utils.detectBrowser.bind(utils)
};

},{}],215:[function(require,module,exports){

/**
 * Module dependencies.
 */

var global = (function() { return this; })();

/**
 * WebSocket constructor.
 */

var WebSocket = global.WebSocket || global.MozWebSocket;

/**
 * Module exports.
 */

module.exports = WebSocket ? ws : null;

/**
 * WebSocket constructor.
 *
 * The third `opts` options object gets ignored in web browsers, since it's
 * non-standard, and throws a TypeError if passed to the constructor.
 * See: https://github.com/einaros/ws/issues/227
 *
 * @param {String} uri
 * @param {Array} protocols (optional)
 * @param {Object) opts (optional)
 * @api public
 */

function ws(uri, protocols, opts) {
  var instance;
  if (protocols) {
    instance = new WebSocket(uri, protocols);
  } else {
    instance = new WebSocket(uri);
  }
  return instance;
}

if (WebSocket) ws.prototype = WebSocket.prototype;

},{}],216:[function(require,module,exports){
'use strict';

// this is the actual OT.properties object
// values are replaced at build time by browserif + envify

module.exports = {
  version: "v2.12.0",
  buildHash: "edb6972765",

  // Whether or not to turn on debug logging by default
  debug: "true",
  // The URL of the tokbox website
  websiteURL: "https://www-tbdev.tokbox.com",

  // The URL of the CDN
  cdnURL: "https://static-tbdev.tokbox.com",
  // The URL to use for logging
  loggingURL: "http://hlg-dev.tokbox.com/qa",

  // The anvil API URL
  apiURL: "http://anvil-tbdev.opentok.com",

  // If this environment supports SSL
  supportSSL: "true",
  // The CDN to use if we're using SSL
  cdnURLSSL: "https://static-tbdev.tokbox.com",
  // The URL to use for logging
  loggingURLSSL: "https://hlg-dev.tokbox.com/qa",

  // The anvil API URL to use if we're using SSL
  apiURLSSL: "https://anvil-tbdev.opentok.com",

  minimumVersion: {
    firefox: 45,
    chrome: 49
  },

  sentryDSN: 'https://40bf769a2f474b2a8ef66d2809c7cfe0@sentry.io/104064',

  enableErrorReporting: false
};

},{}],217:[function(require,module,exports){
'use strict';

// @todo enable the following disabled rules see OPENTOK-31136 for more info
/* eslint-disable no-underscore-dangle */

// The top-level namespace, also performs basic DOMElement selecting.
//
// @example Get the DOM element with the id of 'domId'
//   OTHelpers('#domId')
//
// @example Get all video elements
//   OTHelpers('video')
//
// @example Get all elements with the class name of 'foo'
//   OTHelpers('.foo')
//
// @example Get all elements with the class name of 'foo',
// and do something with the first.
//   var collection = OTHelpers('.foo');
//   console.log(collection.first);
//
//
// The second argument is the context, that is document or parent Element, to
// select from.
//
// @example Get a video element within the element with the id of 'domId'
//   OTHelpers('video', OTHelpers('#domId'))
//
//
//
// OTHelpers will accept any of the following and return a collection:
//   OTHelpers()
//   OTHelpers('css selector', optionalParentNode)
//   OTHelpers(DomNode)
//   OTHelpers([array of DomNode])
//
// The collection is a ElementCollection object, see the ElementCollection docs for usage info.
//
var OTHelpers = require('./elementCollection/shorthandSelector');

OTHelpers.ElementCollection = require('./elementCollection/index');
OTHelpers.util = require('./util');
OTHelpers.env = require('./env');
OTHelpers.logging = require('./logging');
OTHelpers.ajax = require('./ajax');
OTHelpers.Event = require('./behaviours/eventing/event');
OTHelpers.eventing = require('./behaviours/eventing');
OTHelpers.statable = require('./behaviours/statable');
OTHelpers.Analytics = require('./analytics');
OTHelpers.casting = require('./casting');
OTHelpers.Collection = require('./collection');
OTHelpers.domExtras = require('./domExtras');
OTHelpers.Error = require('./error');
OTHelpers.Modal = require('./modal');
OTHelpers.isWebSocketSupported = require('./isWebSocketSupported');
OTHelpers.useLogHelpers = require('./logging/mixin');

// TODO: Remove the need for this kind of bazzadry.
Object.keys(OTHelpers).forEach(function (key) {
  var component = OTHelpers[key];
  var attachments = component._attachToOTHelpers || {};

  Object.keys(attachments).forEach(function (attachmentName) {
    if (Object.hasOwnProperty.call(OTHelpers, attachmentName) && !(key === 'util' && attachmentName === 'bind')) {
      console.warn('More than one module is trying to define ' + attachmentName + ' on OTHelpers.');
    }
    OTHelpers[attachmentName] = attachments[attachmentName];
  });
});

module.exports = OTHelpers;

},{"./ajax":218,"./analytics":219,"./behaviours/eventing":220,"./behaviours/eventing/event":221,"./behaviours/statable":223,"./casting":224,"./collection":225,"./domExtras":226,"./elementCollection/index":231,"./elementCollection/shorthandSelector":232,"./env":233,"./error":234,"./isWebSocketSupported":235,"./logging":236,"./logging/mixin":237,"./modal":239,"./util":240}],218:[function(require,module,exports){
'use strict';

// @todo enable the following disabled rules see OPENTOK-31136 for more info
/* eslint-disable no-underscore-dangle, no-void, no-param-reassign */
/* eslint-disable no-restricted-syntax, no-continue */

var $ = require('../elementCollection/shorthandSelector');
var env = require('../env');
var makeEverythingAttachToOTHelpers = require('../makeEverythingAttachToOTHelpers');
var util = require('../util');

var browserAjax = {};
module.exports = browserAjax;

function formatPostData(data) {
  // , contentType
  // If it's a string, we assume it's properly encoded
  if (typeof data === 'string') {
    return data;
  }

  var queryString = [];

  Object.keys(data).forEach(function (key) {
    queryString.push(encodeURIComponent(key) + '=' + encodeURIComponent(data[key]));
  });

  return queryString.join('&').replace(/\+/g, '%20');
}

if (env.name !== 'Node') {
  browserAjax.request = function (url, options, callback) {
    var request = new XMLHttpRequest();
    var _options = options || {};
    var _method = _options.method;

    if (!_method) {
      callback(new Error('No HTTP method specified in options'));
      return;
    }

    if (options.overrideMimeType) {
      if (request.overrideMimeType) {
        request.overrideMimeType(options.overrideMimeType);
      }
      delete options.overrideMimeType;
    }

    // Setup callbacks to correctly respond to success and error callbacks. This includes
    // interpreting the responses HTTP status, which XmlHttpRequest seems to ignore
    // by default.
    if (callback) {
      $(request).on('load', function (event) {
        var status = event.target.status;

        // We need to detect things that XMLHttpRequest considers a success,
        // but we consider to be failures.
        if (status >= 200 && (status < 300 || status === 304)) {
          callback(null, event);
        } else {
          callback(event);
        }
      });

      $(request).on('error', callback);
    }

    request.open(options.method, url, true);

    if (!_options.headers) {
      _options.headers = {};
    }

    for (var name in _options.headers) {
      if (!Object.prototype.hasOwnProperty.call(_options.headers, name)) {
        continue;
      }
      request.setRequestHeader(name, _options.headers[name]);
    }

    request.send(options.body && formatPostData(options.body));
  };

  browserAjax.get = function (url, options, callback) {
    var _options = util.extend(options || {}, {
      method: 'GET'
    });
    browserAjax.request(url, _options, callback);
  };

  browserAjax.post = function (url, options, callback) {
    var _options = util.extend(options || {}, {
      method: 'POST'
    });

    browserAjax.request(url, _options, callback);
  };

  browserAjax.getJSON = function (url, options, callback) {
    options = options || {};

    var done = function done(error, event) {
      if (error) {
        callback(error, event && event.target && event.target.responseText);
      } else {
        var response = void 0;

        try {
          response = JSON.parse(event.target.responseText);
        } catch (e) {
          // Badly formed JSON
          callback(e, event && event.target && event.target.responseText);
          return;
        }

        callback(null, response, event);
      }
    };

    var extendedHeaders = util.extend({
      Accept: 'application/json'
    }, options.headers || {});

    browserAjax.get(url, util.extend(options || {}, {
      headers: extendedHeaders
    }), done);
  };

  makeEverythingAttachToOTHelpers(browserAjax);
}

},{"../elementCollection/shorthandSelector":232,"../env":233,"../makeEverythingAttachToOTHelpers":238,"../util":240}],219:[function(require,module,exports){
'use strict';

// @todo enable the following disabled rules see OPENTOK-31136 for more info
/* eslint-disable no-param-reassign, no-unneeded-ternary */

var ajax = require('./ajax');
var logging = require('./logging');
var util = require('./util');

// Singleton interval
var logQueue = [];
var queueRunning = false;

module.exports = function Analytics(loggingUrl) {
  var endPoint = loggingUrl + '/logging/ClientEvent';
  var endPointQos = loggingUrl + '/logging/ClientQos';

  var reportedErrors = {};

  var send = function send(data, isQos, callback) {
    ajax.post(isQos ? endPointQos : endPoint, {
      body: data,
      overrideMimeType: 'text/plain',
      headers: {
        Accept: 'text/plain',
        'Content-Type': 'application/json'
      }
    }, callback);
  };

  var throttledPost = function throttledPost() {
    // Throttle logs so that they only happen 1 at a time
    if (!queueRunning && logQueue.length > 0) {
      queueRunning = true;
      var curr = logQueue[0];

      // Remove the current item and send the next log
      var processNextItem = function processNextItem() {
        logQueue.shift();
        queueRunning = false;
        throttledPost();
      };

      if (curr) {
        send(curr.data, curr.isQos, function (err) {
          if (err) {
            console.log('Failed to send ClientEvent, moving on to the next item.');

            if (curr.onComplete) {
              curr.onComplete();
            }
            // There was an error, move onto the next item
          }
          if (curr.onComplete) {
            curr.onComplete(err);
          }

          setTimeout(processNextItem, 50);
        });
      }
    }
  };

  var post = function post(data, onComplete, isQos) {
    logQueue.push({
      data: data,
      onComplete: onComplete,
      isQos: isQos
    });

    throttledPost();
  };

  var shouldThrottleError = function shouldThrottleError(code, type, partnerId) {
    if (!partnerId) {
      return false;
    }

    var errKey = [partnerId, type, code].join('_');
    var msgLimit = 100;

    // msgLimit = DynamicConfig.get('exceptionLogging', 'messageLimitPerPartner', partnerId);
    // if (msgLimit === null || msgLimit === undefined) {
    //   return false;
    // }

    return (reportedErrors[errKey] || 0) <= msgLimit;
  };

  // Log an error via ClientEvents.
  //
  // @param [String] code
  // @param [String] type
  // @param [String] message
  // @param [Hash] details additional error details
  //
  // @param [Hash] options the options to log the client event with.
  // @option options [String] action The name of the Event that we are logging. E.g.
  //  'TokShowLoaded'. Required.
  // @option options [String] variation Usually used for Split A/B testing, when you
  //  have multiple variations of the +_action+.
  // @option options [String] payload The payload. Required.
  // @option options [String] sessionId The active OpenTok session, if there is one
  // @option options [String] connectionId The active OpenTok connectionId, if there is one
  // @option options [String] partnerId
  // @option options [String] guid ...
  // @option options [String] streamId ...
  // @option options [String] section ...
  // @option options [String] clientVersion ...
  //
  // Reports will be throttled to X reports (see exceptionLogging.messageLimitPerPartner
  // from the dynamic config for X) of each error type for each partner. Reports can be
  // disabled/enabled globally or on a per partner basis (per partner settings
  // take precedence) using exceptionLogging.enabled.
  //
  this.logError = function (code, type, message, details, options) {
    options = options || {};
    var partnerId = options.partnerId;

    if (shouldThrottleError(code, type, partnerId)) {
      // OT.log('ClientEvents.error has throttled an error of type ' + type + '.' +
      // code + ' for partner ' + (partnerId || 'No Partner Id'));
      return;
    }

    var errKey = [partnerId, type, code].join('_');
    var payload = details ? details : null;

    reportedErrors[errKey] = typeof reportedErrors[errKey] !== 'undefined' ? reportedErrors[errKey] + 1 : 1;
    this.logEvent(util.extend(options, {
      action: type + '.' + code,
      payload: payload
    }), false);
  };

  // Log a client event to the analytics backend.
  //
  // @example Logs a client event called 'foo'
  //  this.logEvent({
  //      action: 'foo',
  //      payload: 'bar',
  //      sessionId: sessionId,
  //      connectionId: connectionId
  //  }, false)
  //
  // @param [Hash] data the data to log the client event with.
  // @param [Boolean] qos Whether this is a QoS event.
  // @param [Boolean] throttle A number specifying the ratio of events to be sent
  //        out of the total number of events (other events are not ignored). If not
  //        set to a number, all events are sent.
  // @param [Number] completionHandler A completion handler function to call when the
  //                 client event POST request succeeds or fails. If it fails, an error
  //                 object is passed into the function. (See throttledPost().)
  //
  this.logEvent = function (data, qos, throttle, completionHandler) {
    qos = qos || false;

    if (throttle && !isNaN(throttle)) {
      if (Math.random() > throttle) {
        logging.debug('skipping sending analytics due to throttle:', data);
        return;
      }
    }

    logging.debug('sending analytics:', data);

    // TODO: catch error when stringifying an object that has a circular reference
    data = JSON.stringify(data);

    post(data, completionHandler, qos);
  };

  // Log a client QOS to the analytics backend.
  // Log a client QOS to the analytics backend.
  // @option options [String] action The name of the Event that we are logging.
  //  E.g. 'TokShowLoaded'. Required.
  // @option options [String] variation Usually used for Split A/B testing, when
  //  you have multiple variations of the +_action+.
  // @option options [String] payload The payload. Required.
  // @option options [String] sessionId The active OpenTok session, if there is one
  // @option options [String] connectionId The active OpenTok connectionId, if there is one
  // @option options [String] partnerId
  // @option options [String] guid ...
  // @option options [String] streamId ...
  // @option options [String] section ...
  // @option options [String] clientVersion ...
  //
  this.logQOS = function (options) {
    this.logEvent(options, true);
  };
};

},{"./ajax":218,"./logging":236,"./util":240}],220:[function(require,module,exports){
'use strict';

// @todo enable the following disabled rules see OPENTOK-31136 for more info
/* eslint-disable no-param-reassign, no-restricted-syntax, no-prototype-builtins */
/* eslint-disable prefer-rest-params, no-underscore-dangle */

var innerEventingMixin = require('./eventing/innerEventingMixin');
var logging = require('../logging');
var util = require('../util');

/**
* This base class defines the <code>on</code>, <code>once</code>, and <code>off</code>
* methods of objects that can dispatch events.
*
* @class EventDispatcher
*/
module.exports = function eventing(self, syncronous) {
  var innerEventing = innerEventingMixin(syncronous);

  /**
  * Adds an event handler function for one or more events.
  *
  * <p>
  * The following code adds an event handler for one event:
  * </p>
  *
  * <pre>
  * obj.on("eventName", function (event) {
  *     // This is the event handler.
  * });
  * </pre>
  *
  * <p>If you pass in multiple event names and a handler method, the handler is
  * registered for each of those events:</p>
  *
  * <pre>
  * obj.on("eventName1 eventName2",
  *        function (event) {
  *            // This is the event handler.
  *        });
  * </pre>
  *
  * <p>You can also pass in a third <code>context</code> parameter (which is optional) to
  * define the value of <code>this</code> in the handler method:</p>
  *
  * <pre>obj.on("eventName",
  *        function (event) {
  *            // This is the event handler.
  *        },
  *        obj);
  * </pre>
  *
  * <p>
  * The method also supports an alternate syntax, in which the first parameter is an object
  * that is a hash map of event names and handler functions and the second parameter (optional)
  * is the context for this in each handler:
  * </p>
  * <pre>
  * obj.on(
  *    {
  *       eventName1: function (event) {
  *               // This is the handler for eventName1.
  *           },
  *       eventName2:  function (event) {
  *               // This is the handler for eventName2.
  *           }
  *    },
  *    obj);
  * </pre>
  *
  * <p>
  * If you do not add a handler for an event, the event is ignored locally.
  * </p>
  *
  * @param {String} type The string identifying the type of event. You can specify multiple event
  * names in this string, separating them with a space. The event handler will process each of
  * the events.
  * @param {Function} handler The handler function to process the event. This function takes
  * the event object as a parameter.
  * @param {Object} context (Optional) Defines the value of <code>this</code> in the event
  * handler function.
  *
  * @returns {EventDispatcher} The EventDispatcher object.
  *
  * @memberOf EventDispatcher
  * @method #on
  * @see <a href="#off">off()</a>
  * @see <a href="#once">once()</a>
  * @see <a href="#events">Events</a>
  */
  self.on = function (eventNames, handlerOrContext, context) {
    if (typeof eventNames === 'string' && handlerOrContext) {
      innerEventing.addListeners(eventNames.split(' '), handlerOrContext, context);
    } else {
      for (var name in eventNames) {
        if (eventNames.hasOwnProperty(name)) {
          innerEventing.addListeners([name], eventNames[name], handlerOrContext);
        }
      }
    }

    return this;
  };

  /**
  * Removes an event handler or handlers.
  *
  * <p>If you pass in one event name and a handler method, the handler is removed for that
  * event:</p>
  *
  * <pre>obj.off("eventName", eventHandler);</pre>
  *
  * <p>If you pass in multiple event names and a handler method, the handler is removed for
  * those events:</p>
  *
  * <pre>obj.off("eventName1 eventName2", eventHandler);</pre>
  *
  * <p>If you pass in an event name (or names) and <i>no</i> handler method, all handlers are
  * removed for those events:</p>
  *
  * <pre>obj.off("event1Name event2Name");</pre>
  *
  * <p>If you pass in no arguments, <i>all</i> event handlers are removed for all events
  * dispatched by the object:</p>
  *
  * <pre>obj.off();</pre>
  *
  * <p>
  * The method also supports an alternate syntax, in which the first parameter is an object that
  * is a hash map of event names and handler functions and the second parameter (optional) is
  * the context for this in each handler:
  * </p>
  * <pre>
  * obj.off(
  *    {
  *       eventName1: event1Handler,
  *       eventName2: event2Handler
  *    });
  * </pre>
  *
  * @param {String} type (Optional) The string identifying the type of event. You can
  * use a space to specify multiple events, as in "accessAllowed accessDenied
  * accessDialogClosed". If you pass in no <code>type</code> value (or other arguments),
  * all event handlers are removed for the object.
  * @param {Function} handler (Optional) The event handler function to remove. The handler
  * must be the same function object as was passed into <code>on()</code>. Be careful with
  * helpers like <code>bind()</code> that return a new function when called. If you pass in
  * no <code>handler</code>, all event handlers are removed for the specified event
  * <code>type</code>.
  * @param {Object} context (Optional) If you specify a <code>context</code>, the event handler
  * is removed for all specified events and handlers that use the specified context. (The
  * context must match the context passed into <code>on()</code>.)
  *
  * @returns {Object} The object that dispatched the event.
  *
  * @memberOf EventDispatcher
  * @method #off
  * @see <a href="#on">on()</a>
  * @see <a href="#once">once()</a>
  * @see <a href="#events">Events</a>
  */
  self.off = function (eventNames, handlerOrContext, context) {
    if (typeof eventNames === 'string') {
      if (handlerOrContext && util.isFunction(handlerOrContext)) {
        innerEventing.removeListeners(eventNames.split(' '), handlerOrContext, context);
      } else {
        innerEventing.removeAllListenersNamed(eventNames.split(' '));
      }
    } else if (!eventNames) {
      innerEventing.removeAllListeners();
    } else {
      for (var name in eventNames) {
        if (eventNames.hasOwnProperty(name)) {
          innerEventing.removeListeners([name], eventNames[name], handlerOrContext);
        }
      }
    }

    return this;
  };

  /**
  * Adds an event handler function for one or more events. Once the handler is called,
  * the specified handler method is removed as a handler for this event. (When you use
  * the <code>on()</code> method to add an event handler, the handler is <i>not</i>
  * removed when it is called.) The <code>once()</code> method is the equivilent of
  * calling the <code>on()</code>
  * method and calling <code>off()</code> the first time the handler is invoked.
  *
  * <p>
  * The following code adds a one-time event handler for one event:
  * </p>
  *
  * <pre>
  * obj.once("eventName", function (event) {
  *    // This is the event handler.
  * });
  * </pre>
  *
  * <p>If you pass in multiple event names and a handler method, the handler is registered
  * for each of those events:</p>
  *
  * <pre>obj.once("eventName1 eventName2"
  *          function (event) {
  *              // This is the event handler.
  *          });
  * </pre>
  *
  * <p>You can also pass in a third <code>context</code> parameter (which is optional) to define
  * the value of
  * <code>this</code> in the handler method:</p>
  *
  * <pre>obj.once("eventName",
  *          function (event) {
  *              // This is the event handler.
  *          },
  *          obj);
  * </pre>
  *
  * <p>
  * The method also supports an alternate syntax, in which the first parameter is an object that
  * is a hash map of event names and handler functions and the second parameter (optional) is the
  * context for this in each handler:
  * </p>
  * <pre>
  * obj.once(
  *    {
  *       eventName1: function (event) {
  *                  // This is the event handler for eventName1.
  *           },
  *       eventName2:  function (event) {
  *                  // This is the event handler for eventName1.
  *           }
  *    },
  *    obj);
  * </pre>
  *
  * @param {String} type The string identifying the type of event. You can specify multiple
  * event names in this string, separating them with a space. The event handler will process
  * the first occurence of the events. After the first event, the handler is removed (for
  * all specified events).
  * @param {Function} handler The handler function to process the event. This function takes
  * the event object as a parameter.
  * @param {Object} context (Optional) Defines the value of <code>this</code> in the event
  * handler function.
  *
  * @returns {Object} The object that dispatched the event.
  *
  * @memberOf EventDispatcher
  * @method #once
  * @see <a href="#on">on()</a>
  * @see <a href="#off">off()</a>
  * @see <a href="#events">Events</a>
  */

  self.once = function (eventNames, handler, context) {
    var handleThisOnce = function handleThisOnce() {
      self.off(eventNames, handleThisOnce, context);
      handler.apply(context, arguments);
    };

    handleThisOnce.originalHandler = handler;

    self.on(eventNames, handleThisOnce, context);

    return this;
  };

  // Execute any listeners bound to the +event+ Event.
  //
  // Each handler will be executed async. On completion the defaultAction
  // handler will be executed with the args.
  //
  // @param [Event] event
  //    An Event object.
  //
  // @param [Function, Null, Undefined] defaultAction
  //    An optional function to execute after every other handler. This will execute even
  //    if there are listeners bound to this event. +defaultAction+ will be passed
  //    args as a normal handler would.
  //
  // @return this
  //
  self.dispatchEvent = function (event, defaultAction) {
    if (!event.type) {
      logging.error('OTHelpers.Eventing.dispatchEvent: Event has no type');
      logging.error(event);

      throw new Error('OTHelpers.Eventing.dispatchEvent: Event has no type');
    }

    if (!event.target) {
      event.target = this;
    }

    innerEventing.dispatchEvent(event, defaultAction);
    return this;
  };

  // Execute each handler for the event called +name+.
  //
  // Each handler will be executed async, and any exceptions that they throw will
  // be caught and logged
  //
  // How to pass these?
  //  * defaultAction
  //
  // @example
  //  foo.on('bar', function(name, message) {
  //    alert("Hello " + name + ": " + message);
  //  });
  //
  //  foo.trigger('OpenTok', 'asdf');     // -> Hello OpenTok: asdf
  //
  //
  // @param [String] eventName
  //    The name of this event.
  //
  // @param [Array] arguments
  //    Any additional arguments beyond +eventName+ will be passed to the handlers.
  //
  // @return this
  //
  self.trigger = function () /* eventName [, arg0, arg1, ..., argN ] */{
    innerEventing.trigger.apply(innerEventing, arguments);
    return this;
  };

  // Alias of trigger for easier node compatibility
  self.emit = self.trigger;

  /**
  * Deprecated; use <a href="#on">on()</a> or <a href="#once">once()</a> instead.
  * <p>
  * This method registers a method as an event listener for a specific event.
  * <p>
  *
  * <p>
  *   If a handler is not registered for an event, the event is ignored locally. If the
  *   event listener function does not exist, the event is ignored locally.
  * </p>
  * <p>
  *   Throws an exception if the <code>listener</code> name is invalid.
  * </p>
  *
  * @param {String} type The string identifying the type of event.
  *
  * @param {Function} listener The function to be invoked when the object dispatches the event.
  *
  * @param {Object} context (Optional) Defines the value of <code>this</code> in the event
  * handler function.
  *
  * @memberOf EventDispatcher
  * @method #addEventListener
  * @see <a href="#on">on()</a>
  * @see <a href="#once">once()</a>
  * @see <a href="#events">Events</a>
  */
  // See 'on' for usage.
  // @depreciated will become a private helper function in the future.
  self.addEventListener = function (eventName, handler, context) {
    logging.warn('The addEventListener() method is deprecated. Use on() or once() instead.');
    return self.on(eventName, handler, context);
  };

  /**
  * Deprecated; use <a href="#off">off()</a> instead.
  * <p>
  * Removes an event listener for a specific event.
  * <p>
  *
  * <p>
  *   Throws an exception if the <code>listener</code> name is invalid.
  * </p>
  *
  * @param {String} type The string identifying the type of event.
  *
  * @param {Function} listener The event listener function to remove.
  *
  * @param {Object} context (Optional) If you specify a <code>context</code>, the event
  * handler is removed for all specified events and event listeners that use the specified
  context. (The context must match the context passed into
  * <code>addEventListener()</code>.)
  *
  * @memberOf EventDispatcher
  * @method #removeEventListener
  * @see <a href="#off">off()</a>
  * @see <a href="#events">Events</a>
  */
  // See 'off' for usage.
  // @depreciated will become a private helper function in the future.
  self.removeEventListener = function (eventName, handler, context) {
    logging.warn('The removeEventListener() method is deprecated. Use off() instead.');
    return self.off(eventName, handler, context);
  };

  // We expose the inner eventing for testing purposes.
  if (!self.__testOnly) {
    self.__testOnly = {};
  }

  self.__testOnly.innerEventing = innerEventing;

  return self;
};

},{"../logging":236,"../util":240,"./eventing/innerEventingMixin":222}],221:[function(require,module,exports){
'use strict';

// @todo enable the following disabled rules see OPENTOK-31136 for more info
/* eslint-disable no-underscore-dangle */

var logging = require('../../logging');

module.exports = function Event() {
  return function (type, cancelable) {
    this.type = type;
    this.cancelable = cancelable !== undefined ? cancelable : true;

    var _defaultPrevented = false;

    this.preventDefault = function () {
      if (this.cancelable) {
        _defaultPrevented = true;
      } else {
        logging.warn('Event.preventDefault :: Trying to preventDefault ' + 'on an Event that isn\'t cancelable');
      }
    };

    this.isDefaultPrevented = function () {
      return _defaultPrevented;
    };
  };
};

},{"../../logging":236}],222:[function(require,module,exports){
"use strict";

// @todo enable the following disabled rules see OPENTOK-31136 for more info
/* eslint-disable no-plusplus, prefer-rest-params */

module.exports = function innerEventingMixin(syncronous) {
  var api = {
    events: {}
  };

  // Call the defaultAction, passing args
  function executeDefaultAction(defaultAction, args) {
    if (!defaultAction) {
      return;
    }

    defaultAction.apply(undefined, args.slice());
  }

  // Execute each handler in +listeners+ with +args+.
  //
  // Each handler will be executed async. On completion the defaultAction
  // handler will be executed with the args.
  //
  // @param [Array] listeners
  //    An array of functions to execute. Each will be passed args.
  //
  // @param [Array] args
  //    An array of arguments to execute each function in  +listeners+ with.
  //
  // @param [String] name
  //    The name of this event.
  //
  // @param [Function, Null, Undefined] defaultAction
  //    An optional function to execute after every other handler. This will execute even
  //    if +listeners+ is empty. +defaultAction+ will be passed args as a normal
  //    handler would.
  //
  // @return Undefined
  //
  function executeListenersAsyncronously(name, args, defaultAction) {
    var listeners = api.events[name];
    if (!listeners || listeners.length === 0) {
      return;
    }

    var listenerAcks = listeners.length;

    listeners.forEach(function (listener) {
      // , index
      function filterHandlers(_listener) {
        return _listener.handler === listener.handler;
      }

      // We run this asynchronously so that it doesn't interfere with execution if an
      // error happens
      setTimeout(function () {
        try {
          // have to check if the listener has not been removed
          if (api.events[name] && api.events[name].some(filterHandlers)) {
            (listener.closure || listener.handler).apply(listener.context || null, args);
          }
        } finally {
          listenerAcks--;

          if (listenerAcks === 0) {
            executeDefaultAction(defaultAction, args);
          }
        }
      });
    });
  }

  // This is identical to executeListenersAsyncronously except that handlers will
  // be executed syncronously.
  //
  // On completion the defaultAction handler will be executed with the args.
  //
  // @param [Array] listeners
  //    An array of functions to execute. Each will be passed args.
  //
  // @param [Array] args
  //    An array of arguments to execute each function in  +listeners+ with.
  //
  // @param [String] name
  //    The name of this event.
  //
  // @param [Function, Null, Undefined] defaultAction
  //    An optional function to execute after every other handler. This will execute even
  //    if +listeners+ is empty. +defaultAction+ will be passed args as a normal
  //    handler would.
  //
  // @return Undefined
  //
  function executeListenersSyncronously(name, args, defaultAction) {
    var listeners = api.events[name];
    if (!listeners || listeners.length === 0) {
      return;
    }

    listeners.forEach(function (listener) {
      // index
      (listener.closure || listener.handler).apply(listener.context || null, args);
    });
    executeDefaultAction(defaultAction, args);
  }

  var executeListeners = syncronous === true ? executeListenersSyncronously : executeListenersAsyncronously;

  api.addListeners = function (eventNames, handler, context, closure) {
    var listener = { handler: handler };
    if (context) {
      listener.context = context;
    }
    if (closure) {
      listener.closure = closure;
    }

    eventNames.forEach(function (name) {
      if (!api.events[name]) {
        api.events[name] = [];
      }
      api.events[name].push(listener);

      var addedListener = name + ":added";
      if (api.events[addedListener]) {
        executeListeners(addedListener, [api.events[name].length]);
      }
    });
  };

  api.removeListeners = function (eventNames, handler, context) {
    function filterListeners(listener) {
      var isCorrectHandler = listener.handler.originalHandler === handler || listener.handler === handler;

      return !(isCorrectHandler && listener.context === context);
    }

    eventNames.forEach(function (name) {
      if (api.events[name]) {
        api.events[name] = api.events[name].filter(filterListeners);
        if (api.events[name].length === 0) {
          delete api.events[name];
        }

        var removedListener = name + ":removed";
        if (api.events[removedListener]) {
          executeListeners(removedListener, [api.events[name] ? api.events[name].length : 0]);
        }
      }
    });
  };

  api.removeAllListenersNamed = function (eventNames) {
    eventNames.forEach(function (name) {
      if (api.events[name]) {
        delete api.events[name];
      }
    });
  };

  api.removeAllListeners = function () {
    api.events = {};
  };

  api.dispatchEvent = function (event, defaultAction) {
    if (!api.events[event.type] || api.events[event.type].length === 0) {
      executeDefaultAction(defaultAction, [event]);
      return;
    }

    executeListeners(event.type, [event], defaultAction);
  };

  api.trigger = function () /* eventName [, arg1, arg2, ...argN] */{
    var args = Array.prototype.slice.call(arguments);
    var eventName = args.shift();

    if (!api.events[eventName] || api.events[eventName].length === 0) {
      return;
    }

    executeListeners(eventName, args);
  };

  return api;
};

},{}],223:[function(require,module,exports){
'use strict';

// @todo enable the following disabled rules see OPENTOK-31136 for more info
/* eslint-disable no-param-reassign, prefer-rest-params */

var util = require('../util');

module.exports = function statable(self, possibleStates, initialState, stateChanged, stateChangedFailed) {
  var previousState = void 0;
  var currentState = initialState;
  self.currentState = initialState;

  var setState = function setState(state) {
    if (currentState !== state) {
      if (possibleStates.indexOf(state) === -1) {
        if (stateChangedFailed && util.isFunction(stateChangedFailed)) {
          stateChangedFailed('invalidState', state);
        }
        return;
      }

      self.previousState = currentState;
      previousState = currentState;
      self.currentState = state;
      currentState = state;

      if (stateChanged && util.isFunction(stateChanged)) {
        stateChanged(state, previousState);
      }
    }
  };

  // Returns a number of states and returns true if the current state
  // is any of them.
  //
  // @example
  // if (this.is('connecting', 'connected')) {
  //   // do some stuff
  // }
  //
  self.is = function () /* state0:String, state1:String, ..., stateN:String */{
    return Array.prototype.indexOf.call(arguments, currentState) !== -1;
  };

  // Returns a number of states and returns true if the current state
  // is none of them.
  //
  // @example
  // if (this.isNot('connecting', 'connected')) {
  //   // do some stuff
  // }
  //
  self.isNot = function () /* state0:String, state1:String, ..., stateN:String */{
    return Array.prototype.indexOf.call(arguments, currentState) === -1;
  };

  return setState;
};

},{"../util":240}],224:[function(require,module,exports){
'use strict';

var makeEverythingAttachToOTHelpers = require('./makeEverythingAttachToOTHelpers');

var casting = {};
module.exports = casting;

casting.castToBoolean = function (value, defaultValue) {
  if (value === undefined) {
    return defaultValue;
  }

  return value === 'true' || value === true;
};

casting.roundFloat = function (value, places) {
  return Number(value.toFixed(places));
};

makeEverythingAttachToOTHelpers(casting);

},{"./makeEverythingAttachToOTHelpers":238}],225:[function(require,module,exports){
'use strict';

// @todo enable the following disabled rules see OPENTOK-31136 for more info
/* eslint-disable no-underscore-dangle, no-void, no-restricted-syntax, no-prototype-builtins */
/* eslint-disable no-continue, no-plusplus, prefer-spread, prefer-rest-params */

var eventing = require('./behaviours/eventing');
var logging = require('./logging');
var util = require('./util');

module.exports = function Collection(idField) {
  var _models = [];
  var _byId = {};
  var _idField = idField || 'id';

  eventing(this, true);

  var modelProperty = function modelProperty(model, property) {
    if (util.isFunction(model[property])) {
      return model[property]();
    }

    return model[property];
  };

  var onModelUpdate = function onModelUpdate(event) {
    this.trigger('update', event);
    this.trigger('update:' + event.target.id, event);
  }.bind(this);

  var onModelDestroy = function onModelDestroyed(event) {
    this.remove(event.target, event.reason);
  }.bind(this);

  this.reset = function () {
    // Stop listening on the models, they are no longer our problem
    _models.forEach(function (model) {
      model.off('updated', onModelUpdate, this);
      model.off('destroyed', onModelDestroy, this);
    }, this);

    _models = [];
    _byId = {};
  };

  this.destroy = function (reason) {
    _models.forEach(function (model) {
      if (model && typeof model.destroy === 'function') {
        model.destroy(reason, true);
      }
    });

    this.reset();
    this.off();
  };

  this.get = function (id) {
    return id && _byId[id] !== void 0 ? _models[_byId[id]] : void 0;
  };
  this.has = function (id) {
    return id && _byId[id] !== void 0;
  };

  this.toString = function () {
    return _models.toString();
  };

  // Return only models filtered by either a dict of properties
  // or a filter function.
  //
  // @example Return all publishers with a streamId of 1
  //   OT.publishers.where({streamId: 1})
  //
  // @example The same thing but filtering using a filter function
  //   OT.publishers.where(function(publisher) {
  //     return publisher.stream.id === 4;
  //   });
  //
  // @example The same thing but filtering using a filter function
  //          executed with a specific this
  //   OT.publishers.where(function(publisher) {
  //     return publisher.stream.id === 4;
  //   }, self);
  //
  this.where = function (attrsOrFilterFn, context) {
    if (util.isFunction(attrsOrFilterFn)) {
      return _models.filter(attrsOrFilterFn, context);
    }

    return _models.filter(function (model) {
      for (var key in attrsOrFilterFn) {
        if (!attrsOrFilterFn.hasOwnProperty(key)) {
          continue;
        }
        if (modelProperty(model, key) !== attrsOrFilterFn[key]) {
          return false;
        }
      }

      return true;
    });
  };

  // Similar to where in behaviour, except that it only returns
  // the first match.
  this.find = function (attrsOrFilterFn, context) {
    var filterFn = void 0;

    if (util.isFunction(attrsOrFilterFn)) {
      filterFn = attrsOrFilterFn;
    } else {
      filterFn = function filterFn(model) {
        for (var key in attrsOrFilterFn) {
          if (!attrsOrFilterFn.hasOwnProperty(key)) {
            continue;
          }
          if (modelProperty(model, key) !== attrsOrFilterFn[key]) {
            return false;
          }
        }

        return true;
      };
    }

    filterFn = filterFn.bind(context);

    for (var i = 0; i < _models.length; ++i) {
      if (filterFn(_models[i]) === true) {
        return _models[i];
      }
    }

    return null;
  };

  this.forEach = function (fn, context) {
    _models.forEach(fn, context);
    return this;
  };

  this.add = function (model) {
    var id = modelProperty(model, _idField);

    if (this.has(id)) {
      logging.warn('Model ' + id + ' is already in the collection', _models);
      return this;
    }

    _byId[id] = _models.push(model) - 1;

    model.on('updated', onModelUpdate, this);
    model.on('destroyed', onModelDestroy, this);

    this.trigger('add', model);
    this.trigger('add:' + id, model);

    return this;
  };

  this.remove = function (model, reason) {
    var id = modelProperty(model, _idField);

    _models.splice(_byId[id], 1);

    // Shuffle everyone down one
    for (var i = _byId[id]; i < _models.length; ++i) {
      _byId[modelProperty(_models[i], _idField)] = i;
    }

    delete _byId[id];

    model.off('updated', onModelUpdate, this);
    model.off('destroyed', onModelDestroy, this);

    this.trigger('remove', model, reason);
    this.trigger('remove:' + id, model, reason);

    return this;
  };

  // Retrigger the add event behaviour for each model. You can also
  // select a subset of models to trigger using the same arguments
  // as the #where method.
  this._triggerAddEvents = function () {
    this.where.apply(this, arguments).forEach(function (model) {
      this.trigger('add', model);
      this.trigger('add:' + modelProperty(model, _idField), model);
    }, this);
  };

  this.length = function () {
    return _models.length;
  };
};

},{"./behaviours/eventing":220,"./logging":236,"./util":240}],226:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

// @todo enable the following disabled rules see OPENTOK-31136 for more info
/* eslint-disable no-param-reassign */

var makeEverythingAttachToOTHelpers = require('./makeEverythingAttachToOTHelpers');

var domExtras = {};
module.exports = domExtras;

domExtras.isElementNode = function (node) {
  return node && (typeof node === 'undefined' ? 'undefined' : _typeof(node)) === 'object' && node.nodeType === 1;
};

domExtras.createElement = function (nodeName, attributes, children, doc) {
  var element = (doc || document).createElement(nodeName);
  attributes = attributes || {};

  Object.keys(attributes).forEach(function (name) {
    if (_typeof(attributes[name]) === 'object') {
      if (!element[name]) {
        element[name] = {};
      }

      var subAttrs = attributes[name];

      Object.keys(subAttrs).forEach(function (n) {
        element[name][n] = subAttrs[n];
      });
    } else if (name === 'className') {
      element.className = attributes[name];
    } else {
      element.setAttribute(name, attributes[name]);
    }
  });

  var setChildren = function setChildren(child) {
    if (typeof child === 'string') {
      element.innerHTML += child;
    } else {
      element.appendChild(child);
    }
  };

  if (Array.isArray(children)) {
    children.forEach(setChildren);
  } else if (children) {
    setChildren(children);
  }

  return element;
};

makeEverythingAttachToOTHelpers(domExtras);

},{"./makeEverythingAttachToOTHelpers":238}],227:[function(require,module,exports){
'use strict';

// @todo enable the following disabled rules see OPENTOK-31136 for more info
/* eslint-disable no-param-reassign, no-void, no-underscore-dangle */

var util = require('../../util');

var specialDomProperties = {
  for: 'htmlFor',
  class: 'className'
};

module.exports = function (ElementCollection) {
  // Gets or sets the attribute called +name+ for the first element in the collection
  ElementCollection.prototype.attr = function (name, value) {
    var _this = this;

    if (util.isObject(name)) {
      var actualName = void 0;

      Object.keys(name).forEach(function (key) {
        actualName = specialDomProperties[key] || key;
        _this.first.setAttribute(actualName, name[key]);
      });
    } else if (value === void 0) {
      return this.first.getAttribute(specialDomProperties[name] || name);
    } else {
      this.first.setAttribute(specialDomProperties[name] || name, value);
    }

    return this;
  };

  // Removes an attribute called +name+ for the every element in the collection.
  ElementCollection.prototype.removeAttr = function (name) {
    var actualName = specialDomProperties[name] || name;

    this.forEach(function (element) {
      element.removeAttribute(actualName);
    });

    return this;
  };

  // Gets, and optionally sets, the html body of the first element
  // in the collection. If the +html+ is provided then the first
  // element's html body will be replaced with it.
  //
  ElementCollection.prototype.html = function (html) {
    if (html !== void 0) {
      this.first.innerHTML = html;
    }

    return this.first.innerHTML;
  };

  // Centers +element+ within the global. You can pass through the width and height
  // if you know it, if you don't they will be calculated for you.
  ElementCollection.prototype.center = function (width, height) {
    var $element = void 0;

    this.forEach(function (element) {
      $element = new ElementCollection(element);
      width = width || parseInt($element.width(), 10);
      height = height || parseInt($element.height(), 10);

      var marginLeft = -0.5 * width + 'px';
      var marginTop = -0.5 * height + 'px';

      $element.css('margin', marginTop + ' 0 0 ' + marginLeft).addClass('OT_centered');
    });

    return this;
  };

  // @remove
  // Centers +element+ within the global. You can pass through the width and height
  // if you know it, if you don't they will be calculated for you.
  ElementCollection._attachToOTHelpers.centerElement = function (element, width, height) {
    return new ElementCollection(element).center(width, height);
  };

  /**
   * Methods to calculate element widths and heights.
   */
  var _width = function _width(element) {
    if (element.offsetWidth > 0) {
      return element.offsetWidth + 'px';
    }

    return new ElementCollection(element).css('width');
  };

  var _height = function _height(element) {
    if (element.offsetHeight > 0) {
      return element.offsetHeight + 'px';
    }

    return new ElementCollection(element).css('height');
  };

  ElementCollection.prototype.width = function (newWidth) {
    if (newWidth) {
      this.css('width', newWidth);
      return this;
    }

    if (this.isDisplayNone()) {
      return this.makeVisibleAndYield(function (element) {
        return _width(element);
      })[0];
    }

    return _width(this.get(0));
  };

  // @remove
  ElementCollection._attachToOTHelpers.width = function (element, newWidth) {
    var ret = new ElementCollection(element).width(newWidth);
    return newWidth ? ElementCollection._attachToOTHelpers : ret;
  };

  ElementCollection.prototype.height = function (newHeight) {
    if (newHeight) {
      this.css('height', newHeight);
      return this;
    }

    if (this.isDisplayNone()) {
      // We can't get the height, probably since the element is hidden.
      return this.makeVisibleAndYield(function (element) {
        return _height(element);
      })[0];
    }

    return _height(this.get(0));
  };

  // @remove
  ElementCollection._attachToOTHelpers.height = function (element, newHeight) {
    var ret = new ElementCollection(element).height(newHeight);
    return newHeight ? ElementCollection._attachToOTHelpers : ret;
  };
};

},{"../../util":240}],228:[function(require,module,exports){
'use strict';

// @todo enable the following disabled rules see OPENTOK-31136 for more info
/* eslint-disable no-plusplus, no-param-reassign, no-bitwise */

var hasClassListCapability = require('../../../helpers/hasClassListCapability.js');

function hasClass(element, className) {
  if (!className) {
    return false;
  }

  if (hasClassListCapability()) {
    return element.classList.contains(className);
  }

  return element.className.indexOf(className) > -1;
}

function toggleClasses(element, classNames) {
  if (!classNames || classNames.length === 0) {
    return;
  }

  // Only bother targeting Element nodes, ignore Text Nodes, CDATA, etc
  if (element.nodeType !== 1) {
    return;
  }

  var numClasses = classNames.length;
  var i = 0;

  if (hasClassListCapability()) {
    for (; i < numClasses; ++i) {
      element.classList.toggle(classNames[i]);
    }

    return;
  }

  var className = (' ' + element.className + ' ').replace(/[\s+]/, ' ');

  for (; i < numClasses; ++i) {
    if (hasClass(element, classNames[i])) {
      className = className.replace(' ' + classNames[i] + ' ', ' ');
    } else {
      className += classNames[i] + ' ';
    }
  }

  element.className = className.trim();
}

function addClass(element, classNames) {
  if (!classNames || classNames.length === 0) {
    return;
  }

  // Only bother targeting Element nodes, ignore Text Nodes, CDATA, etc
  if (element.nodeType !== 1) {
    return;
  }

  var numClasses = classNames.length;
  var i = 0;

  if (hasClassListCapability()) {
    for (; i < numClasses; ++i) {
      element.classList.add(classNames[i]);
    }

    return;
  }

  // Here's our fallback to browsers that don't support element.classList

  if (!element.className && classNames.length === 1) {
    element.className = classNames.join(' ');
  } else {
    var setClass = ' ' + element.className + ' ';

    for (; i < numClasses; ++i) {
      if (!~setClass.indexOf(' ' + classNames[i] + ' ')) {
        setClass += classNames[i] + ' ';
      }
    }

    element.className = setClass.trim();
  }
}

function removeClass(element, classNames) {
  if (!classNames || classNames.length === 0) {
    return;
  }

  // Only bother targeting Element nodes, ignore Text Nodes, CDATA, etc
  if (element.nodeType !== 1) {
    return;
  }

  var numClasses = classNames.length;
  var i = 0;

  if (hasClassListCapability()) {
    for (; i < numClasses; ++i) {
      element.classList.remove(classNames[i]);
    }

    return;
  }

  var className = (' ' + element.className + ' ').replace(/[\s+]/, ' ');

  for (; i < numClasses; ++i) {
    className = className.replace(' ' + classNames[i] + ' ', ' ');
  }

  element.className = className.trim();
}

module.exports = function (ElementCollection) {
  ElementCollection.prototype.addClass = function (value) {
    if (value) {
      var classNames = value.trim().split(/\s+/);

      this.forEach(function (element) {
        addClass(element, classNames);
      });
    }

    return this;
  };

  ElementCollection.prototype.removeClass = function (value) {
    if (value) {
      var classNames = value.trim().split(/\s+/);

      this.forEach(function (element) {
        removeClass(element, classNames);
      });
    }

    return this;
  };

  ElementCollection.prototype.toggleClass = function (value) {
    if (value) {
      var classNames = value.trim().split(/\s+/);

      this.forEach(function (element) {
        toggleClasses(element, classNames);
      });
    }

    return this;
  };

  ElementCollection.prototype.hasClass = function (value) {
    return this.some(function (element) {
      return hasClass(element, value);
    });
  };
};

},{"../../../helpers/hasClassListCapability.js":261}],229:[function(require,module,exports){
(function (global){
'use strict';

// @todo enable the following disabled rules see OPENTOK-31136 for more info
/* eslint-disable import/newline-after-import, prefer-const, no-restricted-syntax */
/* eslint-disable no-prototype-builtins, no-param-reassign, one-var, no-void */

var env = require('../../env');
var getCompStyle = global.getComputedStyle;

var VENDOR_PREFIXES = {
  Firefox: 'moz',
  Opera: 'O',
  IE: 'ms',
  Chrome: 'Webkit',
  Safari: 'Webkit'
};

function vendorPrefix() {
  return VENDOR_PREFIXES[env.name];
}

module.exports = function (ElementCollection, findElementWithDisplayNone) {
  var displayStateCache = {};
  var defaultDisplays = {};

  var defaultDisplayValueForElement = function defaultDisplayValueForElement(element) {
    if (defaultDisplays[element.ownerDocument] && defaultDisplays[element.ownerDocument][element.nodeName]) {
      return defaultDisplays[element.ownerDocument][element.nodeName];
    }

    if (!defaultDisplays[element.ownerDocument]) {
      defaultDisplays[element.ownerDocument] = {};
    }

    // We need to know what display value to use for this node. The easiest way
    // is to actually create a node and read it out.
    var testNode = element.ownerDocument.createElement(element.nodeName);
    var defaultDisplay = void 0;

    element.ownerDocument.body.appendChild(testNode);
    defaultDisplay = new ElementCollection(testNode).css('display');
    defaultDisplays[element.ownerDocument][element.nodeName] = defaultDisplay;

    new ElementCollection(testNode).remove();
    testNode = null;

    return defaultDisplay;
  };

  var isHidden = function isHidden(element) {
    var computedStyle = getCompStyle(element);
    return computedStyle.getPropertyValue('display') === 'none';
  };

  var getNormalisedPropName = function getNormalisedPropName(element, name) {
    if (name in element.style) {
      return name;
    }

    // Try vendored names next
    var prefix = vendorPrefix();
    var capitalName = prefix + name[0].toUpperCase() + name.slice(1);

    if (capitalName in element.style) {
      return capitalName;
    }

    return name;
  };

  var setCssProperties = function setCssProperties(element, hash) {
    var style = element.style;

    for (var cssName in hash) {
      if (hash.hasOwnProperty(cssName)) {
        style[getNormalisedPropName(element, cssName)] = hash[cssName];
      }
    }
  };

  var setCssProperty = function setCssProperty(element, name, value) {
    element.style[getNormalisedPropName(element, name)] = value;
  };

  var getCssProperty = function getCssProperty(element, unnormalisedName) {
    var name = getNormalisedPropName(element, unnormalisedName);
    var computedStyle = getCompStyle(element);
    var currentValue = computedStyle.getPropertyValue(name);

    if (currentValue === '') {
      currentValue = element.style[name];
    }

    return currentValue;
  };

  var applyCSS = function applyCSS(element, styles, callback) {
    var $element = new ElementCollection(element);
    var oldStyles = {};
    var name = void 0,
        ret = void 0;

    // Backup the old styles
    for (name in styles) {
      if (styles.hasOwnProperty(name)) {
        // We intentionally read out of style here, instead of using the css
        // helper. This is because the css helper uses querySelector and we
        // only want to pull values out of the style (domeElement.style) hash.
        oldStyles[name] = element.style[name];

        $element.css(name, styles[name]);
      }
    }

    ret = callback(element);

    // Restore the old styles
    for (name in styles) {
      if (styles.hasOwnProperty(name)) {
        $element.css(name, oldStyles[name] || '');
      }
    }

    return ret;
  };

  ElementCollection.prototype.show = function () {
    return this.forEach(function (element) {
      var display = element.style.display;

      if (display === '' || display === 'none') {
        element.style.display = displayStateCache[element] || '';
        delete displayStateCache[element];
      }

      if (isHidden(element)) {
        // It's still hidden so there's probably a stylesheet that declares this
        // element as display:none;
        displayStateCache[element] = 'none';

        element.style.display = defaultDisplayValueForElement(element);
      }
    });
  };

  ElementCollection.prototype.hide = function () {
    return this.forEach(function (element) {
      if (element.style.display === 'none') {
        return;
      }

      displayStateCache[element] = element.style.display;
      element.style.display = 'none';
    });
  };

  ElementCollection.prototype.css = function (nameOrHash, value) {
    if (this.length === 0) {
      // FIXME: I made this `return undefined` to preserve behaviour, but `return this` is probably
      // more consistent.
      return undefined;
    }

    if (typeof nameOrHash !== 'string') {
      return this.forEach(function (element) {
        setCssProperties(element, nameOrHash);
      });
    }

    if (value !== undefined) {
      return this.forEach(function (element) {
        setCssProperty(element, nameOrHash, value);
      });
    }

    return getCssProperty(this.first, nameOrHash, value);
  };

  // Make +element+ visible while executing +callback+.
  ElementCollection.prototype.makeVisibleAndYield = function (callback) {
    var hiddenVisually = {
      display: 'block',
      visibility: 'hidden'
    };
    var results = [];

    this.forEach(function (element) {
      // find whether it's the element or an ancestor that's display none and
      // then apply to whichever it is
      var targetElement = findElementWithDisplayNone(element);
      if (!targetElement) {
        results.push(void 0);
      } else {
        results.push(applyCSS(targetElement, hiddenVisually, callback));
      }
    });

    return results;
  };
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../env":233}],230:[function(require,module,exports){
'use strict';

// @todo enable the following disabled rules see OPENTOK-31136 for more info
/* eslint-disable  no-plusplus, prefer-rest-params, no-param-reassign */
/* eslint-disable no-underscore-dangle */

var util = require('../../util');

module.exports = function (ElementCollection) {
  var sizeObserverCount = 0;
  var nodeRemovalObserverCount = 0;

  var observeStyleChanges = function observeStyleChanges(element, stylesToObserve, onChange) {
    var oldStyles = {};

    var getStyle = function getStyle(style) {
      switch (style) {
        case 'width':
          return new ElementCollection(element).width();

        case 'height':
          return new ElementCollection(element).height();

        default:
          return new ElementCollection(element).css(style);
      }
    };

    // get the inital values
    stylesToObserve.forEach(function (style) {
      oldStyles[style] = getStyle(style);
    });

    var observer = new MutationObserver(function (mutations) {
      var changeSet = {};

      mutations.forEach(function (mutation) {
        if (mutation.attributeName !== 'style') {
          return;
        }

        var isHidden = new ElementCollection(element).isDisplayNone();

        stylesToObserve.forEach(function (style) {
          if (isHidden && (style === 'width' || style === 'height')) {
            return;
          }

          var newValue = getStyle(style);

          if (newValue !== oldStyles[style]) {
            changeSet[style] = [oldStyles[style], newValue];
            oldStyles[style] = newValue;
          }
        });
      });

      if (!util.isEmpty(changeSet)) {
        // Do this after so as to help avoid infinite loops of mutations.
        setTimeout(function () {
          onChange.call(null, changeSet);
        });
      }
    });

    observer.observe(element, {
      attributes: true,
      attributeFilter: ['style'],
      childList: false,
      characterData: false,
      subtree: false
    });

    return observer;
  };

  var observeNodeOrChildNodeRemoval = function observeNodeOrChildNodeRemoval(element, onChange) {
    var observer = new MutationObserver(function (mutations) {
      var removedNodes = [];

      mutations.forEach(function (mutation) {
        if (mutation.removedNodes.length) {
          removedNodes = removedNodes.concat(Array.prototype.slice.call(mutation.removedNodes));
        }
      });

      if (removedNodes.length) {
        // Do this after so as to help avoid infinite loops of mutations.
        setTimeout(function () {
          onChange(new ElementCollection(removedNodes));
        });
      }
    });

    observer.observe(element, {
      attributes: false,
      childList: true,
      characterData: false,
      subtree: true
    });

    nodeRemovalObserverCount++;

    // Intercept the native disconnect method so we can keep a valid count
    // of the currently active node removal observers
    var nativeDisconnect = observer.disconnect;
    observer.disconnect = function () {
      nativeDisconnect.apply(observer, arguments);
      nodeRemovalObserverCount--;
    };

    return observer;
  };

  var observeSize = function observeSize(element, onChange) {
    var previousSize = {
      width: 0,
      height: 0
    };

    var interval = setInterval(function () {
      var rect = element.getBoundingClientRect();
      if (previousSize.width !== rect.width || previousSize.height !== rect.height) {
        onChange(rect, previousSize);
        previousSize = {
          width: rect.width,
          height: rect.height
        };
      }
    }, 1000 / 5);

    sizeObserverCount++;

    return {
      disconnect: function disconnect() {
        clearInterval(interval);
        sizeObserverCount--;
      }
    };
  };

  // Allows an +onChange+ callback to be triggered when specific style properties
  // of +element+ are notified. The callback accepts a single parameter, which is
  // a hash where the keys are the style property that changed and the values are
  // an array containing the old and new values ([oldValue, newValue]).
  //
  // Width and Height changes while the element is display: none will not be
  // fired until such time as the element becomes visible again.
  //
  // This function returns the MutationObserver itself. Once you no longer wish
  // to observe the element you should call disconnect on the observer.
  //
  // Observing changes:
  //  // observe changings to the width and height of object
  //  dimensionsObserver = OTHelpers(object).observeStyleChanges(,
  //                                                    ['width', 'height'], function(changeSet) {
  //      OT.debug("The new width and height are " +
  //                      changeSet.width[1] + ',' + changeSet.height[1]);
  //  });
  //
  // Cleaning up
  //  // stop observing changes
  //  dimensionsObserver.disconnect();
  //  dimensionsObserver = null;
  //
  ElementCollection.prototype.observeStyleChanges = function (stylesToObserve, onChange) {
    var observers = [];

    this.forEach(function (element) {
      observers.push(observeStyleChanges(element, stylesToObserve, onChange));
    });

    return observers;
  };

  // trigger the +onChange+ callback whenever
  // 1. +element+ is removed
  // 2. or an immediate child of +element+ is removed.
  //
  // This function returns the MutationObserver itself. Once you no longer wish
  // to observe the element you should call disconnect on the observer.
  //
  // Observing changes:
  //  // observe changings to the width and height of object
  //  nodeObserver = OTHelpers(object).observeNodeOrChildNodeRemoval(function(removedNodes) {
  //      OT.debug("Some child nodes were removed");
  //      removedNodes.forEach(function(node) {
  //          OT.debug(node);
  //      });
  //  });
  //
  // Cleaning up
  //  // stop observing changes
  //  nodeObserver.disconnect();
  //  nodeObserver = null;
  //
  ElementCollection.prototype.observeNodeOrChildNodeRemoval = function (onChange) {
    var observers = [];

    this.forEach(function (element) {
      observers.push(observeNodeOrChildNodeRemoval(element, onChange));
    });

    return observers;
  };

  // trigger the +onChange+ callback whenever the width or the height of the element changes
  //
  // Once you no longer wish to observe the element you should call disconnect on the observer.
  //
  // Observing changes:
  //  // observe changings to the width and height of object
  //  sizeObserver = OTHelpers(object).observeSize(function(newSize, previousSize) {
  //      OT.debug("The new width and height are " +
  //                      newSize.width + ',' + newSize.height);
  //  });
  //
  // Cleaning up
  //  // stop observing changes
  //  sizeObserver.disconnect();
  //  sizeObserver = null;
  //
  ElementCollection.prototype.observeSize = function (onChange) {
    var observers = [];

    this.forEach(function (element) {
      observers.push(observeSize(element, onChange));
    });

    return observers;
  };

  // @remove
  ElementCollection._attachToOTHelpers.observeStyleChanges = function (element, stylesToObserve, onChange) {
    return new ElementCollection(element).observeStyleChanges(stylesToObserve, onChange)[0];
  };

  // @remove
  ElementCollection._attachToOTHelpers.observeNodeOrChildNodeRemoval = function (element, onChange) {
    return new ElementCollection(element).observeNodeOrChildNodeRemoval(onChange)[0];
  };

  // We expose observer counts for testing purposes.
  if (!ElementCollection.__testOnly) {
    ElementCollection.__testOnly = {};
  }

  ElementCollection.__testOnly.sizeObserverCount = function () {
    return sizeObserverCount;
  };

  ElementCollection.__testOnly.nodeRemovalObserverCount = function () {
    return nodeRemovalObserverCount;
  };
};

},{"../../util":240}],231:[function(require,module,exports){
(function (global){
'use strict';

// @todo enable the following disabled rules see OPENTOK-31136 for more info
/* eslint-disable global-require, no-plusplus, no-param-reassign,  no-void */
/* eslint-disable no-underscore-dangle, prefer-rest-params, prefer-const */

var extensions = {
  attributes: require('./extensions/attributes'),
  css: require('./extensions/css'),
  classNames: require('./extensions/classNames'),
  observers: require('./extensions/observers')
};

var env = require('../env');
var util = require('../util');

// A helper for converting a NodeList to a JS Array
var nodeListToArray = function nodeListToArray(nodes) {
  if (env.name !== 'IE' || env.version > 9) {
    return Array.prototype.slice.call(nodes);
  }

  // IE 9 and below call use Array.prototype.slice.call against
  // a NodeList, hence the following
  var array = [];

  for (var i = 0, num = nodes.length; i < num; ++i) {
    array.push(nodes[i]);
  }

  return array;
};

var selectorToElementArray = function selectorToElementArray(selector, context) {
  var elements = void 0;

  if (typeof selector === 'undefined') {
    return [];
  }

  if (typeof selector === 'string') {
    elements = [];

    var idSelector = util.detectIdSelectors.exec(selector);
    context = context || document;

    if (idSelector && idSelector[1]) {
      var element = context.getElementById(idSelector[1]);
      if (element) {
        elements.push(element);
      }
    } else {
      elements = context.querySelectorAll(selector);
    }
  } else if (selector && (selector.nodeType || global.XMLHttpRequest && selector instanceof XMLHttpRequest || selector === global)) {
    // allow OTHelpers(DOMNode) and OTHelpers(xmlHttpRequest)
    elements = [selector];
    context = selector;
  } else if (Array.isArray(selector)) {
    elements = selector.slice();
    context = null;
  } else {
    elements = nodeListToArray(elements);
  }

  return elements;
};

// ElementCollection contains the result of calling OTHelpers.
//
// It has the following properties:
//   length
//   first
//   last
//
// It also has a get method that can be used to access elements in the collection
//
//   var videos = OTHelpers('video');
//   var firstElement = videos.get(0);               // identical to videos.first
//   var lastElement = videos.get(videos.length-1);  // identical to videos.last
//   var allVideos = videos.get();
//
//
// The collection also implements the following helper methods:
//   some, forEach, map, filter, find,
//   appendTo, after, before, remove, empty,
//   attr, center, width, height,
//   addClass, removeClass, hasClass, toggleClass,
//   on, off, once,
//   observeStyleChanges, observeNodeOrChildNodeRemoval
//
// Mostly the usage should be obvious. When in doubt, assume it functions like
// the jQuery equivalent.
//
var ElementCollection = function ElementCollection(selector, context) {
  var elements = selectorToElementArray(selector, context);
  this.context = context;
  this.toArray = function () {
    return elements;
  };

  this.length = elements.length;
  this.first = elements[0];
  this.last = elements[elements.length - 1];

  this.get = function (index) {
    if (index === void 0) {
      return elements;
    }

    return elements[index];
  };
};

module.exports = ElementCollection;

ElementCollection._attachToOTHelpers = {};

// @remove
ElementCollection._attachToOTHelpers.removeElement = function (element) {
  return new ElementCollection(element).remove();
};

ElementCollection.prototype.getAsArray = function () {
  var _collection = this.get();

  if (!util.isFunction(_collection.forEach)) {
    // It's possibly something Array-ish that isn't quite an
    // Array. Something like arguments or a NodeList
    _collection = nodeListToArray(_collection);
  }

  return _collection;
};

ElementCollection.prototype.some = function (iter, context) {
  return this.getAsArray().some(iter, context);
};

ElementCollection.prototype.forEach = function (fn, context) {
  this.getAsArray().forEach(fn, context);
  return this;
};

ElementCollection.prototype.map = function (fn, context) {
  return new ElementCollection(this.getAsArray().map(fn, context), this.context);
};

ElementCollection.prototype.filter = function (fn, context) {
  return new ElementCollection(this.getAsArray().filter(fn, context), this.context);
};

ElementCollection.prototype.find = function (selector) {
  return new ElementCollection(selector, this.first);
};

// Helper function for adding event listeners to dom elements.
// WARNING: This doesn't preserve event types, your handler could
// be getting all kinds of different parameters depending on the browser.
// You also may have different scopes depending on the browser and bubbling
// and cancelable are not supported.
ElementCollection.prototype.on = function (eventName, handler) {
  return this.forEach(function (element) {
    element.addEventListener(eventName, handler, false);
  });
};

// Helper function for removing event listeners from dom elements.
ElementCollection.prototype.off = function (eventName, handler) {
  return this.forEach(function (element) {
    element.removeEventListener(eventName, handler, false);
  });
};

ElementCollection.prototype.once = function (eventName, handler) {
  var removeAfterTrigger = function () {
    this.off(eventName, removeAfterTrigger);
    handler.apply(undefined, arguments);
  }.bind(this);

  return this.on(eventName, removeAfterTrigger);
};

ElementCollection.prototype.appendTo = function (parentElement) {
  if (!parentElement) {
    throw new Error('appendTo requires a DOMElement to append to.');
  }

  return this.forEach(function (child) {
    parentElement.appendChild(child);
  });
};

ElementCollection.prototype.append = function () {
  var parentElement = this.first;
  if (!parentElement) {
    return this;
  }

  Array.prototype.forEach.call(arguments, function (child) {
    parentElement.appendChild(child);
  });

  return this;
};

ElementCollection.prototype.prepend = function () {
  if (arguments.length === 0) {
    return this;
  }

  var parentElement = this.first;
  var elementsToPrepend = void 0;

  if (!parentElement) {
    return this;
  }

  elementsToPrepend = Array.prototype.slice.call(arguments);

  if (!parentElement.firstElementChild) {
    parentElement.appendChild(elementsToPrepend.shift());
  }

  elementsToPrepend.forEach(function (element) {
    parentElement.insertBefore(element, parentElement.firstElementChild);
  });

  return this;
};

ElementCollection.prototype.after = function (prevElement) {
  if (!prevElement) {
    throw new Error('after requires a DOMElement to insert after');
  }

  return this.forEach(function (element) {
    if (element.parentElement) {
      if (prevElement !== element.parentNode.lastChild) {
        element.parentElement.insertBefore(element, prevElement);
      } else {
        element.parentElement.appendChild(element);
      }
    }
  });
};

ElementCollection.prototype.before = function (nextElement) {
  if (!nextElement) {
    throw new Error('before requires a DOMElement to insert before');
  }

  return this.forEach(function (element) {
    if (element.parentElement) {
      element.parentElement.insertBefore(element, nextElement);
    }
  });
};

ElementCollection.prototype.remove = function () {
  return this.forEach(function (element) {
    if (element.parentNode) {
      element.parentNode.removeChild(element);
    }
  });
};

ElementCollection.prototype.empty = function () {
  return this.forEach(function (element) {
    // elements is a "live" NodesList collection. Meaning that the collection
    // itself will be mutated as we remove elements from the DOM. This means
    // that "while there are still elements" is safer than "iterate over each
    // element" as the collection length and the elements indices will be modified
    // with each iteration.
    while (element.firstChild) {
      element.removeChild(element.firstChild);
    }
  });
};

// Detects when an element is not part of the document flow because
// it or one of it's ancesters has display:none.
ElementCollection.prototype.isDisplayNone = function () {
  return this.some(function (element) {
    if ((element.offsetWidth === 0 || element.offsetHeight === 0) && new ElementCollection(element).css('display') === 'none') {
      return true;
    }

    if (element.parentNode && element.parentNode.style) {
      return new ElementCollection(element.parentNode).isDisplayNone();
    }

    return false;
  });
};

var findElementWithDisplayNone = function findElementWithDisplayNone(element) {
  if ((element.offsetWidth === 0 || element.offsetHeight === 0) && new ElementCollection(element).css('display') === 'none') {
    return element;
  }

  if (element.parentNode && element.parentNode.style) {
    return findElementWithDisplayNone(element.parentNode);
  }

  return null;
};

// @remove
ElementCollection._attachToOTHelpers.emptyElement = function (element) {
  return new ElementCollection(element).empty();
};

ElementCollection._attachToOTHelpers._findElementWithDisplayNone = findElementWithDisplayNone;

extensions.css(ElementCollection, findElementWithDisplayNone);
extensions.attributes(ElementCollection);
extensions.classNames(ElementCollection);
extensions.observers(ElementCollection);

// TODO: Deprecation logging?
// @remove
['on', 'off', 'isDisplayNone', 'show', 'hide', 'css', 'makeVisibleAndYield', 'addClass', 'removeClass'].forEach(function (methodName) {
  ElementCollection._attachToOTHelpers[methodName] = function () /* arguments */{
    var args = Array.prototype.slice.apply(arguments);
    var element = args.shift();

    var collection = new ElementCollection(element);

    return ElementCollection.prototype[methodName].apply(collection, args);
  };
});

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../env":233,"../util":240,"./extensions/attributes":227,"./extensions/classNames":228,"./extensions/css":229,"./extensions/observers":230}],232:[function(require,module,exports){
'use strict';

var ElementCollection = require('./index');

module.exports = function (selector, context) {
  return new ElementCollection(selector, context);
};

},{"./index":231}],233:[function(require,module,exports){
(function (process,global){
'use strict';

// @todo enable the following disabled rules see OPENTOK-31136 for more info
/* eslint-disable no-underscore-dangle, no-plusplus, no-useless-escape */

// OTHelpers.env
//
// Contains information about the current environment.
// * **env.name** The name of the Environment (Chrome, FF, Node, etc)
// * **env.version** Usually a Float, except in Node which uses a String
// * **env.userAgent** The raw user agent
// * **env.versionGreaterThan** A helper method that returns true if the
// current version is greater than the argument
//
// Example
//     if (OTHelpers.env.versionGreaterThan('0.10.30')) {
//       // do something
//     }
//

var env = {};
module.exports = env;

env._attachToOTHelpers = {};

// @todo make exposing userAgent unnecessary
env.version = -1;

if (typeof process !== 'undefined' && typeof process.versions !== 'undefined' && typeof process.versions.node === 'string') {
  env.name = 'Node';
  env.version = parseInt(process.versions.node, 10);
  env.userAgent = 'Node ' + env.version;
  env.iframeNeedsLoad = false;
} else {
  env.userAgent = global.navigator.userAgent.toLowerCase();
  env.appName = global.navigator.appName;
  env.navigatorVendor = undefined;
  env.name = 'unknown';

  if (env.userAgent.indexOf('opera') > -1 || env.userAgent.indexOf('opr') > -1) {
    env.name = 'Opera';

    if (/opr\/([0-9]{1,}[\.0-9]{0,})/.exec(env.userAgent) !== null) {
      env.version = parseFloat(RegExp.$1);
    }
  } else if (env.userAgent.indexOf('firefox') > -1) {
    env.name = 'Firefox';

    if (/firefox\/([0-9]{1,}[\.0-9]{0,})/.exec(env.userAgent) !== null) {
      env.version = parseFloat(RegExp.$1);
    }
  } else if (env.appName === 'Microsoft Internet Explorer') {
    // IE 10 and below
    env.name = 'IE';

    if (/msie ([0-9]{1,}[\.0-9]{0,})/.exec(env.userAgent) !== null) {
      env.version = parseFloat(RegExp.$1);
    }
  } else if (env.userAgent.search(/edge\/\d+(\.\d+)?$/) > -1) {
    env.name = 'Edge';

    if (/Edge\/(\d+(\.\d+)?)$/.exec(env.userAgent) !== null) {
      env.version = parseFloat(RegExp.$1);
    }
  } else if (env.appName === 'Netscape' && env.userAgent.indexOf('trident') > -1) {
    // IE 11+

    env.name = 'IE';

    if (/trident\/.*rv:([0-9]{1,}[\.0-9]{0,})/.exec(env.userAgent) !== null) {
      env.version = parseFloat(RegExp.$1);
    }
  } else if (env.userAgent.indexOf('chrome') > -1) {
    env.name = 'Chrome';

    if (/chrome\/([0-9]{1,}[\.0-9]{0,})/.exec(env.userAgent) !== null) {
      env.version = parseFloat(RegExp.$1);
    }
  } else if (global.navigator.vendor && global.navigator.vendor.toLowerCase().indexOf('apple') > -1) {
    env.name = 'Safari';

    if (/version\/([0-9]{1,}[\.0-9]{0,})/.exec(env.userAgent) !== null) {
      env.version = parseFloat(RegExp.$1);
    }
  }

  env.iframeNeedsLoad = env.userAgent.indexOf('webkit') < 0;
  env.userAgent = global.navigator.userAgent;
  env.protocol = global.location.protocol;
  env.hostName = global.location.hostName;
}

env._attachToOTHelpers.browser = function () {
  return env.name;
};

env._attachToOTHelpers.browserVersion = function () {
  return env;
};

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"_process":186}],234:[function(require,module,exports){
(function (global){
'use strict';

// @todo enable the following disabled rules see OPENTOK-31136 for more info
/* eslint-disable no-underscore-dangle, no-param-reassign, no-void, no-plusplus */
/* eslint-disable no-restricted-syntax, no-prototype-builtins, no-shadow, one-var, vars-on-top */
/* eslint-disable no-var */

var env = require('./env');
var util = require('./util');

var getErrorLocation = void 0;

// Properties that we'll acknowledge from the JS Error object
var safeErrorProps = ['description', 'fileName', 'lineNumber', 'message', 'name', 'number', 'stack'];

// OTHelpers.Error
//
// A construct to contain error information that also helps with extracting error
// context, such as stack trace.
//
// @constructor
// @memberof OTHelpers
// @method Error
//
// @param {String} message
//      Optional. The error message
//
// @param {Object} props
//      Optional. A dictionary of properties containing extra Error info.
//
//
// @example Create a simple error with juts a custom message
//   var error = new OTHelpers.Error('Something Broke!');
//   error.message === 'Something Broke!';
//
// @example Create an Error with a message and a name
//   var error = new OTHelpers.Error('Something Broke!', 'FooError');
//   error.message === 'Something Broke!';
//   error.name === 'FooError';
//
// @example Create an Error with a message, name, and custom properties
//   var error = new OTHelpers.Error('Something Broke!', 'FooError', {
//     foo: 'bar',
//     listOfImportantThings: [1,2,3,4]
//   });
//   error.message === 'Something Broke!';
//   error.name === 'FooError';
//   error.foo === 'bar';
//   error.listOfImportantThings == [1,2,3,4];
//
// @example Create an Error from a Javascript Error
//   var error = new OTHelpers.Error(domSyntaxError);
//   error.message === domSyntaxError.message;
//   error.name === domSyntaxError.name === 'SyntaxError';
//   // ...continues for each properties of domSyntaxError
//
// @references
// * https://code.google.com/p/v8/wiki/JavaScriptStackTraceApi
// * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error/Stack
// * http://www.w3.org/TR/dom/#interface-domerror
//
//
// @todo
// * update usage in OTMedia
// * replace error handling in OT.js
// * normalise stack behaviour under Chrome/Node/Safari with other browsers
// * unit test for stack parsing
//
var Error_ = function Error_(message, name, props) {
  switch (arguments.length) {
    case 1:
      if (util.isObject(message)) {
        props = message;
        name = void 0;
        message = void 0;
      }
      // Otherwise it's the message
      break;

    case 2:
      if (util.isObject(name)) {
        props = name;
        name = void 0;
      }
      // Otherwise name is actually the name
      break;

    default:
    // FIXME: Should something go here?
  }

  if (props instanceof Error) {
    // Special handling of this due to Chrome weirdness. It seems that
    // properties of the Error object, and it's children, are not
    // enumerable in Chrome?
    for (var i = 0, num = safeErrorProps.length; i < num; ++i) {
      this[safeErrorProps[i]] = props[safeErrorProps[i]];
    }
  } else if (util.isObject(props)) {
    // Use an custom properties that are provided
    for (var key in props) {
      if (props.hasOwnProperty(key)) {
        this[key] = props[key];
      }
    }
  }

  // If any of the fundamental properties are missing then try and
  // extract them.
  if (!(this.fileName && this.lineNumber && this.columnNumber && this.stack)) {
    var err = getErrorLocation();

    if (!this.fileName && err.fileName) {
      this.fileName = err.fileName;
    }

    if (!this.lineNumber && err.lineNumber) {
      this.lineNumber = err.lineNumber;
    }

    if (!this.columnNumber && err.columnNumber) {
      this.columnNumber = err.columnNumber;
    }

    if (!this.stack && err.stack) {
      this.stack = err.stack;
    }
  }

  if (!this.message && message) {
    this.message = message;
  }

  if ((!this.name || this.name === 'Error') && name) {
    this.name = name;
  }
};

module.exports = Error_;

Error_.prototype = Object.create(Error.prototype);
Error_.prototype.toString = function () {
  var locationDetails = '';
  if (this.fileName) {
    locationDetails += ' ' + this.fileName;
  }

  if (this.lineNumber) {
    locationDetails += ' ' + this.lineNumber;

    if (this.columnNumber) {
      locationDetails += ':' + this.columnNumber;
    }
  }

  return '<' + (this.name ? this.name + ' ' : '') + this.message + locationDetails + '>';
};

Error_.prototype.valueOf = Error_.prototype.toString;

// Normalise err.stack so that it is the same format as the other browsers
// We skip the first two frames so that we don't capture getErrorLocation() and
// the callee.
//
// Used by Environments that support the StackTrace API. (Chrome, Node, Opera)
//
var prepareStackTrace = function prepareStackTrace(_, stack) {
  return stack.slice(2).map(function (frame) {
    var _f = {
      fileName: frame.getFileName(),
      linenumber: frame.getLineNumber(),
      columnNumber: frame.getColumnNumber()
    };

    if (frame.getFunctionName()) {
      _f.functionName = frame.getFunctionName();
    }

    if (frame.getMethodName()) {
      _f.methodName = frame.getMethodName();
    }

    if (frame.getThis()) {
      _f.self = frame.getThis();
    }

    return _f;
  });
};

// Black magic to retrieve error location info for various environments
getErrorLocation = function getErrorLocation() {
  var info = {};
  var callstack = void 0,
      errLocation = void 0,
      err = void 0;

  switch (env.name) {
    case 'Firefox':
    case 'Safari':
    case 'IE':

      try {
        global.call.js.is.explody();
      } catch (e) {
        err = e;
      }

      callstack = (err.stack || '').split('\n');

      // Remove call to getErrorLocation() and the callee
      callstack.shift();
      callstack.shift();

      info.stack = callstack;

      if (env.name === 'IE') {
        // IE also includes the error message in it's stack trace
        info.stack.shift();

        // each line begins with some amounts of spaces and 'at', we remove
        // these to normalise with the other browsers.
        info.stack = callstack.map(function (call) {
          return call.replace(/^\s+at\s+/g, '');
        });
      }

      errLocation = /@(.+?):([0-9]+)(:([0-9]+))?$/.exec(callstack[0]);
      if (errLocation) {
        info.fileName = errLocation[1];
        info.lineNumber = parseInt(errLocation[2], 10);
        if (errLocation.length > 3) {
          info.columnNumber = parseInt(errLocation[4], 10);
        }
      }
      break;

    case 'Chrome':
    case 'Node':
    case 'Opera':
      var currentPST = Error.prepareStackTrace;
      Error.prepareStackTrace = prepareStackTrace;
      err = new Error();
      info.stack = err.stack;
      Error.prepareStackTrace = currentPST;

      var topFrame = info.stack[0];
      info.lineNumber = topFrame.lineNumber;
      info.columnNumber = topFrame.columnNumber;
      info.fileName = topFrame.fileName;

      if (topFrame.functionName) {
        info.functionName = topFrame.functionName;
      }

      if (topFrame.methodName) {
        info.methodName = topFrame.methodName;
      }

      if (topFrame.self) {
        info.self = topFrame.self;
      }

      break;

    default:
      err = new Error();

      if (err.stack) {
        info.stack = err.stack.split('\n');
      }

      break;
  }

  if (err.message) {
    info.message = err.message;
  }

  return info;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./env":233,"./util":240}],235:[function(require,module,exports){
(function (global){
'use strict';

// @todo enable the following disabled rules see OPENTOK-31136 for more info
/* eslint-disable no-void */

var once = require('lodash/once');

// Indicates if the client supports WebSockets.
module.exports = once(function () {
  return 'WebSocket' in global && global.WebSocket !== void 0;
});

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"lodash/once":174}],236:[function(require,module,exports){
'use strict';

var useLogHelpers = require('./mixin');
var makeEverythingAttachToOTHelpers = require('../makeEverythingAttachToOTHelpers');

var logging = exports;
useLogHelpers(logging);

makeEverythingAttachToOTHelpers(logging);

},{"../makeEverythingAttachToOTHelpers":238,"./mixin":237}],237:[function(require,module,exports){
'use strict';

// @todo enable the following disabled rules see OPENTOK-31136 for more info
/* eslint-disable no-underscore-dangle, prefer-rest-params, no-param-reassign */

/* jshint browser:true, smarttabs:true */

var LEVELS_DESCRIPTORS = [{ name: 'NONE', value: 0, method: null }, { name: 'ERROR', value: 1, method: 'error' }, { name: 'WARN', value: 2, method: 'warn' }, { name: 'INFO', value: 3, method: 'info' }, { name: 'LOG', value: 4, method: 'log' }, { name: 'DEBUG', value: 5, method: 'debug' }];

function noop() {}

/**
 * Creates a logging method that retains as much context as possible.
 *
 * In IE it creates a function that formats data better. In other browsers it returns a function
 * bound to the console to keep the file/line debugging info.
 */
function createLoggingMethod(obj, methodName) {
  return obj[methodName].bind(obj);
}

function getLoggingMethod(methodName) {
  if (typeof console === 'undefined') {
    return noop;
  }

  if (console[methodName] !== undefined) {
    return createLoggingMethod(console, methodName);
  }

  if (console.log !== undefined) {
    return createLoggingMethod(console, 'log');
  }

  return noop;
}

// This logging mixin is based on the idea that to get correct file / line info in log trace we
// need direct console method call. To ensure that we need to implement logging level filtering by
// rebinding method every time it changes: we can't wrap logging methods to filter otherwise we
// would lose the file/line info
module.exports = function applyLoggerMixin(logging) {
  LEVELS_DESCRIPTORS.forEach(function (levelDescriptor) {
    logging[levelDescriptor.name] = levelDescriptor.value;
  });

  // Dead code. Should be removed in v3
  logging.shouldLog = noop;

  logging.setLogLevel = function setLogLevel(level) {
    // make sure the level value is a valid one
    level = typeof level === 'number' ? level : 0;

    LEVELS_DESCRIPTORS.forEach(function (levelDescriptor) {
      if (levelDescriptor.method !== null) {
        if (levelDescriptor.value <= level) {
          logging[levelDescriptor.method] = getLoggingMethod(levelDescriptor.method);
        } else {
          logging[levelDescriptor.method] = noop;
        }
      }
    });

    logging.debug('Setting the debug level to ' + level);

    return level;
  };

  logging.setLogLevel(logging.ERROR);
};

},{}],238:[function(require,module,exports){
"use strict";

// @todo enable the following disabled rules see OPENTOK-31136 for more info
/* eslint-disable no-underscore-dangle, no-param-reassign */

module.exports = function (mod) {
  var attachments = {};

  Object.keys(mod).forEach(function (key) {
    attachments[key] = mod[key];
  });

  mod._attachToOTHelpers = attachments;
};

},{}],239:[function(require,module,exports){
'use strict';

// @todo enable the following disabled rules see OPENTOK-31136 for more info
/* eslint-disable prefer-rest-params, no-param-reassign */

var $ = require('./elementCollection/shorthandSelector');
var env = require('./env');
var eventing = require('./behaviours/eventing');
var util = require('./util');
var uuid = require('uuid');

module.exports = function Modal(options) {
  eventing(this, true);

  var callback = arguments[arguments.length - 1];

  if (!util.isFunction(callback)) {
    throw new Error('OTHelpers.Modal2 must be given a callback');
  }

  if (arguments.length < 2) {
    options = {};
  }

  var domElement = document.createElement('iframe');

  domElement.id = options.id || uuid();
  domElement.style.position = 'absolute';
  domElement.style.position = 'fixed';
  domElement.style.height = '100%';
  domElement.style.width = '100%';
  domElement.style.top = '0px';
  domElement.style.left = '0px';
  domElement.style.right = '0px';
  domElement.style.bottom = '0px';
  domElement.style.zIndex = 1000;
  domElement.style.border = '0';

  try {
    domElement.style.backgroundColor = 'rgba(0,0,0,0.2)';
  } catch (err) {
    // Old IE browsers don't support rgba and we still want to show the upgrade message
    // but we just make the background of the iframe completely transparent.
    domElement.style.backgroundColor = 'transparent';
    domElement.setAttribute('allowTransparency', 'true');
  }

  domElement.scrolling = 'no';
  domElement.setAttribute('scrolling', 'no');

  // This is necessary for IE, as it will not inherit it's doctype from
  // the parent frame.
  var frameContent = '<!DOCTYPE html><html><head>' + '<meta http-equiv="x-ua-compatible" content="IE=Edge">' + '<meta http-equiv="Content-type" content="text/html; charset=utf-8">' + '<title></title></head><body></body></html>';

  var wrappedCallback = function wrappedCallback() {
    var doc = domElement.contentDocument || domElement.contentWindow.document;

    if (env.iframeNeedsLoad) {
      doc.body.style.backgroundColor = 'transparent';
      doc.body.style.border = 'none';

      if (env.name !== 'IE') {
        // Skip this for IE as we use the bookmarklet workaround
        // for THAT browser.
        doc.open();
        doc.write(frameContent);
        doc.close();
      }
    }

    callback(domElement.contentWindow, doc);
  };

  document.body.appendChild(domElement);

  if (env.iframeNeedsLoad) {
    if (env.name === 'IE') {
      // This works around some issues with IE and document.write.
      // Basically this works by slightly abusing the bookmarklet/scriptlet
      // functionality that all browsers support.
      domElement.contentWindow.contents = frameContent;
      domElement.src = 'javascript:window["contents"]'; // eslint-disable-line no-script-url
    }

    $(domElement).on('load', wrappedCallback);
  } else {
    setTimeout(wrappedCallback, 0);
  }

  this.close = function () {
    $(domElement).remove();
    this.trigger('closed');
    this.element = null;
    domElement = null;
    return this;
  };

  this.element = domElement;
};

},{"./behaviours/eventing":220,"./elementCollection/shorthandSelector":232,"./env":233,"./util":240,"uuid":200}],240:[function(require,module,exports){
(function (global){
'use strict';

// @todo enable the following disabled rules see OPENTOK-31136 for more info
/* eslint-disable no-void, no-restricted-syntax, no-prototype-builtins, no-plusplus */
/* eslint-disable prefer-rest-params, no-continue, no-param-reassign */

var makeEverythingAttachToOTHelpers = require('./makeEverythingAttachToOTHelpers');

var util = exports;

// OT Helper Methods
//
// helpers.js                           <- the root file
// helpers/lib/{helper topic}.js        <- specialised helpers for specific tasks/topics
//                                          (i.e. video, dom, etc)
//
// @example Getting a DOM element by it's id
//  var element = OTHelpers('#domId');
//
//

/* jshint browser:true, smarttabs:true*/

// RegEx to detect CSS Id selectors
util.detectIdSelectors = /^#([\w-]*)$/;

util.isFunction = function (obj) {
  return !!obj && (obj.toString().indexOf('()') !== -1 || Object.prototype.toString.call(obj) === '[object Function]');
};

util.isObject = function (obj) {
  return obj === Object(obj);
};

util.isEmpty = function (obj) {
  if (obj === null || obj === void 0) {
    return true;
  }

  if (Array.isArray(obj) || typeof obj === 'string') {
    return obj.length === 0;
  }

  // Objects without enumerable owned properties are empty.
  for (var key in obj) {
    if (obj.hasOwnProperty(key)) {
      return false;
    }
  }

  return true;
};

util.find = function (array, iter, ctx) {
  if (!util.isFunction(iter)) {
    throw new TypeError('iter must be a function');
  }

  var any = void 0;
  for (var idx = 0, count = array.length || 0; idx < count; ++idx) {
    if (idx in array) {
      if (iter.call(ctx, array[idx], idx)) {
        any = array[idx];
        break;
      }
    }
  }
  return any;
};

util.findIndex = function (array, iter, ctx) {
  if (!util.isFunction(iter)) {
    throw new TypeError('iter must be a function');
  }

  for (var i = 0, count = array.length || 0; i < count; ++i) {
    if (i in array && iter.call(ctx, array[i], i, array)) {
      return i;
    }
  }

  return -1;
};

// Extend a target object with the properties from one or
// more source objects
//
// @example:
//    dest = OTHelpers.extend(dest, source1, source2, source3);
//
util.extend = Object.assign || function (target /* , source1[, source2, ..., , sourceN]*/) {
  if (target === undefined || target === null) {
    throw new TypeError('Cannot convert first argument to object');
  }

  var to = Object(target);
  for (var i = 1; i < arguments.length; i++) {
    var nextSource = arguments[i];
    if (nextSource === undefined || nextSource === null) {
      continue;
    }
    nextSource = Object(nextSource);

    var keysArray = Object.keys(Object(nextSource));
    for (var nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex++) {
      var nextKey = keysArray[nextIndex];
      var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
      if (desc !== undefined && desc.enumerable) {
        to[nextKey] = nextSource[nextKey];
      }
    }
  }

  return to;
};

// Ensures that the target object contains certain defaults.
//
// @example
//   var options = OTHelpers.defaults(options, {
//     loading: true     // loading by default
//   });
//
util.defaults = function (target /* , defaults1[, defaults2, ..., , defaultsN]*/) {
  if (target === undefined || target === null) {
    throw new TypeError('Cannot convert first argument to object');
  }

  var to = Object(target);
  for (var i = 1; i < arguments.length; i++) {
    var nextSource = arguments[i];
    if (nextSource === undefined || nextSource === null) {
      continue;
    }
    nextSource = Object(nextSource);

    var keysArray = Object.keys(Object(nextSource));
    for (var nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex++) {
      var nextKey = keysArray[nextIndex];
      if (!to.hasOwnProperty(nextKey)) {
        var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
        if (desc !== undefined && desc.enumerable) {
          to[nextKey] = nextSource[nextKey];
        }
      }
    }
  }

  return to;
};

util.clone = function (obj) {
  if (!util.isObject(obj)) {
    return obj;
  }

  return Array.isArray(obj) ? obj.slice() : util.extend({}, obj);
};

// Returns the number of millisceonds since the the UNIX epoch, this is functionally
// equivalent to executing new Date().getTime().
//
// Where available, we use 'performance.now' which is more accurate and reliable,
// otherwise we default to new Date().getTime().
util.now = function () {
  var performance = global.performance || {};
  var navigationStart = void 0;
  var now = performance.now || performance.mozNow || performance.msNow || performance.oNow || performance.webkitNow;

  if (now) {
    now = now.bind(performance);
    navigationStart = performance.timing.navigationStart;

    return function () {
      return navigationStart + now();
    };
  }

  return function () {
    return new Date().getTime();
  };
}();

var generatePropertyFunction = function generatePropertyFunction(object, getter, setter) {
  if (getter && !setter) {
    return function () {
      return getter.call(object);
    };
  }

  if (getter && setter) {
    return function (value) {
      if (value !== void 0) {
        setter.call(object, value);
      }
      return getter.call(object);
    };
  }

  return function (value) {
    if (value !== void 0) {
      setter.call(object, value);
    }
  };
};

util.defineProperties = function (object, getterSetters) {
  Object.keys(getterSetters).forEach(function (key) {
    object[key] = generatePropertyFunction(object, getterSetters[key].get, getterSetters[key].set);
  });
};

makeEverythingAttachToOTHelpers(util);

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./makeEverythingAttachToOTHelpers":238}],241:[function(require,module,exports){
(function (global){
'use strict';

// @todo enable the following disabled rules see OPENTOK-31136 for more info
/* eslint-disable no-underscore-dangle */

var guidStorage = require('./guid_storage.js');
var logging = require('../ot/logging.js');
var OTHelpers = require('../common-js-helpers/OTHelpers.js');
var otProperties = require('./otProperties.js');

module.exports = function Analytics(loggingUrl) {
  var LOG_VERSION = '2';
  var _analytics = new OTHelpers.Analytics(loggingUrl, logging.debug, guidStorage.get);

  this.logError = function (code, type, message, details) {
    var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};

    var partnerId = options.partnerId;

    guidStorage.get(function (error, guid) {
      if (error) {
        // @todo
        return;
      }
      var data = OTHelpers.extend({
        // TODO: properties.version only gives '2.2', not '2.2.9.3'.
        clientVersion: 'js-' + otProperties.version.replace('v', ''),
        buildHash: otProperties.buildHash,
        guid: guid,
        partnerId: partnerId,
        source: global.location && global.location.href,
        logVersion: LOG_VERSION,
        apiServer: otProperties.apiURL,
        clientSystemTime: new Date().getTime()
      }, options);
      _analytics.logError(code, type, message, details, data);
    });
  };

  this.logEvent = function () {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var throttle = arguments[1];
    var completionHandler = arguments[2];

    var partnerId = options.partnerId;

    guidStorage.get(function (error, guid) {
      if (error) {
        // @todo
        return;
      }

      // Set a bunch of defaults
      var data = OTHelpers.extend({
        // TODO: properties.version only gives '2.2', not '2.2.9.3'.
        clientVersion: 'js-' + otProperties.version.replace('v', ''),
        buildHash: otProperties.buildHash,
        guid: guid,
        partnerId: partnerId,
        source: global.location && global.location.href,
        logVersion: LOG_VERSION,
        apiServer: otProperties.apiURL,
        clientSystemTime: new Date().getTime()
      }, options);
      _analytics.logEvent(data, false, throttle, completionHandler);
    });
  };

  this.logQOS = function () {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    var partnerId = options.partnerId;

    guidStorage.get(function (error, guid) {
      if (error) {
        // @todo
        return;
      }

      // Set a bunch of defaults
      var data = OTHelpers.extend({
        // TODO: properties.version only gives '2.2', not '2.2.9.3'.
        clientVersion: 'js-' + otProperties.version.replace('v', ''),
        buildHash: otProperties.buildHash,
        guid: guid,
        partnerId: partnerId,
        source: global.location && global.location.href,
        logVersion: LOG_VERSION,
        apiServer: otProperties.apiURL,
        clientSystemTime: new Date().getTime(),
        duration: 0 // in milliseconds
      }, options);

      _analytics.logQOS(data);
    });
  };
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../common-js-helpers/OTHelpers.js":217,"../ot/logging.js":312,"./guid_storage.js":258,"./otProperties.js":272}],242:[function(require,module,exports){
(function (global){
"use strict";

// @todo enable the following disabled rules see OPENTOK-31136 for more info
/* eslint-disable no-param-reassign */

// TODO - Move this back within the factory once all modules have been
// converted to DI factories. This will ensure different unit tests are
// using distinct instances of AudioContext.
var context = void 0;

module.exports = function audioContextFactory() {
  var deps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var AudioContext = deps.AudioContext || global.AudioContext || global.webkitAudioContext;

  /*
   * Lazy instantiates an audio context and always return the same instance on following calls
   *
   * @returns {AudioContext}
   */

  return function audioContext() {
    context = context || AudioContext && new AudioContext();
    return context;
  };
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],243:[function(require,module,exports){
"use strict";

// @todo enable the following disabled rules see OPENTOK-31136 for more info
/* eslint-disable no-plusplus */

/*
 * A <code>RTCPeerConnection.getStats</code> based audio level sampler.
 *
 * It uses the <code>getStats</code> method to get the <code>audioOutputLevel</code>.
 * This implementation expects the single parameter version of the <code>getStats</code> method.
 *
 * Currently the <code>audioOutputLevel</code> stats is only supported in Chrome.
 *
 * @param {function} getStatsFn the "getStats" function
 * @constructor
 */
module.exports = function GetstatsAudioOutputLevelSampler(getStatsFn) {
  /*
   * Acquires the audio level.
   *
   * @param {function(?number)} done a callback to be called with the acquired value in the
   * [0, 1] range when available or <code>null</code> if no value could be acquired
   */
  this.sample = function (done) {
    getStatsFn(function (error, stats) {
      if (!error) {
        for (var idx = 0; idx < stats.length; idx++) {
          var stat = stats[idx];
          var audioOutputLevel = parseFloat(stat.audioOutputLevel);
          if (!isNaN(audioOutputLevel)) {
            // the mex value delivered by getStats for audio levels is 2^15
            done(audioOutputLevel / 32768);
            return;
          }
        }
      }

      done(null);
    });
  };
};

},{}],244:[function(require,module,exports){
'use strict';

// @todo enable the following disabled rules see OPENTOK-31136 for more info
/* eslint-disable no-underscore-dangle, no-plusplus */

var OTHelpers = require('../../common-js-helpers/OTHelpers.js');

/*
 * An <code>AudioContext</code> based audio level sampler. It returns the maximum value in the
 * last 1024 samples.
 *
 * It is worth noting that the remote <code>MediaStream</code> audio analysis is currently only
 * available in FF.
 *
 * This implementation gracefully handles the case where the <code>MediaStream</code> has not
 * been set yet by returning a <code>null</code> value until the stream is set. It is up to the
 * call site to decide what to do with this value (most likely ignore it and retry later).
 *
 * @constructor
 * @param {AudioContext} audioContext an audio context instance to get an analyser node
 */
module.exports = function WebaudioAudioLevelSampler(audioContext) {
  var _sampler = this;
  var _analyser = null;
  var _timeDomainData = null;
  var _webRTCStream = null;

  var buildAnalyzer = function buildAnalyzer(stream) {
    var sourceNode = stream.otWebkitAudioSource || audioContext.createMediaStreamSource(stream);
    var analyser = audioContext.createAnalyser();
    sourceNode.connect(analyser);
    return analyser;
  };

  OTHelpers.defineProperties(_sampler, {
    webRTCStream: {
      get: function get() {
        return _webRTCStream;
      },
      set: function set(webRTCStream) {
        // when the stream is updated we need to create a new analyzer
        _webRTCStream = webRTCStream;
        _analyser = buildAnalyzer(_webRTCStream);
        _timeDomainData = new Uint8Array(_analyser.frequencyBinCount);
      }
    }
  });

  this.sample = function (done) {
    if (_analyser) {
      _analyser.getByteTimeDomainData(_timeDomainData);

      // varies from 0 to 255
      var max = 0;
      for (var idx = 0; idx < _timeDomainData.length; idx++) {
        max = Math.max(max, Math.abs(_timeDomainData[idx] - 128));
      }

      // normalize the collected level to match the range delivered by
      // the getStats' audioOutputLevel
      done(max / 128);
    } else {
      done(null);
    }
  };
};

},{"../../common-js-helpers/OTHelpers.js":217}],245:[function(require,module,exports){
'use strict';

// @todo enable the following disabled rules see OPENTOK-31136 for more info
/* eslint-disable no-underscore-dangle, one-var, no-use-before-define, no-plusplus */

// TODO: this is not unit tested

var analytics = require('../ot/analytics.js');
var OTHelpers = require('../common-js-helpers/OTHelpers.js');

module.exports = function ConnectivityAttemptPinger(options) {
  var _state = 'Initial';
  var states = ['Initial', 'Attempt', 'Success', 'Failure'];
  var PING_INTERVAL = 5000;
  var PING_COUNT_TOTAL = 6;

  var _previousState = void 0,
      pingTimer = void 0,
      // Timer for the Attempting ping;
  pingCount = void 0;

  // // Private API
  var stateChanged = function stateChanged(newState) {
    _state = newState;
    var invalidSequence = false;
    switch (_state) {
      case 'Attempt':
        if (_previousState !== 'Initial') {
          invalidSequence = true;
        }
        startAttemptPings();
        break;
      case 'Success':
        if (_previousState !== 'Attempt') {
          invalidSequence = true;
        }
        stopAttemptPings();
        break;
      case 'Failure':
        if (_previousState !== 'Attempt') {
          invalidSequence = true;
        }
        stopAttemptPings();
        break;
      default:
    }
    if (invalidSequence) {
      var data = options ? OTHelpers.clone(options) : {};
      data.action = 'Internal Error';
      data.variation = 'Non-fatal';
      data.payload = {
        debug: 'Invalid sequence: ' + options.action + ' ' + _previousState + ' -> ' + _state
      };
      analytics.logEvent(data);
    }
  };

  var setState = OTHelpers.statable(this, states, 'Failure', stateChanged);

  var startAttemptPings = function startAttemptPings() {
    pingCount = 0;
    pingTimer = setInterval(function () {
      if (pingCount < PING_COUNT_TOTAL) {
        var data = OTHelpers.extend(options, { variation: 'Attempting' });
        analytics.logEvent(data);
      } else {
        stopAttemptPings();
      }
      pingCount++;
    }, PING_INTERVAL);
  };

  var stopAttemptPings = function stopAttemptPings() {
    clearInterval(pingTimer);
  };

  this.setVariation = function (variation) {
    _previousState = _state;
    setState(variation);

    // We could change the ConnectivityAttemptPinger to a ConnectivityAttemptLogger
    // that also logs events in addition to logging the ping ('Attempting') events.
    //
    // var payload = OTHelpers.extend(options, {variation:variation});
    // analytics.logEvent(payload);
  };

  this.stop = function () {
    stopAttemptPings();
  };
};

},{"../common-js-helpers/OTHelpers.js":217,"../ot/analytics.js":289}],246:[function(require,module,exports){
'use strict';

var ExceptionCodes = require('../ot/exception_codes.js');

module.exports = function convertAnvilErrorCode(code) {
  switch (code) {
    case ExceptionCodes.AUTHENTICATION_ERROR:
    case ExceptionCodes.INVALID_SESSION_ID:
    case ExceptionCodes.TERMS_OF_SERVICE_FAILURE:
    case ExceptionCodes.UNEXPECTED_SERVER_RESPONSE:
      return code;
    case ExceptionCodes.ANVIL_EMPTY_RESPONSE_BODY:
      return ExceptionCodes.CONNECT_FAILED;
    case ExceptionCodes.ANVIL_BADLY_FORMED_RESPONSE:
    case ExceptionCodes.ANVIL_INVALID_HTTP_STATUS:
    case ExceptionCodes.ANVIL_XDOMAIN_OR_PARSING_ERROR:
    case ExceptionCodes.ANVIL_UNKNOWN_HTTP_ERROR:
    case ExceptionCodes.ANVIL_UNEXPECTED_ERROR_CODE:
    default:
      return ExceptionCodes.UNEXPECTED_SERVER_RESPONSE;
  }
};

},{"../ot/exception_codes.js":307}],247:[function(require,module,exports){
'use strict';

var ExceptionCodes = require('../ot/exception_codes.js');
var OTErrorClass = require('../ot/ot_error_class.js');

var knownErrorCodes = [400, 403, 409, ExceptionCodes.CONNECTION_LIMIT_EXCEEDED];

var reasons = {
  CONNECT: 'ConnectToSession',
  SESSION_STATE: 'GetSessionState'
};

/*
 * Converts an error from RumorSocket to use generic exception codes
 * @param {Error} error - Error object with reason property
 * @return {Object} The converted error code and message
 * @property {number} code
 * @property {string} message
 */
module.exports = function convertRumorError(error) {
  var code = void 0;
  var message = void 0;

  if (error.reason === reasons.CONNECT && error.code === ExceptionCodes.CONNECT_FAILED) {
    code = error.code;
    message = OTErrorClass.getTitleByCode(error.code);
  } else if (error.code && knownErrorCodes.indexOf(Number(error.code)) > -1) {
    code = ExceptionCodes.CONNECT_FAILED;
    switch (error.reason) {
      case reasons.CONNECT:
        switch (error.code) {
          case ExceptionCodes.CONNECTION_LIMIT_EXCEEDED:
            code = error.code;
            message = 'Cannot connect -- the limit for concurrent connections to the session ' + 'has been reached';
            break;
          default:
            message = 'Received error response to connection create message.';
            break;
        }
        break;
      case reasons.SESSION_STATE:
        message = 'Received error response to session read';
        break;
      default:
        message = '';
        break;
    }
  } else {
    code = ExceptionCodes.UNEXPECTED_SERVER_RESPONSE;
    message = 'Unexpected server response. Try this operation again later.';
  }

  return { code: code, message: message };
};

},{"../ot/exception_codes.js":307,"../ot/ot_error_class.js":334}],248:[function(require,module,exports){
'use strict';

var webrtcAdapter = require('webrtc-adapter/src/js/adapter_factory.js');
var logging = require('../ot/logging.js');
var env = require('../common-js-helpers/env.js');

var windowKeys = [{ key: 'setTimeout', type: 'function' }, { key: 'URL', type: 'function' }, { key: 'MediaStream', type: 'class' }, { key: 'webkitMediaStream', type: 'class' }, { key: 'RTCIceCandidate', type: 'class' }, { key: 'mozRTCIceCandidate', type: 'class' }, { key: 'RTCSessionDescription', type: 'class' }, { key: 'mozRTCSessionDescription', type: 'class' }, { key: 'RTCIceGatherer', type: 'class' }, { key: 'RTCIceTransport', type: 'class' }, { key: 'RTCDtlsTransport', type: 'class' }, { key: 'RTCRtpReceiver', type: 'class' }, { key: 'HTMLMediaElement', type: 'class' }, { key: 'RTCPeerConnection', type: 'class' }, { key: 'webkitRTCPeerConnection', type: 'class' }, { key: 'mozRTCPeerConnection', type: 'class' }, { key: 'MediaStreamTrack', type: 'class' }, { key: 'RTCRtpSender', type: 'class' }];

var navigatorKeys = [{ key: 'userAgent', type: 'string' }, { key: 'getUserMedia', type: 'function' }, { key: 'webkitGetUserMedia', type: 'function' }, { key: 'mozGetUserMedia', type: 'function' }];

var mediaDevicesKeys = [{ key: 'getUserMedia', type: 'function' }, { key: 'enumerateDevices', type: 'function' }, { key: 'getSupportedConstraints', type: 'function' }, { key: 'addEventListener', type: 'function' }, { key: 'removeEventListener', type: 'function' }];

var bindWithStaticProperties = function bindWithStaticProperties(context, func) {
  if (typeof func !== 'function') {
    logging.warn('Non-function passed into bindWithStaticProperties()');
    return func;
  }

  var bound = func.bind(context);
  Object.keys(func).forEach(function (key) {
    return bound[key] = func[key];
  });
  return bound;
};

var getAllProperties = function getAllProperties(target) {
  var properties = {};
  var o = target;
  var processPropertyName = function processPropertyName(key) {
    if (!properties[key]) {
      properties[key] = Object.getOwnPropertyDescriptor(o, key);
    }
  };
  while (o && o !== Object.prototype) {
    Object.getOwnPropertyNames(o).forEach(processPropertyName);
    o = Object.getPrototypeOf(o);
  }
  return properties;
};

var extendParentClass = function extendParentClass(ParentClass) {
  try {
    // The below __proto__ hack is so we can extend RTCPeerConnection in Firefox and Safari
    // See: https://bugs.webkit.org/show_bug.cgi?id=172867#c6

    // eslint-disable-next-line no-eval
    var ChildClass = eval('\n      "use strict"; // Chrome<49 requires strict mode\n      class ChildClass extends ParentClass {\n        constructor(...args) {\n          super(...args);\n          try {\n            this.__proto__ = ChildClass.prototype;\n          } catch (e) {}\n        }\n      };\n      ChildClass; // Ensure the final statement is returned in FF\n    ');
    if (ChildClass && ChildClass.prototype instanceof ParentClass) {
      return ChildClass;
    }
  } catch (e) {
    // Failed to use ES6 class
  }
  return null;
};

var canUseES6Class = function canUseES6Class(window) {
  var RTCPeerConnection = window.RTCPeerConnection || window.webkitRTCPeerConnection || window.mozRTCPeerConnection;

  var PC = extendParentClass(RTCPeerConnection);
  if (PC) {
    try {
      PC.prototype.foo = 'bar';
      var instance = new PC(null);
      if (instance.foo === 'bar') {
        return true;
      }
    } catch (e) {
      // Failed to instantiate the subclass
    }
  }
  return false;
};

var extendClass = function extendClass(ParentClass, label, canUseClass) {
  if (typeof ParentClass !== 'function') {
    logging.warn('Non-function passed into extendClass()');
    return ParentClass;
  }

  if (canUseClass) {
    var result = extendParentClass(ParentClass);
    if (result) {
      return result;
    }
  }

  // We can't use ES6 classes with babel because babel invokes the super
  // constructor without the new keyword. This triggers an error when used
  // with RTCPeerConnection and other native classes.

  function ChildClass() {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var self = new (Function.prototype.bind.apply(ParentClass, [this].concat(args)))();

    // There's no way that I've found to instantiate ParentClass with a custom
    // context so that it uses the ChildClass prototype, therefore here I'm
    // adding everything from the prototype directly onto the instance.

    var properties = getAllProperties(this);
    Object.defineProperties(self, properties);

    return self;
  }

  if (ParentClass.prototype !== undefined) {
    ChildClass.prototype = Object.create(ParentClass.prototype);
    ChildClass.prototype.constructor = ChildClass;
  }

  Object.keys(ParentClass).forEach(function (staticKey) {
    return ChildClass[staticKey] = ParentClass[staticKey];
  });

  return ChildClass;
};

var getCopyProperties = function getCopyProperties(canUseClass) {
  return function (target, source, keys) {
    keys.forEach(function (_ref) {
      var key = _ref.key,
          type = _ref.type;

      var value = source[key];
      if (value !== undefined) {
        switch (type) {
          case 'function':
            value = bindWithStaticProperties(source, value);
            break;

          case 'class':
            value = extendClass(value, key, canUseClass);
            break;

          case 'string':
          case 'object':
            break;

          default:
            throw new Error('Invalid type of window key: ' + type);
        }
        target[key] = value; // eslint-disable-line no-param-reassign
      }
    });
  };
};

var cloneWindow = function cloneWindow(window) {
  var windowMock = {};

  var copyProperties = getCopyProperties(canUseES6Class(window));

  copyProperties(windowMock, window, windowKeys);

  if (window.navigator !== undefined) {
    windowMock.navigator = {};

    copyProperties(windowMock.navigator, window.navigator, navigatorKeys);

    if (window.navigator.mediaDevices !== undefined) {
      windowMock.navigator.mediaDevices = {};

      copyProperties(windowMock.navigator.mediaDevices, window.navigator.mediaDevices, mediaDevicesKeys);
    }
  }

  return windowMock;
};

module.exports = function createWindowMock(window) {
  // We avoid shimming twice because adapter is not idempotent.
  // Unfortunately checking for window.adapter can be used to detect
  // adapter.js but not adapter_no_global.js, there is no reliable
  // way of detecting it. We also avoid shimming in IE since it
  // doesn't make sense to.
  if (window.adapter !== undefined || env.name === 'IE') {
    return window;
  }

  var windowMock = cloneWindow(window);
  webrtcAdapter({ window: windowMock });
  return windowMock;
};

},{"../common-js-helpers/env.js":233,"../ot/logging.js":312,"webrtc-adapter/src/js/adapter_factory.js":205}],249:[function(require,module,exports){
'use strict';

var clone = require('lodash/clone');

var env = require('../common-js-helpers/env.js');
var filterIceServers = require('./filterIceServers.js');
var logging = require('../ot/logging.js');
var OTPlugin = require('../otplugin/otplugin.js');

module.exports = function createPeerConnection(_ref) {
  var window = _ref.window,
      originalConfig = _ref.config,
      constraints = _ref.constraints,
      webRTCStream = _ref.webRTCStream,
      originalCompletion = _ref.completion;

  logging.debug('createPeerConnection: called');

  var config = clone(originalConfig);

  var completion = function completion(err) {
    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    if (err) {
      logging.error('createPeerConnection: failure:', err);
    } else {
      logging.debug('createPeerConnection: success');
    }

    originalCompletion.apply(undefined, [err].concat(args));
  };

  var pc = void 0;

  if (OTPlugin.isInstalled()) {
    OTPlugin.initPeerConnection(config, constraints, webRTCStream, completion);
    return;
  }

  config.iceServers = filterIceServers(env.name, config.iceServers);

  try {
    pc = new window.RTCPeerConnection(config, constraints);
  } catch (e) {
    // @todo why do we pass the message back up, rather than the error?
    completion(e.message);
    return;
  }

  completion(null, pc);
};

},{"../common-js-helpers/env.js":233,"../ot/logging.js":312,"../otplugin/otplugin.js":390,"./filterIceServers.js":255,"lodash/clone":146}],250:[function(require,module,exports){
'use strict';

module.exports = function cssLoader(cssURL) {
  var style = document.createElement('link');
  style.type = 'text/css';
  style.media = 'screen';
  style.rel = 'stylesheet';
  style.href = cssURL;
  var head = document.head || document.getElementsByTagName('head')[0];
  head.appendChild(style);
};

},{}],251:[function(require,module,exports){
'use strict';

// @todo enable the following disabled rules see OPENTOK-31136 for more info
/* eslint-disable no-param-reassign, global-require */

var bluebird = require('bluebird');

module.exports = function deviceHelpersFactory() {
  var deps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var getNativeEnumerateDevices = deps.getNativeEnumerateDevices || require('./getNativeEnumerateDevices.js')();

  var deviceHelpers = {};

  // /
  // Device Helpers
  //
  // Support functions to enumerating and guerying device info
  //

  var deviceKindsMap = {
    audio: 'audioInput',
    video: 'videoInput',
    audioinput: 'audioInput',
    videoinput: 'videoInput',
    audioInput: 'audioInput',
    videoInput: 'videoInput'
  };

  var enumerateDevices = function enumerateDevices() {
    // Our mocking currently requires that this be re-evaluated each time.
    var fn = getNativeEnumerateDevices();
    return fn();
  };

  // Indicates whether this browser supports the enumerateDevices (getSources) API.
  //
  deviceHelpers.hasEnumerateDevicesCapability = function () {
    return typeof getNativeEnumerateDevices() === 'function';
  };

  deviceHelpers.getMediaDevices = function () {
    if (!deviceHelpers.hasEnumerateDevicesCapability()) {
      return bluebird.Promise.reject(new Error('This browser does not support enumerateDevices APIs'));
    }

    return enumerateDevices().then(function (devices) {
      return (
        // Normalise the device kinds
        devices.map(function (device) {
          return {
            deviceId: device.deviceId || device.id,
            label: device.label,
            kind: deviceKindsMap[device.kind]
          };
        }).filter(function (device) {
          return device.kind === 'audioInput' || device.kind === 'videoInput';
        })
      );
    });
  };

  deviceHelpers.shouldAskForDevices = function () {
    if (!deviceHelpers.hasEnumerateDevicesCapability()) {
      // Assume video and audio exists if enumerateDevices is not available
      return bluebird.Promise.resolve({ video: true, audio: true });
    }

    return deviceHelpers.getMediaDevices().then(function (devices) {
      if (devices.length === 0) {
        // If no devices reported, might as well try anyway, maybe it was just an issue with
        // device enumeration.
        return { video: true, audio: true };
      }

      var audioDevices = devices.filter(function (device) {
        return device.kind === 'audioInput';
      });
      var videoDevices = devices.filter(function (device) {
        return device.kind === 'videoInput';
      });

      return {
        video: videoDevices.length > 0,
        audio: audioDevices.length > 0,
        videoDevices: videoDevices,
        audioDevices: audioDevices
      };
    }).catch(function () {
      return (
        // There was an error. It may be temporally. Just assume
        // all devices exist for now.
        { video: true, audio: true }
      );
    });
  };

  return deviceHelpers;
};

},{"./getNativeEnumerateDevices.js":256,"bluebird":2}],252:[function(require,module,exports){
'use strict';

// @todo enable the following disabled rules see OPENTOK-31136 for more info
/* eslint-disable no-mixed-operators, no-plusplus, one-var, no-use-before-define, prefer-const */

var OTHelpers = require('../common-js-helpers/OTHelpers.js');
var otProperties = require('./otProperties.js');
var logging = require('../ot/logging.js');

var Dialogs = {};
module.exports = Dialogs;

var addCss = function addCss(document, url, callback) {
  var head = document.head || document.getElementsByTagName('head')[0];
  var cssTag = OTHelpers.createElement('link', {
    type: 'text/css',
    media: 'screen',
    rel: 'stylesheet',
    href: url
  });
  head.appendChild(cssTag);
  OTHelpers.on(cssTag, 'error', function (error) {
    logging.error('Could not load CSS for dialog', url, error && error.message || error);
  });
  OTHelpers.on(cssTag, 'load', callback);
};

var addDialogCSS = function addDialogCSS(document, urls, callback) {
  var allURLs = ['//fonts.googleapis.com/css?family=Didact+Gothic', otProperties.cssURL].concat(urls);
  var remainingStylesheets = allURLs.length;
  allURLs.forEach(function (stylesheetUrl) {
    addCss(document, stylesheetUrl, function () {
      if (--remainingStylesheets <= 0) {
        callback();
      }
    });
  });
};

var templateElement = function templateElement(classes, children, tagName) {
  var el = OTHelpers.createElement(tagName || 'div', { class: classes }, children, this);
  el.on = OTHelpers.on.bind(OTHelpers, el);
  el.off = OTHelpers.off.bind(OTHelpers, el);
  return el;
};

var checkBoxElement = function checkBoxElement(classes, nameAndId, onChange) {
  var checkbox = templateElement.call(this, '', null, 'input');
  checkbox = OTHelpers(checkbox).on('change', onChange);

  checkbox.attr({
    name: nameAndId,
    id: nameAndId,
    type: 'checkbox'
  });

  return checkbox.first;
};

var linkElement = function linkElement(children, href, classes) {
  var link = templateElement.call(this, classes || '', children, 'a');
  link.setAttribute('href', href);
  return link;
};

Dialogs.Plugin = {};

Dialogs.Plugin.promptToInstall = function () {
  var modal = new OTHelpers.Modal(function (global, document) {
    var el = templateElement.bind(document);
    var btn = function btn(children, size) {
      var classes = 'OT_dialog-button ' + (size ? 'OT_dialog-button-' + size : 'OT_dialog-button-large');
      var b = el(classes, children);

      b.enable = function () {
        OTHelpers.removeClass(this, 'OT_dialog-button-disabled');
        return this;
      };

      b.disable = function () {
        OTHelpers.addClass(this, 'OT_dialog-button-disabled');
        return this;
      };

      return b;
    };
    var downloadButton = btn('Download plugin');
    var cancelButton = btn('cancel', 'small');
    var refreshButton = btn('Refresh browser');
    var acceptEULA = void 0,
        checkbox = void 0,
        close = void 0,
        root = void 0;

    OTHelpers.addClass(cancelButton, 'OT_dialog-no-natural-margin OT_dialog-button-block');
    OTHelpers.addClass(refreshButton, 'OT_dialog-no-natural-margin');

    function onDownload() {
      modal.trigger('download');
      setTimeout(function () {
        root.querySelector('.OT_dialog-messages-main').innerHTML = 'To enable audio & video chat on this website, run the installer and then refresh ' + 'your browser window.';
        var sections = root.querySelectorAll('.OT_dialog-section');
        OTHelpers.addClass(sections[0], 'OT_dialog-hidden');
        OTHelpers.removeClass(sections[1], 'OT_dialog-hidden');
      }, 3000);
    }

    function onRefresh() {
      modal.trigger('refresh');
    }

    function onToggleEULA() {
      if (checkbox.checked) {
        enableButtons();
      } else {
        disableButtons();
      }
    }

    function enableButtons() {
      downloadButton.enable();
      downloadButton.on('click', onDownload);

      refreshButton.enable();
      refreshButton.on('click', onRefresh);
    }

    function disableButtons() {
      downloadButton.disable();
      downloadButton.off('click', onDownload);

      refreshButton.disable();
      refreshButton.off('click', onRefresh);
    }

    downloadButton.disable();
    refreshButton.disable();

    cancelButton.on('click', function () {
      modal.trigger('cancelButtonClicked');
      modal.close();
    });

    close = el('OT_closeButton', '&times;').on('click', function () {
      modal.trigger('closeButtonClicked');
      modal.close();
    }).first;

    var protocol = global.location.protocol.indexOf('https') >= 0 ? 'https' : 'http';
    acceptEULA = linkElement.call(document, 'end-user license agreement', protocol + '://tokbox.com/support/ie-eula');

    checkbox = checkBoxElement.call(document, null, 'acceptEULA', onToggleEULA);

    root = el('OT_dialog-centering', [el('OT_dialog-centering-child', [el('OT_root OT_dialog OT_dialog-plugin-prompt', [close, el('OT_dialog-messages', [el('OT_dialog-messages-main', 'This app requires real-time communication')]), el('OT_dialog-section', [el('OT_dialog-single-button-with-title', [el('OT_dialog-button-title', [checkbox, function () {
      var x = el('', 'accept', 'label');
      x.setAttribute('for', checkbox.id);
      x.style.margin = '0 5px';
      return x;
    }(), acceptEULA]), el('OT_dialog-actions-card', [downloadButton, cancelButton])])]), el('OT_dialog-section OT_dialog-hidden', [el('OT_dialog-button-title', ['You will then be able to continue using this application in Internet Explorer.']), refreshButton])])])]);

    addDialogCSS(document, [], function () {
      document.body.appendChild(root);
    });
  });
  return modal;
};

Dialogs.Plugin.promptToReinstall = function () {
  var modal = new OTHelpers.Modal(function (global, document) {
    var el = templateElement.bind(document);
    var close = void 0,
        okayButton = void 0,
        root = void 0;

    close = el('OT_closeButton', '&times;').on('click', function () {
      modal.trigger('closeButtonClicked');
      modal.close();
    }).first;

    okayButton = el('OT_dialog-button OT_dialog-button-large OT_dialog-no-natural-margin', 'Okay').on('click', function () {
      modal.trigger('okay');
    }).first;

    root = el('OT_dialog-centering', [el('OT_dialog-centering-child', [el('OT_ROOT OT_dialog OT_dialog-plugin-reinstall', [close, el('OT_dialog-messages', [el('OT_dialog-messages-main', 'Reinstall Opentok Plugin'), el('OT_dialog-messages-minor', 'Uh oh! Try reinstalling the OpenTok plugin again ' + 'to enable real-time video communication for Internet Explorer.')]), el('OT_dialog-section', [el('OT_dialog-single-button', okayButton)])])])]);

    addDialogCSS(document, [], function () {
      document.body.appendChild(root);
    });
  });

  return modal;
};

Dialogs.Plugin.updateInProgress = function () {
  var progressValue = 0;
  var progressBar = void 0,
      progressText = void 0;

  var modal = new OTHelpers.Modal(function (global, document) {
    var el = templateElement.bind(document);
    var root = void 0;

    progressText = el('OT_dialog-plugin-upgrade-percentage', '0%', 'strong');

    progressBar = el('OT_dialog-progress-bar-fill');

    root = el('OT_dialog-centering', [el('OT_dialog-centering-child', [el('OT_ROOT OT_dialog OT_dialog-plugin-upgrading', [el('OT_dialog-messages', [el('OT_dialog-messages-main', ['One moment please... ', progressText]), el('OT_dialog-progress-bar', progressBar), el('OT_dialog-messages-minor OT_dialog-no-natural-margin', 'Please wait while the OpenTok plugin is updated')])])])]);

    addDialogCSS(document, [], function () {
      document.body.appendChild(root);
      if (progressValue != null) {
        modal.setUpdateProgress(progressValue);
      }
    });
  });

  modal.setUpdateProgress = function (newProgress) {
    if (progressBar && progressText) {
      if (newProgress > 99) {
        OTHelpers.css(progressBar, 'width', '');
        progressText.innerHTML = '100%';
      } else if (newProgress < 1) {
        OTHelpers.css(progressBar, 'width', '0%');
        progressText.innerHTML = '0%';
      } else {
        OTHelpers.css(progressBar, 'width', newProgress + '%');
        progressText.innerHTML = newProgress + '%';
      }
    } else {
      progressValue = newProgress;
    }
  };

  return modal;
};

Dialogs.Plugin.updateComplete = function (error) {
  var modal = new OTHelpers.Modal(function (global, document) {
    var el = templateElement.bind(document);
    var reloadButton = void 0,
        root = void 0,
        msgs = void 0;

    reloadButton = el('OT_dialog-button OT_dialog-button-large OT_dialog-no-natural-margin', 'Reload').on('click', function () {
      modal.trigger('reload');
    }).first;

    if (error) {
      msgs = ['Update Failed.', '' + error || 'NO ERROR'];
    } else {
      msgs = ['Update Complete.', 'The OpenTok plugin has been succesfully updated. ' + 'Please reload your browser.'];
    }

    root = el('OT_dialog-centering', [el('OT_dialog-centering-child', [el('OT_root OT_dialog OT_dialog-plugin-upgraded', [el('OT_dialog-messages', [el('OT_dialog-messages-main', msgs[0]), el('OT_dialog-messages-minor', msgs[1])]), el('OT_dialog-single-button', reloadButton)])])]);

    addDialogCSS(document, [], function () {
      document.body.appendChild(root);
    });
  });

  return modal;
};

},{"../common-js-helpers/OTHelpers.js":217,"../ot/logging.js":312,"./otProperties.js":272}],253:[function(require,module,exports){
'use strict';

var Bluebird = require('bluebird');

function isDomReady() {
  // if there is no document, how is the document object model ready?
  return typeof document === 'undefined' || document.readyState === 'complete' || document.readyState === 'interactive' && document.body;
}

module.exports = {
  unloaded: false,
  isDomLoaded: isDomReady,
  isDomUnloaded: function isDomUnloaded() {
    return this.unloaded;
  },

  whenUnloaded: new Bluebird.Promise(function (resolve) {
    document.addEventListener('unload', function () {
      undefined.unloaded = true;
      resolve();
    });
  }),
  whenLoaded: new Bluebird.Promise(function (resolve) {
    if (isDomReady()) {
      return resolve();
    }
    document.addEventListener('DOMContentLoaded', resolve);
    document.addEventListener('load', resolve);
    return undefined;
  })
};

},{"bluebird":2}],254:[function(require,module,exports){
'use strict';

// @todo enable the following disabled rules see OPENTOK-31136 for more info
/* eslint-disable global-require */

module.exports = function errorReportingFactory() {
  var deps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var APIKEY = deps.APIKEY || require('../ot/api_key.js');
  var logging = deps.logging || require('../ot/logging.js');
  var otProperties = deps.otProperties || require('./otProperties.js');
  var isEnabled = otProperties.enableErrorReporting;

  var context = deps.global;
  if (!context && typeof window !== 'undefined') {
    context = window;
  }

  var Raven = deps.Raven;
  if (!Raven && context) {
    Raven = require('raven-js');
  }

  var whitelistUrlPattern = /(opentok|ot|tb|tokbox)(?:\.min)?\.js/;

  /*
   * Blocks error reporting until it has been explicitly enabled.
   *
   * The otError tag workaround is necessary because raven-js will
   * automatically wrap global error listeners. We prevent this by
   * only accepting errors that have the otError tag set by our
   * generateTags() function. It is deleted because it's not used
   * after this point.
   */
  var shouldSendCallback = function shouldSendCallback(errorData) {
    if (!isEnabled) {
      return false;
    }

    if (errorData && errorData.tags && errorData.tags.otError) {
      delete errorData.tags.otError; // eslint-disable-line no-param-reassign
      return true;
    }

    return false;
  };

  var installRaven = function installRaven() {
    if (Raven) {
      Raven.config(otProperties.sentryDSN, {
        whitelistUrls: [whitelistUrlPattern],
        logger: 'webrtc-js',
        release: otProperties.version,
        autoBreadcrumbs: false,
        shouldSendCallback: shouldSendCallback
      }).install().noConflict();
    }
  };

  /*
   * The rawError object must be normalised to an instance of Error because
   * raven-js will cast anything else to a string. This prevents objects
   * like ExceptionEvent from being reported as "[object Object]".
   *
   * @param {Error|Object|String} rawError
   * @return {Error|String}
   */
  var normaliseError = function normaliseError(rawError) {
    var error = void 0;

    if (rawError instanceof Error || typeof rawError === 'string') {
      error = rawError;
    } else if (rawError == null) {
      error = new Error('Undefined or null error was reported!');
    } else {
      error = new Error(rawError.message);
      ['name', 'title', 'code', 'stack'].forEach(function (key) {
        if (rawError[key]) {
          error[key] = rawError[key];
        }
      });
    }

    if (error instanceof Error && !error.stack) {
      try {
        throw error;
      } catch (e) {
        // IE populates the error's .stack when it is thrown, nothing to do here
      }
    }

    return error;
  };

  /*
   * We generate a fingerprint because some unrelated errors can end up
   * being grouped together as the same issue, particularly normalised
   * errors that end up with identical stacktraces.
   * https://docs.sentry.io/learn/rollups/#customize-grouping-with-fingerprints
   */
  var generateFingerprint = function generateFingerprint(error) {
    var fingerprint = ['{{ default }}'];

    if (typeof error === 'string') {
      fingerprint.push('message::' + error);
    } else if (error != null) {
      ['message', 'name', 'title', 'code'].forEach(function (key) {
        if (error[key]) {
          fingerprint.push(key + '::' + error[key]);
        }
      });
    }

    return fingerprint;
  };

  var generateTags = function generateTags(error) {
    var tags = {
      otError: true,
      partnerId: APIKEY.value,
      buildHash: otProperties.buildHash
    };

    if (error instanceof Error) {
      ['name', 'title', 'code'].forEach(function (key) {
        if (error[key]) {
          tags['error.' + key] = error[key];
        }
      });
    }

    return tags;
  };

  var errorReporting = {
    /*
     * Reports an error to Sentry.io if error reporting has been enabled.
     *
     * @param {Error|Object|String} rawError
     * @return {String} Report event ID
     */
    send: function send(rawError) {
      if (!isEnabled || !Raven) {
        return null;
      }

      var error = normaliseError(rawError);

      var options = {
        fingerprint: generateFingerprint(error),
        tags: generateTags(error)
      };

      Raven.captureException(error, options);

      var lastId = Raven.lastEventId();
      logging.debug('Reported error with ID: ' + lastId, error, options);
      return lastId;
    }
  };

  var attachGlobalListener = function attachGlobalListener() {
    context.addEventListener('error', function (e) {
      if (e.error == null) {
        // unfortunately we can't do much about errors we know nothing about
        return;
      }
      errorReporting.send(e.error);
    });
  };

  if (isEnabled) {
    attachGlobalListener();
    installRaven();
  }

  return errorReporting;
};

},{"../ot/api_key.js":291,"../ot/logging.js":312,"./otProperties.js":272,"raven-js":190}],255:[function(require,module,exports){
'use strict';

var assign = require('lodash/assign');
var omit = require('lodash/omit');

var filters = {
  Edge: function Edge(iceServers) {
    var foundTurn = false;

    return iceServers.map(function (server) {
      if (!server) {
        return undefined;
      }

      var urls = server.urls || server.url && [server.url];

      if (!urls) {
        return undefined;
      }

      var filteredUrls = urls.filter(function (url) {
        var turnOk = url.indexOf('turn:') === 0 && url.indexOf('transport=udp') !== -1 && url.indexOf('turn:[') === -1 && !foundTurn;

        if (turnOk) {
          foundTurn = true;
          return true;
        }

        return url.indexOf('stun:') === 0;
      });

      if (filteredUrls.length === 0) {
        return undefined;
      }

      return assign(omit(server, ['url', 'urls']), { urls: filteredUrls });
    }).filter(function (server) {
      return server !== undefined;
    });
  },
  Safari: function Safari(iceServers) {
    return iceServers.map(function (server) {
      if (server.urls !== undefined && server.url === undefined) {
        return server;
      }

      var urls = server.urls || server.url && [server.url];

      return assign(omit(server, ['url', 'urls']), { urls: urls });
    });
  }
};

module.exports = function filterIceServers(browserName, iceServers) {
  var filter = filters[browserName];

  if (filter) {
    return filter(iceServers);
  }

  return iceServers;
};

},{"lodash/assign":142,"lodash/omit":173}],256:[function(require,module,exports){
(function (global){
'use strict';

// @todo enable the following disabled rules see OPENTOK-31136 for more info
/* eslint-disable no-param-reassign, global-require */

var bluebird = require('bluebird');

module.exports = function getNativeEnumerateDevicesFactory() {
  var deps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var OTPlugin = deps.OTPlugin || require('../otplugin/otplugin.js');
  var window = deps.global || global;

  return function getNativeEnumerateDevices() {
    if (window.navigator.mediaDevices) {
      var mediaDevices = window.navigator.mediaDevices;

      return mediaDevices.enumerateDevices && mediaDevices.enumerateDevices.bind(mediaDevices);
    }

    if (OTPlugin.isInstalled()) {
      var _mediaDevices = OTPlugin.mediaDevices;


      return _mediaDevices.enumerateDevices && bluebird.promisify(_mediaDevices.enumerateDevices.bind(_mediaDevices));
    }

    // @todo perhaps we should throw here?
    return undefined;
  };
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../otplugin/otplugin.js":390,"bluebird":2}],257:[function(require,module,exports){
(function (global){
'use strict';

// @todo enable the following disabled rules see OPENTOK-31136 for more info
/* eslint-disable no-param-reassign, global-require, one-var, prefer-const */
/* eslint-disable no-restricted-syntax, no-prototype-builtins, no-continue */

var assign = require('lodash/assign');
var Bluebird = require('bluebird');

var webkitAudioWorkaround = require('./webkitAudioWorkaround.js');
var eventing = require('../common-js-helpers/behaviours/eventing.js');

module.exports = function getUserMediaFactory() {
  var deps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var Errors = deps.Errors || require('../ot/Errors.js');
  var otError = deps.otError || require('./otError.js')();
  var OTPlugin = deps.OTPlugin || require('../otplugin/otplugin.js');
  var OTHelpers = deps.OTHelpers || require('../common-js-helpers/OTHelpers.js');
  var logging = deps.logging || require('../ot/logging.js');
  var throttleUntilComplete = deps.throttleUntilComplete || require('./throttle_until_complete.js')();
  var screenSharing = deps.screenSharing || require('../ot/screensharing/screen_sharing.js')();
  var customGetUserMedia = deps.customGetUserMedia;
  var window = deps.global || global;

  var navigator = window.navigator;


  var promisifyGetUserMedia = function promisifyGetUserMedia(context, gumKey) {
    return function (constraints) {
      return new Bluebird.Promise(function (resolve, reject) {
        context[gumKey](constraints, resolve, reject);
      });
    };
  };

  var promisifiedGetUserMedia = customGetUserMedia || function () {
    if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
      return navigator.mediaDevices.getUserMedia.bind(navigator.mediaDevices);
    } else if (navigator.getUserMedia) {
      return promisifyGetUserMedia(navigator, 'getUserMedia');
    } else if (navigator.mozGetUserMedia) {
      return promisifyGetUserMedia(navigator, 'mozGetUserMedia');
    } else if (navigator.webkitGetUserMedia) {
      return promisifyGetUserMedia(navigator, 'webkitGetUserMedia');
    } else if (OTPlugin.isInstalled()) {
      return promisifyGetUserMedia(OTPlugin, 'getUserMedia');
    }
    // @todo perhaps we should throw here?
    return undefined;
  }();

  // This waits to call getUserMedia() until after the access allowed db is closed
  var throttledGetUserMedia = throttleUntilComplete(promisifiedGetUserMedia);

  var vendorToOTErrorDetails = function () {
    var userMediaAccessDenied = {
      name: Errors.USER_MEDIA_ACCESS_DENIED,
      message: 'End-user denied permission to hardware devices'
    };

    var notSupported = {
      name: Errors.NOT_SUPPORTED,
      message: 'A constraint specified is not supported by the browser.'
    };

    var constraintsNotSatisfied = {
      name: Errors.CONSTRAINTS_NOT_SATISFIED,
      message: 'It\'s not possible to satisfy one or more constraints ' + 'passed into the getUserMedia function'
    };

    var noDevicesFound = {
      name: Errors.NO_DEVICES_FOUND,
      message: 'No voice or video input devices are available on this machine.'
    };

    var hardwareUnavailable = {
      name: Errors.HARDWARE_UNAVAILABLE,
      message: 'The selected voice or video devices are unavailable. Verify ' + 'that the chosen devices are not in use by another application.'
    };

    var screenCaptureError = {
      name: Errors.UNABLE_TO_CAPTURE_SCREEN,
      message: 'Unable to capture screen. Unknown error occurred'
    };

    // Mozilla error strings and the equivalent W3C names. NOT_SUPPORTED_ERROR does not
    // exist in the spec right now, so we'll include Mozilla's error description.
    // Chrome TrackStartError is triggered when the camera is already used by another app (Windows)
    return {
      PermissionDeniedError: userMediaAccessDenied,
      PermissionDismissedError: userMediaAccessDenied,
      NotAllowedError: userMediaAccessDenied,
      SecurityError: assign({}, userMediaAccessDenied, {
        message: 'End-user denied permission to hardware devices or user media' + ' support may be disabled on this page'
      }),
      NotSupportedError: notSupported,
      ConstraintNotSatisfiedError: constraintsNotSatisfied,
      MandatoryUnsatisfiedError: constraintsNotSatisfied,
      OverConstrainedError: constraintsNotSatisfied,
      DevicesNotFoundError: noDevicesFound,
      NotFoundError: noDevicesFound,
      NoDevicesFoundError: noDevicesFound,
      HardwareUnavailableError: hardwareUnavailable,
      NotReadableError: hardwareUnavailable,
      SourceUnavailableError: hardwareUnavailable,
      TrackStartError: hardwareUnavailable,
      ScreenCaptureError: screenCaptureError
    };
  }();

  // Map vendor error strings to errors we emit
  var errorFromVendorName = function mapVendorErrorName(vendorErrorName) {
    var otErrorDetails = vendorToOTErrorDetails[vendorErrorName];

    if (otErrorDetails) {
      return otError(otErrorDetails.name, new Error(otErrorDetails.message + ' (getUserMedia error: ' + vendorErrorName + ')'));
    }

    return new Error('Unknown error while getting user media: ' + vendorErrorName);
  };

  // Parse and normalise a getUserMedia error event from Chrome or Mozilla
  // @ref http://dev.w3.org/2011/webrtc/editor/getusermedia.html#idl-def-NavigatorUserMediaError
  var parseErrorEvent = function parseErrorObject(event) {
    var error = void 0;

    if (OTHelpers.isObject(event) && event.name) {
      error = errorFromVendorName(event.name);
      error.constraintName = event.constraintName;
    } else if (typeof event === 'string') {
      error = errorFromVendorName(event);
    } else {
      error = new Error('Unknown error type while getting media');
    }

    return error;
  };

  // Validates a Hash of getUserMedia constraints. Currently we only
  // check to see if there is at least one non-false constraint.
  var areInvalidConstraints = function areInvalidConstraints(constraints) {
    if (!constraints || !OTHelpers.isObject(constraints)) {
      return true;
    }

    for (var key in constraints) {
      if (!constraints.hasOwnProperty(key)) {
        continue;
      }
      if (constraints[key]) {
        return false;
      }
    }

    return true;
  };

  // A wrapper for the builtin navigator.getUserMedia. In addition to the usual
  // getUserMedia behaviour, this helper method also accepts a accessDialogOpened
  // and accessDialogClosed callback.
  //
  // @memberof OTHelpers
  // @private
  //
  // @param {Object} constraints
  //      A dictionary of constraints to pass to getUserMedia. See
  //      http://dev.w3.org/2011/webrtc/editor/getusermedia.html#idl-def-MediaStreamConstraints
  //      in the Media Capture and Streams spec for more info.
  //
  // @param {function} success
  //      Called when getUserMedia completes successfully. The callback will be passed a WebRTC
  //      Stream object.
  //
  // @param {function} failure
  //      Called when getUserMedia fails to access a user stream. It will be passed an object
  //      with a code property representing the error that occurred.
  //
  // @param {function} accessDialogOpened
  //      Called when the access allow/deny dialog is opened.
  //
  // @param {function} accessDialogClosed
  //      Called when the access allow/deny dialog is closed.
  //
  // @param {function} accessDenied
  //      Called when access is denied to the camera/mic. This will be either because
  //      the user has clicked deny or because a particular origin is permanently denied.
  //
  return function (constraints) {
    var request = {};
    eventing(request);

    if (areInvalidConstraints(constraints)) {
      // All constraints are false, we don't allow this. This may be valid later
      // depending on how/if we integrate data channels.
      logging.error('Couldn\'t get UserMedia: All constraints were false');

      request.promise = Bluebird.reject(otError(Errors.NO_VALID_CONSTRAINTS, new Error('Video and Audio was disabled, you need to enable at least one')));

      request.release = function () {};

      return request;
    }

    var throttledRequest = throttledGetUserMedia(constraints);
    request.release = throttledRequest.release;

    var finalized = throttledRequest.promise.catch(function () {});

    request.promise = throttledRequest.promise.catch(function (browserError) {
      // This also restores bluebird's ability to check we handle the error since we ignored
      // it when creating `finalized` above.
      var error = parseErrorEvent(browserError);

      if (error.name === Errors.UNABLE_TO_CAPTURE_SCREEN) {
        return new Bluebird.Promise(function (resolve, reject) {
          screenSharing.checkCapability(function (response) {
            if (response.extensionRequired === 'chrome') {
              if (response.extensionRegistered && !response.extensionInstalled) {
                var newErr = otError(Errors.SCREEN_SHARING_EXTENSION_NOT_INSTALLED, error);
                newErr.message = 'Screen sharing extension not installed see https://tokbox.com/developer/guides/screen-sharing/js/#chrome-extension';
                reject(newErr);
              } else if (!response.extensionRegistered) {
                var _newErr = otError(Errors.SCREEN_SHARING_EXTENSION_NOT_REGISTERED, error);
                _newErr.message = 'Screen sharing extension not registered see https://tokbox.com/developer/guides/screen-sharing/js/#chrome-extension';
                reject(_newErr);
              }
            } else {
              reject(error);
            }
          });
        });
      }
      throw error;
    }).then(webkitAudioWorkaround);

    // The 'remember me' functionality of WebRTC only functions over HTTPS, if
    // we aren't on HTTPS then we should definitely be displaying the access
    // dialog.
    //
    // If we are on HTTPS, we'll wait 500ms to see if we get a stream
    // immediately. If we do then the user had clicked 'remember me'. Otherwise
    // we assume that the accessAllowed dialog is visible.
    //
    // Otherwise, we still wait 100ms to give the client a chance to bind to the
    // event.
    //
    // @todo benchmark and see if 500ms is a reasonable number. It seems like
    // we should know a lot quicker.
    //
    var dialogOpenedDelay = location.protocol.indexOf('https') !== -1 ? 500 : 100;

    var waitingForStream = true;
    finalized.then(function () {
      waitingForStream = false;
    });

    Bluebird.delay(dialogOpenedDelay).then(function () {
      if (!waitingForStream) {
        return;
      }

      request.emit('accessDialogOpened');
      finalized.then(function () {
        return request.emit('accessDialogClosed');
      });
    });

    return request;
  };
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../common-js-helpers/OTHelpers.js":217,"../common-js-helpers/behaviours/eventing.js":220,"../ot/Errors.js":288,"../ot/logging.js":312,"../ot/screensharing/screen_sharing.js":366,"../otplugin/otplugin.js":390,"./otError.js":271,"./throttle_until_complete.js":275,"./webkitAudioWorkaround.js":285,"bluebird":2,"lodash/assign":142}],258:[function(require,module,exports){
'use strict';

// @todo enable the following disabled rules see OPENTOK-31136 for more info
/* eslint-disable one-var, no-param-reassign, no-shadow */

var uuid = require('uuid');
var OTHelpers = require('../common-js-helpers/OTHelpers.js');
var logging = require('../ot/logging.js');

var guidStorage = {};
module.exports = guidStorage;

var currentGuidStorage = void 0,
    currentGuid = void 0;

var isInvalidStorage = function isInvalidStorage(storageInterface) {
  return !(OTHelpers.isFunction(storageInterface.get) && OTHelpers.isFunction(storageInterface.set));
};

var getClientGuid = function getClientGuid(completion) {
  if (currentGuid) {
    completion(null, currentGuid);
    return;
  }

  // It's the first time that getClientGuid has been called
  // in this page lifetime. Attempt to load any existing Guid
  // from the storage
  currentGuidStorage.get(completion);
};

/*
* Sets the methods for storing and retrieving client GUIDs persistently
* across sessions. By default, OpenTok.js attempts to use browser cookies to
* store GUIDs.
* <p>
* Pass in an object that has a <code>get()</code> method and
* a <code>set()</code> method.
* <p>
* The <code>get()</code> method must take one parameter: the callback
* method to invoke. The callback method is passed two parameters &mdash;
* the first parameter is an error object or null if the call is successful;
* and the second parameter is the GUID (a string) if successful.
* <p>
* The <code>set()</code> method must include two parameters: the GUID to set
* (a string) and the callback method to invoke. The callback method is
* passed an error object on error, or it is passed no parameter if the call is
* successful.
* <p>
* Here is an example:
* <p>
* <pre>
* var ComplexStorage = function() {
*   this.set = function(guid, completion) {
*     AwesomeBackendService.set(guid, function(response) {
*       completion(response.error || null);
*     });
*   };
*   this.get = function(completion) {
*     AwesomeBackendService.get(function(response, guid) {
*       completion(response.error || null, guid);
*     });
*   };
* };
*
* OT.overrideGuidStorage(new ComplexStorage());
* </pre>
*/
guidStorage.override = function (storageInterface) {
  if (isInvalidStorage(storageInterface)) {
    throw new Error('The storageInterface argument does not seem to be valid, ' + 'it must implement get and set methods');
  }

  if (currentGuidStorage === storageInterface) {
    return;
  }

  currentGuidStorage = storageInterface;

  // If a client Guid has already been assigned to this client then
  // let the new storage know about it so that it's in sync.
  if (currentGuid) {
    currentGuidStorage.set(currentGuid, function (error) {
      if (error) {
        logging.error('Failed to send initial Guid value (' + currentGuid + ') to the newly assigned Guid Storage. The error was: ' + error);
        // @todo error
      }
    });
  }
};

guidStorage.get = function (completion) {
  getClientGuid(function (error, guid) {
    if (error) {
      completion(error);
      return;
    }

    if (!guid) {
      // Nothing came back, this client is entirely new.
      // generate a new Guid and persist it
      guid = uuid();
      currentGuidStorage.set(guid, function (error) {
        if (error) {
          completion(error);
          return;
        }

        currentGuid = guid;
      });
    } else if (!currentGuid) {
      currentGuid = guid;
    }

    completion(null, currentGuid);
  });
};

// Implement our default storage mechanism, which sets/gets a cookie
// called 'opentok_client_id'
guidStorage.override({
  get: function get(completion) {
    completion(null, localStorage.getItem('opentok_client_id'));
  },
  set: function set(guid, completion) {
    localStorage.setItem('opentok_client_id', guid);
    completion(null);
  }
});

// Test only
guidStorage.set = function (guid) {
  currentGuid = guid;
};

},{"../common-js-helpers/OTHelpers.js":217,"../ot/logging.js":312,"uuid":200}],259:[function(require,module,exports){
'use strict';

var env = require('../common-js-helpers/env.js');

module.exports = function () {
  return ['Chrome', 'IE', 'Opera'].indexOf(env.name) > -1;
};

},{"../common-js-helpers/env.js":233}],260:[function(require,module,exports){
'use strict';

var OTPlugin = require('../otplugin/otplugin.js');

var env = require('../common-js-helpers/env.js');
var hasOpenTokSupport = require('./hasOpenTokSupport.js').once;

// TODO Remove all transport stuff, that belongs to the messaging layer not the Media layer.
// Indicates if the browser supports bundle
//
// Broadly:
// * Firefox support bundle
// * Chrome support bundle
// * OT Plugin supports bundle
// * We assume NodeJs supports bundle (e.g. 'you're on your own' mode)
//
module.exports = function () {
  return hasOpenTokSupport() && (env.name === 'Chrome' || env.name === 'Firefox' || env.name === 'Node' || OTPlugin.isInstalled());
};

},{"../common-js-helpers/env.js":233,"../otplugin/otplugin.js":390,"./hasOpenTokSupport.js":264}],261:[function(require,module,exports){
'use strict';

module.exports = function () {
  return typeof document !== 'undefined' && 'classList' in document.createElement('a');
};

},{}],262:[function(require,module,exports){
(function (global){
'use strict';

var OTPlugin = require('../otplugin/otplugin.js');
var env = require('../common-js-helpers/env.js');

// Indicates whether this client supports the getUserMedia API.

module.exports = function () {
  return Boolean(env.name !== 'Node' && (global.navigator.webkitGetUserMedia || global.navigator.mozGetUserMedia || global.navigator.mediaDevices && global.navigator.mediaDevices.getUserMedia || OTPlugin.isInstalled()));
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../common-js-helpers/env.js":233,"../otplugin/otplugin.js":390}],263:[function(require,module,exports){
'use strict';

var env = require('../common-js-helpers/env.js');
var hasOpenTokSupport = require('./hasOpenTokSupport.js').once;

module.exports = function () {
  return hasOpenTokSupport() && env.name === 'Chrome';
};

},{"../common-js-helpers/env.js":233,"./hasOpenTokSupport.js":264}],264:[function(require,module,exports){
'use strict';

/* eslint-disable global-require */

var once = require('lodash/once');

// Indicates whether this client supports WebRTC
//
// This is defined as: getUserMedia + PeerConnection + exceeds min browser version
//
exports.check = function () {
  var deps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var env = deps.env || require('../common-js-helpers/env.js');
  var hasGetUserMediaCapability = deps.hasGetUserMediaCapability || require('./hasGetUserMediaCapability.js');
  var hasPeerConnectionCapability = deps.hasPeerConnectionCapability || require('./hasPeerConnectionCapability.js');
  var logging = deps.logging || require('../ot/logging.js');
  var otProperties = deps.otProperties || require('./otProperties.js');

  if (otProperties) {
    var minimumVersions = otProperties.minimumVersion || {};
    var minimumVersion = minimumVersions[env.name.toLowerCase()];

    if (minimumVersion && minimumVersion > env.version) {
      logging.debug('Support for', env.name, 'is disabled because we require', minimumVersion, 'but this is', env.version);
      return false;
    }
  }

  if (env.name === 'Node') {
    // Node works, even though it doesn't have getUserMedia
    return true;
  }

  return hasGetUserMediaCapability() && hasPeerConnectionCapability();
};

exports.once = once(function () {
  return exports.check();
});

},{"../common-js-helpers/env.js":233,"../ot/logging.js":312,"./hasGetUserMediaCapability.js":262,"./hasPeerConnectionCapability.js":265,"./otProperties.js":272,"lodash/once":174}],265:[function(require,module,exports){
(function (global){
'use strict';

var OTPlugin = require('../otplugin/otplugin.js');

var env = require('../common-js-helpers/env.js');

// TODO Remove all PeerConnection stuff, that belongs to the messaging layer not the Media layer.
// Indicates whether this client supports the PeerConnection
// API.
//
// Chrome Issues:
// * The explicit prototype.addStream check is because webkitRTCPeerConnection was
// partially implemented, but not functional, in Chrome 22.
//
// Firefox Issues:
// * No real support before Firefox 19
// * Firefox 19 has issues with generating Offers.
// * Firefox 20 doesn't interoperate with Chrome.
//
module.exports = function () {
  if (env.name === 'Node') {
    return false;
  } else if (typeof global.webkitRTCPeerConnection === 'function' && !!global.webkitRTCPeerConnection.prototype.addStream) {
    return true;
  } else if (typeof global.RTCPeerConnection === 'function') {
    return true;
  } else if (typeof global.mozRTCPeerConnection === 'function' && env.version > 20.0) {
    return true;
  }

  return OTPlugin.isInstalled();
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../common-js-helpers/env.js":233,"../otplugin/otplugin.js":390}],266:[function(require,module,exports){
'use strict';

var hasOpenTokSupport = require('./hasOpenTokSupport.js').once;

// Indicates if the browser supports RTCP Mux
//
// Broadly:
// * All recent versions of WebRTC (both Chrome and Firefox) support RtcpMux

module.exports = function () {
  return hasOpenTokSupport();
};

},{"./hasOpenTokSupport.js":264}],267:[function(require,module,exports){
'use strict';

var _require = require('../common-js-helpers/env.js'),
    name = _require.name;

module.exports = function () {
  return ['Firefox', 'Safari'].indexOf(name) > -1;
};

},{"../common-js-helpers/env.js":233}],268:[function(require,module,exports){
'use strict';

var _require = require('../common-js-helpers/env.js'),
    name = _require.name;

var hasOpenTokSupport = require('./hasOpenTokSupport.js').once;

module.exports = function () {
  return hasOpenTokSupport() && ['Chrome', 'Firefox'].indexOf(name) > -1;
};

},{"../common-js-helpers/env.js":233,"./hasOpenTokSupport.js":264}],269:[function(require,module,exports){
(function (global){
'use strict';

// Returns true if we think the DOM has been unloaded
// It detects this by looking for a global object, which
// should always exist until the DOM is cleaned up.

var uuid = require('uuid');

var canary = 'OT_CANARY_' + uuid();

global[canary] = {};

module.exports = function () {
  return !global[canary];
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"uuid":200}],270:[function(require,module,exports){
(function (global){
"use strict";

module.exports = function noConflict() {
  var globalOT = global.OT;
  var globalTB = global.TB;
  return function () {
    var OT = global.OT;
    global.OT = globalOT;
    global.TB = globalTB;
    return OT;
  };
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],271:[function(require,module,exports){
'use strict';

// @todo enable the following disabled rules see OPENTOK-31136 for more info
/* eslint-disable no-param-reassign, global-require */

module.exports = function otErrorFactory() {
  var deps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var errorReporting = deps.errorReporting || require('./errorReporting.js')();
  var Errors = deps.Errors || require('../ot/Errors.js');
  var OTErrorClass = deps.OTErrorClass || require('../ot/ot_error_class.js');

  var names = Object.keys(Errors).map(function (shortName) {
    return Errors[shortName];
  });

  return function otError(name, plainError, code) {
    if (names.indexOf(name) === -1) {
      throw new Error('Attempt to use invalid error name (' + name + '). Original message: ' + plainError.message);
    }

    if (!(plainError instanceof Error || /^\[object .*Error\]$/.test(plainError.toString()))) {
      throw new Error('Did not pass Error as second argument');
    }

    // OTErrorClass is the deprecated OT.Error class from the docs.
    var error = new OTErrorClass(undefined, plainError.message);

    error.name = name;

    if (!plainError.stack) {
      try {
        throw plainError;
      } catch (e) {
        // IE populates the error's .stack when it is thrown, nothing to do here
      }
    }

    error.stack = plainError.stack;

    if (code) {
      error.code = code;
    }

    errorReporting.send(error);

    return error;
  };
};

},{"../ot/Errors.js":288,"../ot/ot_error_class.js":334,"./errorReporting.js":254}],272:[function(require,module,exports){
(function (global){
'use strict';

var assign = require('lodash/assign');
var pick = require('lodash/pick');
var OTHelpers = require('../common-js-helpers/OTHelpers.js');
var incompleteProperties = require('../../conf/properties.js');

// Augments properties from conf. Makes it better and stronger!

var properties = OTHelpers.clone(incompleteProperties);

properties.debug = properties.debug === 'true' || properties.debug === true;
properties.supportSSL = properties.supportSSL === 'true' || properties.supportSSL === true;

if (global.OTProperties) {
  // Allow global.OTProperties to override cdnURL, configURL, assetURL and cssURL
  // TODO: Can we find a better solution here? This is the only place where I'm allowing this kind
  // of global interaction post-modularization.

  // override "authorized" properties with the global settings
  assign(properties, pick(global.OTProperties, ['cdnURL', 'cdnURLSSL', 'configURL', 'assetURL', 'cssURL', 'apiURL', 'apiURLSSL', 'enableErrorReporting', 'loggingURL', 'loggingURLSSL']));
}

if (!properties.cdnURLSSL && global.location) {
  properties.cdnURLSSL = global.location.protocol + '//' + global.location.host;
}

if (!properties.cdnURL && global.location) {
  properties.cdnURL = global.location.protocol + '//' + global.location.host;
}

if (!properties.assetURL) {
  if (properties.supportSSL) {
    properties.assetURL = properties.cdnURLSSL + '/webrtc/' + properties.version;
  } else {
    properties.assetURL = properties.cdnURL + '/webrtc/' + properties.version;
  }
}

var isIE89 = OTHelpers.env.name === 'IE' && OTHelpers.env.version <= 9;
if (!(isIE89 && global.location.protocol.indexOf('https') < 0)) {
  properties.apiURL = properties.apiURLSSL;
  properties.loggingURL = properties.loggingURLSSL;
}

// at this stage if cssURL is still not defined (no one set it using global.OTProperties) we
// consider it an oversight and we are forcing a default value
if (!Object.prototype.hasOwnProperty.call(properties, 'cssURL')) {
  properties.cssURL = typeof undefined !== 'undefined' ? undefined : properties.assetURL + '/css/TB.min.css';
}

properties.enableErrorReporting = Boolean(properties.enableErrorReporting);

module.exports = properties;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../conf/properties.js":216,"../common-js-helpers/OTHelpers.js":217,"lodash/assign":142,"lodash/pick":175}],273:[function(require,module,exports){
(function (global){
"use strict";

// @todo both Chrome and Firefox have a `resize` event for when the videoWidth
// or videoHeight properties change. We should investigate if this is also
// possible in Safari/ Edge. I'm not sure if the plugin supports it, but we
// should be able to add that. If that is the case, we could get rid of this
// code and the polling behavior

module.exports = function videoContentResizesMixinFactory() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref$requestAnimation = _ref.requestAnimationFrame,
      requestAnimationFrame = _ref$requestAnimation === undefined ? global.requestAnimationFrame : _ref$requestAnimation;

  return function (_ref2) {
    var element = _ref2.element,
        onSizeChange = _ref2.onSizeChange,
        whenTimeIncrements = _ref2.whenTimeIncrements;

    var width = element.videoWidth;
    var height = element.videoHeight;
    var stopped = true;

    function checkSizeLoop() {
      if (stopped) {
        return;
      }

      if (width !== element.videoWidth || height !== element.videoHeight) {
        onSizeChange({ width: width, height: height }, { width: element.videoWidth, height: element.videoHeight });
        width = element.videoWidth;
        height = element.videoHeight;
      }
      whenTimeIncrements(function () {
        return requestAnimationFrame(checkSizeLoop);
      });
    }

    return {
      start: function start() {
        stopped = false;
        checkSizeLoop();
      },
      stop: function stop() {
        stopped = true;
      }
    };
  };
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],274:[function(require,module,exports){
'use strict';

// @todo we might not need this anymore, it's really old

var OTHelpers = require('../common-js-helpers/OTHelpers.js');

// Returns a String representing the supported WebRTC crypto scheme. The possible
// values are SDES_SRTP, DTLS_SRTP, and NONE;
//
// Broadly:
// * Firefox only supports DTLS
// * Older versions of Chrome (<= 24) only support SDES
// * Newer versions of Chrome (>= 25) support DTLS and SDES
//
module.exports = function supportedCryptoScheme() {
  var chromeBefore25 = OTHelpers.env.name === 'Chrome' && OTHelpers.env.version < 25;

  return chromeBefore25 ? 'SDES_SRTP' : 'DTLS_SRTP';
};

},{"../common-js-helpers/OTHelpers.js":217}],275:[function(require,module,exports){
'use strict';

var Bluebird = require('bluebird');

module.exports = function throttleUntilCompleteFactory() {
  // Ensures that promisified functions run in serial.
  // Perhaps this module should be called "serialize," but that seems too generic.
  //
  // @memberof OTHelpers
  // @private
  //
  // @return The throttled function.
  //
  return function throttleUntilComplete(fn) {
    // We start our queue with a resolved promise. We do this
    // because we want queue to be thenable, but we also want
    // it to execute the first element of the queue immediately.
    var queue = Bluebird.Promise.resolve();

    return function () {
      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      var promiseAndRelease = {};

      // execute our function with args when the previous
      // steps/releases have finished.
      promiseAndRelease.promise = queue.then(function () {
        return fn.apply(undefined, args);
      });

      var releasePromise = new Bluebird.Promise(function (resolve) {
        promiseAndRelease.release = resolve;
      });

      queue = queue.then(function () {
        return Bluebird.race([promiseAndRelease.promise, releasePromise]);
      }).catch(function () {});

      return promiseAndRelease;
    };
  };
};

},{"bluebird":2}],276:[function(require,module,exports){
(function (global){
'use strict';

// @todo enable the following disabled rules see OPENTOK-31136 for more info
/* eslint-disable no-param-reassign, global-require, one-var, no-underscore-dangle */
/* eslint-disable no-cond-assign,  max-len, no-void, prefer-const */

var bluebird = require('bluebird');
var once = require('lodash/once');

module.exports = function NativeVideoElementWrapperFactory() {
  var deps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var audioContextProvider = deps.audioContext || require('../../audio_context')();
  var canBeOrientatedMixin = deps.canBeOrientatedMixin || require('../can_be_oriented_mixin.js');
  var document = deps.document || global.document;
  var env = deps.env || require('../../../common-js-helpers/env.js');
  var listenForTracksEnded = deps.listenForTracksEnded || require('./listenForTracksEnded.js')();
  var logging = deps.logging || require('../../../ot/logging.js');
  var OTHelpers = deps.OTHelpers || require('../../../common-js-helpers/OTHelpers.js');
  var streamBinding = deps.streamBinding || require('./streamBinding.js')();
  var pollForVideoResize = deps.pollForVideoResize || require('../../pollForVideoResize.js')();
  var videoElementErrorMap = deps.videoElementErrorMap || require('../videoElementErrorMap.js')();
  var WebaudioAudioLevelSampler = deps.WebaudioAudioLevelSampler || require('../../audio_level_samplers/webaudio_audio_level_sampler');
  var WebAudioPlayer = deps.WebAudioPlayer || require('./WebAudioPlayer.js')();

  return function NativeVideoElementWrapper(options, errorHandler, orientationChangedHandler, defaultAudioVolume) {
    var _this2 = this;

    var _domElement = void 0,
        _audioLevelSampler = void 0,
        _webAudioPlayer = void 0;
    var _videoElementMovedWarning = false;
    var _destroyed = false;
    var _createVideoElement = options._inject.createVideoElement;
    var _stream = void 0;
    var _bindInProgress = void 0;

    OTHelpers.eventing(this);

    // / Private API

    // The video element pauses itself when it's reparented, this is
    // unfortunate. This function plays the video again and is triggered
    // on the pause event.
    var _playVideoOnPause = function _playVideoOnPause() {
      if (!_videoElementMovedWarning) {
        logging.warn('Video element paused, auto-resuming. If you intended to do this, ' + 'use publishVideo(false) or subscribeToVideo(false) instead.');

        _videoElementMovedWarning = true;
      }

      _domElement.play();
    };

    _domElement = _createVideoElement(options.fallbackText, options.muted || env.name === 'Safari');
    this.trigger('videoElementCreated', _domElement);

    if (env.name === 'Safari') {
      _webAudioPlayer = new WebAudioPlayer();
      _webAudioPlayer.volume = options.muted ? 0 : 1;
    }

    _domElement.addEventListener('error', function (event) {
      errorHandler(videoElementErrorMap(event.target.error));
    }, false);

    _domElement.addEventListener('pause', _playVideoOnPause);

    this.whenTimeIncrements = function (callback, context) {
      if (_domElement) {
        var lastTime = void 0;
        var handler = function handler() {
          if (_domElement) {
            if (!lastTime || lastTime >= _domElement.currentTime) {
              lastTime = _domElement.currentTime;
            } else {
              _domElement.removeEventListener('timeupdate', handler, false);
              callback.call(context, _this2);
            }
          }
        };
        _domElement.addEventListener('timeupdate', handler, false);
      }
    };

    var videoResizePoller = pollForVideoResize({
      element: _domElement,
      onSizeChange: function onSizeChange(oldSize, size) {
        return _this2.trigger('videoDimensionsChanged', oldSize, size);
      },
      whenTimeIncrements: this.whenTimeIncrements.bind(this)
    });

    canBeOrientatedMixin(this, function () {
      return _domElement;
    }, orientationChangedHandler);

    // / Public methods

    this.domElement = function () {
      return _domElement;
    };

    this.videoWidth = function () {
      return _domElement ? _domElement.videoWidth : 0;
    };

    this.videoHeight = function () {
      return _domElement ? _domElement.videoHeight : 0;
    };

    this.imgData = function () {
      var canvas = OTHelpers.createElement('canvas', {
        width: _domElement.videoWidth,
        height: _domElement.videoHeight,
        style: { display: 'none' }
      });

      document.body.appendChild(canvas);

      var imgData = null;

      try {
        canvas.getContext('2d').drawImage(_domElement, 0, 0, canvas.width, canvas.height);
        imgData = canvas.toDataURL('image/png');
      } catch (err) {
        // Warning emitted for imgData === null below
      }

      OTHelpers.removeElement(canvas);

      if (imgData === null || imgData === 'data:,') {
        // 'data:,' is sometimes returned by canvas.toDataURL when one cannot be
        // generated.

        logging.warn('Cannot get image data yet');
        return null;
      }

      return imgData.replace('data:image/png;base64,', '').trim();
    };

    // Append the Video DOM element to a parent node
    this.appendTo = function (parentDomElement) {
      parentDomElement.appendChild(_domElement);
      return this;
    };

    // The videoWidth and videoHeight can be bogus when the video hasn't loaded yet. This returns
    // a promise to a resolution when the video is loaded.
    this.getLoadedResolution = function () {
      return new bluebird.Promise(function (resolve, reject) {
        if (!_stream || _stream.getVideoTracks().length === 0) {
          resolve(null);
          return;
        }

        var onResolutionLoaded = void 0;

        var cleanupJobs = [];
        var cleanup = once(function () {
          return cleanupJobs.forEach(function (job) {
            return job();
          });
        });

        var resolutionListener = function resolutionListener() {
          // Chrome does a hack that causes the videoWidth to be 2 when it hasn't completely loaded.
          // Firefox also has videoWidth 0 sometimes, often on first timeupdate. So if there is a
          // video track (even a disabled one - OPENTOK-31836), we make sure videoWidth > 2 before
          // completing.
          if (_domElement.videoWidth > 2) {
            onResolutionLoaded({
              width: _domElement.videoWidth,
              height: _domElement.videoHeight
            });
          }
        };

        onResolutionLoaded = once(function (resolution) {
          cleanup();
          resolve(resolution);
        });

        _domElement.addEventListener('timeupdate', resolutionListener);
        cleanupJobs.push(function () {
          return _domElement.removeEventListener('timeupdate', resolutionListener);
        });

        _domElement.addEventListener('loadedmetadata', resolutionListener);
        cleanupJobs.push(function () {
          return _domElement.removeEventListener('loadedmetadata', resolutionListener);
        });

        resolutionListener();
        var intervalId = setInterval(resolutionListener, 100);
        cleanupJobs.push(function () {
          return clearInterval(intervalId);
        });

        var timeoutId = setTimeout(function () {
          return onResolutionLoaded({ width: 0, height: 0 });
        }, 1000);
        cleanupJobs.push(function () {
          return clearTimeout(timeoutId);
        });

        var destroyedListener = function destroyedListener() {
          cleanup();
          reject(new Error('Failed to get resolution: destroyed'));
        };

        _this2.once('destroyed', destroyedListener);
        cleanupJobs.push(function () {
          return _this2.off('destroyed', destroyedListener);
        });
      });
    };

    // Bind a stream to the video element.
    this.bindToStream = function (webRtcStream, completion) {
      if (_bindInProgress && _stream === webRtcStream) {
        _bindInProgress.asCallback(completion);
        return;
      }

      var _this = this;
      _stream = webRtcStream;

      if (_webAudioPlayer && _stream.otWebkitAudioSource) {
        _webAudioPlayer.stream = _stream;
      }

      _bindInProgress = streamBinding.bind(_domElement, webRtcStream).then(function () {
        if (_destroyed) {
          // the operation has been canceled
          return undefined;
        }

        if (!_domElement) {
          return bluebird.Promise.reject(new Error('Can\'t bind because _domElement no longer exists'));
        }

        videoResizePoller.start();

        var listener = void 0;

        function onAllEnded() {
          listener.stop();

          if (_domElement) {
            _domElement.onended = null;
          }

          _this.trigger('mediaStopped');
        }

        function onSingleEnded(track) {
          _this.trigger('mediaStopped', track);
        }

        // OPENTOK-22428: Firefox doesn't emit the ended event on the webRtcStream when the user
        // stops sharing their camera, but we do get the ended event on the video element.
        _domElement.onended = onAllEnded;

        // Note: This can only recognise the *current* tracks of the stream have ended. If the stream
        // tracks change, this will need to be updated.
        listener = listenForTracksEnded(webRtcStream, onAllEnded, onSingleEnded);

        if (webRtcStream.getAudioTracks().length > 0) {
          var audioContext = audioContextProvider();
          if (audioContext) {
            _audioLevelSampler = new WebaudioAudioLevelSampler(audioContext);
            _audioLevelSampler.webRTCStream(webRtcStream);
          }
        }

        _bindInProgress = undefined;

        return undefined;
      });

      _bindInProgress.asCallback(completion);
    };

    // Unbind the currently bound stream from the video element.
    this.unbindStream = function () {
      if (_domElement) {
        streamBinding.unbind(_domElement);
      }

      if (_webAudioPlayer) {
        _webAudioPlayer.stream = null;
      }

      videoResizePoller.stop();
      _audioLevelSampler = null;
      _stream = null;

      return this;
    };

    this.setAudioVolume = function (value) {
      var target = _webAudioPlayer || _domElement;
      if (target) {
        target.volume = value;
      }
    };

    this.getAudioVolume = function () {
      // Return the actual volume of the DOM element
      var target = _webAudioPlayer || _domElement;
      if (target) {
        return target.volume;
      }
      return defaultAudioVolume;
    };

    // see https://wiki.mozilla.org/WebAPI/AudioChannels
    // The audioChannelType is currently only available in Firefox. This property returns
    // "unknown" in other browser. The related HTML tag attribute is "mozaudiochannel"
    this.audioChannelType = function (type) {
      if (type !== void 0) {
        _domElement.mozAudioChannelType = type;
      }

      if ('mozAudioChannelType' in _domElement) {
        return _domElement.mozAudioChannelType;
      }

      return 'unknown';
    };

    this.getAudioInputLevel = function () {
      return new bluebird.Promise(function (resolve) {
        if (_audioLevelSampler) {
          _audioLevelSampler.sample(resolve);
        } else {
          // if we can't sample a value we still resolve but with a null value
          // it is up to the caller to figure out what to do with it
          resolve(null);
        }
      });
    };

    this.destroy = function () {
      _destroyed = true;

      this.unbindStream();

      if (_domElement) {
        // Unbind this first, otherwise it will trigger when the
        // video element is removed from the DOM.
        _domElement.removeEventListener('pause', _playVideoOnPause);

        OTHelpers.removeElement(_domElement);
        _domElement = null;
      }

      if (_webAudioPlayer) {
        _webAudioPlayer.destroy();
        _webAudioPlayer = null;
      }

      this.trigger('destroyed');

      return void 0;
    };
  };
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../../common-js-helpers/OTHelpers.js":217,"../../../common-js-helpers/env.js":233,"../../../ot/logging.js":312,"../../audio_context":242,"../../audio_level_samplers/webaudio_audio_level_sampler":244,"../../pollForVideoResize.js":273,"../can_be_oriented_mixin.js":280,"../videoElementErrorMap.js":283,"./WebAudioPlayer.js":277,"./listenForTracksEnded.js":278,"./streamBinding.js":279,"bluebird":2,"lodash/once":174}],277:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/* eslint-disable global-require, no-underscore-dangle */

var clamp = require('lodash/clamp');

module.exports = function () {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref$audioContextProv = _ref.audioContextProvider,
      audioContextProvider = _ref$audioContextProv === undefined ? require('../../audio_context')() : _ref$audioContextProv;

  return function () {
    function WebAudioPlayer() {
      _classCallCheck(this, WebAudioPlayer);

      this._stream = null;
      this._audioContext = audioContextProvider();
      this._gainNode = this._audioContext.createGain();
      this._gainNode.connect(this._audioContext.destination);
    }

    WebAudioPlayer.prototype.destroy = function destroy() {
      this.stream = null;
      this._gainNode.disconnect(this._audioContext.destination);
    };

    _createClass(WebAudioPlayer, [{
      key: 'stream',
      get: function get() {
        return this._stream;
      },
      set: function set(newStream) {
        if (this._stream) {
          this._stream.otWebkitAudioSource.disconnect(this._gainNode);
        }

        this._stream = newStream;

        if (this._stream) {
          this._stream.otWebkitAudioSource.connect(this._gainNode);
        }
      }
    }, {
      key: 'volume',
      get: function get() {
        return this._gainNode.gain.value;
      },
      set: function set(newVolume) {
        this._gainNode.gain.value = clamp(newVolume, 0, 1);
      }
    }]);

    return WebAudioPlayer;
  }();
};

},{"../../audio_context":242,"lodash/clamp":145}],278:[function(require,module,exports){
'use strict';

// @todo enable the following disabled rules see OPENTOK-31136 for more info
/* eslint-disable no-use-before-define */

module.exports = function listenForTracksEndedFactory() {
  function isEveryTrackEnded(stream) {
    return stream.getTracks().every(function (track) {
      return track.readyState === 'ended';
    });
  }

  return function listenForTracksEnded(stream, onAllEnded, onSingleEnded) {
    var tracks = [];

    function singleTrackEndedHandler(event) {
      // We wait a fraction of a second for all ended events to be emitted before
      // determining if all tracks have ended or just a subset of them.
      setTimeout(function () {
        if (!tracks.length) {
          return;
        }

        if (isEveryTrackEnded(stream)) {
          removeAllTrackListeners();
          if (typeof onAllEnded === 'function') {
            onAllEnded();
          }
        } else {
          var track = event.target;
          removeTrackListener(track);
          if (typeof onSingleEnded === 'function') {
            onSingleEnded(track);
          }
        }
      }, 100);
    }

    function removeTrackListener(track) {
      track.removeEventListener('ended', singleTrackEndedHandler);

      var index = tracks.indexOf(track);
      if (index >= 0) {
        tracks.splice(index, 1);
      }
    }

    function removeAllTrackListeners() {
      tracks.slice().forEach(removeTrackListener);
    }

    stream.getTracks().forEach(function (track) {
      tracks.push(track);
      track.addEventListener('ended', singleTrackEndedHandler);
    });

    return {
      stop: removeAllTrackListeners
    };
  };
};

},{}],279:[function(require,module,exports){
(function (global){
'use strict';

// @todo enable the following disabled rules see OPENTOK-31136 for more info
/* eslint-disable no-param-reassign, global-require, no-void, no-use-before-define */

var bluebird = require('bluebird');

var logging = require('../../../ot/logging.js');

var streamHasEnabledVideoTrack = function streamHasEnabledVideoTrack(stream) {
  var videoTrack = stream.getVideoTracks()[0];
  return Boolean(videoTrack && videoTrack.enabled);
};

module.exports = function streamBindingFactory() {
  var deps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var errors = deps.Errors || require('../../../ot/Errors.js');
  var otError = deps.otError || require('../../otError.js')();
  var videoElementErrorMap = deps.videoElementErrorMap || require('../videoElementErrorMap.js')();
  var window = deps.global || global;

  var streamBinding = {};

  streamBinding.unbind = function (videoElement) {
    videoElement.onended = null;

    if (videoElement.srcObject !== void 0) {
      videoElement.srcObject = null;
    } else if (videoElement.mozSrcObject !== void 0) {
      videoElement.mozSrcObject = null;
    } else {
      window.URL.revokeObjectURL(videoElement.src);
    }
  };

  function uncheckedBind(videoElement, webRtcStream) {
    // The official spec way is 'srcObject', we are slowly converging there.
    if (videoElement.srcObject !== void 0) {
      if (videoElement.srcObject !== webRtcStream) {
        videoElement.srcObject = webRtcStream;
      }
    } else if (videoElement.mozSrcObject !== void 0) {
      if (videoElement.mozSrcObject !== webRtcStream) {
        videoElement.mozSrcObject = webRtcStream;
      }
    } else {
      videoElement.src = window.URL.createObjectURL(webRtcStream);
    }
  }

  streamBinding.bind = function (videoElement, webRtcStream) {
    uncheckedBind(videoElement, webRtcStream);

    if (videoElement.muted && !streamHasEnabledVideoTrack(webRtcStream)) {
      // Won't be actually playing audio or video, so just resolve.
      return bluebird.resolve();
    }

    var cleanupJobs = [];
    var cleanup = function cleanup() {
      return cleanupJobs.forEach(function (job) {
        return job();
      });
    };

    var loaded = new bluebird.Promise(function (resolve, reject) {
      var addListenerWithCleanup = function addListenerWithCleanup(obj, evtName, handler) {
        var wrappedHandler = function wrappedHandler(evt) {
          var log = evtName === 'error' ? logging.error : logging.debug;
          log('streamBinding.bind(', videoElement, webRtcStream, '):', evtName, ':', evt);
          handler(evt);
        };

        obj.addEventListener(evtName, wrappedHandler);
        cleanupJobs.push(function () {
          return obj.removeEventListener(evtName, wrappedHandler);
        });
      };

      var stoppedLoadingError = function stoppedLoadingError() {
        return otError(errors.HARDWARE_UNAVAILABLE, new Error('Stream ended while trying to bind it to a video element. This may be due to ' + 'your webcam being in use by another application.'));
      };

      webRtcStream.getTracks().forEach(function (track) {
        addListenerWithCleanup(track, 'ended', function () {
          return reject(stoppedLoadingError());
        });
      });

      addListenerWithCleanup(videoElement, 'loadedmetadata', resolve);
      addListenerWithCleanup(videoElement, 'timeupdate', resolve);

      addListenerWithCleanup(videoElement, 'error', function (event) {
        return reject(videoElementErrorMap(event.target.error));
      });

      videoElement.onended = function () {
        return reject(stoppedLoadingError());
      };
      cleanupJobs.push(function () {
        videoElement.onended = null;
      });
    });

    return loaded.then(cleanup).catch(function (err) {
      cleanup();
      streamBinding.unbind(videoElement);
      throw err;
    });
  };

  return streamBinding;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../../ot/Errors.js":288,"../../../ot/logging.js":312,"../../otError.js":271,"../videoElementErrorMap.js":283,"bluebird":2}],280:[function(require,module,exports){
'use strict';

// @todo enable the following disabled rules see OPENTOK-31136 for more info
/* eslint-disable no-underscore-dangle, no-param-reassign */

var OTHelpers = require('../../common-js-helpers/OTHelpers.js');

var VideoOrientationTransforms = {
  0: 'rotate(0deg)',
  270: 'rotate(90deg)',
  90: 'rotate(-90deg)',
  180: 'rotate(180deg)'
};

// A mixin to create the orientation API implementation on +self+
// +getDomElementCallback+ is a function that the mixin will call when it wants to
// get the native Dom element for +self+.
//
// +initialOrientation+ sets the initial orientation (shockingly), it's currently unused
// so the initial value is actually undefined.
//
module.exports = function canBeOrientatedMixin(self, getDomElementCallback, orientationChangedHandler, initialOrientation) {
  var _orientation = initialOrientation;

  OTHelpers.defineProperties(self, {
    isRotated: {
      get: function get() {
        return this.orientation() && (this.orientation().videoOrientation === 270 || this.orientation().videoOrientation === 90);
      }
    },

    orientation: {
      get: function get() {
        return _orientation;
      },
      set: function set(orientation) {
        _orientation = orientation;

        var transform = VideoOrientationTransforms[orientation.videoOrientation] || VideoOrientationTransforms.ROTATED_NORMAL;

        switch (OTHelpers.env.name) {
          case 'Chrome':
          case 'Safari':
            getDomElementCallback().style.webkitTransform = transform;
            break;

          case 'IE':
            getDomElementCallback().style.msTransform = transform;
            break;

          default:
            // The standard version, just Firefox, Opera, and IE > 9
            getDomElementCallback().style.transform = transform;
        }

        orientationChangedHandler(_orientation);
      }
    },

    // see https://wiki.mozilla.org/WebAPI/AudioChannels
    // The audioChannelType is currently only available in Firefox. This property returns
    // "unknown" in other browser. The related HTML tag attribute is "mozaudiochannel"
    audioChannelType: {
      get: function get() {
        if ('mozAudioChannelType' in this.domElement) {
          return this.domElement.mozAudioChannelType;
        }

        return 'unknown';
      },
      set: function set(type) {
        if ('mozAudioChannelType' in this.domElement) {
          this.domElement.mozAudioChannelType = type;
        }
      }
    }
  });
};

},{"../../common-js-helpers/OTHelpers.js":217}],281:[function(require,module,exports){
'use strict';

// @todo enable the following disabled rules see OPENTOK-31136 for more info
/* eslint-disable no-param-reassign, global-require,  one-var, no-underscore-dangle */
/* eslint-disable prefer-rest-params, no-void, max-len */

var assign = require('lodash/assign');

module.exports = function VideoElementFacadeFactory() {
  var deps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var NativeVideoElementWrapper = deps.NativeVideoElementWrapper || require('./NativeVideoElementWrapper/NativeVideoElementWrapper.js')();
  var OTHelpers = deps.OTHelpers || require('../../common-js-helpers/OTHelpers.js');
  var OTPlugin = deps.OTPlugin || require('../../otplugin/otplugin.js');
  var PluginVideoElementWrapper = deps.PluginVideoElementWrapper || require('./plugin_video_element_wrapper');

  var defaultAudioVolume = 50;

  function createDomVideoElement(fallbackText, muted) {
    var videoElement = document.createElement('video');
    videoElement.setAttribute('autoplay', '');
    videoElement.setAttribute('playsinline', '');
    videoElement.innerHTML = fallbackText;

    if (muted === true) {
      videoElement.muted = 'true';
    }

    return videoElement;
  }

  //
  //
  //   var _videoElement = new VideoElement({
  //     fallbackText: 'blah'
  //   }, errorHandler);
  //
  //   _videoElement.bindToStream(webRtcStream, completion);      // => VideoElement
  //   _videoElement.appendTo(DOMElement)                         // => VideoElement
  //
  //   _videoElement.domElement                       // => DomNode
  //
  //   _videoElement.imgData                          // => PNG Data string
  //
  //   _videoElement.orientation = VideoOrientation.ROTATED_LEFT;
  //
  //   _videoElement.unbindStream();
  //   _videoElement.destroy()                        // => Completely cleans up and
  //                                                        removes the video element
  //
  //
  return function VideoElementFacade(
  /* optional */options /* ,
                        optional errorHandler*/
  ) {
    var _this = this;

    var _stream = void 0,
        _preInitialisedVolume = void 0;
    var _streamBound = false;

    var _options = OTHelpers.defaults(options && !OTHelpers.isFunction(options) ? options : {}, {
      fallbackText: 'Sorry, Web RTC is not available in your browser'
    });

    if (!OTPlugin.isInstalled()) {
      assign(_options, {
        _inject: { createVideoElement: createDomVideoElement }
      });
    }

    var errorHandler = OTHelpers.isFunction(arguments[arguments.length - 1]) ? arguments[arguments.length - 1] : void 0;

    var orientationHandler = function (orientation) {
      this.trigger('orientationChanged', orientation);
    }.bind(this);

    var _videoElementWrapper = OTPlugin.isInstalled() ? new PluginVideoElementWrapper(_options, errorHandler, orientationHandler, defaultAudioVolume) : new NativeVideoElementWrapper(_options, errorHandler, orientationHandler, defaultAudioVolume);

    OTHelpers.eventing(this);

    _videoElementWrapper.on('videoDimensionsChanged', function (oldValue, newValue) {
      _this.trigger('videoDimensionsChanged', oldValue, newValue);
    });

    _videoElementWrapper.on('mediaStopped', function (track) {
      _this.trigger('mediaStopped', track);
    });

    _videoElementWrapper.on('videoElementCreated', function (element) {
      _this.trigger('videoElementCreated', element);
    });

    this.getLoadedResolution = function () {
      return _videoElementWrapper.getLoadedResolution();
    };

    // Public Properties
    OTHelpers.defineProperties(this, {

      domElement: {
        get: function get() {
          return _videoElementWrapper.domElement();
        }
      },

      videoWidth: {
        get: function get() {
          return _videoElementWrapper['video' + (this.isRotated() ? 'Height' : 'Width')]();
        }
      },

      videoHeight: {
        get: function get() {
          return _videoElementWrapper['video' + (this.isRotated() ? 'Width' : 'Height')]();
        }
      },

      aspectRatio: {
        get: function get() {
          return (this.videoWidth() + 0.0) / this.videoHeight();
        }
      },

      isRotated: {
        get: function get() {
          return _videoElementWrapper.isRotated();
        }
      },

      orientation: {
        get: function get() {
          return _videoElementWrapper.orientation();
        },
        set: function set(orientation) {
          _videoElementWrapper.orientation(orientation);
        }
      },

      audioChannelType: {
        get: function get() {
          return _videoElementWrapper.audioChannelType();
        },
        set: function set(type) {
          _videoElementWrapper.audioChannelType(type);
        }
      }
    });

    // Public Methods

    this.imgData = function () {
      return _videoElementWrapper.imgData();
    };

    this.appendTo = function (parentDomElement) {
      _videoElementWrapper.appendTo(parentDomElement);
      return this;
    };

    this.bindToStream = function (webRtcStream, completion) {
      var _this2 = this;

      _streamBound = false;
      _stream = webRtcStream;

      _videoElementWrapper.bindToStream(webRtcStream, function (err) {
        if (err) {
          completion(err);
          return;
        }

        _streamBound = true;

        if (typeof _preInitialisedVolume !== 'undefined') {
          _this2.setAudioVolume(_preInitialisedVolume);
          _preInitialisedVolume = undefined;
        }

        _videoElementWrapper.on('aspectRatioAvailable', _this2.trigger.bind(_this2, 'aspectRatioAvailable'));

        completion(null);
      });

      return this;
    };

    this.unbindStream = function () {
      if (!_stream) {
        return this;
      }

      _stream.onended = null;
      _stream = null;
      _videoElementWrapper.unbindStream();
      return this;
    };

    this.setAudioVolume = function (value) {
      if (_streamBound) {
        _videoElementWrapper.setAudioVolume(OTHelpers.roundFloat(value / 100, 2));
      } else {
        _preInitialisedVolume = parseFloat(value);
      }

      return this;
    };

    this.getAudioVolume = function () {
      if (_streamBound) {
        return Math.round(_videoElementWrapper.getAudioVolume() * 100);
      }

      if (typeof _preInitialisedVolume !== 'undefined') {
        return _preInitialisedVolume;
      }

      return 50;
    };

    this.getAudioInputLevel = function () {
      return _videoElementWrapper.getAudioInputLevel();
    };

    this.whenTimeIncrements = function (callback, context) {
      _videoElementWrapper.whenTimeIncrements(callback, context);
      return this;
    };

    this.destroy = function () {
      // unbind all events so they don't fire after the object is dead
      this.off();

      _videoElementWrapper.destroy();
      return void 0;
    };
  };
};

},{"../../common-js-helpers/OTHelpers.js":217,"../../otplugin/otplugin.js":390,"./NativeVideoElementWrapper/NativeVideoElementWrapper.js":276,"./plugin_video_element_wrapper":282,"lodash/assign":142}],282:[function(require,module,exports){
'use strict';

// @todo enable the following disabled rules see OPENTOK-31136 for more info
/* eslint-disable one-var, no-underscore-dangle, no-void */

var bluebird = require('bluebird');
var OTHelpers = require('../../common-js-helpers/OTHelpers.js');
var logging = require('../../ot/logging.js');

var canBeOrientatedMixin = require('./can_be_oriented_mixin.js');

module.exports = function PluginVideoElementWrapper(options, errorHandler, orientationChangedHandler, defaultAudioVolume) {
  var _this = this;

  var _pluginVideoContainer = void 0,
      _parentDomElement = void 0;

  OTHelpers.eventing(this);

  canBeOrientatedMixin(this, function () {
    return _pluginVideoContainer.domElement;
  }, orientationChangedHandler);

  // / Public methods

  this.domElement = function () {
    return _pluginVideoContainer ? _pluginVideoContainer.domElement : void 0;
  };

  this.videoWidth = function () {
    return _pluginVideoContainer ? _pluginVideoContainer.videoWidth() : void 0;
  };

  this.videoHeight = function () {
    return _pluginVideoContainer ? _pluginVideoContainer.videoHeight() : void 0;
  };

  this.imgData = function () {
    return _pluginVideoContainer ? _pluginVideoContainer.getImgData() : null;
  };

  // Append the Video DOM element to a parent node
  this.appendTo = function (parentDomElement) {
    _parentDomElement = parentDomElement;
    return this;
  };

  this.getLoadedResolution = function () {
    var promise = new bluebird.Promise(function (resolve, reject) {
      _this.once('_resolutionLoaded', resolve);
      _this.once('destroyed', reject);
    });

    return function () {
      return promise;
    };
  }();

  // Bind a stream to the video element.
  this.bindToStream = function (webRtcStream, completion) {
    var _this2 = this;

    if (!_parentDomElement || !document.body.contains(_parentDomElement)) {
      logging.error('The VideoElement must be attached to a DOM node before a stream can be bound');
    }
    _pluginVideoContainer = webRtcStream._.render();
    this.trigger('videoElementCreated', this.domElement());
    _pluginVideoContainer.setFitMode(options.fitMode);
    _pluginVideoContainer.appendTo(_parentDomElement);
    _pluginVideoContainer.show(function (error) {
      _this2.trigger('_resolutionLoaded', {
        width: _pluginVideoContainer.videoWidth(),
        height: _pluginVideoContainer.videoHeight()
      });
      completion(error);
    });
  };

  // Unbind the currently bound stream from the video element.
  this.unbindStream = function () {
    // TODO: some way to tell OTPlugin to release that stream and controller

    if (_pluginVideoContainer) {
      _pluginVideoContainer.destroy();
      if (this.domElement() && this.domElement().parentNode) {
        this.domElement().parentNode.removeChild(this.domElement());
      }
      _parentDomElement = null;
      _pluginVideoContainer = null;
    }

    return this;
  };

  this.setAudioVolume = function (value) {
    if (_pluginVideoContainer) {
      _pluginVideoContainer.volume(value);
    }
  };

  this.getAudioVolume = function () {
    // Return the actual volume of the DOM element
    if (_pluginVideoContainer) {
      return _pluginVideoContainer.volume();
    }
    return defaultAudioVolume;
  };

  // see https://wiki.mozilla.org/WebAPI/AudioChannels
  // The audioChannelType is not currently supported in the plugin.
  this.audioChannelType = function () /* type */{
    return 'unknown';
  };

  this.getAudioInputLevel = function () {
    return bluebird.resolve(_pluginVideoContainer.getAudioInputLevel());
  };

  this.whenTimeIncrements = function (callback, context) {
    // exists for compatibility with NativeVideoElement
    setTimeout(callback.bind(context));
  };

  this.destroy = function () {
    this.unbindStream();
    this.trigger('destroyed');

    return void 0;
  };
};

},{"../../common-js-helpers/OTHelpers.js":217,"../../ot/logging.js":312,"./can_be_oriented_mixin.js":280,"bluebird":2}],283:[function(require,module,exports){
(function (global){
'use strict';

// @todo enable the following disabled rules see OPENTOK-31136 for more info
/* eslint-disable no-param-reassign, global-require */

module.exports = function videoElementErrorMapFactory() {
  var deps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var Errors = deps.Errors || require('../../ot/Errors.js');
  var otError = deps.otError || require('../otError.js')();

  // See http://www.w3.org/TR/2010/WD-html5-20101019/video.html#error-codes
  var videoErrorDetails = {};

  // Checking for global.MediaError for IE compatibility, just so we don't throw
  // exceptions when the script is included
  if (global.MediaError) {
    videoErrorDetails[global.MediaError.MEDIA_ERR_ABORTED] = {
      name: Errors.MEDIA_ERR_ABORTED,
      message: 'The fetching process for the media resource was aborted by the ' + 'user agent at the user\'s request.'
    };

    videoErrorDetails[global.MediaError.MEDIA_ERR_NETWORK] = {
      name: Errors.MEDIA_ERR_NETWORK,
      message: 'A network error of some description caused the user agent to ' + 'stop fetching the media resource, after the resource was established ' + 'to be usable.'
    };

    videoErrorDetails[global.MediaError.MEDIA_ERR_DECODE] = {
      name: Errors.MEDIA_ERR_DECODE,
      message: 'An error of some description occurred while decoding the media ' + 'resource, after the resource was established to be usable.'
    };

    videoErrorDetails[global.MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED] = {
      name: Errors.MEDIA_ERR_SRC_NOT_SUPPORTED,
      message: 'The media resource indicated by the src attribute was not ' + 'suitable.'
    };
  }

  return function videoElementErrorMap(error) {
    var errorDetails = videoErrorDetails[error.code];

    if (!errorDetails) {
      return new Error('An unknown error occurred' + (error.message ? ': ' + error.message : '.'));
    }

    return otError(errorDetails.name, new Error('There was an unexpected problem with the Video Stream: ' + errorDetails.message));
  };
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../ot/Errors.js":288,"../otError.js":271}],284:[function(require,module,exports){
"use strict";

module.exports = function videoOrientationFactory() {
  return {
    ROTATED_NORMAL: 0,
    ROTATED_LEFT: 270,
    ROTATED_RIGHT: 90,
    ROTATED_UPSIDE_DOWN: 180
  };
};

},{}],285:[function(require,module,exports){
'use strict';

var audioContext = require('./audio_context.js')();

module.exports = function (stream) {
  if (stream.getAudioTracks().length > 0 && window.webkitAudioContext && !window.AudioContext) {
    // webkitAudioContext has a bug that requires createMediaStreamSource to be called
    // immediately after the stream is created.
    // https://bugs.webkit.org/show_bug.cgi?id=172261
    // eslint-disable-next-line no-param-reassign
    stream.otWebkitAudioSource = audioContext().createMediaStreamSource(stream);
  }

  return stream;
};

},{"./audio_context.js":242}],286:[function(require,module,exports){
'use strict';

// @todo enable the following disabled rules see OPENTOK-31136 for more info
/* eslint-disable no-param-reassign, global-require, one-var,  no-underscore-dangle */
/* eslint-disable no-unneeded-ternary, prefer-const, no-shadow */

var uuid = require('uuid');

module.exports = function WidgetViewFactory() {
  var deps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var logging = deps.logging || require('../ot/logging.js');
  var OTHelpers = deps.OTHelpers || require('../common-js-helpers/OTHelpers.js');
  var OTPlugin = deps.OTPlugin || require('../otplugin/otplugin.js');
  var VideoElementFacade = deps.VideoElementFacade || require('./video_element/index.js')();

  var miniWidth = 128;
  var miniHeight = 128;
  var microWidth = 64;
  var microHeight = 64;

  function fixMini(container, width, height) {
    var w = parseInt(width, 10);
    var h = parseInt(height, 10);

    if (w < microWidth || h < microHeight) {
      OTHelpers.addClass(container, 'OT_micro');
    } else {
      OTHelpers.removeClass(container, 'OT_micro');
    }
    if (w < miniWidth || h < miniHeight) {
      OTHelpers.addClass(container, 'OT_mini');
    } else {
      OTHelpers.removeClass(container, 'OT_mini');
    }
  }

  var getOrCreateContainer = function getOrCreateContainer(elementOrDomId, insertMode) {
    var container = void 0,
        domId = void 0;

    if (elementOrDomId && elementOrDomId.nodeName) {
      // It looks like we were given a DOM element. Grab the id or generate
      // one if it doesn't have one.
      container = elementOrDomId;
      if (!container.getAttribute('id') || container.getAttribute('id').length === 0) {
        container.setAttribute('id', 'OT_' + uuid());
      }

      domId = container.getAttribute('id');
    } else if (elementOrDomId) {
      // We may have got an id, try and get it's DOM element.
      container = OTHelpers('#' + elementOrDomId).get(0);
      if (container) {
        domId = elementOrDomId;
      }
    }

    if (!domId) {
      domId = 'OT_' + uuid().replace(/-/g, '_');
    }

    if (!container) {
      container = OTHelpers.createElement('div', { id: domId });
      container.style.backgroundColor = '#000000';
      document.body.appendChild(container);
    } else if (!(insertMode == null || insertMode === 'replace')) {
      var placeholder = document.createElement('div');
      placeholder.id = 'OT_' + uuid();
      if (insertMode === 'append') {
        container.appendChild(placeholder);
        container = placeholder;
      } else if (insertMode === 'before') {
        container.parentNode.insertBefore(placeholder, container);
        container = placeholder;
      } else if (insertMode === 'after') {
        container.parentNode.insertBefore(placeholder, container.nextSibling);
        container = placeholder;
      }
    } else {
      OTHelpers.emptyElement(container);
    }

    return container;
  };

  // Creates the standard container that the Subscriber and Publisher use to hold
  // their video element and other chrome.
  var WidgetView = function WidgetView(targetElement, properties) {
    var widgetView = {};
    var oldContainerStyles = {};
    var loading = true;
    var audioOnly = false;
    var fitMode = 'cover';
    var sizeObserver = void 0,
        _videoElementFacade = void 0,
        videoObserver = void 0,
        posterContainer = void 0,
        loadingContainer = void 0,
        loadingSpinner = void 0,
        width = void 0,
        height = void 0,
        container = void 0;

    if (properties.insertDefaultUI !== false) {
      container = getOrCreateContainer(targetElement, properties && properties.insertMode);
    }

    var widgetContainer = document.createElement('div');

    OTHelpers.eventing(widgetView);

    if (properties && container) {
      width = properties.width;
      height = properties.height;

      if (width) {
        if (typeof width === 'number') {
          width += 'px';
        }
      }

      if (height) {
        if (typeof height === 'number') {
          height += 'px';
        }
      }

      container.style.width = width ? width : '264px';
      container.style.height = height ? height : '198px';
      container.style.overflow = 'hidden';
      fixMini(container, width || '264px', height || '198px');

      if (properties.mirror) {
        OTHelpers.addClass(container, 'OT_mirrored');
      }

      if (properties.fitMode === 'contain') {
        fitMode = 'contain';
      } else if (properties.fitMode !== 'cover') {
        logging.warn('Invalid fit value "' + properties.fitMode + '" passed. ' + 'Only "contain" and "cover" can be used.');
      }

      if (properties.classNames) {
        OTHelpers.addClass(container, properties.classNames);
      }

      OTHelpers(container).addClass('OT_loading OT_fit-mode-' + fitMode);
    }

    OTHelpers.addClass(widgetContainer, 'OT_widget-container');
    widgetContainer.style.width = '100%'; // container.style.width;
    widgetContainer.style.height = '100%'; // container.style.height;

    if (container) {
      container.appendChild(widgetContainer);
    }

    posterContainer = document.createElement('div');
    OTHelpers.addClass(posterContainer, 'OT_video-poster');
    widgetContainer.appendChild(posterContainer);

    loadingContainer = document.createElement('div');
    OTHelpers.addClass(loadingContainer, 'OT_video-loading');
    widgetContainer.appendChild(loadingContainer);

    loadingSpinner = document.createElement('div');
    OTHelpers.addClass(loadingSpinner, 'OT_video-loading-spinner');
    loadingContainer.appendChild(loadingSpinner);

    if (container) {
      oldContainerStyles.width = container.offsetWidth;
      oldContainerStyles.height = container.offsetHeight;
    }

    if (!OTPlugin.isInstalled() && container) {
      // Observe changes to the width and height and update the aspect ratio
      sizeObserver = OTHelpers(container).observeSize(function (size) {
        var width = size.width;
        var height = size.height;

        fixMini(container, width, height);
      })[0];

      // @todo observe if the video container or the video element get removed
      // if they do we should do some cleanup
      videoObserver = OTHelpers.observeNodeOrChildNodeRemoval(container, function (removedNodes) {
        if (!_videoElementFacade) {
          return;
        }

        // This assumes a video element being removed is the main video element. This may
        // not be the case.
        var videoRemoved = removedNodes.some(function (node) {
          return node === widgetContainer || node.nodeName === 'VIDEO';
        });

        if (videoRemoved) {
          _videoElementFacade.destroy();
          _videoElementFacade = null;
        }
      });
    }

    widgetView.destroy = function () {
      if (sizeObserver) {
        sizeObserver.disconnect();
        sizeObserver = null;
      }

      if (videoObserver) {
        videoObserver.disconnect();
        videoObserver = null;
      }

      if (_videoElementFacade) {
        _videoElementFacade.destroy();
        _videoElementFacade = null;
      }

      if (container) {
        OTHelpers.removeElement(container);
        container = null;
      }
    };

    widgetView.setBackgroundImageURI = function (bgImgURI) {
      OTHelpers.css(posterContainer, 'backgroundImage', 'url(' + bgImgURI + ')');
      OTHelpers.css(posterContainer, 'backgroundSize', 'contain');
      OTHelpers.css(posterContainer, 'opacity', '1.0');
    };

    if (properties && properties.style && properties.style.backgroundImageURI) {
      widgetView.setBackgroundImageURI(properties.style.backgroundImageURI);
    }

    /**
     * @returns {VideoElementFacade}
     */
    widgetView.bindVideo = function (webRTCStream, options, completion) {
      // remove the old video element if it exists
      // @todo this might not be safe, publishers/subscribers use this as well...

      options.fitMode = fitMode;

      if (typeof options.audioVolume !== 'undefined') {
        options.audioVolume = parseFloat(options.audioVolume);
      }

      if (_videoElementFacade) {
        _videoElementFacade.destroy();
        _videoElementFacade = null;
      }

      var onError = options.error;
      delete options.error;

      _videoElementFacade = new WidgetView.VideoElementFacade(options, onError);

      if (_videoElementFacade.domElement()) {
        widgetView.trigger('videoElementCreated', _videoElementFacade.domElement());
      }
      _videoElementFacade.on('videoElementCreated', function (element) {
        widgetView.trigger('videoElementCreated', element);
      });

      // Initialize the audio volume
      if (typeof options.audioVolume !== 'undefined') {
        _videoElementFacade.setAudioVolume(options.audioVolume);
      }

      // makes the incoming audio streams take priority (will impact only FF OS for now)
      _videoElementFacade.audioChannelType('telephony');

      _videoElementFacade.appendTo(widgetContainer);

      _videoElementFacade.bindToStream(webRTCStream, function (err) {
        if (err) {
          _videoElementFacade.destroy();
          completion(err);
          return;
        }

        _videoElementFacade.on({
          videoDimensionsChanged: function videoDimensionsChanged(oldValue, newValue) {
            widgetView.trigger('videoDimensionsChanged', oldValue, newValue);
          },
          mediaStopped: function mediaStopped(track) {
            widgetView.trigger('mediaStopped', track);
          }
        });

        completion(null, _videoElementFacade);
      });

      if (properties.insertDefaultUI !== false) {
        OTHelpers.addClass(_videoElementFacade.domElement(), 'OT_video-element');
      }

      return _videoElementFacade;
    };

    OTHelpers.defineProperties(widgetView, {

      video: {
        get: function get() {
          return _videoElementFacade;
        }
      },

      showPoster: {
        get: function get() {
          return !OTHelpers.isDisplayNone(posterContainer);
        },
        set: function set(newValue) {
          if (newValue) {
            OTHelpers.show(posterContainer);
          } else {
            OTHelpers.hide(posterContainer);
          }
        }
      },

      poster: {
        get: function get() {
          return OTHelpers.css(posterContainer, 'backgroundImage');
        },
        set: function set(src) {
          OTHelpers.css(posterContainer, 'backgroundImage', 'url(' + src + ')');
        }
      },

      loading: {
        get: function get() {
          return loading;
        },
        set: function set(l) {
          loading = l;

          if (container) {
            if (loading) {
              OTHelpers.addClass(container, 'OT_loading');
            } else {
              OTHelpers.removeClass(container, 'OT_loading');
            }
          }
        }
      },

      audioOnly: {
        get: function get() {
          return audioOnly;
        },
        set: function set(a) {
          audioOnly = a;

          if (audioOnly) {
            OTHelpers.addClass(container, 'OT_audio-only');
          } else {
            OTHelpers.removeClass(container, 'OT_audio-only');
          }
        }
      },

      domId: {
        get: function get() {
          return container && container.getAttribute('id');
        }
      }

    });

    widgetView.domElement = container;

    widgetView.addError = function (errorMsg, helpMsg, classNames) {
      if (container) {
        container.innerHTML = '<p>' + errorMsg + (helpMsg ? ' <span class="ot-help-message">' + helpMsg + '</span>' : '') + '</p>';
        OTHelpers.addClass(container, classNames || 'OT_subscriber_error');
        if (container.querySelector('p').offsetHeight > container.offsetHeight) {
          container.querySelector('span').style.display = 'none';
        }
      }
    };

    return widgetView;
  };

  // This is bound here so that it can be mocked in testing. Feels like a smell that's a symptom of
  // larger problems to me, but I'm just maintaining existing behaviour right now.
  WidgetView.VideoElementFacade = VideoElementFacade;

  return WidgetView;
};

},{"../common-js-helpers/OTHelpers.js":217,"../ot/logging.js":312,"../otplugin/otplugin.js":390,"./video_element/index.js":281,"uuid":200}],287:[function(require,module,exports){
(function (global){
'use strict';

// @todo enable the following disabled rules see OPENTOK-31136 for more info
/* eslint-disable  import/newline-after-import, no-param-reassign */

var errorReporting = require('./helpers/errorReporting.js')();

// We need to do this first because of circular dependency issues with otplugin.js. @TODO: fix this.
var OT = {};

// noConflict is constructed before we override global.OT so we keep the original value
OT.noConflict = require('./helpers/no_conflict.js')();

global.OT = OT;
module.exports = OT;

(function () {
  var TB = OT;
  Object.defineProperty(global, 'TB', {
    get: function get() {
      if (TB === OT) {
        console.warn('window.TB is deprecated, and will be removed in the future. Please access via window.OT');
      }
      return TB;
    },
    set: function set(_TB) {
      return TB = _TB;
    }, // We provide a setter so noConflict works
    configurable: true
  });
})();

var windowMock = require('./helpers/createWindowMock.js')(global);

var OTHelpers = require('./common-js-helpers/OTHelpers.js');

var Analytics = require('./helpers/analytics.js');
var analytics = require('./ot/analytics.js');
var APIKEY = require('./ot/api_key.js');
var AudioLevelTransformer = require('./ot/audio_level_transformer');
var calculateCapableSimulcastStreams = require('./ot/publisher/calculateCapableSimulcastStreams.js');
var Chrome = require('./ot/chrome/chrome.js');
var ConnectivityAttemptPinger = require('./helpers/connectivity_attempt_pinger.js');
var WebaudioAudioLevelSampler = require('./helpers/audio_level_samplers/webaudio_audio_level_sampler');
var GetstatsAudioOutputLevelSampler = require('./helpers/audio_level_samplers/getstats_audio_output_level_sampler');
var cssLoader = require('./helpers/css_loader.js');
var Dialogs = require('./helpers/dialogs.js');
var EnvironmentLoader = require('./ot/environment_loader.js');
var Errors = require('./ot/Errors.js');
var ExceptionCodes = require('./ot/exception_codes.js');
var generateConstraintInfo = require('./ot/publisher/generateConstraintInfo.js');
var guidStorage = require('./helpers/guid_storage.js');
var logging = require('./ot/logging.js');
var OTErrorClass = require('./ot/ot_error_class.js');
var OTPlugin = require('./otplugin/otplugin.js');
var otProperties = require('./helpers/otProperties.js');

var _require = require('./ot/messaging/raptor/parse_ice_servers.js'),
    parseIceServers = _require.parseIceServers;

var PUBLISH_MAX_DELAY = require('./ot/publisher/max_delay.js');
var sessionObjects = require('./ot/session/objects.js');
var StreamChannel = require('./ot/stream_channel.js');
var StylableComponent = require('./ot/styling/stylable_component.js');
var systemRequirements = require('./ot/system_requirements.js');

var PeerConnection = require('./ot/peer_connection/peer_connection.js')({
  global: windowMock
});

var otError = require('./helpers/otError.js')({
  errorReporting: errorReporting
});

var audioContext = require('./helpers/audio_context.js')();
var chromeExtensionHelper = require('./ot/screensharing/chrome_extension_helper.js')({
  otError: otError
});
var createChromeMixin = require('./ot/publisher/createChromeMixin.js')();
var getNativeEnumerateDevices = require('./helpers/getNativeEnumerateDevices.js')({
  global: windowMock
});
var deviceHelpers = require('./helpers/device_helpers.js')({
  getNativeEnumerateDevices: getNativeEnumerateDevices
});
var Events = require('./ot/events.js')();
var generateSimpleStateMachine = require('./ot/generate_simple_state_machine.js')();
var getUserMedia = require('./helpers/get_user_media.js')({
  otError: otError,
  global: windowMock
});
var interpretPeerConnectionError = require('./ot/interpretPeerConnectionError.js')({
  otError: otError
});
var IntervalRunner = require('./ot/interval_runner.js')();
var Microphone = require('./ot/publisher/microphone.js')();
var videoElementErrorMap = require('./helpers/video_element/videoElementErrorMap.js')({
  otError: otError
});
var streamBinding = require('./helpers/video_element/NativeVideoElementWrapper/streamBinding.js')({
  otError: otError,
  videoElementErrorMap: videoElementErrorMap,
  global: windowMock
});
var NativeVideoElementWrapper = require('./helpers/video_element/NativeVideoElementWrapper/NativeVideoElementWrapper.js')({
  streamBinding: streamBinding,
  videoElementErrorMap: videoElementErrorMap
});
var setCertificates = require('./ot/peer_connection/set_certificates.js')({
  global: windowMock
});
var PublisherPeerConnection = require('./ot/peer_connection/publisher_peer_connection.js')({
  PeerConnection: PeerConnection,
  setCertificates: setCertificates
});
var SubscriberPeerConnection = require('./ot/peer_connection/subscriber_peer_connection.js')({
  PeerConnection: PeerConnection,
  setCertificates: setCertificates
});
var PublishingState = require('./ot/publisher/state.js')();
var reportIssue = require('./ot/report_issue.js')({
  otError: otError
});
var screenSharing = require('./ot/screensharing/screen_sharing.js')({
  chromeExtensionHelper: chromeExtensionHelper,
  otError: otError
});
var VideoElementFacade = require('./helpers/video_element/index.js')({
  NativeVideoElementWrapper: NativeVideoElementWrapper
});
var VideoOrientation = require('./helpers/video_orientation.js')();
var WidgetView = require('./helpers/widget_view.js')({
  VideoElementFacade: VideoElementFacade
});

// TODO: This is added to OTHelpers for consistency with the capabilities stuff. Capabilities' days
// are numbered though.
OTHelpers.getUserMedia = getUserMedia;

var Subscriber = require('./ot/subscriber')({
  interpretPeerConnectionError: interpretPeerConnectionError,
  otError: otError,
  SubscriberPeerConnection: SubscriberPeerConnection,
  WidgetView: WidgetView
});

var Publisher = require('./ot/publisher')({
  analytics: analytics,
  APIKEY: APIKEY,
  ConnectivityAttemptPinger: ConnectivityAttemptPinger,
  createChromeMixin: createChromeMixin,
  EnvironmentLoader: EnvironmentLoader,
  Errors: Errors,
  Events: Events,
  ExceptionCodes: ExceptionCodes,
  deviceHelpers: deviceHelpers,
  calculateCapableSimulcastStreams: calculateCapableSimulcastStreams,
  generateConstraintInfo: generateConstraintInfo,
  getUserMedia: getUserMedia,
  interpretPeerConnectionError: interpretPeerConnectionError,
  IntervalRunner: IntervalRunner,
  logging: logging,
  Microphone: Microphone,
  otError: otError,
  OTErrorClass: OTErrorClass,
  OTHelpers: OTHelpers,
  OTPlugin: OTPlugin,
  otProperties: otProperties,
  parseIceServers: parseIceServers,
  PUBLISH_MAX_DELAY: PUBLISH_MAX_DELAY,
  PublisherPeerConnection: PublisherPeerConnection,
  PublishingState: PublishingState,
  screenSharing: screenSharing,
  StreamChannel: StreamChannel,
  systemRequirements: systemRequirements,
  VideoOrientation: VideoOrientation,
  WidgetView: WidgetView
});

var initPublisher = require('./ot/publisher/init.js')({
  otError: otError,
  Publisher: Publisher
});

var Session = require('./ot/session')({
  initPublisher: initPublisher,
  otError: otError,
  Publisher: Publisher,
  Subscriber: Subscriber
});

var initSession = require('./ot/session/init.js')({
  Session: Session
});

// Allow events to be bound on OT
OTHelpers.eventing(OT);

OT.$ = OTHelpers;

// Define the APIKEY this is a global parameter which should not change
OT.APIKEY = APIKEY.value;

OT.AnalyserAudioLevelSampler = WebaudioAudioLevelSampler;

// TODO: Fix dodgy use of this by OTPlugin. It may also need to be exposed here for public use,
// hopefully not.
OT.Analytics = Analytics;

OT.Anvil = require('./ot/anvil.js');
OT.Archive = require('./ot/archive.js');
OT.ArchiveEvent = Events.ArchiveEvent;
OT.ArchiveUpdatedEvent = Events.ArchiveUpdatedEvent;
OT.AudioLevelTransformer = AudioLevelTransformer;
OT.AudioLevelUpdatedEvent = Events.AudioLevelUpdatedEvent;
OT.Capabilities = require('./ot/capabilities.js');
OT.Chrome = Chrome;
OT.Connection = require('./ot/connection.js');
OT.ConnectionCapabilities = OT.Connection.Capabilities;
OT.ConnectionEvent = Events.ConnectionEvent;
OT.ConnectivityAttemptPinger = ConnectivityAttemptPinger;
OT.DEBUG = logging.DEBUG;
OT.DestroyedEvent = Events.DestroyedEvent;

// TODO: This is here because of OTPlugin. Another circular dependency issue we need to sort out.
OT.Dialogs = Dialogs;

OT.ERROR = logging.ERROR;

OT.EnvLoadedEvent = Events.EnvLoadedEvent;

// TODO: re-expose old screenSharing api

OT.Error = OTErrorClass;

OT.Error.on(Events.Event.names.EXCEPTION, function (exceptionEvent) {
  if (exceptionEvent.target === OT.Error) {
    // Rebind target to OT if it's set to OT.Error to preserve old behaviour.
    var exceptionEventClone = OTHelpers.clone(exceptionEvent);
    exceptionEventClone.target = OT;
    OT.dispatchEvent(exceptionEventClone);
  } else {
    OT.dispatchEvent(exceptionEvent);
  }
});

OT.Event = Events.Event;
OT.ExceptionCodes = ExceptionCodes;
OT.ExceptionEvent = Events.ExceptionEvent;

OT.getDevices = require('./ot/get_devices.js');
OT.GetStatsAudioLevelSampler = GetstatsAudioOutputLevelSampler;
OT.HAS_REQUIREMENTS = 1;

OT.INFO = logging.INFO;
OT.IntervalRunner = IntervalRunner;
OT.IssueReportedEvent = Events.IssueReportedEvent;
OT.LOG = logging.LOG;
OT.MediaStoppedEvent = Events.MediaStoppedEvent;
OT.Microphone = Microphone;
OT.Modal = OTHelpers.Modal;
OT.NONE = logging.NONE;
OT.NOT_HAS_REQUIREMENTS = 0;
OT.PeerConnection = PeerConnection;

// TODO: this is here for repel, but it doesn't belong here
OT.PeerConnection.QOS = require('./ot/peer_connection/qos.js');

OT.Publisher = Publisher;
OT.PublisherPeerConnection = PublisherPeerConnection;
OT.PublishingState = PublishingState;
OT.Raptor = require('./ot/messaging/raptor/legacy_structure.js');
OT.Rumor = require('./ot/messaging/rumor/legacy_structure.js');
OT.Session = Session;
OT.SessionConnectEvent = Events.SessionConnectEvent;
OT.SessionDisconnectEvent = Events.SessionDisconnectEvent;
OT.SessionDispatcher = require('./ot/messaging/raptor/session_dispatcher.js');
OT.SessionInfo = require('./ot/session/info.js');
OT.Signal = require('./ot/messaging/raptor/signal.js');
OT.SignalEvent = Events.SignalEvent;
OT.Stream = require('./ot/stream.js');
OT.StreamChannel = StreamChannel;
OT.StreamEvent = Events.StreamEvent;
OT.StreamPropertyChangedEvent = Events.StreamPropertyChangedEvent;
OT.StreamUpdatedEvent = Events.StreamUpdatedEvent;
OT.StylableComponent = StylableComponent;
OT.Subscriber = Subscriber;
OT.SubscriberPeerConnection = SubscriberPeerConnection;
OT.SubscribingState = require('./ot/subscriber/state.js');
OT.VideoDimensionsChangedEvent = Events.VideoDimensionsChangedEvent;
OT.VideoDisableWarningEvent = Events.VideoDisableWarningEvent;
OT.VideoElement = VideoElementFacade;
OT.VideoEnabledChangedEvent = Events.VideoEnabledChangedEvent;
OT.VideoOrientation = VideoOrientation;
OT.WARN = logging.WARN;
OT.WidgetView = WidgetView;
OT._ = {
  getClientGuid: guidStorage.get
};
// OT.addEventListener comes from OTHelpers.eventing(OT)
OT.analytics = analytics;
OT.audioContext = audioContext;
OT.checkScreenSharingCapability = screenSharing.checkCapability;
OT.checkSystemRequirements = systemRequirements.check;
OT.components = {};
OT.debug = logging.debug;
// OT.dispatchEvent comes from OTHelpers.eventing(OT)
// OT.emit comes from OTHelpers.eventing(OT)
OT.error = logging.error;
OT.generateSimpleStateMachine = generateSimpleStateMachine;
OT.getDevices = require('./ot/get_devices.js');
OT.getErrorTitleByCode = OTErrorClass.getTitleByCode;
OT.getLogs = logging.getLogs;

// This is misspelled in production too, being compatible here.
OT.getStatsAdpater = require('./ot/peer_connection/get_stats_adapter.js');

OT.getStatsHelpers = require('./ot/peer_connection/get_stats_helpers.js');
OT.handleJsException = OTErrorClass.handleJsException;
OT.info = logging.info;
OT.initPublisher = initPublisher;

OT.initSession = function (apiKey, sessionId, opt) {
  if (sessionId == null) {
    sessionId = apiKey;
    apiKey = null;
  }

  // Ugly hack, make sure OT.APIKEY is set
  // TODO: Yep, sure is ugly. It appears to be needed by raptor. We should fix this situation.
  // UPDATE: This hack is the only reason why we need to wrap the actual initSession.
  if (APIKEY.value.length === 0 && apiKey) {
    APIKEY.value = apiKey;
    OT.APIKEY = apiKey;
  }

  return initSession(apiKey, sessionId, opt);
};

OT.isUnloaded = EnvironmentLoader.isUnloaded;
OT.log = logging.log;
// OT.off comes from OTHelpers.eventing(OT)
// OT.on comes from OTHelpers.eventing(OT)
OT.onLoad = EnvironmentLoader.onLoad;
OT.onUnload = EnvironmentLoader.onUnload;
// OT.once comes from OTHelpers.eventing(OT)

// Exposed here for partner usage.
OT.overrideGuidStorage = guidStorage.override;

OT.pickScreenSharingHelper = screenSharing.pickHelper;
OT.properties = otProperties;
OT.publishers = sessionObjects.publishers;
OT.registerScreenSharingExtension = screenSharing.registerExtension;
OT.registerScreenSharingExtensionHelper = screenSharing.registerExtensionHelper;
// OT.removeEventListener comes from OTHelpers.eventing(OT)
OT.reportIssue = reportIssue;
OT.sessions = sessionObjects.sessions;
OT.setLogLevel = logging.setLogLevel;
OT.shouldLog = logging.shouldLog;
OT.subscribers = sessionObjects.subscribers;
// OT.trigger comes from OTHelpers.eventing(OT)
OT.upgradeSystemRequirements = systemRequirements.upgrade;
OT.warn = logging.warn;

// Tidy up everything on unload
EnvironmentLoader.onUnload(function () {
  sessionObjects.publishers.destroy();
  sessionObjects.subscribers.destroy();
  sessionObjects.sessions.destroy('unloaded');
});

if (otProperties.cssURL) {
  cssLoader(otProperties.cssURL);
}

/**
 * This method is deprecated. Use <a href="#on">on()</a> or <a href="#once">once()</a> instead.
 *
 * <p>
 * Registers a method as an event listener for a specific event.
 * </p>
 *
 * <p>
 * The OT object dispatches one type of event &#151; an <code>exception</code> event. The
 * following code adds an event listener for the <code>exception</code> event:
 * </p>
 *
 * <pre>
 * OT.addEventListener("exception", exceptionHandler);
 *
 * function exceptionHandler(event) {
 *    alert("exception event. \n  code == " + event.code + "\n  message == " + event.message);
 * }
 * </pre>
 *
 * <p>
 *   If a handler is not registered for an event, the event is ignored locally. If the event
 *   listener function does not exist, the event is ignored locally.
 * </p>
 * <p>
 *   Throws an exception if the <code>listener</code> name is invalid.
 * </p>
 *
 * @param {String} type The string identifying the type of event.
 *
 * @param {Function} listener The function to be invoked when the OT object dispatches the event.
 * @see <a href="#on">on()</a>
 * @see <a href="#once">once()</a>
 * @memberof OT
 * @method addEventListener
 *
 */

/**
 * This method is deprecated. Use <a href="#off">off()</a> instead.
 *
 * <p>
 * Removes an event listener for a specific event.
 * </p>
 *
 * <p>
 *   Throws an exception if the <code>listener</code> name is invalid.
 * </p>
 *
 * @param {String} type The string identifying the type of event.
 *
 * @param {Function} listener The event listener function to remove.
 *
 * @see <a href="#off">off()</a>
 * @memberof OT
 * @method removeEventListener
 */

/**
* Adds an event handler function for one or more events.
*
* <p>
* The OT object dispatches one type of event &#151; an <code>exception</code> event. The following
* code adds an event
* listener for the <code>exception</code> event:
* </p>
*
* <pre>
* OT.on("exception", function (event) {
*   // This is the event handler.
* });
* </pre>
*
* <p>You can also pass in a third <code>context</code> parameter (which is optional) to define the
* value of
* <code>this</code> in the handler method:</p>
*
* <pre>
* OT.on("exception",
*   function (event) {
*     // This is the event handler.
*   }),
*   session
* );
* </pre>
*
* <p>
* If you do not add a handler for an event, the event is ignored locally.
* </p>
*
* @param {String} type The string identifying the type of event.
* @param {Function} handler The handler function to process the event. This function takes the event
* object as a parameter.
* @param {Object} context (Optional) Defines the value of <code>this</code> in the event handler
* function.
*
* @memberof OT
* @method on
* @see <a href="#off">off()</a>
* @see <a href="#once">once()</a>
* @see <a href="#events">Events</a>
*/

/**
* Adds an event handler function for an event. Once the handler is called, the specified handler
* method is
* removed as a handler for this event. (When you use the <code>OT.on()</code> method to add an event
* handler, the handler
* is <i>not</i> removed when it is called.) The <code>OT.once()</code> method is the equivilent of
* calling the <code>OT.on()</code>
* method and calling <code>OT.off()</code> the first time the handler is invoked.
*
* <p>
* The following code adds a one-time event handler for the <code>exception</code> event:
* </p>
*
* <pre>
* OT.once("exception", function (event) {
*   console.log(event);
* }
* </pre>
*
* <p>You can also pass in a third <code>context</code> parameter (which is optional) to define the
* value of
* <code>this</code> in the handler method:</p>
*
* <pre>
* OT.once("exception",
*   function (event) {
*     // This is the event handler.
*   },
*   session
* );
* </pre>
*
* <p>
* The method also supports an alternate syntax, in which the first parameter is an object that is a
* hash map of
* event names and handler functions and the second parameter (optional) is the context for this in
* each handler:
* </p>
* <pre>
* OT.once(
*   {exeption: function (event) {
*     // This is the event handler.
*     }
*   },
*   session
* );
* </pre>
*
* @param {String} type The string identifying the type of event. You can specify multiple event
* names in this string,
* separating them with a space. The event handler will process the first occurence of the events.
* After the first event,
* the handler is removed (for all specified events).
* @param {Function} handler The handler function to process the event. This function takes the event
* object as a parameter.
* @param {Object} context (Optional) Defines the value of <code>this</code> in the event handler
* function.
*
* @memberof OT
* @method once
* @see <a href="#on">on()</a>
* @see <a href="#once">once()</a>
* @see <a href="#events">Events</a>
*/

/**
 * Removes an event handler.
 *
 * <p>Pass in an event name and a handler method, the handler is removed for that event:</p>
 *
 * <pre>OT.off("exceptionEvent", exceptionEventHandler);</pre>
 *
 * <p>If you pass in an event name and <i>no</i> handler method, all handlers are removed for that
 * events:</p>
 *
 * <pre>OT.off("exceptionEvent");</pre>
 *
 * <p>
 * The method also supports an alternate syntax, in which the first parameter is an object that is a
 * hash map of
 * event names and handler functions and the second parameter (optional) is the context for matching
 * handlers:
 * </p>
 * <pre>
 * OT.off(
 *   {
 *     exceptionEvent: exceptionEventHandler
 *   },
 *   this
 * );
 * </pre>
 *
 * @param {String} type (Optional) The string identifying the type of event. You can use a space to
 * specify multiple events, as in "eventName1 eventName2 eventName3". If you pass in no
 * <code>type</code> value (or other arguments), all event handlers are removed for the object.
 * @param {Function} handler (Optional) The event handler function to remove. If you pass in no
 * <code>handler</code>, all event handlers are removed for the specified event <code>type</code>.
 * @param {Object} context (Optional) If you specify a <code>context</code>, the event handler is
 * removed for all specified events and handlers that use the specified context.
 *
 * @memberof OT
 * @method off
 * @see <a href="#on">on()</a>
 * @see <a href="#once">once()</a>
 * @see <a href="#events">Events</a>
 */

/**
 * Dispatched by the OT class when the app encounters an exception.
 * Note that you set up an event handler for the <code>exception</code> event by calling the
 * <code>OT.on()</code> method.
 *
 * @name exception
 * @event
 * @borrows ExceptionEvent#message as this.message
 * @memberof OT
 * @see ExceptionEvent
 */

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./common-js-helpers/OTHelpers.js":217,"./helpers/analytics.js":241,"./helpers/audio_context.js":242,"./helpers/audio_level_samplers/getstats_audio_output_level_sampler":243,"./helpers/audio_level_samplers/webaudio_audio_level_sampler":244,"./helpers/connectivity_attempt_pinger.js":245,"./helpers/createWindowMock.js":248,"./helpers/css_loader.js":250,"./helpers/device_helpers.js":251,"./helpers/dialogs.js":252,"./helpers/errorReporting.js":254,"./helpers/getNativeEnumerateDevices.js":256,"./helpers/get_user_media.js":257,"./helpers/guid_storage.js":258,"./helpers/no_conflict.js":270,"./helpers/otError.js":271,"./helpers/otProperties.js":272,"./helpers/video_element/NativeVideoElementWrapper/NativeVideoElementWrapper.js":276,"./helpers/video_element/NativeVideoElementWrapper/streamBinding.js":279,"./helpers/video_element/index.js":281,"./helpers/video_element/videoElementErrorMap.js":283,"./helpers/video_orientation.js":284,"./helpers/widget_view.js":286,"./ot/Errors.js":288,"./ot/analytics.js":289,"./ot/anvil.js":290,"./ot/api_key.js":291,"./ot/archive.js":292,"./ot/audio_level_transformer":293,"./ot/capabilities.js":294,"./ot/chrome/chrome.js":299,"./ot/connection.js":303,"./ot/environment_loader.js":305,"./ot/events.js":306,"./ot/exception_codes.js":307,"./ot/generate_simple_state_machine.js":308,"./ot/get_devices.js":309,"./ot/interpretPeerConnectionError.js":310,"./ot/interval_runner.js":311,"./ot/logging.js":312,"./ot/messaging/raptor/legacy_structure.js":316,"./ot/messaging/raptor/parse_ice_servers.js":318,"./ot/messaging/raptor/session_dispatcher.js":322,"./ot/messaging/raptor/signal.js":323,"./ot/messaging/rumor/legacy_structure.js":327,"./ot/ot_error_class.js":334,"./ot/peer_connection/get_stats_adapter.js":337,"./ot/peer_connection/get_stats_helpers.js":338,"./ot/peer_connection/peer_connection.js":341,"./ot/peer_connection/publisher_peer_connection.js":344,"./ot/peer_connection/qos.js":345,"./ot/peer_connection/set_certificates.js":348,"./ot/peer_connection/subscriber_peer_connection.js":350,"./ot/publisher":355,"./ot/publisher/calculateCapableSimulcastStreams.js":352,"./ot/publisher/createChromeMixin.js":353,"./ot/publisher/generateConstraintInfo.js":354,"./ot/publisher/init.js":356,"./ot/publisher/max_delay.js":357,"./ot/publisher/microphone.js":358,"./ot/publisher/state.js":360,"./ot/report_issue.js":361,"./ot/screensharing/chrome_extension_helper.js":362,"./ot/screensharing/screen_sharing.js":366,"./ot/session":367,"./ot/session/info.js":368,"./ot/session/init.js":369,"./ot/session/objects.js":370,"./ot/stream.js":372,"./ot/stream_channel.js":373,"./ot/styling/stylable_component.js":375,"./ot/subscriber":378,"./ot/subscriber/state.js":379,"./ot/system_requirements.js":380,"./otplugin/otplugin.js":390}],288:[function(require,module,exports){
'use strict';

// Note: Some of these descriptions here are more specific than the name would suggest, because we
// only use them in one place. However, this shouldn't prevent us from using the error elsewhere if
// the name fits, and we should update the description to be more general when this happens.

module.exports = {
  // The API key does not match the token or session.
  AUTHENTICATION_ERROR: 'OT_AUTHENTICATION_ERROR',

  // JSON response was badly formed.
  BADLY_FORMED_RESPONSE: 'OT_BADLY_FORMED_RESPONSE',

  // Unable to publish because your browser failed to get access to your microphone. You may need to
  // fully quit and restart your browser to get it to work.
  // See https://bugs.chromium.org/p/webrtc/issues/detail?id=4799 for more details.
  CHROME_MICROPHONE_ACQUISITION_ERROR: 'OT_CHROME_MICROPHONE_ACQUISITION_ERROR',

  // Failed to connect to session.
  CONNECT_FAILED: 'OT_CONNECT_FAILED',

  // The session has exceded the maximum number of simultaneous connections.
  CONNECTION_LIMIT_EXCEEDED: 'OT_CONNECTION_LIMIT_EXCEEDED',

  // The constraints for getting user media could not be satisfied.
  CONSTRAINTS_NOT_SATISFIED: 'OT_CONSTRAINTS_NOT_SATISFIED',

  // Failed to create peer connection.
  CREATE_PEER_CONNECTION_FAILED: 'OT_CREATE_PEER_CONNECTION_FAILED',

  // Action failed due to session disconnection.
  DISCONNECTED: 'OT_DISCONNECTED',

  // Received an unexpected empty response from the server.
  EMPTY_RESPONSE_BODY: 'OT_EMPTY_RESPONSE_BODY',

  // The hardware to fulfil the user media request appears to exist but could not be acquired. It
  // might be in use by another application.
  HARDWARE_UNAVAILABLE: 'OT_HARDWARE_UNAVAILABLE',

  // Something went wrong while establishing WebRTC connectivity.
  ICE_WORKFLOW_FAILED: 'OT_ICE_WORKFLOW_FAILED',

  // Received an invalid HTTP status. This may be considered invalid for the endpoint only and not
  // HTTP in general.
  INVALID_HTTP_STATUS: 'OT_INVALID_HTTP_STATUS',

  // One or more parameters was not valid or not provided.
  INVALID_PARAMETER: 'OT_INVALID_PARAMETER',

  // The session id was invalid.
  INVALID_SESSION_ID: 'OT_INVALID_SESSION_ID',

  // The fetching of the stream for the video element has been aborted.
  MEDIA_ERR_ABORTED: 'OT_MEDIA_ERR_ABORTED',

  // A decoding error occurred while trying to play the stream in the video element.
  MEDIA_ERR_DECODE: 'OT_MEDIA_ERR_DECODE',

  // A network error caused the stream to stop being fetched.
  MEDIA_ERR_NETWORK: 'OT_MEDIA_ERR_NETWORK',

  // The stream has been detected to be not suitable for playback.
  MEDIA_ERR_SRC_NOT_SUPPORTED: 'OT_MEDIA_ERR_SRC_NOT_SUPPORTED',

  // No devices were found to provide the media stream.
  NO_DEVICES_FOUND: 'OT_NO_DEVICES_FOUND',

  // Video and audio was disabled. You need to enable at least one.
  NO_VALID_CONSTRAINTS: 'OT_NO_VALID_CONSTRAINTS',

  // Couldn't perform action due to not being connected.
  NOT_CONNECTED: 'OT_NOT_CONNECTED',

  // A resource was not found.
  NOT_FOUND: 'OT_NOT_FOUND',

  // Something in the user media request is not supported.
  NOT_SUPPORTED: 'OT_NOT_SUPPORTED',

  // An action was not permitted.
  PERMISSION_DENIED: 'OT_PERMISSION_DENIED',

  // The signal could not be sent due to the rate limit.
  RATE_LIMIT_EXCEEDED: 'OT_RATE_LIMIT_EXCEEDED',

  // Error calling OT.reportIssue(). Check the client\'s network connection.
  REPORT_ISSUE_FAILED: 'OT_REPORT_ISSUE_FAILED',

  // Screen-sharing support in this browser requires an extension, but the extension is not
  // installed.
  SCREEN_SHARING_EXTENSION_NOT_INSTALLED: 'OT_SCREEN_SHARING_EXTENSION_NOT_INSTALLED',

  // Screen-sharing support in this browser requires an extension, but one has not been registered.
  SCREEN_SHARING_EXTENSION_NOT_REGISTERED: 'OT_SCREEN_SHARING_EXTENSION_NOT_REGISTERED',

  // Screen sharing is not supported in the browser.
  SCREEN_SHARING_NOT_SUPPORTED: 'OT_SCREEN_SHARING_NOT_SUPPORTED',

  // Generic/ Unknown screen share error
  UNABLE_TO_CAPTURE_SCREEN: 'OT_UNABLE_TO_CAPTURE_SCREEN',

  // The WebRTC connection failed during setDescription.
  SET_REMOTE_DESCRIPTION_FAILED: 'OT_SET_REMOTE_DESCRIPTION_FAILED',

  // Rumor.Socket cannot connect when it is already connecting or connected.
  SOCKET_ALREADY_CONNECTED_CONNECTING: 'OT_SOCKET_ALREADY_CONNECTED_CONNECTING',

  // A connection was closed abnormally (that is, with no close frame being sent) when a status code
  // is expected.
  SOCKET_CLOSE_ABNORMAL: 'OT_SOCKET_CLOSE_ABNORMAL',

  // Exception was thrown during Rumor connection, possibly because of a blocked port.
  SOCKET_CLOSE_CONNECT_EXCEPTION: 'OT_SOCKET_CLOSE_CONNECT_EXCEPTION',

  // Connectivity loss was detected as it was too long since the socket received the last PONG
  // message.
  SOCKET_CLOSE_CONNECTIVITY_LOSS: 'OT_SOCKET_CLOSE_CONNECTIVITY_LOSS',

  // Falling back on this error for socket close because a more suitable one was not found.
  SOCKET_CLOSE_FALLBACK_CODE: 'OT_SOCKET_CLOSE_FALLBACK_CODE',

  // An endpoint received data within a message that was not consistent with the type of the message
  // (e.g., non-UTF-8 [RFC3629] data within a text message)
  SOCKET_CLOSE_INCONSISTENT_DATA: 'OT_SOCKET_CLOSE_INCONSISTENT_DATA',

  // No status code was provided even though one was expected.
  SOCKET_CLOSE_NO_STATUS: 'OT_SOCKET_CLOSE_NO_STATUS',

  // An endpoint received a message that violates its policy.  This is a generic status code that
  // can be returned when there is no other more suitable status code (e.g., 1003 or 1009) or if
  // there is a need to hide specific details about the policy.
  SOCKET_CLOSE_POLICY_VIOLATION: 'OT_SOCKET_CLOSE_POLICY_VIOLATION',

  // A protocol error occurred.
  SOCKET_CLOSE_PROTOCOL_ERROR: 'OT_SOCKET_CLOSE_PROTOCOL_ERROR',

  // Timed out while waiting for the Rumor socket to connect.
  SOCKET_CLOSE_TIMEOUT: 'OT_SOCKET_CLOSE_TIMEOUT',

  // An endpoint received a message that is too big for it to process
  SOCKET_CLOSE_TOO_LARGE: 'OT_SOCKET_CLOSE_TOO_LARGE',

  // An endpoint encountered an unexpected condition that prevented it from fulfilling the request.
  SOCKET_CLOSE_UNEXPECTED_CONDITION: 'OT_SOCKET_CLOSE_UNEXPECTED_CONDITION',

  // An endpoint has indicated that reconnections are not available.
  SOCKET_CLOSE_UNSUPPORTED: 'OT_SOCKET_CLOSE_UNSUPPORTED',

  // Failed to create the stream in the server model.
  STREAM_CREATE_FAILED: 'OT_STREAM_CREATE_FAILED',

  // The stream was destroyed before it could be subscribed to.
  STREAM_DESTROYED: 'OT_STREAM_DESTROYED',

  // The session has exceded the maximum number of simultaneous streams.
  STREAM_LIMIT_EXCEEDED: 'OT_STREAM_LIMIT_EXCEEDED',

  // Couldn't subscribe to the stream because it was not found.
  STREAM_NOT_FOUND: 'OT_STREAM_NOT_FOUND',

  // Couldn't connect due to a terms of service violation.
  TERMS_OF_SERVICE_FAILURE: 'OT_TERMS_OF_SERVICE_FAILURE',

  // A timer expired while waiting for an action to occur.
  TIMEOUT: 'OT_TIMEOUT',

  // The error code received was unexpected.
  UNEXPECTED_ERROR_CODE: 'OT_UNEXPECTED_ERROR_CODE',

  // Received an unexpected HTTP status.
  UNEXPECTED_HTTP_STATUS: 'OT_UNEXPECTED_HTTP_STATUS',

  // An unexpected server response was received which could not be handled.
  UNEXPECTED_SERVER_RESPONSE: 'OT_UNEXPECTED_SERVER_RESPONSE',

  // An unknown anvil error occurred.
  UNKNOWN_HTTP_ERROR: 'OT_UNKNOWN_HTTP_ERROR',

  // Access to user media was denied.
  USER_MEDIA_ACCESS_DENIED: 'OT_USER_MEDIA_ACCESS_DENIED',

  // There was a cross domain error or the server responded with invalid JSON.
  XDOMAIN_OR_PARSING_ERROR: 'OT_XDOMAIN_OR_PARSING_ERROR'
};

},{}],289:[function(require,module,exports){
'use strict';

var Analytics = require('../helpers/analytics.js');
var otProperties = require('../helpers/otProperties.js');

module.exports = new Analytics(otProperties.loggingURL);

},{"../helpers/analytics.js":241,"../helpers/otProperties.js":272}],290:[function(require,module,exports){
'use strict';

var Bluebird = require('bluebird');
var ExceptionCodes = require('./exception_codes.js');
var OTHelpers = require('../common-js-helpers/OTHelpers.js');
var otProperties = require('../helpers/otProperties.js');

var Anvil = {};
module.exports = Anvil;

// These are only valid for Session resources
// See: https://github.com/opentok/anvil/blob/develop/src/main/java/com/tokbox/anvil/api/SessionResource.java
var httpToClientCode = {
  400: ExceptionCodes.INVALID_SESSION_ID,
  403: ExceptionCodes.AUTHENTICATION_ERROR,
  404: ExceptionCodes.INVALID_SESSION_ID,
  409: ExceptionCodes.TERMS_OF_SERVICE_FAILURE,
  500: ExceptionCodes.UNEXPECTED_SERVER_RESPONSE
};

function getRequestParams(resourcePath, token, connectionId) {
  var url = otProperties.apiURL + '/' + resourcePath;
  var clientVersion = 'js-' + otProperties.version.replace(/^v/, '');

  var options = {
    headers: {
      'X-OPENTOK-AUTH': token,
      'X-TB-VERSION': 1,
      'X-TB-CLIENT-VERSION': clientVersion,
      'X-TB-CONNECTIONID': connectionId
    }
  };

  return { url: url, options: options };
}

/*
 * @param {number} code
 * @param {string} message
 * @return {Error}
 */
function createError(code, message) {
  var error = new Error(message);
  error.code = code;
  return error;
}

/*
 * @param {Object} httpError
 * @property {Object} httpError.target
 * @property {number} httpError.target.status
 *
 * @return {Object|null}
 * @property {number} code
 * @property {string} message
 */
function getErrorsFromHTTP(httpError) {
  var code = void 0;
  var detail = void 0;
  var httpStatusText = void 0;

  if (!httpError) {
    return null;
  }

  var httpStatus = httpError.target && httpError.target.status;

  if (httpStatus !== undefined) {
    code = ExceptionCodes.ANVIL_INVALID_HTTP_STATUS;
    detail = httpStatus;

    httpStatusText = httpError.target && httpError.target.statusText;
    if (httpStatusText !== undefined) {
      detail += ' ' + httpStatusText;
    }
  } else if (httpError.message !== undefined) {
    // Error from browserAjax.xdomainRequest() (which no longer exists) or while parsing JSON
    code = ExceptionCodes.ANVIL_XDOMAIN_OR_PARSING_ERROR;
    detail = httpError.message;
  } else {
    code = ExceptionCodes.ANVIL_UNKNOWN_HTTP_ERROR;
    detail = 'No status';
  }

  return createError(code, 'Unexpected server response (' + detail + '). Try this operation again later.');
}

function handleBadlyFormedResponse(responseJson) {
  var code = void 0;
  var message = void 0;

  var responseText = responseJson && !OTHelpers.isEmpty(responseJson) ? JSON.stringify(responseJson) : '';

  if (responseText.length === 0) {
    // This is a weird edge case that usually means that there was connectivity
    // loss after Anvil sent the response but before the client had fully received it
    code = ExceptionCodes.ANVIL_EMPTY_RESPONSE_BODY;
    message = 'Response body was empty, probably due to connectivity loss';
  } else {
    code = ExceptionCodes.ANVIL_BADLY_FORMED_RESPONSE;
    message = 'Unknown error: JSON response was badly formed';
  }

  return createError(code, message);
}

/*
 * @param {Array<Object>} responseJson
 *
 * @return {Object}
 * @property {number} code
 * @property {string} message
 */
function getErrorsFromResponse(responseJson) {
  var code = void 0;
  var message = void 0;

  if (!Array.isArray(responseJson)) {
    return handleBadlyFormedResponse(responseJson);
  }

  var errorNode = OTHelpers.find(responseJson, function (node) {
    return node.error != null;
  });

  if (!errorNode) {
    return null;
  }

  code = httpToClientCode[errorNode.error.code];
  message = errorNode.error.errorMessage && errorNode.error.errorMessage.message;

  if (!code) {
    if (!message) {
      message = 'Unknown error: ' + code;
    }
    code = ExceptionCodes.ANVIL_UNEXPECTED_ERROR_CODE;
  }

  if (!message) {
    message = 'No error message';
  }

  return createError(code, message);
}

Anvil.get = function getFromAnvil(resourcePath, token, connectionId) {
  var params = getRequestParams(resourcePath, token, connectionId);

  return new Bluebird.Promise(function (resolve, reject) {
    OTHelpers.getJSON(params.url, params.options, function (httpError, responseJson) {
      var err = getErrorsFromHTTP(httpError) || getErrorsFromResponse(responseJson);

      if (err) {
        reject(err);
        return;
      }

      resolve(responseJson[0]);
    });
  });
};

},{"../common-js-helpers/OTHelpers.js":217,"../helpers/otProperties.js":272,"./exception_codes.js":307,"bluebird":2}],291:[function(require,module,exports){
'use strict';

var OTHelpers = require('../common-js-helpers/OTHelpers.js');

if (OTHelpers.env.name === 'Node') {
  module.exports = { value: '' };
} else {
  // Script embed
  var scriptSrc = Array.prototype.slice.call(document.getElementsByTagName('script')).pop().getAttribute('src');

  var _ref = scriptSrc.match(/[?&]apikey=([^&]+)/i) || [],
      apiKey = _ref[1];

  // TODO: The indirection here is due to the need to set APIKEY in testing. We should find a better
  // solution.


  module.exports = { value: apiKey || '' };
}

},{"../common-js-helpers/OTHelpers.js":217}],292:[function(require,module,exports){
'use strict';

var Events = require('./events.js')();
var OTHelpers = require('../common-js-helpers/OTHelpers.js');

module.exports = function Archive(id, name, status) {
  var _this = this;

  this.id = id;
  this.name = name;
  this.status = status;
  this._ = {};

  OTHelpers.eventing(this);

  // Mass update, called by Raptor.Dispatcher
  this._.update = function (attributes) {
    Object.keys(attributes).forEach(function (key) {
      var oldValue = _this[key];
      _this[key] = attributes[key];

      var event = new Events.ArchiveUpdatedEvent(_this, key, oldValue, _this[key]);
      _this.dispatchEvent(event);
    });
  };

  this.destroy = function () {};
};

},{"../common-js-helpers/OTHelpers.js":217,"./events.js":306}],293:[function(require,module,exports){
"use strict";

/*
 * Transforms a raw audio level to produce a "smoother" animation when using displaying the
 * audio level. This transformer is state-full because it needs to keep the previous average
 * value of the signal for filtering.
 *
 * It applies a low pass filter to get rid of level jumps and apply a log scale.
 *
 * @constructor
 */
module.exports = function AudioLevelTransformer() {
  var averageAudioLevel = null;

  /*
   *
   * @param {number} audioLevel a level in the [0,1] range
   * @returns {number} a level in the [0,1] range transformed
   */
  this.transform = function (audioLevel) {
    if (averageAudioLevel === null || audioLevel >= averageAudioLevel) {
      averageAudioLevel = audioLevel;
    } else {
      // a simple low pass filter with a smoothing of 70
      averageAudioLevel = audioLevel * 0.3 + averageAudioLevel * 0.7;
    }

    // 1.5 scaling to map -30-0 dBm range to [0,1]
    var logScaled = Math.log(averageAudioLevel) / Math.LN10 / 1.5 + 1;

    return Math.min(Math.max(logScaled, 0), 1);
  };
};

},{}],294:[function(require,module,exports){
'use strict';

var hasOpenTokSupport = require('../helpers/hasOpenTokSupport.js').once;

/**
 * A class defining properties of the <code>capabilities</code> property of a
 * Session object. See <a href="Session.html#properties">Session.capabilities</a>.
 * <p>
 * All Capabilities properties are undefined until you have connected to a session
 * and the Session object has dispatched the <code>sessionConnected</code> event.
 * <p>
 * For more information on token roles, see the
 * <a href="https://tokbox.com/developer/guides/create-token/">Token Creation Overview</a>.
 *
 * @class Capabilities
 *
 * @property {Number} forceDisconnect Specifies whether you can call
 * the <code>Session.forceDisconnect()</code> method (1) or not (0). To call the
 * <code>Session.forceDisconnect()</code> method,
 * the user must have a token that is assigned the role of moderator.
 * @property {Number} forceUnpublish Specifies whether you can call
 * the <code>Session.forceUnpublish()</code> method (1) or not (0). To call the
 * <code>Session.forceUnpublish()</code> method, the user must have a token that
 * is assigned the role of moderator.
 * @property {Number} publish Specifies whether you can publish to the session (1) or not (0).
 * The ability to publish is based on a few factors. To publish, the user must have a token that
 * is assigned a role that supports publishing. There must be a connected camera and microphone.
 * @property {Number} subscribe Specifies whether you can subscribe to streams
 * in the session (1) or not (0). Currently, this capability is available for all users on all
 * platforms.
 */
module.exports = function Capabilities(permissions) {
  var _this = this;

  this.publish = permissions.indexOf('publish') !== -1 ? 1 : 0;
  this.subscribe = permissions.indexOf('subscribe') !== -1 ? 1 : 0;
  this.forceUnpublish = permissions.indexOf('forceunpublish') !== -1 ? 1 : 0;
  this.forceDisconnect = permissions.indexOf('forcedisconnect') !== -1 ? 1 : 0;
  this.supportsWebRTC = hasOpenTokSupport() ? 1 : 0;

  this.permittedTo = function (action) {
    return Object.prototype.hasOwnProperty.call(_this, action) && _this[action] === 1;
  };
};

},{"../helpers/hasOpenTokSupport.js":264}],295:[function(require,module,exports){
'use strict';

// @todo enable the following disabled rules see OPENTOK-31136 for more info
/* eslint-disable one-var, no-underscore-dangle, no-mixed-operators,  no-param-reassign */

var Widget = require('./behaviour/widget.js');
var OTHelpers = require('../../common-js-helpers/OTHelpers.js');

// Archving Chrome Widget
//
// mode (String)
// Whether to display the archving widget. Possible values are: "on" (the status is displayed
// when archiving and briefly when archving ends) and "off" (the status is not displayed)

// Whether to display the archving widget. Possible values are: "auto" (the name is displayed
// when the status is first displayed and when the user mouses over the display),
// "off" (the name is not displayed), and "on" (the name is displayed).
//
// displays a name
// can be shown/hidden
// can be destroyed
module.exports = function Archiving(options) {
  var _lightBox = void 0,
      _light = void 0,
      _text = void 0,
      _textNode = void 0,
      renderStageDelayedAction = void 0;
  var self = this;
  var _archiving = options.archiving;
  var _archivingStarted = options.archivingStarted || 'Archiving on';
  var _archivingEnded = options.archivingEnded || 'Archiving off';
  var _initialState = true;

  var renderText = function renderText(text) {
    _textNode.nodeValue = text;
    _lightBox.setAttribute('title', text);
  };

  var renderStage = function renderStage() {
    if (renderStageDelayedAction) {
      clearTimeout(renderStageDelayedAction);
      renderStageDelayedAction = null;
    }

    if (_archiving) {
      OTHelpers.addClass(_light, 'OT_active');
    } else {
      OTHelpers.removeClass(_light, 'OT_active');
    }

    OTHelpers.removeClass(self.domElement, 'OT_archiving-' + (!_archiving ? 'on' : 'off'));
    OTHelpers.addClass(self.domElement, 'OT_archiving-' + (_archiving ? 'on' : 'off'));
    if (options.show && _archiving) {
      renderText(_archivingStarted);
      OTHelpers.addClass(_text, 'OT_mode-on');
      OTHelpers.removeClass(_text, 'OT_mode-auto');
      self.setDisplayMode('on');
      renderStageDelayedAction = setTimeout(function () {
        OTHelpers.addClass(_text, 'OT_mode-auto');
        OTHelpers.removeClass(_text, 'OT_mode-on');
      }, 5000);
    } else if (options.show && !_initialState) {
      OTHelpers.addClass(_text, 'OT_mode-on');
      OTHelpers.removeClass(_text, 'OT_mode-auto');
      self.setDisplayMode('on');
      renderText(_archivingEnded);
      renderStageDelayedAction = setTimeout(function () {
        self.setDisplayMode('off');
      }, 5000);
    } else {
      self.setDisplayMode('off');
    }
  };

  // Mixin common widget behaviour
  Widget(this, {
    mode: _archiving && options.show && 'on' || 'off',
    nodeName: 'h1',
    htmlAttributes: { className: 'OT_archiving OT_edge-bar-item OT_edge-bottom' },
    onCreate: function onCreate() {
      _lightBox = OTHelpers.createElement('div', {
        className: 'OT_archiving-light-box'
      }, '');
      _light = OTHelpers.createElement('div', {
        className: 'OT_archiving-light'
      }, '');
      _lightBox.appendChild(_light);
      _text = OTHelpers.createElement('div', {
        className: 'OT_archiving-status OT_mode-on OT_edge-bar-item OT_edge-bottom'
      }, '');
      _textNode = document.createTextNode('');
      _text.appendChild(_textNode);
      self.domElement.appendChild(_lightBox);
      self.domElement.appendChild(_text);
      renderStage();
    }
  });

  this.setShowArchiveStatus = function (show) {
    options.show = show;
    if (self.domElement) {
      renderStage.call(self);
    }
  };

  this.setArchiving = function (status) {
    _archiving = status;
    _initialState = false;
    if (self.domElement) {
      renderStage.call(self);
    }
  };
};

},{"../../common-js-helpers/OTHelpers.js":217,"./behaviour/widget.js":298}],296:[function(require,module,exports){
'use strict';

// @todo enable the following disabled rules see OPENTOK-31136 for more info
/* eslint-disable no-underscore-dangle, one-var, no-mixed-operators */

var Widget = require('./behaviour/widget');
var OTHelpers = require('../../common-js-helpers/OTHelpers.js');
var Promise = require('bluebird');
var EventEmitter = require('events');

module.exports = function AudioLevelMeter(options) {
  var _audioLevelMeter = this;
  var _eventEmitter = new EventEmitter();

  var _meterBarElement = void 0,
      _voiceOnlyIconElement = void 0,
      _meterValueElement = void 0,
      _value = void 0,
      _lastComputedVisibility = void 0;

  // display the widget by default but can be hidden when calling hideWhileLoading
  var _displayAroundLoading = true;

  var _audioOnly = false;
  var _displayMode = 'auto';

  var _maxValue = options.maxValue || 1;
  var _minValue = options.minValue || 0;

  function onCreate() {
    _meterBarElement = OTHelpers.createElement('div', {
      className: 'OT_audio-level-meter__bar'
    }, '');
    _meterValueElement = OTHelpers.createElement('div', {
      className: 'OT_audio-level-meter__value'
    }, '');
    _voiceOnlyIconElement = OTHelpers.createElement('div', {
      className: 'OT_audio-level-meter__audio-only-img'
    }, '');

    var domElement = _audioLevelMeter.domElement;
    domElement.appendChild(_meterBarElement);
    domElement.appendChild(_voiceOnlyIconElement);
    domElement.appendChild(_meterValueElement);

    _audioLevelMeter.watchVisibilityChanged(function (visible) {
      if (visible) {
        OTHelpers.removeClass(_audioLevelMeter.domElement, 'OT_hide-forced');
      } else {
        OTHelpers.addClass(_audioLevelMeter.domElement, 'OT_hide-forced');
      }
    });
  }

  function onDestroy() {
    _eventEmitter.removeAllListeners('visibilityChanged');
  }

  function updateView() {
    var percentSize = _value * 100 / (_maxValue - _minValue);
    _meterValueElement.style.width = 2 * percentSize + '%';
    _meterValueElement.style.height = 2 * percentSize + '%';

    _meterValueElement.style.top = -percentSize + '%';
    _meterValueElement.style.right = -percentSize + '%';
  }

  // computes the visibility value from the different "inputs" variables and asynchronously triggers
  // the internal "visibilityChanged" events if the value changed from last time it was computed
  function computeVisibility() {
    var computedVisibility = (_audioOnly && _displayMode === 'auto' || _displayMode === 'on') && _displayAroundLoading;
    if (_lastComputedVisibility !== computedVisibility) {
      _lastComputedVisibility = computedVisibility;
      _eventEmitter.emit('visibilityChanged', computedVisibility);
    }
  }

  OTHelpers.defineProperties(_audioLevelMeter, {
    audioOnly: {
      get: function get() {
        return _audioOnly;
      },
      set: function set(audioOnly) {
        _audioOnly = audioOnly;
        computeVisibility();
      }
    }
  });

  _audioLevelMeter.setValue = function (value) {
    _value = value;
    updateView();
  };

  /**
   * Registers an callback to be executed when the visibility of the audio level meter changes.
   * "true" means the widget is shown.
   * The contracts is that the handlers should not try to change the visibility of the widget by
   * changing the value of visibility "inputs" (setting "audioOnly", "displayMode" or calling
   * "hideWhileLoading" and "showAfterLoading")
   *
   * @param {function(boolean)} cb the callback to be executed when the display value changes.
   * The callback is also executed with the last computed value when registered.
   * @returns {function} a callback to unregister the handler
   */
  _audioLevelMeter.watchVisibilityChanged = function (cb) {
    _eventEmitter.on('visibilityChanged', cb);
    Promise.resolve().then(function () {
      cb(_lastComputedVisibility);
    });
    return function stopWatching() {
      _eventEmitter.removeListener('visibilityChanged', cb);
    };
  };

  // Mixin common widget behaviour
  var widgetOptions = {
    mode: options ? options.mode : 'auto',
    nodeName: 'div',
    htmlAttributes: {
      className: 'OT_audio-level-meter'
    },
    onCreate: onCreate,
    onDestroy: onDestroy
  };

  Widget(this, widgetOptions);

  // The methods underneath are mixed in by "Widget" but overridden
  // Doing so, we can bypass it and compute the display value ourselves without relying on CSS
  _audioLevelMeter.setDisplayMode = function (mode) {
    _displayMode = mode;
    computeVisibility();
  };

  _audioLevelMeter.getDisplayMode = function () {
    return _displayMode;
  };

  _audioLevelMeter.showAfterLoading = function () {
    _displayAroundLoading = true;
    computeVisibility();
  };

  _audioLevelMeter.hideWhileLoading = function () {
    _displayAroundLoading = false;
    computeVisibility();
  };

  // compute the initial visibility value
  computeVisibility();
};

},{"../../common-js-helpers/OTHelpers.js":217,"./behaviour/widget":298,"bluebird":2,"events":3}],297:[function(require,module,exports){
'use strict';

// @todo enable the following disabled rules see OPENTOK-31136 for more info
/* eslint-disable no-underscore-dangle */

var Widget = require('./behaviour/widget.js');

// BackingBar Chrome Widget
//
// nameMode (String)
// Whether or not the name panel is being displayed
// Possible values are: "auto" (the name is displayed
// when the stream is first displayed and when the user mouses over the display),
// "off" (the name is not displayed), and "on" (the name is displayed).
//
// muteMode (String)
// Whether or not the mute button is being displayed
// Possible values are: "auto" (the mute button is displayed
// when the stream is first displayed and when the user mouses over the display),
// "off" (the mute button is not displayed), and "on" (the mute button is displayed).
//
// displays a backing bar
// can be shown/hidden
// can be destroyed
module.exports = function BackingBar(options) {
  var _nameMode = options.nameMode;
  var _muteMode = options.muteMode;

  function getDisplayMode() {
    if (_nameMode === 'on' || _muteMode === 'on') {
      return 'on';
    } else if (_nameMode === 'mini' || _muteMode === 'mini') {
      return 'mini';
    } else if (_nameMode === 'mini-auto' || _muteMode === 'mini-auto') {
      return 'mini-auto';
    } else if (_nameMode === 'auto' || _muteMode === 'auto') {
      return 'auto';
    }

    return 'off';
  }

  // Mixin common widget behaviour
  Widget(this, {
    mode: getDisplayMode(),
    nodeName: 'div',
    htmlContent: '',
    htmlAttributes: {
      className: 'OT_bar OT_edge-bar-item'
    }
  });

  this.setNameMode = function (nameMode) {
    _nameMode = nameMode;
    this.setDisplayMode(getDisplayMode());
  };

  this.setMuteMode = function (muteMode) {
    _muteMode = muteMode;
    this.setDisplayMode(getDisplayMode());
  };
};

},{"./behaviour/widget.js":298}],298:[function(require,module,exports){
'use strict';

// @todo enable the following disabled rules see OPENTOK-31136 for more info
/* eslint-disable no-underscore-dangle, no-param-reassign */

var OTHelpers = require('../../../common-js-helpers/OTHelpers.js');

// A mixin to encapsulate the basic widget behaviour. This needs a better name,
// it's not actually a widget. It's actually "Behaviour that can be applied to
// an object to make it support the basic Chrome widget workflow"...but that would
// probably been too long a name.
module.exports = function Widget(widget, options) {
  var _mode = void 0;
  var _options = options || {};

  //
  // @param [String] mode
  //      'on', 'off', or 'auto'
  //
  widget.setDisplayMode = function (mode) {
    var newMode = mode || 'auto';
    if (_mode === newMode) {
      return;
    }

    OTHelpers.removeClass(this.domElement, 'OT_mode-' + _mode);
    OTHelpers.addClass(this.domElement, 'OT_mode-' + newMode);

    _mode = newMode;
  };

  widget.getDisplayMode = function () {
    return _mode;
  };

  widget.showAfterLoading = function () {
    OTHelpers.removeClass(this.domElement, 'OT_hide-forced');
  };

  widget.hideWhileLoading = function () {
    OTHelpers.addClass(this.domElement, 'OT_hide-forced');
  };

  widget.destroy = function () {
    if (_options.onDestroy) {
      _options.onDestroy(this.domElement);
    }
    if (this.domElement) {
      OTHelpers.removeElement(this.domElement);
    }

    return widget;
  };

  widget.appendTo = function (parent) {
    // create the element under parent
    this.domElement = OTHelpers.createElement(_options.nodeName || 'div', _options.htmlAttributes, _options.htmlContent);

    if (_options.onCreate) {
      _options.onCreate(this.domElement);
    }

    widget.setDisplayMode(_options.mode);

    if (_options.mode === 'auto') {
      // if the mode is auto we hold the "on mode" for 2 seconds
      // this will let the proper widgets nicely fade away and help discoverability
      OTHelpers.addClass(widget.domElement, 'OT_mode-on-hold');
      setTimeout(function () {
        OTHelpers.removeClass(widget.domElement, 'OT_mode-on-hold');
      }, 2000);
    }

    // add the widget to the parent
    parent.appendChild(this.domElement);

    return widget;
  };
};

},{"../../../common-js-helpers/OTHelpers.js":217}],299:[function(require,module,exports){
'use strict';

// @todo enable the following disabled rules see OPENTOK-31136 for more info
/* eslint-disable no-underscore-dangle, no-param-reassign, no-restricted-syntax */
/* eslint-disable no-prototype-builtins */

var OTHelpers = require('../../common-js-helpers/OTHelpers.js');

// Manages N Chrome elements
module.exports = function Chrome(properties) {
  var _widgets = {};

  // Private helper function
  var _set = function _set(name, widget) {
    widget.parent = this;
    widget.appendTo(properties.parent);

    _widgets[name] = widget;

    this[name] = widget;
  };

  if (!properties.parent) {
    // @todo raise an exception
    return;
  }

  OTHelpers.eventing(this);

  this.destroy = function () {
    this.off();
    this.hideWhileLoading();

    for (var name in _widgets) {
      if (_widgets.hasOwnProperty(name)) {
        _widgets[name].destroy();
      }
    }
  };

  this.showAfterLoading = function () {
    for (var name in _widgets) {
      if (_widgets.hasOwnProperty(name)) {
        _widgets[name].showAfterLoading();
      }
    }
  };

  this.hideWhileLoading = function () {
    for (var name in _widgets) {
      if (_widgets.hasOwnProperty(name)) {
        _widgets[name].hideWhileLoading();
      }
    }
  };

  // Adds the widget to the chrome and to the DOM. Also creates a accessor
  // property for it on the chrome.
  //
  // @example
  //  chrome.set('foo', new FooWidget());
  //  chrome.foo.setDisplayMode('on');
  //
  // @example
  //  chrome.set({
  //      foo: new FooWidget(),
  //      bar: new BarWidget()
  //  });
  //  chrome.foo.setDisplayMode('on');
  //
  this.set = function (widgetName, widget) {
    if (typeof widgetName === 'string' && widget) {
      _set.call(this, widgetName, widget);
    } else {
      for (var name in widgetName) {
        if (widgetName.hasOwnProperty(name)) {
          _set.call(this, name, widgetName[name]);
        }
      }
    }
    return this;
  };
};

},{"../../common-js-helpers/OTHelpers.js":217}],300:[function(require,module,exports){
'use strict';

var globalOTHelpers = require('../../common-js-helpers/OTHelpers.js');
var globalWidget = require('./behaviour/widget.js');

module.exports = function MuteButtonFactory() {
  var deps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var OTHelpers = deps.OTHelpers || globalOTHelpers;
  var Widget = deps.Widget || globalWidget;

  return function MuteButton(options) {
    var _this = this;

    var muted = options.muted || false;

    var updateClasses = function updateClasses() {
      if (muted) {
        OTHelpers.addClass(_this.domElement, 'OT_active');
      } else {
        OTHelpers.removeClass(_this.domElement, 'OT_active ');
      }
    };

    var onClick = function onClick() {
      muted = !muted;

      updateClasses();

      if (muted) {
        _this.parent.trigger('muted', _this);
      } else {
        _this.parent.trigger('unmuted', _this);
      }

      return false;
    };

    // Private Event Callbacks
    var attachEvents = function attachEvents(elem) {
      OTHelpers.on(elem, 'click', onClick);
    };

    var detachEvents = function detachEvents(elem) {
      OTHelpers.off(elem, 'click', onClick);
    };

    OTHelpers.defineProperties(this, {
      muted: {
        get: function get() {
          return muted;
        },
        set: function set(m) {
          muted = m;
          updateClasses();
        }
      }
    });

    // Mixin common widget behaviour
    var classNames = muted ? 'OT_edge-bar-item OT_mute OT_active' : 'OT_edge-bar-item OT_mute';
    Widget(this, {
      mode: options.mode,
      nodeName: 'button',
      htmlContent: 'Mute',
      htmlAttributes: {
        className: classNames,
        type: 'button'
      },
      onCreate: attachEvents,
      onDestroy: detachEvents
    });
  };
};

},{"../../common-js-helpers/OTHelpers.js":217,"./behaviour/widget.js":298}],301:[function(require,module,exports){
'use strict';

// @todo enable the following disabled rules see OPENTOK-31136 for more info
/* eslint-disable no-underscore-dangle, no-param-reassign */

var Widget = require('./behaviour/widget.js');

// NamePanel Chrome Widget
//
// mode (String)
// Whether to display the name. Possible values are: "auto" (the name is displayed
// when the stream is first displayed and when the user mouses over the display),
// "off" (the name is not displayed), and "on" (the name is displayed).
//
// displays a name
// can be shown/hidden
// can be destroyed
module.exports = function NamePanel(options) {
  var _name = options.name;

  if (!_name || _name.trim().length === '') {
    _name = null;

    // THere's no name, just flip the mode off
    options.mode = 'off';
  }

  this.setName = function (name) {
    if (!_name) {
      this.setDisplayMode('auto');
    }
    _name = name;
    this.domElement.innerHTML = _name;
  }.bind(this);

  // Mixin common widget behaviour
  Widget(this, {
    mode: options.mode,
    nodeName: 'h1',
    htmlContent: _name,
    htmlAttributes: {
      className: 'OT_name OT_edge-bar-item'
    }
  });
};

},{"./behaviour/widget.js":298}],302:[function(require,module,exports){
'use strict';

var Widget = require('./behaviour/widget.js');
var OTHelpers = require('../../common-js-helpers/OTHelpers.js');

module.exports = function VideoDisabledIndicator(options) {
  var videoDisabled = false;
  var warning = false;

  var updateClasses = function (element) {
    var shouldDisplay = ['auto', 'on'].indexOf(this.getDisplayMode()) > -1;

    OTHelpers.removeClass(element, 'OT_video-disabled OT_video-disabled-warning OT_active');

    if (!shouldDisplay) {
      return;
    }

    if (videoDisabled) {
      OTHelpers.addClass(element, 'OT_video-disabled');
    } else if (warning) {
      OTHelpers.addClass(element, 'OT_video-disabled-warning');
    }

    OTHelpers.addClass(element, 'OT_active');
  }.bind(this);

  this.disableVideo = function (value) {
    videoDisabled = value;
    if (value === true) {
      warning = false;
    }
    updateClasses(this.domElement);
  };

  this.setWarning = function (value) {
    warning = value;
    updateClasses(this.domElement);
  };

  // Mixin common widget behaviour
  Widget(this, {
    mode: options.mode || 'auto',
    nodeName: 'div',
    htmlAttributes: {
      className: 'OT_video-disabled-indicator'
    }
  });

  var parentSetDisplayMode = this.setDisplayMode.bind(this);
  this.setDisplayMode = function (mode) {
    parentSetDisplayMode(mode);
    updateClasses(this.domElement);
  };
};

},{"../../common-js-helpers/OTHelpers.js":217,"./behaviour/widget.js":298}],303:[function(require,module,exports){
'use strict';

var Capabilities = require('./capabilities.js');
var OTHelpers = require('../common-js-helpers/OTHelpers.js');
var Events = require('./events.js')();
var connectionCapabilities = require('./connectionCapabilities.js');

/**
 * The Connection object represents a connection to an OpenTok session. Each client that connects
 * to a session has a unique connection, with a unique connection ID (represented by the
 * <code>id</code> property of the Connection object for the client).
 * <p>
 * The Session object has a <code>connection</code> property that is a Connection object.
 * It represents the local client's connection. (A client only has a connection once the
 * client has successfully called the <code>connect()</code> method of the {@link Session}
 * object.)
 * <p>
 * The Session object dispatches a <code>connectionCreated</code> event when each client (including
 * your own) connects to a session (and for clients that are present in the session when you
 * connect). The <code>connectionCreated</code> event object has a <code>connection</code>
 * property, which is a Connection object corresponding to the client the event pertains to.
 * <p>
 * The Stream object has a <code>connection</code> property that is a Connection object.
 * It represents the connection of the client that is publishing the stream.
 *
 * @class Connection
 * @property {String} connectionId The ID of this connection.
 * @property {Number} creationTime The timestamp for the creation of the connection. This
 * value is calculated in milliseconds.
 * You can convert this value to a Date object by calling <code>new Date(creationTime)</code>,
 * where <code>creationTime</code>
 * is the <code>creationTime</code> property of the Connection object.
 * @property {String} data A string containing metadata describing the
 * connection. When you generate a user token, you can define connection data (see the
 * <a href="https://tokbox.com/developer/guides/create-token/">Token creation overview</a>).
 */
var Connection = function Connection(id, creationTime, data, capabilitiesHash, permissionsHash) {
  var destroyedReason = void 0;

  this.id = id;
  this.connectionId = id;
  this.creationTime = creationTime ? Number(creationTime) : null;
  this.data = data;
  this.capabilities = connectionCapabilities(capabilitiesHash);
  this.permissions = new Capabilities(permissionsHash);
  this.quality = null;

  OTHelpers.eventing(this);

  this.destroy = function (reason, quiet) {
    destroyedReason = reason || 'clientDisconnected';

    if (quiet !== true) {
      this.dispatchEvent(new Events.DestroyedEvent(
      // This should be Events.Event.names.CONNECTION_DESTROYED, but
      // the value of that is currently shared with Session
      'destroyed', this, destroyedReason));
    }
  }.bind(this);

  this.destroyed = function () {
    return destroyedReason !== undefined;
  };

  this.destroyedReason = function () {
    return destroyedReason;
  };
};

Connection.fromHash = function (hash) {
  return new Connection(hash.id, hash.creationTime, hash.data, OTHelpers.extend(hash.capablities || {}, { supportsWebRTC: true }), hash.permissions || []);
};

module.exports = Connection;

},{"../common-js-helpers/OTHelpers.js":217,"./capabilities.js":294,"./connectionCapabilities.js":304,"./events.js":306}],304:[function(require,module,exports){
'use strict';

module.exports = function capabilitiesFromHash(_ref) {
  var supportsWebRTC = _ref.supportsWebRTC;

  return {
    supportsWebRTC: supportsWebRTC === 'true' || supportsWebRTC === true
  };
};

},{}],305:[function(require,module,exports){
'use strict';

// @todo enable the following disabled rules see OPENTOK-31136 for more info
/* eslint-disable no-underscore-dangle, no-use-before-define */

var logging = require('./logging.js');
var OTHelpers = require('../common-js-helpers/OTHelpers.js');
var OTPlugin = require('../otplugin/otplugin.js');
var domState = require('../helpers/domState.js');

var Events = require('./events.js')();

// Helper to synchronise several startup tasks and then dispatch a unified
// 'envLoaded' event.

function EnvironmentLoader() {
  var environmentLoader = this;
  OTHelpers.eventing(environmentLoader, true);

  // If the plugin is installed, then we should wait for it to be ready as well.
  var _pluginLoadAttemptComplete = OTPlugin.isSupported() ? OTPlugin.isReady() : true;

  function isReady() {
    return domState.isDomLoaded() && !domState.isDomUnloaded() && _pluginLoadAttemptComplete;
  }

  function onLoaded() {
    if (isReady()) {
      environmentLoader.dispatchEvent(new Events.EnvLoadedEvent(Events.Event.names.ENV_LOADED));
    }
  }

  function onDomReady() {
    domState.whenUnloaded.then(onDomUnload);
    onLoaded();
  }

  function onDomUnload() {
    environmentLoader.dispatchEvent(new Events.EnvLoadedEvent(Events.Event.names.ENV_UNLOADED));
  }

  function onPluginReady(err) {
    // We mark the plugin as ready so as not to stall the environment
    // loader. In this case though, OTPlugin is not supported.
    _pluginLoadAttemptComplete = true;

    if (err) {
      logging.error('OTPlugin failed to load or was not installed:', err);
    }

    onLoaded();
  }

  domState.whenLoaded.then(onDomReady);

  // If the plugin should work on this platform then
  // see if it loads.
  if (OTPlugin.isSupported()) {
    OTPlugin.ready(onPluginReady);
  }

  this.onLoad = function (cb, context) {
    if (isReady()) {
      cb.call(context);
      return;
    }

    environmentLoader.on(Events.Event.names.ENV_LOADED, cb, context);
  };

  this.onUnload = function (cb, context) {
    if (this.isUnloaded()) {
      cb.call(context);
      return;
    }

    environmentLoader.on(Events.Event.names.ENV_UNLOADED, cb, context);
  };

  this.isUnloaded = function () {
    return domState.isDomUnloaded();
  };
}

module.exports = new EnvironmentLoader();

},{"../common-js-helpers/OTHelpers.js":217,"../helpers/domState.js":253,"../otplugin/otplugin.js":390,"./events.js":306,"./logging.js":312}],306:[function(require,module,exports){
'use strict';

// @todo enable the following disabled rules see OPENTOK-31136 for more info
/* eslint-disable no-param-reassign, global-require, max-len */

module.exports = function EventsFactory() {
  var deps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var logging = deps.logging || require('./logging.js');
  var OTHelpers = deps.OTHelpers || require('../common-js-helpers/OTHelpers.js');

  var Events = {};

  /**
   * The Event object defines the basic OpenTok event object that is passed to
   * event listeners. Other OpenTok event classes implement the properties and methods of
   * the Event object.</p>
   *
   * <p>For example, the Stream object dispatches a <code>streamPropertyChanged</code> event when
   * the stream's properties are updated. You add a callback for an event using the
   * <code>on()</code> method of the Stream object:</p>
   *
   * <pre>
   * stream.on("streamPropertyChanged", function (event) {
   *     alert("Properties changed for stream " + event.target.streamId);
   * });</pre>
   *
   * @class Event
   * @property {Boolean} cancelable Whether the event has a default behavior that is cancelable
   * (<code>true</code>) or not (<code>false</code>). You can cancel the default behavior by
   * calling the <code>preventDefault()</code> method of the Event object in the callback
   * function. (See <a href="#preventDefault">preventDefault()</a>.)
   *
   * @property {Object} target The object that dispatched the event.
   *
   * @property {String} type  The type of event.
   */
  Events.Event = OTHelpers.Event();
  /**
  * Prevents the default behavior associated with the event from taking place.
  *
  * <p>To see whether an event has a default behavior, check the <code>cancelable</code> property
  * of the event object. </p>
  *
  * <p>Call the <code>preventDefault()</code> method in the callback function for the event.</p>
  *
  * <p>The following events have default behaviors:</p>
  *
  * <ul>
  *
  *   <li><code>sessionDisconnect</code> &#151; See
  *   <a href="SessionDisconnectEvent.html#preventDefault">
  *   SessionDisconnectEvent.preventDefault()</a>.</li>
  *
  *   <li><code>streamDestroyed</code> &#151; See <a href="StreamEvent.html#preventDefault">
  *   StreamEvent.preventDefault()</a>.</li>
  *
  *   <li><code>accessDialogOpened</code> &#151; See the
  *   <a href="Publisher.html#event:accessDialogOpened">accessDialogOpened event</a>.</li>
  *
  *   <li><code>accessDenied</code> &#151; See the <a href="Publisher.html#event:accessDenied">
  *   accessDenied event</a>.</li>
  *
  * </ul>
  *
  * @method #preventDefault
  * @memberof Event
  */
  /**
  * Whether the default event behavior has been prevented via a call to
  * <code>preventDefault()</code> (<code>true</code>) or not (<code>false</code>).
  * See <a href="#preventDefault">preventDefault()</a>.
  * @method #isDefaultPrevented
  * @return {Boolean}
  * @memberof Event
  */

  // Event names lookup
  Events.Event.names = {
    // Activity Status for cams/mics
    ACTIVE: 'active',
    INACTIVE: 'inactive',
    UNKNOWN: 'unknown',

    // Archive types
    PER_SESSION: 'perSession',
    PER_STREAM: 'perStream',

    // Events
    EXCEPTION: 'exception',
    ISSUE_REPORTED: 'issueReported',

    // Session Events
    SESSION_CONNECTED: 'sessionConnected',
    SESSION_RECONNECTING: 'sessionReconnecting',
    SESSION_RECONNECTED: 'sessionReconnected',
    SESSION_DISCONNECTED: 'sessionDisconnected',
    STREAM_CREATED: 'streamCreated',
    STREAM_DESTROYED: 'streamDestroyed',
    CONNECTION_CREATED: 'connectionCreated',
    CONNECTION_DESTROYED: 'connectionDestroyed',
    SIGNAL: 'signal',
    STREAM_PROPERTY_CHANGED: 'streamPropertyChanged',
    MICROPHONE_LEVEL_CHANGED: 'microphoneLevelChanged',

    // Publisher Events
    RESIZE: 'resize',
    SETTINGS_BUTTON_CLICK: 'settingsButtonClick',
    DEVICE_INACTIVE: 'deviceInactive',
    INVALID_DEVICE_NAME: 'invalidDeviceName',
    ACCESS_ALLOWED: 'accessAllowed',
    ACCESS_DENIED: 'accessDenied',
    ACCESS_DIALOG_OPENED: 'accessDialogOpened',
    ACCESS_DIALOG_CLOSED: 'accessDialogClosed',
    ECHO_CANCELLATION_MODE_CHANGED: 'echoCancellationModeChanged',
    MEDIA_STOPPED: 'mediaStopped',
    PUBLISHER_DESTROYED: 'destroyed',

    // Subscriber Events
    SUBSCRIBER_DESTROYED: 'destroyed',
    SUBSCRIBER_CONNECTED: 'connected',
    SUBSCRIBER_DISCONNECTED: 'disconnected',

    // DeviceManager Events
    DEVICES_DETECTED: 'devicesDetected',

    // DevicePanel Events
    DEVICES_SELECTED: 'devicesSelected',
    CLOSE_BUTTON_CLICK: 'closeButtonClick',

    MICLEVEL: 'microphoneActivityLevel',
    MICGAINCHANGED: 'microphoneGainChanged',

    // Environment Loader
    ENV_LOADED: 'envLoaded',
    ENV_UNLOADED: 'envUnloaded',

    // Audio activity Events
    AUDIO_LEVEL_UPDATED: 'audioLevelUpdated',

    VIDEO_ELEMENT_CREATED: 'videoElementCreated'
  };

  /**
  * The {@link OT} class dispatches <code>exception</code> events when the OpenTok API encounters
  * an exception (error). The ExceptionEvent object defines the properties of the event
  * object that is dispatched.
  *
  * <p>Note that you set up a callback for the <code>exception</code> event by calling the
  * <code>OT.on()</code> method.</p>
  *
  * @class ExceptionEvent
  * @property {Number} code The error code. The following is a list of error codes:</p>
  *
  * <table class="docs_table">
  *  <tbody><tr>
  *   <td>
  *   <b>code</b>
  *
  *   </td>
  *   <td>
  *   <b>title</b>
  *   </td>
  *  </tr>
  *
  *  <tr>
  *   <td>
  *   1004
  *
  *   </td>
  *   <td>
  *   Authentication error
  *   </td>
  *  </tr>
  *
  *  <tr>
  *   <td>
  *   1005
  *
  *   </td>
  *   <td>
  *   Invalid Session ID
  *   </td>
  *  </tr>
  *  <tr>
  *   <td>
  *   1006
  *
  *   </td>
  *   <td>
  *   Connect Failed
  *   </td>
  *  </tr>
  *  <tr>
  *   <td>
  *   1007
  *
  *   </td>
  *   <td>
  *   Connect Rejected
  *   </td>
  *  </tr>
  *  <tr>
  *   <td>
  *   1008
  *
  *   </td>
  *   <td>
  *   Connect Time-out
  *   </td>
  *  </tr>
  *  <tr>
  *   <td>
  *   1009
  *
  *   </td>
  *   <td>
  *   Security Error
  *   </td>
  *  </tr>
  *   <tr>
  *    <td>
  *    1010
  *
  *    </td>
  *    <td>
  *    Not Connected
  *    </td>
  *   </tr>
  *   <tr>
  *    <td>
  *    1011
  *
  *    </td>
  *    <td>
  *    Invalid Parameter
  *    </td>
  *   </tr>
  *   <tr>
  *    <td>
  *    1013
  *    </td>
  *    <td>
  *    Connection Failed
  *    </td>
  *   </tr>
  *   <tr>
  *    <td>
  *    1014
  *    </td>
  *    <td>
  *    API Response Failure
  *    </td>
  *   </tr>
  *   <tr>
  *    <td>
  *    1026
  *    </td>
  *    <td>
  *    Terms of Service Violation: Export Compliance
  *    </td>
  *   </tr>
  *  <tr>
  *    <td>
  *    1500
  *    </td>
  *    <td>
  *    Unable to Publish
  *    </td>
  *   </tr>
  *
  *  <tr>
  *    <td>
  *    1520
  *    </td>
  *    <td>
  *    Unable to Force Disconnect
  *    </td>
  *   </tr>
  *
  *  <tr>
  *    <td>
  *    1530
  *    </td>
  *    <td>
  *    Unable to Force Unpublish
  *    </td>
  *   </tr>
  *  <tr>
  *    <td>
  *    1535
  *    </td>
  *    <td>
  *    Force Unpublish on Invalid Stream
  *    </td>
  *   </tr>
  *
  *  <tr>
  *    <td>
  *    2000
  *
  *    </td>
  *    <td>
  *    Internal Error
  *    </td>
  *  </tr>
  *
  *  <tr>
  *    <td>
  *    2010
  *
  *    </td>
  *    <td>
  *    Report Issue Failure
  *    </td>
  *  </tr>
  *
  *
  *  </tbody></table>
  *
  *  <p>Check the <code>message</code> property for more details about the error.</p>
  *
  * @property {String} message The error message.
  *
  * @property {Object} target The object that the event pertains to. For an
  * <code>exception</code> event, this will be an object other than the OT object
  * (such as a Session object or a Publisher object).
  *
  * @property {String} title The error title.
  * @augments Event
  */
  Events.ExceptionEvent = function (type, message, title, code, component, target) {
    Events.Event.call(this, type);

    this.message = message;
    this.title = title;
    this.code = code;
    this.component = component;
    this.target = target;
  };

  Events.IssueReportedEvent = function (type, issueId) {
    Events.Event.call(this, type);
    this.issueId = issueId;
  };

  // Triggered when the JS dynamic config and the DOM have loaded.
  Events.EnvLoadedEvent = function (type) {
    Events.Event.call(this, type);
  };

  /**
   * Defines <code>connectionCreated</code> and <code>connectionDestroyed</code> events dispatched
   * by the {@link Session} object.
   * <p>
   * The Session object dispatches a <code>connectionCreated</code> event when a client (including
   * your own) connects to a Session. It also dispatches a <code>connectionCreated</code> event for
   * every client in the session when you first connect. (when your local client connects, the
   * Session object also dispatches a <code>sessionConnected</code> event, defined by the
   * {@link SessionConnectEvent} class.)
   * <p>
   * While you are connected to the session, the Session object dispatches a
   * <code>connectionDestroyed</code> event when another client disconnects from the Session.
   * (When you disconnect, the Session object also dispatches a <code>sessionDisconnected</code>
   * event, defined by the {@link SessionDisconnectEvent} class.)
   *
   * <h5><a name="example"></a>Example</h5>
   *
   * <p>The following code keeps a running total of the number of connections to a session
   * by monitoring the <code>connections</code> property of the <code>sessionConnect</code>,
   * <code>connectionCreated</code> and <code>connectionDestroyed</code> events:</p>
   *
   * <pre>var apiKey = ""; // Replace with your API key. See https://tokbox.com/account
   * var sessionID = ""; // Replace with your own session ID.
   *                     // See https://tokbox.com/developer/guides/create-session/.
   * var token = ""; // Replace with a generated token that has been assigned the moderator role.
   *                 // See https://tokbox.com/developer/guides/create-token/.
   * var connectionCount = 0;
   *
   * var session = OT.initSession(apiKey, sessionID);
   * session.on("connectionCreated", function(event) {
   *    connectionCount++;
   *    displayConnectionCount();
   * });
   * session.on("connectionDestroyed", function(event) {
   *    connectionCount--;
   *    displayConnectionCount();
   * });
   * session.connect(token);
   *
   * function displayConnectionCount() {
   *     document.getElementById("connectionCountField").value = connectionCount.toString();
   * }</pre>
   *
   * <p>This example assumes that there is an input text field in the HTML DOM
   * with the <code>id</code> set to <code>"connectionCountField"</code>:</p>
   *
   * <pre>&lt;input type="text" id="connectionCountField" value="0"&gt;&lt;/input&gt;</pre>
   *
   *
   * @property {Connection} connection A Connection object for the connection that was
   * created or deleted.
   *
   * @property {Array} connections Deprecated. Use the <code>connection</code> property. A
   * <code>connectionCreated</code> or <code>connectionDestroyed</code> event is dispatched
   * for each connection created and destroyed in the session.
   *
   * @property {String} reason For a <code>connectionDestroyed</code> event,
   *  a description of why the connection ended. This property can have the following values:
   * </p>
   * <ul>
   *  <li><code>"clientDisconnected"</code> &#151; A client disconnected from the session by calling
   *     the <code>disconnect()</code> method of the Session object or by closing the browser.
   *     (See <a href="Session.html#disconnect">Session.disconnect()</a>.)</li>
   *
   *  <li><code>"forceDisconnected"</code> &#151; A moderator has disconnected the publisher
   *      from the session, by calling the <code>forceDisconnect()</code> method of the Session
   *      object. (See <a href="Session.html#forceDisconnect">Session.forceDisconnect()</a>.)</li>
   *
   *  <li><code>"networkDisconnected"</code> &#151; The network connection terminated abruptly
   *      (for example, the client lost their internet connection).</li>
   * </ul>
   *
   * <p>Depending on the context, this description may allow the developer to refine
   * the course of action they take in response to an event.</p>
   *
   * <p>For a <code>connectionCreated</code> event, this string is undefined.</p>
   *
   * @class ConnectionEvent
   * @augments Event
   */
  var connectionEventPluralDeprecationWarningShown = false;
  Events.ConnectionEvent = function (type, connection, reason) {
    Events.Event.call(this, type, false);

    Object.defineProperty(this, 'connections', {
      get: function get() {
        if (!connectionEventPluralDeprecationWarningShown) {
          logging.warn('OT.ConnectionEvent connections property is deprecated, ' + 'use connection instead.');
          connectionEventPluralDeprecationWarningShown = true;
        }
        return [connection];
      }
    });

    this.connection = connection;
    this.reason = reason;
  };

  /**
   * StreamEvent is an event that can have the type "streamCreated" or "streamDestroyed".
   * These events are dispatched by the Session object when another client starts or
   * stops publishing a stream to a {@link Session}. For a local client's stream, the
   * Publisher object dispatches the event.
   *
   * <h4><a name="example_streamCreated"></a>Example &#151; streamCreated event dispatched
   * by the Session object</h4>
   *  <p>The following code initializes a session and sets up an event listener for when
   *    a stream published by another client is created:</p>
   *
   * <pre>
   * session.on("streamCreated", function(event) {
   *   // streamContainer is a DOM element
   *   subscriber = session.subscribe(event.stream, targetElement);
   * }).connect(token);
   * </pre>
   *
   *  <h4><a name="example_streamDestroyed"></a>Example &#151; streamDestroyed event dispatched
   * by the Session object</h4>
   *
   *    <p>The following code initializes a session and sets up an event listener for when
   *       other clients' streams end:</p>
   *
   * <pre>
   * session.on("streamDestroyed", function(event) {
   *     console.log("Stream " + event.stream.name + " ended. " + event.reason);
   * }).connect(token);
   * </pre>
   *
   * <h4><a name="example_streamCreated_publisher"></a>Example &#151; streamCreated event dispatched
   * by a Publisher object</h4>
   *  <p>The following code publishes a stream and adds an event listener for when the streaming
   * starts</p>
   *
   * <pre>
   * var publisher = session.publish(targetElement)
   *   .on("streamCreated", function(event) {
   *     console.log("Publisher started streaming.");
   *   );
   * </pre>
   *
   *  <h4><a name="example_streamDestroyed_publisher"></a>Example &#151; streamDestroyed event
   * dispatched by a Publisher object</h4>
   *
   *  <p>The following code publishes a stream, and leaves the Publisher in the HTML DOM
   * when the streaming stops:</p>
   *
   * <pre>
   * var publisher = session.publish(targetElement)
   *   .on("streamDestroyed", function(event) {
   *     event.preventDefault();
   *     console.log("Publisher stopped streaming.");
   *   );
   * </pre>
   *
   * @class StreamEvent
   *
   * @property {Boolean} cancelable   Whether the event has a default behavior that is cancelable
   *  (<code>true</code>) or not (<code>false</code>). You can cancel the default behavior by
   * calling the <code>preventDefault()</code> method of the StreamEvent object in the event
   * listener function. The <code>streamDestroyed</code> event is cancelable.
   * (See <a href="#preventDefault">preventDefault()</a>.)
   *
   * @property {String} reason For a <code>streamDestroyed</code> event,
   *  a description of why the session disconnected. This property can have one of the following
   *  values:
   * </p>
   * <ul>
   *  <li><code>"clientDisconnected"</code> &#151; A client disconnected from the session by calling
   *     the <code>disconnect()</code> method of the Session object or by closing the browser.
   *     (See <a href="Session.html#disconnect">Session.disconnect()</a>.)</li>
   *
   *  <li><code>"forceDisconnected"</code> &#151; A moderator has disconnected the publisher of the
   *    stream from the session, by calling the <code>forceDisconnect()</code> method of the Session
   *     object. (See <a href="Session.html#forceDisconnect">Session.forceDisconnect()</a>.)</li>
   *
   *  <li><code>"forceUnpublished"</code> &#151; A moderator has forced the publisher of the stream
   *    to stop publishing the stream, by calling the <code>forceUnpublish()</code> method of the
   *    Session object.
   *    (See <a href="Session.html#forceUnpublish">Session.forceUnpublish()</a>.)</li>
   *
   *  <li><code>"mediaStopped"</code> &#151; The user publishing the stream has stopped sharing
   *    one or all media types (video, audio and/or screen). The <code>track</code> event property
   *    contains the track that has ended or is undefined if all media has stopped.</li>
   *
   *  <li><code>"networkDisconnected"</code> &#151; The network connection terminated abruptly (for
   *      example, the client lost their internet connection).</li>
   *
   * </ul>
   *
   * <p>Depending on the context, this description may allow the developer to refine
   * the course of action they take in response to an event.</p>
   *
   * <p>For a <code>streamCreated</code> event, this string is undefined.</p>
   *
   * @property {Stream} stream A Stream object corresponding to the stream that was added (in the
   * case of a <code>streamCreated</code> event) or deleted (in the case of a
   * <code>streamDestroyed</code> event).
   *
   * @property {Array} streams Deprecated. Use the <code>stream</code> property. A
   * <code>streamCreated</code> or <code>streamDestroyed</code> event is dispatched for
   * each stream added or destroyed.
   *
   * @augments Event
   */

  var streamEventPluralDeprecationWarningShown = false;
  Events.StreamEvent = function (type, stream, reason, cancelable) {
    Events.Event.call(this, type, cancelable);

    Object.defineProperty(this, 'streams', {
      get: function get() {
        if (!streamEventPluralDeprecationWarningShown) {
          logging.warn('OT.StreamEvent streams property is deprecated, use stream instead.');
          streamEventPluralDeprecationWarningShown = true;
        }
        return [stream];
      }
    });

    this.stream = stream;
    this.reason = reason;
  };

  /**
  * Prevents the default behavior associated with the event from taking place.
  *
  * <p>For the <code>streamDestroyed</code> event dispatched by the Session object,
  * the default behavior is that all Subscriber objects that are subscribed to the stream are
  * unsubscribed and removed from the HTML DOM. Each Subscriber object dispatches a
  * <code>destroyed</code> event when the element is removed from the HTML DOM. If you call the
  * <code>preventDefault()</code> method in the event listener for the <code>streamDestroyed</code>
  * event, the default behavior is prevented and you can clean up Subscriber objects using your
  * own code. See
  * <a href="Session.html#getSubscribersForStream">Session.getSubscribersForStream()</a>.</p>
  * <p>
  * For the <code>streamDestroyed</code> event dispatched by a Publisher object, the default
  * behavior is that the Publisher object is removed from the HTML DOM. The Publisher object
  * dispatches a <code>destroyed</code> event when the element is removed from the HTML DOM.
  * If you call the <code>preventDefault()</code> method in the event listener for the
  * <code>streamDestroyed</code> event, the default behavior is prevented, and you can
  * retain the Publisher for reuse or clean it up using your own code.
  *</p>
  * <p>To see whether an event has a default behavior, check the <code>cancelable</code> property of
  * the event object. </p>
  *
  * <p>
  *   Call the <code>preventDefault()</code> method in the event listener function for the event.
  * </p>
  *
  * @method #preventDefault
  * @memberof StreamEvent
  */

  /**
   * The Session object dispatches SessionConnectEvent object when a session has successfully
   * connected in response to a call to the <code>connect()</code> method of the Session object.
   * <p>
   * In version 2.2, the completionHandler of the <code>Session.connect()</code> method
   * indicates success or failure in connecting to the session.
   *
   * @class SessionConnectEvent
   * @property {Array} connections Deprecated in version 2.2 (and set to an empty array). In
   * version 2.2, listen for the <code>connectionCreated</code> event dispatched by the Session
   * object. In version 2.2, the Session object dispatches a <code>connectionCreated</code> event
   * for each connection (including your own). This includes connections present when you first
   * connect to the session.
   *
   * @property {Array} streams Deprecated in version 2.2 (and set to an empty array). In version
   * 2.2, listen for the <code>streamCreated</code> event dispatched by the Session object. In
   * version 2.2, the Session object dispatches a <code>streamCreated</code> event for each stream
   * other than those published by your client. This includes streams
   * present when you first connect to the session.
   *
   * @see <a href="Session.html#connect">Session.connect()</a></p>
   * @augments Event
   */

  var sessionConnectedConnectionsDeprecationWarningShown = false;
  var sessionConnectedStreamsDeprecationWarningShown = false;
  var sessionConnectedArchivesDeprecationWarningShown = false;

  Events.SessionConnectEvent = function (type) {
    Events.Event.call(this, type, false);

    Object.defineProperties(this, {
      connections: {
        get: function get() {
          if (!sessionConnectedConnectionsDeprecationWarningShown) {
            logging.warn('OT.SessionConnectedEvent no longer includes connections. Listen ' + 'for connectionCreated events instead.');
            sessionConnectedConnectionsDeprecationWarningShown = true;
          }
          return [];
        }
      },
      streams: {
        get: function get() {
          if (!sessionConnectedStreamsDeprecationWarningShown) {
            logging.warn('OT.SessionConnectedEvent no longer includes streams. Listen for ' + 'streamCreated events instead.');
            sessionConnectedConnectionsDeprecationWarningShown = true;
          }
          return [];
        }
      },
      archives: {
        get: function get() {
          if (!sessionConnectedArchivesDeprecationWarningShown) {
            logging.warn('OT.SessionConnectedEvent no longer includes archives. Listen for ' + 'archiveStarted events instead.');
            sessionConnectedArchivesDeprecationWarningShown = true;
          }
          return [];
        }
      }
    });
  };

  Events.SessionReconnectingEvent = function () {
    Events.Event.call(this, Events.Event.names.SESSION_RECONNECTING);
  };

  Events.SessionReconnectedEvent = function () {
    Events.Event.call(this, Events.Event.names.SESSION_RECONNECTED);
  };

  /**
   * The Session object dispatches SessionDisconnectEvent object when a session has disconnected.
   * This event may be dispatched asynchronously in response to a successful call to the
   * <code>disconnect()</code> method of the session object.
   *
   *  <h4>
   *    <a href="example"></a>Example
   *  </h4>
   *  <p>
   *    The following code initializes a session and sets up an event listener for when a session is
   * disconnected.
   *  </p>
   * <pre>var apiKey = ""; // Replace with your API key. See https://tokbox.com/account
   *  var sessionID = ""; // Replace with your own session ID.
   *                      // See https://tokbox.com/developer/guides/create-session/
   *  var token = ""; // Replace with a generated token that has been assigned the moderator role.
   *                  // See https://tokbox.com/developer/guides/create-token/
   *
   *  var session = OT.initSession(apiKey, sessionID);
   *  session.on("sessionDisconnected", function(event) {
   *      alert("The session disconnected. " + event.reason);
   *  });
   *  session.connect(token);
   *  </pre>
   *
   * @property {String} reason A description of why the session disconnected.
   *   This property can have the following values:
   *  </p>
   *  <ul>
   *    <li>
   *      <code>"clientDisconnected"</code> &mdash; A client disconnected from the
   *      session by calling the <code>disconnect()</code> method of the Session
   *      object or by closing the browser. ( See <a href=
   *      "Session.html#disconnect">Session.disconnect()</a>.)
   *    </li>
   *
   *    <li>
   *      <code>"forceDisconnected"</code> &mdash; A moderator has disconnected you from
   *      the session by calling the <code>forceDisconnect()</code> method of the
   *      Session object. (See <a href=
   *      "Session.html#forceDisconnect">Session.forceDisconnect()</a>.)
   *    </li>
   *
   *    <li><code>"networkDisconnected"</code> &mdash; The network connection terminated
   *    abruptly (for example, the client lost its internet connection).
   *    <p>
   *    Prior to dispatching a
   *    <code>sessionDisconnected</code> event for this reason, the Session object dispatches a
   *    <code>reconnecting</code> event, and the client attempts to reconnect to the OpenTok session.
   *    If the reconnection fails, the Session object dispatches a <code>sessionDisconnected</code>
   *    event with the <code>reason</code> property set to <code>"networkDisconnected"</code>.
   *  </ul>
   *  <ul>
   *
   * @class SessionDisconnectEvent
   * @augments Event
   */
  Events.SessionDisconnectEvent = function (type, reason, cancelable) {
    Events.Event.call(this, type, cancelable);
    this.reason = reason;
  };

  /**
  * Prevents the default behavior associated with the event from taking place.
  *
  * <p>
  *   For the <code>sessionDisconnectEvent</code>, the default behavior is that all
  *   Subscriber objects are unsubscribed and removed from the HTML DOM. Each
  *   Subscriber object dispatches a <code>destroyed</code> event when the element
  *   is removed from the HTML DOM. If you call the <code>preventDefault()</code>
  *   method in the event listener for the <code>sessionDisconnect</code> event,
  *   the default behavior is prevented, and you can, optionally, clean up
  *   Subscriber objects using your own code).
  * </p>
  * <p>
  *   To see whether an event has a default behavior, check the
  *   <code>cancelable</code> property of the event object.
  * </p>
  * <p>
  *   Call the <code>preventDefault()</code> method in the event listener function
  *   for the event.
  * </p>
  *
  * @method #preventDefault
  * @memberof SessionDisconnectEvent
  */

  /**
   * The Session object dispatches a <code>streamPropertyChanged</code> event in the
   * following circumstances:
   *
   * <ul>
   *   <li> A stream has started or stopped publishing audio or video (see
   *     <a href="Publisher.html#publishAudio">Publisher.publishAudio()</a> and
   *     <a href="Publisher.html#publishVideo">Publisher.publishVideo()</a>).
   *     This change results from a call to the <code>publishAudio()</code> or
   *     <code>publishVideo()</code> methods of the Publish object. Note that a
   *     subscriber's video can be disabled or enabled for reasons other than the
   *     publisher disabling or enabling it. A Subscriber object dispatches
   *     <code>videoDisabled</code> and <code>videoEnabled</code> events in all
   *     conditions that cause the subscriber's stream to be disabled or enabled.
   *   </li>
   *   <li> The <code>videoDimensions</code> property of the Stream object has
   *     changed (see <a href="Stream.html#properties">Stream.videoDimensions</a>).
   *   </li>
   *   <li> The <code>videoType</code> property of the Stream object has changed.
   *     This can happen in a stream published by a mobile device. (See
   *     <a href="Stream.html#properties">Stream.videoType</a>.)
   *   </li>
   * </ul>
   *
   * @class StreamPropertyChangedEvent
   * @property {String} changedProperty The property of the stream that changed. This value
   * is either <code>"hasAudio"</code>, <code>"hasVideo"</code>, or <code>"videoDimensions"</code>.
   * @property {Object} newValue The new value of the property (after the change).
   * @property {Object} oldValue The old value of the property (before the change).
   * @property {Stream} stream The Stream object for which a property has changed.
   *
   * @see <a href="Publisher.html#publishAudio">Publisher.publishAudio()</a></p>
   * @see <a href="Publisher.html#publishVideo">Publisher.publishVideo()</a></p>
   * @see <a href="Stream.html#properties">Stream.videoDimensions</a></p>
   * @augments Event
   */
  Events.StreamPropertyChangedEvent = function (type, stream, changedProperty, oldValue, newValue) {
    Events.Event.call(this, type, false);
    this.type = type;
    this.stream = stream;
    this.changedProperty = changedProperty;
    this.oldValue = oldValue;
    this.newValue = newValue;
  };

  /**
   * Dispatched when the video dimensions of the video change for a screen-sharing
   * video stream (when the user resizes the window being captured).
   *
   * @class VideoDimensionsChangedEvent
   * @property {Object} newValue The new video dimensions (after the change). This object has two
   * properties: <code>height</code> (the height, in pixels) and <code>width</code> (the width,
   * in pixels).
   * @property {Object} oldValue The old video dimensions (before the change). This object has two
   * properties: <code>height</code> (the old height, in pixels) and <code>width</code> (the old
   * width, in pixels).
   *
   * @see <a href="Publisher.html#event:videoDimensionsChanged">Publisher videoDimensionsChanged
   *   event</a>
   * @see <a href="Subscriber.html#event:videoDimensionsChanged">Subscriber videoDimensionsChanged
   *   event</a>
   * @augments Event
   */
  Events.VideoDimensionsChangedEvent = function (target, oldValue, newValue) {
    Events.Event.call(this, 'videoDimensionsChanged', false);
    this.type = 'videoDimensionsChanged';
    this.target = target;
    this.oldValue = oldValue;
    this.newValue = newValue;
  };

  /**
   * Defines event objects for the <code>archiveStarted</code> and <code>archiveStopped</code>
   * events. The Session object dispatches these events when an archive recording of the session
   * starts and stops.
   *
   * @property {String} id The archive ID.
   * @property {String} name The name of the archive. You can assign an archive a name when you
   * create it, using the <a href="http://www.tokbox.com/opentok/api">OpenTok REST API</a> or one
   * of the <a href="http://www.tokbox.com/opentok/libraries/server">OpenTok server SDKs</a>.
   *
   * @class ArchiveEvent
   * @augments Event
   */
  Events.ArchiveEvent = function (type, archive) {
    Events.Event.call(this, type, false);
    this.type = type;
    this.id = archive.id;
    this.name = archive.name;
    this.status = archive.status;
    this.archive = archive;
  };

  Events.ArchiveUpdatedEvent = function (stream, key, oldValue, newValue) {
    Events.Event.call(this, 'updated', false);
    this.target = stream;
    this.changedProperty = key;
    this.oldValue = oldValue;
    this.newValue = newValue;
  };

  /**
   * The Session object dispatches a signal event when the client receives a signal from the
   * session.
   *
   * @class SignalEvent
   * @property {String} type The type assigned to the signal (if there is one). Use the type to
   * filter signals received (by adding an event handler for signal:type1 or signal:type2, etc.)
   * @property {String} data The data string sent with the signal (if there is one).
   * @property {Connection} from The Connection corresponding to the client that sent the
   * signal.
   *
   * @see <a href="Session.html#signal">Session.signal()</a></p>
   * @see <a href="Session.html#events">Session events (signal and signal:type)</a></p>
   * @augments Event
   */
  Events.SignalEvent = function (type, data, from) {
    Events.Event.call(this, type ? 'signal:' + type : Events.Event.names.SIGNAL, false);
    this.data = data;
    this.from = from;
  };

  Events.StreamUpdatedEvent = function (stream, key, oldValue, newValue) {
    Events.Event.call(this, 'updated', false);
    this.target = stream;
    this.changedProperty = key;
    this.oldValue = oldValue;
    this.newValue = newValue;
  };

  Events.DestroyedEvent = function (type, target, reason) {
    Events.Event.call(this, type, false);
    this.target = target;
    this.reason = reason;
  };

  Events.ConnectionStateChangedEvent = function (type, target) {
    Events.Event.call(this, type, false);
    this.target = target;
  };

  /**
   * Defines the event object for the <code>videoDisabled</code> and <code>videoEnabled</code>
   * events dispatched by the Subscriber.
   *
   * @class VideoEnabledChangedEvent
   *
   * @property {Boolean} cancelable Whether the event has a default behavior that is cancelable
   * (<code>true</code>) or not (<code>false</code>). You can cancel the default behavior by
   * calling the <code>preventDefault()</code> method of the event object in the callback
   * function. (See <a href="#preventDefault">preventDefault()</a>.)
   *
   * @property {String} reason The reason the video was disabled or enabled. This can be set to one
   * of the following values:
   *
   * <ul>
   *
   *   <li><code>"publishVideo"</code> &mdash; The publisher started or stopped publishing video,
   *   by calling <code>publishVideo(true)</code> or <code>publishVideo(false)</code>.</li>
   *
   *   <li><code>"quality"</code> &mdash; The OpenTok Media Router starts or stops sending video
   *   to the subscriber based on stream quality changes. This feature of the OpenTok Media
   *   Router has a subscriber drop the video stream when connectivity degrades. (The subscriber
   *   continues to receive the audio stream, if there is one.)
   *   <p>
   *   If connectivity improves to support video again, the Subscriber object dispatches
   *   a <code>videoEnabled</code> event, and the Subscriber resumes receiving video.
   *   <p>
   *   By default, the Subscriber displays a video disabled indicator when a
   *   <code>videoDisabled</code> event with this reason is dispatched and removes the indicator
   *   when the <code>videoEnabled</code> event with this reason is dispatched. You can control
   *   the display of this icon by calling the <code>setStyle()</code> method of the Subscriber,
   *   setting the <code>videoDisabledDisplayMode</code> property(or you can set the style when
   *   calling the <code>Session.subscribe()</code> method, setting the <code>style</code> property
   *   of the <code>properties</code> parameter).
   *   <p>
   *   This feature is only available in sessions that use the OpenTok Media Router (sessions with
   *   the <a href="http://tokbox.com/opentok/tutorials/create-session/#media-mode">media mode</a>
   *   set to routed), not in sessions with the media mode set to relayed.
   *   </li>
   *
   *   <li><code>"subscribeToVideo"</code> &mdash; The subscriber started or stopped subscribing to
   *   video, by calling <code>subscribeToVideo(true)</code> or
   *   <code>subscribeToVideo(false)</code>.</li>
   *
   * </ul>
   *
   * @property {Object} target The object that dispatched the event.
   *
   * @property {String} type  The type of event: <code>"videoDisabled"</code> or
   * <code>"videoEnabled"</code>.
   *
   * @see <a href="Subscriber.html#event:videoDisabled">Subscriber videoDisabled event</a></p>
   * @see <a href="Subscriber.html#event:videoEnabled">Subscriber videoEnabled event</a></p>
   * @augments Event
   */
  Events.VideoEnabledChangedEvent = function (type, properties) {
    Events.Event.call(this, type, false);
    this.reason = properties.reason;
  };

  Events.VideoDisableWarningEvent = function (type /* , properties*/) {
    Events.Event.call(this, type, false);
  };

  /**
   * Dispatched periodically by a Subscriber or Publisher object to indicate the audio
   * level. This event is dispatched up to 60 times per second, depending on the browser.
   *
   * @property {Number} audioLevel The audio level, from 0 to 1.0. Adjust this value logarithmically
   * for use in adjusting a user interface element, such as a volume meter. Use a moving average
   * to smooth the data.
   *
   * @class AudioLevelUpdatedEvent
   * @augments Event
   */
  Events.AudioLevelUpdatedEvent = function (audioLevel) {
    Events.Event.call(this, Events.Event.names.AUDIO_LEVEL_UPDATED, false);
    this.audioLevel = audioLevel;
  };

  Events.MediaStoppedEvent = function (target, track) {
    Events.Event.call(this, Events.Event.names.MEDIA_STOPPED, true);
    this.target = target;
    this.track = track;
  };

  /**
   * Dispatched by a Subscriber or Publisher object to indicate the <code>video</code> element
   * (or <code>object</code> element in Internet Explorer) was created. Add a listener for this event
   * when you set the <code>insertDefaultUI</code> option to <code>false</code> in the call to the
   * <a href="OT.html#initPublisher">OT.initPublisher()</a> method or the
   * <a href="Session.html#subscribe">Session.subscribe()</a> method. The <code>element</code>
   * property of the event object is a reference to the Publisher's <code>video</code> element
   * (or the <code>object</code> element in Internet Explorer). Add it to the HTML DOM to display the
   * video. (When you set the <code>insertDefaultUI</code> option to <code>false</code>, the
   * <code>video</code> element is not inserted into the DOM automatically.)
   * <p>
   * Add a listener for this event only if you have set the <code>insertDefaultUI</code> option to
   * <code>false</code>. If you have not set <code>insertDefaultUI</code> option
   * to <code>false</code>, do not move the <code>video</code> element (or the <code>object</code>
   * element containing the video in Internet Explorer) in the HTML DOM. Doing so causes the
   * Publisher or Subscriber object to be destroyed.
   *
   * @property {Number} element A reference to the Publisher or Subscriber's <code>video</code>
   * element (or in Internet Explorer the <code>object</code> element containing the video).
   * Add it to the HTML DOM to display the video.
   *
   * @class VideoElementCreatedEvent
   * @augments Event
   */
  Events.VideoElementCreatedEvent = function (element) {
    Events.Event.call(this, Events.Event.names.VIDEO_ELEMENT_CREATED, false);
    this.element = element;
  };

  return Events;
};

},{"../common-js-helpers/OTHelpers.js":217,"./logging.js":312}],307:[function(require,module,exports){
"use strict";

module.exports = {
  JS_EXCEPTION: 2000,
  AUTHENTICATION_ERROR: 1004,
  INVALID_SESSION_ID: 1005,
  CONNECT_FAILED: 1006,
  CONNECT_REJECTED: 1007,
  CONNECTION_TIMEOUT: 1008,
  NOT_CONNECTED: 1010,
  INVALID_PARAMETER: 1011,
  P2P_CONNECTION_FAILED: 1013,
  API_RESPONSE_FAILURE: 1014,
  TERMS_OF_SERVICE_FAILURE: 1026,
  CONNECTION_LIMIT_EXCEEDED: 1027,
  UNABLE_TO_PUBLISH: 1500,
  UNABLE_TO_SUBSCRIBE: 1501,
  UNABLE_TO_FORCE_DISCONNECT: 1520,
  UNABLE_TO_FORCE_UNPUBLISH: 1530,
  PUBLISHER_ICE_WORKFLOW_FAILED: 1553,
  SUBSCRIBER_ICE_WORKFLOW_FAILED: 1554,
  STREAM_LIMIT_EXCEEDED: 1605,
  UNEXPECTED_SERVER_RESPONSE: 2001,
  REPORT_ISSUE_ERROR: 2011,
  ANVIL_BADLY_FORMED_RESPONSE: 3001,
  ANVIL_INVALID_HTTP_STATUS: 3002,
  ANVIL_XDOMAIN_OR_PARSING_ERROR: 3003,
  ANVIL_UNKNOWN_HTTP_ERROR: 3004,
  ANVIL_UNEXPECTED_ERROR_CODE: 3005,
  ANVIL_EMPTY_RESPONSE_BODY: 3006
};

},{}],308:[function(require,module,exports){
'use strict';

// @todo enable the following disabled rules see OPENTOK-31136 for more info
/* eslint-disable no-param-reassign, global-require */

module.exports = function generateSimpleStateMachineFactory() {
  var deps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var OTHelpers = deps.OTHelpers || require('../common-js-helpers/OTHelpers.js');

  // A Factory method for generating simple state machine classes.
  //
  // @usage
  //    var StateMachine = generateSimpleStateMachine('start', ['start', 'middle', 'end', {
  //      start: ['middle'],
  //      middle: ['end'],
  //      end: ['start']
  //    }]);
  //
  //    var states = new StateMachine();
  //    state.current;            // <-- start
  //    state.set('middle');
  //
  return function generateSimpleStateMachine(initialState, states, transitions) {
    var validStates = states.slice();
    var validTransitions = OTHelpers.clone(transitions);

    var isValidState = function isValidState(state) {
      return validStates.indexOf(state) !== -1;
    };

    var isValidTransition = function isValidTransition(fromState, toState) {
      return validTransitions[fromState] && validTransitions[fromState].indexOf(toState) !== -1;
    };

    return function (stateChangeFailed) {
      var currentState = initialState;
      var previousState = null;

      this.current = currentState;

      function signalChangeFailed(message, newState) {
        stateChangeFailed({
          message: message,
          newState: newState,
          currentState: currentState,
          previousState: previousState
        });
      }

      // Validates +newState+. If it's invalid it triggers stateChangeFailed and returns false.
      function handleInvalidStateChanges(newState) {
        if (!isValidState(newState)) {
          signalChangeFailed('\'' + newState + '\' is not a valid state', newState);

          return false;
        }

        if (!isValidTransition(currentState, newState)) {
          signalChangeFailed('\'' + currentState + '\' cannot transition to \'' + newState + '\'', newState);

          return false;
        }

        return true;
      }

      this.set = function (newState) {
        if (!handleInvalidStateChanges(newState)) {
          return;
        }
        previousState = currentState;
        this.current = newState;
        currentState = newState;
      };
    };
  };
};

},{"../common-js-helpers/OTHelpers.js":217}],309:[function(require,module,exports){
'use strict';

var _require = require('../helpers/device_helpers.js')(),
    getMediaDevices = _require.getMediaDevices;

/**
 * Enumerates the audio input devices (such as microphones) and video input devices
 * (cameras) available to the browser.
 * <p>
 * The array of devices is passed in as the <code>devices</code> parameter of
 * the <code>callback</code> function passed into the method.
 *
 * @param callback {Function} The callback function invoked when the list of devices
 * devices is available. This function takes two parameters:
 * <ul>
 *   <li><code>error</code> &mdash; This is set to an error object when
 *   there is an error in calling this method; it is set to <code>null</code>
 *   when the call succeeds.</li>
 *
 *   <li><p><code>devices</code> &mdash; An array of objects corresponding to
 *   available microphones and cameras. Each object has three properties: <code>kind</code>,
 *   <code>deviceId</code>, and <code>label</code>, each of which are strings.
 *   <p>
 *   The <code>kind</code> property is set to <code>"audioInput"</code> for audio input
 *   devices or <code>"videoInput"</code> for video input devices.
 *   <p>
 *   The <code>deviceId</code> property is a unique ID for the device. You can pass
 *   the <code>deviceId</code> in as the <code>audioSource</code> or <code>videoSource</code>
 *   property of the <code>options</code> parameter of the
 *   <a href="#initPublisher">OT.initPublisher()</a> method.
 *   <p>
 *   The <code>label</code> property identifies the device. The <code>label</code>
 *   property is set to an empty string if the user has not previously granted access to
 *   a camera and microphone. In HTTP, the user must have granted access to a camera and
 *   microphone in the current page (for example, in response to a call to
 *   <code>OT.initPublisher()</code>). In HTTPS, the user must have previously granted access
 *   to the camera and microphone in the current page or in a page previously loaded from the
 *   domain.</li>
 * </ul>
 *
 * @see <a href="#initPublisher">OT.initPublisher()</a>
 * @method OT.getDevices
 * @memberof OT
 */


module.exports = function getDevices(callback) {
  getMediaDevices().then(function (devices) {
    return callback(undefined, devices);
  }, callback);
};

},{"../helpers/device_helpers.js":251}],310:[function(require,module,exports){
'use strict';

// @todo enable the following disabled rules see OPENTOK-31136 for more info
/* eslint-disable global-require */

module.exports = function interpretPeerConnectionErrorFactory() {
  var _Subscribe;

  var deps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var Errors = deps.Errors || require('./Errors.js');
  var ExceptionCodes = deps.ExceptionCodes || require('./exception_codes.js');
  var otError = deps.otError || require('../helpers/otError.js')();

  var errorPrefixMap = {
    ICEWorkflow: Errors.ICE_WORKFLOW_FAILED,
    NewPeerConnection: Errors.CREATE_PEER_CONNECTION_FAILED,
    SetRemoteDescription: Errors.SET_REMOTE_DESCRIPTION_FAILED,
    Subscribe: (_Subscribe = {
      404: Errors.STREAM_NOT_FOUND
    }, _Subscribe[ExceptionCodes.STREAM_LIMIT_EXCEEDED] = Errors.STREAM_LIMIT_EXCEEDED, _Subscribe)
  };

  return function interpretPeerConnectionError(httpCode, reason, prefix, remoteConnectionId, className) {
    var message = (prefix ? prefix + ': ' : '') + className + ' PeerConnection with connection ' + remoteConnectionId + ' failed: ' + reason;

    var nameOrCodeMap = errorPrefixMap[prefix] || {};

    var name = typeof nameOrCodeMap === 'string' ? nameOrCodeMap : nameOrCodeMap[httpCode];

    var defaultCode = className === 'Publisher' ? ExceptionCodes.UNABLE_TO_PUBLISH : ExceptionCodes.UNABLE_TO_SUBSCRIBE;

    if (!name) {
      var error = new Error(message);
      error.code = defaultCode;

      return error;
    }

    var code = function () {
      if (prefix === 'ICEWorkflow') {
        return className === 'Publisher' ? ExceptionCodes.PUBLISHER_ICE_WORKFLOW_FAILED : ExceptionCodes.SUBSCRIBER_ICE_WORKFLOW_FAILED;
      }

      if (name === Errors.STREAM_LIMIT_EXCEEDED) {
        return ExceptionCodes.STREAM_LIMIT_EXCEEDED;
      }

      return defaultCode;
    }();

    return otError(name, new Error(message), code);
  };
};

},{"../helpers/otError.js":271,"./Errors.js":288,"./exception_codes.js":307}],311:[function(require,module,exports){
(function (global){
"use strict";

module.exports = function IntervalRunnerFactory() {
  /*
   * Executes the provided callback thanks to <code>global.setInterval</code>.
   *
   * @param {function()} callback
   * @param {number} frequency how many times per second we want to execute the callback
   * @constructor
   */

  return function IntervalRunner(callback, frequency) {
    var intervalId = null;

    this.start = function () {
      if (intervalId != null) {
        return;
      }
      intervalId = global.setInterval(callback, 1000 / frequency);
    };

    this.stop = function () {
      if (intervalId == null) {
        return;
      }
      global.clearInterval(intervalId);
      intervalId = null;
    };
  };
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],312:[function(require,module,exports){
'use strict';

// @todo enable the following disabled rules see OPENTOK-31136 for more info
/* eslint-disable no-underscore-dangle */

var bluebird = require('bluebird');

var OTHelpers = require('../common-js-helpers/OTHelpers.js');
var otProperties = require('../helpers/otProperties.js');

var logging = {};
module.exports = logging;

OTHelpers.useLogHelpers(logging);

var _debugHeaderLogged = false;
var _setLogLevel = logging.setLogLevel;

// On the first time log level is set to DEBUG (or higher) show version info.
logging.setLogLevel = function (level) {
  // Set OTHelpers to the same log level
  OTHelpers.setLogLevel(level);
  var retVal = _setLogLevel.call(logging, level);

  if (!_debugHeaderLogged) {
    logging.debug('OpenTok JavaScript library ' + otProperties.version);
    logging.debug('Release notes: ' + otProperties.websiteURL + '/opentok/webrtc/docs/js/release-notes.html');
    logging.debug('Known issues: ' + otProperties.websiteURL + '/opentok/webrtc/docs/js/release-notes.html#knownIssues');
    _debugHeaderLogged = true;
  }

  bluebird.config({
    warnings: retVal >= logging.DEBUG
  });

  logging.debug('OT.setLogLevel(' + retVal + ')');
  return retVal;
};

var debugTrue = otProperties.debug === 'true' || otProperties.debug === true;
logging.setLogLevel(debugTrue ? logging.DEBUG : logging.WARN);

// TODO: these methods need to be re-exposed for public use on OT :-(

/**
  * Sets the API log level.
  * <p>
  * Calling <code>OT.setLogLevel()</code> sets the log level for runtime log messages that
  * are the OpenTok library generates. The default value for the log level is
  * <code>OT.ERROR</code>.
  * </p>
  * <p>
  * The OpenTok JavaScript library displays log messages in the debugger console (such as
  * Firebug), if one exists.
  * </p>
  * <p>
  * The following example logs the session ID to the console, by calling <code>OT.log()</code>.
  * The code also logs an error message when it attempts to publish a stream before you have
  * connected to the session (by calling <code>Session.connect()</code>).
  * </p>
  * <pre>
  * OT.setLogLevel(OT.LOG);
  * session = OT.initSession(sessionId);
  * OT.log(sessionId);
  * publisher = OT.initPublisher("publishContainer");
  * session.publish(publisher);
  * </pre>
  *
  * @param {Number} logLevel The degree of logging desired by the developer:
  *
  * <p>
  * <ul>
  *   <li>
  *     <code>OT.NONE</code> &#151; API logging is disabled.
  *   </li>
  *   <li>
  *     <code>OT.ERROR</code> &#151; Logging of errors only.
  *   </li>
  *   <li>
  *     <code>OT.WARN</code> &#151; Logging of warnings and errors.
  *   </li>
  *   <li>
  *     <code>OT.INFO</code> &#151; Logging of other useful information, in addition to
  *     warnings and errors.
  *   </li>
  *   <li>
  *     <code>OT.LOG</code> &#151; Logging of <code>OT.log()</code> messages, in addition
  *     to OpenTok info, warning,
  *     and error messages.
  *   </li>
  *   <li>
  *     <code>OT.DEBUG</code> &#151; Fine-grained logging of all API actions, as well as
  *     <code>OT.log()</code> messages.
  *   </li>
  * </ul>
  * </p>
  *
  * @name OT.setLogLevel
  * @memberof OT
  * @function
  * @see <a href="#log">OT.log()</a>
  */

/**
  * Sends a string to the debugger console. However, the function only logs to the console
  * if you have set the log level to <code>OT.LOG</code> or <code>OT.DEBUG</code>,
  * by calling <code>OT.setLogLevel(OT.LOG)</code> or <code>OT.setLogLevel(OT.DEBUG)</code>.
  *
  * @param {String} message The string to log.
  *
  * @name OT.log
  * @memberof OT
  * @function
  * @see <a href="#setLogLevel">OT.setLogLevel()</a>
  */

},{"../common-js-helpers/OTHelpers.js":217,"../helpers/otProperties.js":272,"bluebird":2}],313:[function(require,module,exports){
"use strict";

// @todo enable the following disabled rules see OPENTOK-31136 for more info
/* eslint-disable prefer-rest-params, no-cond-assign */

var DelayedEventQueue = function DelayedEventQueue(eventDispatcher) {
  var queue = [];

  this.enqueue = function enqueue() /* arg1, arg2, ..., argN */{
    queue.push(Array.prototype.slice.call(arguments));
  };

  this.triggerAll = function triggerAll() {
    var event = void 0;

    // Array.prototype.shift is actually pretty inefficient for longer Arrays,
    // this is because after the first element is removed it reshuffles every
    // remaining element up one (1). This involves way too many allocations and
    // deallocations as the queue size increases.
    //
    // A more efficient version could be written by keeping an index to the current
    // 'first' element in the Array and increasing that by one whenever an element
    // is removed. The elements that are infront of the index have been 'deleted'.
    // Periodically the front of the Array could be spliced off to reclaim the space.
    //
    // 1. http://www.ecma-international.org/ecma-262/5.1/#sec-15.4.4.9
    //
    //
    // TLDR: Array.prototype.shift is O(n), where n is the array length,
    // instead of the expected O(1). You can implement your own shift that runs
    // in amortised constant time.
    //
    // @todo benchmark and see if we should actually care about shift's performance
    // for our common queue sizes.
    //
    while (event = queue.shift()) {
      eventDispatcher.trigger.apply(eventDispatcher, event);
    }
  };
};

module.exports = DelayedEventQueue;

},{}],314:[function(require,module,exports){
'use strict';

// Deserialising a Raptor message mainly means doing a JSON.parse on it.
// We do decorate the final message with a few extra helper properies though.
//
// These include:
// * typeName: A human readable version of the Raptor type. E.g. STREAM instead of 102
// * actionName: A human readable version of the Raptor action. E.g. CREATE instead of 101
// * signature: typeName and actionName combined. This is mainly for debugging. E.g. A type
//    of 102 and an action of 101 would result in a signature of "STREAM:CREATE"
//
module.exports = function deserializeMessage(msg) {
  if (msg.length === 0) {
    return {};
  }

  var message = JSON.parse(msg);
  var bits = message.uri.substr(1).split('/');

  // Remove the Raptor protocol version
  bits.shift();
  if (bits[bits.length - 1] === '') {
    bits.pop();
  }

  message.params = {};
  for (var i = 0, numBits = bits.length; i < numBits - 1; i += 2) {
    message.params[bits[i]] = bits[i + 1];
  }

  // extract the resource name. We special case 'channel' slightly, as
  // 'subscriber_channel' or 'stream_channel' is more useful for us
  // than 'channel' alone.
  if (bits.length % 2 === 0) {
    if (bits[bits.length - 2] === 'channel' && bits.length > 6) {
      message.resource = bits[bits.length - 4] + '_' + bits[bits.length - 2];
    } else {
      message.resource = bits[bits.length - 2];
    }
  } else if (bits[bits.length - 1] === 'channel' && bits.length > 5) {
    message.resource = bits[bits.length - 3] + '_' + bits[bits.length - 1];
  } else {
    message.resource = bits[bits.length - 1];
  }

  message.signature = message.resource + '#' + message.method;
  return message;
};

},{}],315:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

// @todo enable the following disabled rules see OPENTOK-31136 for more info
/* eslint-disable prefer-rest-params */

var OTErrorClass = require('../../ot_error_class.js');
var OTHelpers = require('../../../common-js-helpers/OTHelpers.js');
var logging = require('../../logging.js');
var RumorMessageTypes = require('../rumor/rumor_message_types.js');
var unboxFromRumorMessage = require('./unbox_from_rumor_message.js');

var Dispatcher = function Dispatcher() {
  OTHelpers.eventing(this, true);
  this.callbacks = {};
};

module.exports = Dispatcher;

Dispatcher.prototype.registerCallback = function (transactionId, completion) {
  this.callbacks[transactionId] = completion;
};

Dispatcher.prototype.triggerCallback = function (transactionId) {
  /* , arg1, arg2, argN-1, argN*/
  if (!transactionId) {
    return;
  }

  var completion = this.callbacks[transactionId];

  if (completion && OTHelpers.isFunction(completion)) {
    var args = Array.prototype.slice.call(arguments);
    args.shift();

    completion.apply(undefined, args);
  }

  delete this.callbacks[transactionId];
};

Dispatcher.prototype.onClose = function (reason) {
  this.emit('close', reason);
};

Dispatcher.prototype.onReconnected = function () {
  this.emit('reconnected');
};

Dispatcher.prototype.onReconnecting = function () {
  this.emit('reconnecting');
};

Dispatcher.prototype.dispatch = function (rumorMessage) {
  // The special casing of STATUS messages is ugly. Need to think about
  // how to better integrate this.

  if (rumorMessage.type === RumorMessageTypes.STATUS) {
    logging.debug('OT.Raptor.dispatch: STATUS');
    logging.debug(rumorMessage);

    var error = void 0;

    if (rumorMessage.isError) {
      var _message = void 0;
      if (typeof rumorMessage.data === 'string') {
        try {
          var data = JSON.parse(rumorMessage.data);
          if (data && (typeof data === 'undefined' ? 'undefined' : _typeof(data)) === 'object') {
            _message = data.reason;
          }
        } catch (e) {
          logging.warn('OT.Raptor.dispatch Failed to parse rumorMessage.data', e);
        }
      }
      error = new OTErrorClass(rumorMessage.status, _message);
    }

    this.triggerCallback(rumorMessage.transactionId, error, rumorMessage);

    return;
  }

  var message = unboxFromRumorMessage(rumorMessage);
  logging.debug('OT.Raptor.dispatch ' + message.signature + ':', message);

  switch (message.resource) {
    case 'session':
      this.dispatchSession(message);
      break;

    case 'connection':
      this.dispatchConnection(message);
      break;

    case 'stream':
      this.dispatchStream(message);
      break;

    case 'stream_channel':
      this.dispatchStreamChannel(message);
      break;

    case 'subscriber':
      this.dispatchSubscriber(message);
      break;

    case 'subscriber_channel':
      this.dispatchSubscriberChannel(message);
      break;

    case 'signal':
      this.dispatchSignal(message);
      break;

    case 'archive':
      this.dispatchArchive(message);
      break;

    default:
      logging.debug('OT.Raptor.dispatch: Type ' + message.resource + ' is not currently implemented');
  }
};

Dispatcher.prototype.dispatchSession = function (message) {
  switch (message.method) {
    case 'read':
      this.emit('session#read', message.content, message.transactionId);
      break;

    default:
      logging.debug('OT.Raptor.dispatch: ' + message.signature + ' is not currently implemented');
  }
};

Dispatcher.prototype.dispatchConnection = function (message) {
  switch (message.method) {
    case 'created':
      this.emit('connection#created', message.content);
      break;

    case 'deleted':
      this.emit('connection#deleted', message.params.connection, message.reason);
      break;

    default:
      logging.debug('OT.Raptor.dispatch: ' + message.signature + ' is not currently implemented');
  }
};

Dispatcher.prototype.dispatchStream = function (message) {
  switch (message.method) {
    case 'created':
      this.emit('stream#created', message.content, message.transactionId);
      break;

    case 'deleted':
      this.emit('stream#deleted', message.params.stream, message.reason);
      break;

    case 'updated':
      this.emit('stream#updated', message.params.stream, message.content);
      break;

    // The JSEP process
    case 'generateoffer':
    case 'answer':
    case 'pranswer':
    case 'offer':
    case 'candidate':
      this.dispatchJsep(message.method, message);
      break;

    default:
      logging.debug('OT.Raptor.dispatch: ' + message.signature + ' is not currently implemented');
  }
};

Dispatcher.prototype.dispatchStreamChannel = function (message) {
  switch (message.method) {
    case 'updated':
      this.emit('streamChannel#updated', message.params.stream, message.params.channel, message.content);
      break;

    default:
      logging.debug('OT.Raptor.dispatch: ' + message.signature + ' is not currently implemented');
  }
};

// Dispatch JSEP messages
//
// generateoffer:
// Request to generate a offer for another Peer (or Prism). This kicks
// off the JSEP process.
//
// answer:
// generate a response to another peers offer, this contains our constraints
// and requirements.
//
// pranswer:
// a provisional answer, i.e. not the final one.
//
// candidate
//
//
Dispatcher.prototype.dispatchJsep = function (method, message) {
  this.emit('jsep#' + method, message.params.stream, message.fromAddress, message);
};

Dispatcher.prototype.dispatchSubscriberChannel = function (message) {
  switch (message.method) {
    case 'updated':
      this.emit('subscriberChannel#updated', message.params.stream, message.params.channel, message.content);
      break;

    case 'update':
      // subscriberId, streamId, content
      this.emit('subscriberChannel#update', message.params.subscriber, message.params.stream, message.content);
      break;

    default:
      logging.debug('OT.Raptor.dispatch: ' + message.signature + ' is not currently implemented');
  }
};

Dispatcher.prototype.dispatchSubscriber = function (message) {
  switch (message.method) {
    case 'created':
      this.emit('subscriber#created', message.params.stream, message.fromAddress, message.content.id);
      break;

    case 'deleted':
      this.dispatchJsep('unsubscribe', message);
      this.emit('subscriber#deleted', message.params.stream, message.fromAddress);
      break;

    // The JSEP process
    case 'generateoffer':
    case 'answer':
    case 'pranswer':
    case 'offer':
    case 'candidate':
      this.dispatchJsep(message.method, message);
      break;

    default:
      logging.debug('OT.Raptor.dispatch: ' + message.signature + ' is not currently implemented');
  }
};

Dispatcher.prototype.dispatchSignal = function (message) {
  if (message.method !== 'signal') {
    logging.debug('OT.Raptor.dispatch: ' + message.signature + ' is not currently implemented');
    return;
  }
  this.emit('signal', message.fromAddress, message.content);
};

Dispatcher.prototype.dispatchArchive = function (message) {
  switch (message.method) {
    case 'created':
      this.emit('archive#created', message.content);
      break;

    case 'updated':
      this.emit('archive#updated', message.params.archive, message.content);
      break;

    default:
  }
};

},{"../../../common-js-helpers/OTHelpers.js":217,"../../logging.js":312,"../../ot_error_class.js":334,"../rumor/rumor_message_types.js":330,"./unbox_from_rumor_message.js":325}],316:[function(require,module,exports){
'use strict';

var RaptorConstants = require('./raptor_constants.js');

var Raptor = {};

Raptor.Actions = RaptorConstants.Actions;
Raptor.Types = RaptorConstants.Types;
Raptor.Dispatcher = require('./dispatcher.js');
Raptor.serializeMessage = require('./serialize_message.js');
Raptor.deserializeMessage = require('./deserialize_message.js');
Raptor.unboxFromRumorMessage = require('./unbox_from_rumor_message.js');
Raptor.parseIceServers = require('./parse_ice_servers.js').parseIceServers;
Raptor.Message = require('./message.js');
Raptor.Socket = require('./raptor_socket.js')();

module.exports = Raptor;

},{"./deserialize_message.js":314,"./dispatcher.js":315,"./message.js":317,"./parse_ice_servers.js":318,"./raptor_constants.js":319,"./raptor_socket.js":320,"./serialize_message.js":321,"./unbox_from_rumor_message.js":325}],317:[function(require,module,exports){
'use strict';

// @todo enable the following disabled rules see OPENTOK-31136 for more info
/* eslint-disable no-void */

var uuid = require('uuid');

var OTHelpers = require('../../../common-js-helpers/OTHelpers.js');

var hasBundleCapability = require('../../../helpers/hasBundleCapability.js');
var hasRTCPMuxCapability = require('../../../helpers/hasRTCPMuxCapability.js');
var serializeMessage = require('./serialize_message.js');
var supportedCryptoScheme = require('../../../helpers/supported_crypto_scheme.js');
var otProperties = require('../../../helpers/otProperties.js');

var Message = {};
module.exports = Message;

Message.offer = function (uri, offerSdp) {
  return serializeMessage({
    method: 'offer',
    uri: uri,
    content: {
      sdp: offerSdp
    }
  });
};

Message.answer = function (uri, answerSdp) {
  return serializeMessage({
    method: 'answer',
    uri: uri,
    content: {
      sdp: answerSdp
    }
  });
};

Message.candidate = function (uri, candidate) {
  return serializeMessage({
    method: 'candidate',
    uri: uri,
    content: candidate
  });
};

Message.connections = {};

Message.connections.create = function (opt) {
  var apiKey = opt.apiKey;
  var sessionId = opt.sessionId;
  var connectionId = opt.connectionId;
  var connectionEventsSuppressed = opt.connectionEventsSuppressed;
  var capabilities = opt.capabilities;

  return serializeMessage({
    method: 'create',
    uri: '/v2/partner/' + apiKey + '/session/' + sessionId + '/connection/' + connectionId,
    content: {
      userAgent: OTHelpers.env.userAgent,
      clientVersion: 'js-' + otProperties.version.replace('v', ''),
      capabilities: capabilities || [],
      connectionEventsSuppressed: connectionEventsSuppressed
    }
  });
};

Message.connections.destroy = function (opt) {
  var apiKey = opt.apiKey;
  var sessionId = opt.sessionId;
  var connectionId = opt.connectionId;

  return serializeMessage({
    method: 'delete',
    uri: '/v2/partner/' + apiKey + '/session/' + sessionId + '/connection/' + connectionId,
    content: {}
  });
};

Message.sessions = {};

Message.sessions.get = function (apiKey, sessionId) {
  return serializeMessage({
    method: 'read',
    uri: '/v2/partner/' + apiKey + '/session/' + sessionId,
    content: {}
  });
};

Message.streams = {};

Message.streams.get = function (apiKey, sessionId, streamId) {
  return serializeMessage({
    method: 'read',
    uri: '/v2/partner/' + apiKey + '/session/' + sessionId + '/stream/' + streamId,
    content: {}
  });
};

Message.streams.channelFromOTChannel = function (channel) {
  var raptorChannel = {
    id: channel.id,
    type: channel.type,
    active: channel.active
  };

  if (channel.type === 'video') {
    raptorChannel.width = channel.width;
    raptorChannel.height = channel.height;
    raptorChannel.orientation = channel.orientation;
    raptorChannel.frameRate = channel.frameRate;
    if (channel.source !== 'default') {
      raptorChannel.source = channel.source;
    }
    raptorChannel.fitMode = channel.fitMode;
  }

  return raptorChannel;
};

Message.streams.create = function (apiKey, sessionId, streamId, name, audioFallbackEnabled, channels, minBitrate, maxBitrate) {
  var messageContent = {
    id: streamId,
    name: name,
    audioFallbackEnabled: audioFallbackEnabled,
    channel: channels.map(function (channel) {
      return Message.streams.channelFromOTChannel(channel);
    })
  };

  if (minBitrate) {
    messageContent.minBitrate = Math.round(minBitrate);
  }
  if (maxBitrate) {
    messageContent.maxBitrate = Math.round(maxBitrate);
  }

  return serializeMessage({
    method: 'create',
    uri: '/v2/partner/' + apiKey + '/session/' + sessionId + '/stream/' + streamId,
    content: messageContent
  });
};

Message.streams.destroy = function (apiKey, sessionId, streamId) {
  return serializeMessage({
    method: 'delete',
    uri: '/v2/partner/' + apiKey + '/session/' + sessionId + '/stream/' + streamId,
    content: {}
  });
};

Message.streamChannels = {};

Message.streamChannels.update = function (apiKey, sessionId, streamId, channelId, attributes) {
  return serializeMessage({
    method: 'update',
    uri: '/v2/partner/' + apiKey + '/session/' + sessionId + '/stream/' + streamId + '/channel/' + channelId,
    content: attributes
  });
};

Message.subscribers = {};

Message.subscribers.uri = function (apiKey, sessionId, streamId, subscriberId) {
  return '/v2/partner/' + apiKey + '/session/' + sessionId + '/stream/' + streamId + '/subscriber/' + subscriberId;
};

Message.subscribers.create = function (apiKey, sessionId, streamId, subscriberId, connectionId, channelsToSubscribeTo) {
  var content = {
    id: subscriberId,
    connection: connectionId,
    keyManagementMethod: supportedCryptoScheme(),
    bundleSupport: hasBundleCapability(),
    rtcpMuxSupport: hasRTCPMuxCapability()
  };

  if (channelsToSubscribeTo) {
    content.channel = channelsToSubscribeTo;
  }

  return serializeMessage({
    method: 'create',
    uri: '/v2/partner/' + apiKey + '/session/' + sessionId + '/stream/' + streamId + '/subscriber/' + subscriberId,
    content: content
  });
};

Message.subscribers.destroy = function (apiKey, sessionId, streamId, subscriberId) {
  return serializeMessage({
    method: 'delete',
    uri: '/v2/partner/' + apiKey + '/session/' + sessionId + '/stream/' + streamId + '/subscriber/' + subscriberId,
    content: {}
  });
};

Message.subscribers.update = function (apiKey, sessionId, streamId, subscriberId, attributes) {
  return serializeMessage({
    method: 'update',
    uri: '/v2/partner/' + apiKey + '/session/' + sessionId + '/stream/' + streamId + '/subscriber/' + subscriberId,
    content: attributes
  });
};

Message.subscriberChannels = {};

Message.subscriberChannels.update = function (apiKey, sessionId, streamId, subscriberId, channelId, attributes) {
  return serializeMessage({
    method: 'update',
    uri: '/v2/partner/' + apiKey + '/session/' + sessionId + '/stream/' + streamId + '/subscriber/' + subscriberId + '/channel/' + channelId,
    content: attributes
  });
};

Message.signals = {};

Message.signals.create = function (apiKey, sessionId, toAddress, type, data) {
  var content = {};
  if (type !== void 0) {
    content.type = type;
  }
  if (data !== void 0) {
    content.data = data;
  }

  return serializeMessage({
    method: 'signal',
    uri: '/v2/partner/' + apiKey + '/session/' + sessionId + (toAddress !== void 0 ? '/connection/' + toAddress : '') + '/signal/' + uuid(),
    content: content
  });
};

},{"../../../common-js-helpers/OTHelpers.js":217,"../../../helpers/hasBundleCapability.js":260,"../../../helpers/hasRTCPMuxCapability.js":266,"../../../helpers/otProperties.js":272,"../../../helpers/supported_crypto_scheme.js":274,"./serialize_message.js":321,"uuid":200}],318:[function(require,module,exports){
"use strict";

exports.adaptIceServers = function adaptIceServers(iceServers) {
  return iceServers.map(function (iceServer) {
    return {
      url: iceServer.url, // deprecated
      urls: iceServer.urls || [iceServer.url],
      username: iceServer.username,
      credential: iceServer.credential
    };
  });
};

exports.parseIceServers = function parseIceServers(message) {
  var iceServers = void 0;

  try {
    iceServers = JSON.parse(message.data).content.iceServers;
  } catch (e) {
    return [];
  }

  return exports.adaptIceServers(iceServers);
};

},{}],319:[function(require,module,exports){
"use strict";

// Rumor Messaging for JS
//
// https://tbwiki.tokbox.com/index.php/Raptor_Messages_(Sent_as_a_RumorMessage_payload_in_JSON)
//
// @todo Raptor {
//     Look at disconnection cleanup: i.e. subscriber + publisher cleanup
//     Add error codes for all the error cases
//     Write unit tests for SessionInfo
//     Write unit tests for Session
//     Make use of the new DestroyedEvent
//     Capabilities must be part of the Raptor namespace
//     Add Dependability commands
//     Think about noConflict, or whether we should just use the OT namespace
//     Think about how to expose sessionObjects.publishers, sessionObjects.subscribers, and
//        sessionObjects.sessions if messaging was being included as a component
//     Another solution to the problem of having publishers/subscribers/etc would be to make
//        Raptor Socket a separate component from Dispatch (dispatch being more business logic)
//     Look at the coupling of sessionObjects.sessions to RaptorSocket
// }
//
// @todo Raptor Docs {
//   Document payload formats for incoming messages (what are the payloads for
//    STREAM CREATED/MODIFIED for example)
//   Document how keepalives work
//   Document all the Raptor actions and types
//   Document the session connect flow (including error cases)
// }

module.exports = {
  Actions: {
    // General
    CONNECT: 100,
    CREATE: 101,
    UPDATE: 102,
    DELETE: 103,
    STATE: 104,

    // Moderation
    FORCE_DISCONNECT: 105,
    FORCE_UNPUBLISH: 106,
    SIGNAL: 107,

    // Archives
    CREATE_ARCHIVE: 108,
    CLOSE_ARCHIVE: 109,
    START_RECORDING_SESSION: 110,
    STOP_RECORDING_SESSION: 111,
    START_RECORDING_STREAM: 112,
    STOP_RECORDING_STREAM: 113,
    LOAD_ARCHIVE: 114,
    START_PLAYBACK: 115,
    STOP_PLAYBACK: 116,

    // AppState
    APPSTATE_PUT: 117,
    APPSTATE_DELETE: 118,

    // JSEP
    OFFER: 119,
    ANSWER: 120,
    PRANSWER: 121,
    CANDIDATE: 122,
    SUBSCRIBE: 123,
    UNSUBSCRIBE: 124,
    QUERY: 125,
    SDP_ANSWER: 126,

    // KeepAlive
    PONG: 127,
    REGISTER: 128, // Used for registering streams.

    QUALITY_CHANGED: 129
  },

  Types: {
    // RPC
    RPC_REQUEST: 100,
    RPC_RESPONSE: 101,

    // EVENT
    STREAM: 102,
    ARCHIVE: 103,
    CONNECTION: 104,
    APPSTATE: 105,
    CONNECTIONCOUNT: 106,
    MODERATION: 107,
    SIGNAL: 108,
    SUBSCRIBER: 110,

    // JSEP Protocol
    JSEP: 109
  }
};

},{}],320:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

// @todo enable the following disabled rules see OPENTOK-31136 for more info
/* eslint-disable no-param-reassign, global-require, one-var, no-underscore-dangle */
/* eslint-disable prefer-rest-params, prefer-const, no-shadow, max-len */

var assign = require('lodash/assign');
var once = require('lodash/once');
var uuid = require('uuid');

module.exports = function RaptorSocketFactory() {
  var deps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var analytics = deps.analytics || require('../../analytics.js');
  var convertRumorError = deps.convertRumorError || require('../../../helpers/convertRumorError.js');
  var Dispatcher = deps.Dispatcher || require('./dispatcher.js');
  var ExceptionCodes = deps.ExceptionCodes || require('../../exception_codes.js');
  var hasIceRestartsCapability = deps.hasIceRestartsCapability || require('../../../helpers/hasIceRestartsCapability.js');
  var hasRenegotiationCapability = deps.hasRenegotiationCapability || require('../../../helpers/hasRenegotiationCapability.js');
  var logging = deps.logging || require('../../logging.js');
  var Message = deps.Message || require('./message.js');
  var OTHelpers = deps.OTHelpers || require('../../../common-js-helpers/OTHelpers.js');
  var RumorSocket = deps.RumorSocket || require('../rumor/rumor_socket.js');
  var Signal = deps.Signal || require('./signal.js');
  var SignalError = deps.SignalError || require('./signal_error.js');

  // The Dispatcher bit is purely to make testing simpler, it defaults to a new Dispatcher so in
  // normal operation you would omit it.
  var RaptorSocket = function RaptorSocket(connectionId, widgetId, messagingSocketUrl, symphonyUrl, dispatcher) {
    var _apiKey = void 0,
        _sessionId = void 0,
        _token = void 0,
        _rumor = void 0,
        _completion = void 0,
        _p2p = void 0,
        _messagingServer = void 0;
    var _states = ['disconnected', 'connecting', 'connected', 'error', 'disconnecting'];

    var _dispatcher = dispatcher || new Dispatcher();

    // // Private API
    var setState = OTHelpers.statable(this, _states, 'disconnected');

    var logAnalyticsEvent = function logAnalyticsEvent(opt) {
      if (!opt.action || !opt.variation) {
        logging.debug('Expected action and variation');
      }

      analytics.logEvent(assign({
        sessionId: _sessionId,
        partnerId: _apiKey,
        p2p: _p2p,
        messagingServer: _messagingServer,
        connectionId: connectionId
      }, opt));
    };

    var onConnectComplete = function onConnectComplete(error) {
      if (error) {
        setState('error');
      } else {
        setState('connected');
      }

      _completion.apply(undefined, arguments);
    };

    var onClose = function onClose(err) {
      var reason = 'clientDisconnected';
      if (!this.is('disconnecting') && _rumor.is('error')) {
        reason = 'networkDisconnected';
      }
      if (err && err.code === 4001) {
        reason = 'networkTimedout';
      }

      setState('disconnected');

      _dispatcher.onClose(reason);
    }.bind(this);

    var onError = function onError(err) {
      logging.error('OT.Raptor.Socket error:', err);
    };
    // @todo what does having an error mean? Are they always fatal? Are we disconnected now?

    var onReconnecting = function onReconnecting() {
      _dispatcher.onReconnecting();
    };

    var onReconnected = function onReconnected() {
      logAnalyticsEvent({
        action: 'Reconnect',
        variation: 'Success',
        retries: _rumor.reconnectRetriesCount(),
        messageQueueSize: _rumor.messageQueueSize(),
        socketId: _rumor.socketID()
      });

      _dispatcher.onReconnected();
    };

    var onReconnectAttempt = function onReconnectAttempt() {
      logAnalyticsEvent({
        action: 'Reconnect',
        variation: 'Attempt',
        retries: _rumor.reconnectRetriesCount(),
        messageQueueSize: _rumor.messageQueueSize(),
        socketId: _rumor.socketID()
      });
    };

    var onReconnectFailure = function onReconnectFailure(error) {
      if (error.message === 'connectionLimitExceeded') {
        error.code = ExceptionCodes.CONNECTION_LIMIT_EXCEEDED;
      }
      error.reason = 'ConnectToSession';

      var converted = convertRumorError(error);

      logAnalyticsEvent({
        action: 'Reconnect',
        variation: 'Failure',
        failureReason: error.reason,
        failureCode: converted.code,
        failureMessage: converted.message,
        messageQueueSize: _rumor.messageQueueSize(),
        socketId: _rumor.socketID()
      });
    };

    // // Public API

    this.connect = function (token, sessionInfo, opt, completion) {
      var _this = this;

      if (!this.is('disconnected', 'error')) {
        logging.warn('Cannot connect the Raptor Socket as it is currently connected. You should ' + 'disconnect first.');
        return;
      }

      setState('connecting');
      _apiKey = sessionInfo.partnerId;
      _sessionId = sessionInfo.sessionId;
      _p2p = sessionInfo.p2pEnabled;
      _messagingServer = sessionInfo.messagingServer;
      _token = token;
      _completion = completion;

      var rumorChannel = '/v2/partner/' + _apiKey + '/session/' + _sessionId;

      _rumor = new RaptorSocket.RumorSocket({
        messagingURL: messagingSocketUrl,
        notifyDisconnectAddress: symphonyUrl,
        connectionId: connectionId,
        enableReconnection: sessionInfo.reconnection
      });

      _rumor.onClose(onClose);
      _rumor.onError(onError);
      _rumor.onReconnecting(onReconnecting);
      _rumor.onReconnectAttempt(onReconnectAttempt);
      _rumor.onReconnectFailure(onReconnectFailure);
      _rumor.onReconnected(onReconnected);
      _rumor.onMessage(_dispatcher.dispatch.bind(_dispatcher));

      _rumor.connect(function (error) {
        if (error) {
          onConnectComplete({
            reason: 'WebSocketConnection',
            code: error.code,
            message: error.message
          });
          return;
        }

        logging.debug('OT.Raptor.Socket connected. Subscribing to ' + rumorChannel + ' on ' + messagingSocketUrl);

        _rumor.subscribe([rumorChannel]);

        var capabilities = [];
        var supportRenegotiation = (RaptorSocket.hasIceRestartsCapability() || RaptorSocket.hasRenegotiationCapability()) && sessionInfo.renegotiation;

        if (supportRenegotiation) {
          capabilities.push('renegotiation');
          capabilities.push('regeneration');
        }

        // connect to session
        var connectMessage = Message.connections.create({
          apiKey: _apiKey,
          sessionId: _sessionId,
          connectionId: _rumor.id(),
          connectionEventsSuppressed: opt.connectionEventsSuppressed,
          capabilities: capabilities
        });
        _this.publish(connectMessage, { 'X-TB-TOKEN-AUTH': _token }, true, function (error, reply) {
          if (error) {
            if (error.message === 'connectionLimitExceeded') {
              error.code = ExceptionCodes.CONNECTION_LIMIT_EXCEEDED;
            }
            onConnectComplete({
              reason: 'ConnectToSession',
              code: error.code,
              message: error.message,
              socketId: _rumor.socketID()
            });
            return;
          }

          var onSessionState = function onSessionState(error, sessionState) {
            if (error) {
              onConnectComplete({
                reason: 'GetSessionState',
                code: error.code,
                message: error.message,
                socketId: _rumor.socketID()
              });
            } else {
              onConnectComplete(undefined, sessionState);
            }
          };

          var replyData = reply && reply.data ? JSON.parse(reply.data) : null;

          if (replyData && replyData.connection) {
            // OPENTOK-27994: Unfortunately, we need to send a fake session#read into the dispatcher
            // in order to get the right side effects to happen to the Session. Ideally, we could
            // transform the data here and send it into the completion handler for Session to decide
            // for itself what to do with it. The problem is that SessionDispatcher contains both
            // transformation code that belongs here and Session manipulation that belongs in Session,
            // and refactoring that structure isn't appropriate right now.
            var transactionId = uuid();
            _dispatcher.registerCallback(transactionId, onSessionState);
            _dispatcher.emit('session#read', replyData, transactionId);
          } else {
            // Older implementations do not send session#read data in the connect reply, so we have
            // to get it the old way (OPENTOK-27775).
            _this.publish(Message.sessions.get(_apiKey, _sessionId), {}, true, onSessionState);
          }
        });
      });
    };

    this.disconnect = function (drainSocketBuffer) {
      if (this.is('disconnected')) {
        return;
      }

      setState('disconnecting');
      _rumor.disconnect(drainSocketBuffer);
    };

    // Publishes +message+ to the Symphony app server.
    //
    // The completion handler is optional, as is the headers
    // dict, but if you provide the completion handler it must
    // be the last argument.
    //
    this.publish = function (message, headers, retryAfterReconnect, completion) {
      completion = completion || function () {};
      var completionOnce = once(completion);

      var transactionId = uuid();

      logging.debug('OT.Raptor.Socket Publish (ID:' + transactionId + ') ' + message);

      if (_rumor.isNot('connected', 'reconnecting') || _rumor.is('reconnecting') && !retryAfterReconnect) {
        var error = new Error('Not connected.');
        error.code = 500;
        completionOnce(error);
        logging.error('OT.Raptor.Socket: cannot publish until the socket is connected.');

        return undefined;
      }

      _dispatcher.registerCallback(transactionId, completionOnce);

      _rumor.publish([symphonyUrl], message, OTHelpers.extend({}, headers, {
        'Content-Type': 'application/x-raptor+v2',
        'TRANSACTION-ID': transactionId,
        'X-TB-FROM-ADDRESS': _rumor.id()
      }), retryAfterReconnect, function (err) {
        // We want to propagate errors from rumor here. In particular, errors
        // related to not receiving a reply due to disconnection. However, when
        // a reply is received, the dispatcher may transform the reply, and may
        // generate an error that would not be recognized here. This isn't the
        // only awkward outcome related to the dispatcher design, and there are
        // plans to address this technical debt: OPENTOK-27994.
        if (err) {
          completionOnce.apply(undefined, arguments);
        }
      });

      return transactionId;
    };

    // Register a new stream against _sessionId
    this.streamCreate = function (name, streamId, audioFallbackEnabled, channels, minBitrate, maxBitrate, completion) {
      var message = Message.streams.create(_apiKey, _sessionId, streamId, name, audioFallbackEnabled, channels, minBitrate, maxBitrate);

      this.publish(message, {}, true, function (error, message) {
        completion(error, streamId, message);
      });
    };

    this.streamDestroy = function (streamId) {
      this.publish(Message.streams.destroy(_apiKey, _sessionId, streamId), {}, true);
    };

    this.streamChannelUpdate = function (streamId, channelId, attributes) {
      this.publish(Message.streamChannels.update(_apiKey, _sessionId, streamId, channelId, attributes), {}, true);
    };

    this.subscriberCreate = function (streamId, subscriberId, channelsToSubscribeTo, completion) {
      this.publish(Message.subscribers.create(_apiKey, _sessionId, streamId, subscriberId, _rumor.id(), channelsToSubscribeTo), {}, true, completion);
    };

    this.subscriberDestroy = function (streamId, subscriberId) {
      this.publish(Message.subscribers.destroy(_apiKey, _sessionId, streamId, subscriberId), {}, true);
    };

    this.subscriberUpdate = function (streamId, subscriberId, attributes) {
      this.publish(Message.subscribers.update(_apiKey, _sessionId, streamId, subscriberId, attributes), {}, true);
    };

    this.subscriberChannelUpdate = function (streamId, subscriberId, channelId, attributes) {
      this.publish(Message.subscriberChannels.update(_apiKey, _sessionId, streamId, subscriberId, channelId, attributes), {}, true);
    };

    this.forceDisconnect = function (connectionIdToDisconnect, completion) {
      this.publish(Message.connections.destroy({
        apiKey: _apiKey,
        sessionId: _sessionId,
        connectionId: connectionIdToDisconnect
      }), {}, true, completion);
    };

    this.forceUnpublish = function (streamIdToUnpublish, completion) {
      this.publish(Message.streams.destroy(_apiKey, _sessionId, streamIdToUnpublish), {}, true, completion);
    };

    this.jsepCandidate = function (uri, candidate) {
      this.publish(Message.candidate(uri, candidate), {}, true);
    };

    this.jsepOffer = function (uri, offerSdp) {
      this.publish(Message.offer(uri, offerSdp), {}, true);
    };

    this.jsepAnswer = function (uri, answerSdp) {
      this.publish(Message.answer(uri, answerSdp), {}, true);
    };

    this.signal = function (options, completion, logEventFn) {
      var signal = new Signal(_sessionId, _rumor.id(), options || {});

      if (!signal.valid) {
        if (completion && OTHelpers.isFunction(completion)) {
          completion(new SignalError(signal.error.code, signal.error.reason), signal.toHash());
        }

        return;
      }

      this.publish(signal.toRaptorMessage(), {}, signal.retryAfterReconnect, function (err) {
        var error = void 0,
            errorCode = void 0,
            errorMessage = void 0;
        var expectedErrorCodes = [400, 403, 404, 413, 500];

        if (err) {
          if (err.code && expectedErrorCodes.indexOf(err.code) > -1) {
            errorCode = err.code;
            errorMessage = err.message;
          } else {
            errorCode = ExceptionCodes.UNEXPECTED_SERVER_RESPONSE;
            errorMessage = 'Unexpected server response. Try this operation again later.';
          }
          error = new SignalError(errorCode, errorMessage);
        } else {
          var typeStr = signal.data ? _typeof(signal.data) : null;
          logEventFn('signal', 'send', { type: typeStr });
        }

        if (completion && OTHelpers.isFunction(completion)) {
          completion(error, signal.toHash());
        }
      });
    };

    this.id = function () {
      return _rumor && _rumor.id();
    };
  };

  RaptorSocket.hasIceRestartsCapability = hasIceRestartsCapability;
  RaptorSocket.hasRenegotiationCapability = hasRenegotiationCapability;
  RaptorSocket.RumorSocket = RumorSocket;

  return RaptorSocket;
};

},{"../../../common-js-helpers/OTHelpers.js":217,"../../../helpers/convertRumorError.js":247,"../../../helpers/hasIceRestartsCapability.js":263,"../../../helpers/hasRenegotiationCapability.js":268,"../../analytics.js":289,"../../exception_codes.js":307,"../../logging.js":312,"../rumor/rumor_socket.js":331,"./dispatcher.js":315,"./message.js":317,"./signal.js":323,"./signal_error.js":324,"lodash/assign":142,"lodash/once":174,"uuid":200}],321:[function(require,module,exports){
"use strict";

module.exports = function serializeMessage(message) {
  return JSON.stringify(message);
};

},{}],322:[function(require,module,exports){
'use strict';

// @todo enable the following disabled rules see OPENTOK-31136 for more info
/* eslint-disable no-shadow, prefer-rest-params, prefer-spread, no-param-reassign */
/* eslint-disable no-mixed-operators, no-cond-assign, one-var */

var Archive = require('../../archive.js');
var Connection = require('../../connection.js');
var DelayedEventQueue = require('./delayed_event_queue.js');
var Dispatcher = require('./dispatcher.js');
var logging = require('../../logging.js');
var OTHelpers = require('../../../common-js-helpers/OTHelpers.js');
var sessionObjects = require('../../session/objects.js');
var Stream = require('../../stream.js');
var StreamChannel = require('../../stream_channel.js');

function parseStream(dict, session) {
  var channel = dict.channel.map(function (channel) {
    return new StreamChannel(channel);
  });

  var connectionId = dict.connectionId ? dict.connectionId : dict.connection.id;

  return new Stream(dict.id, dict.name, dict.creationTime, session.connections.get(connectionId), session, channel);
}

function parseAndAddStreamToSession(dict, session) {
  if (session.streams.has(dict.id)) {
    return undefined;
  }

  var stream = parseStream(dict, session);
  session.streams.add(stream);

  return stream;
}

function parseArchive(dict) {
  return new Archive(dict.id, dict.name, dict.status);
}

function parseAndAddArchiveToSession(dict, session) {
  if (session.archives.has(dict.id)) {
    return undefined;
  }

  var archive = parseArchive(dict);
  session.archives.add(archive);

  return archive;
}

var DelayedSessionEvents = function DelayedSessionEvents(dispatcher) {
  var eventQueues = {};

  this.enqueue = function enqueue() /* key, arg1, arg2, ..., argN */{
    var key = arguments[0];
    var eventArgs = Array.prototype.slice.call(arguments, 1);
    if (!eventQueues[key]) {
      eventQueues[key] = new DelayedEventQueue(dispatcher);
    }
    eventQueues[key].enqueue.apply(eventQueues[key], eventArgs);
  };

  this.triggerConnectionCreated = function triggerConnectionCreated(connection) {
    if (eventQueues['connectionCreated' + connection.id]) {
      eventQueues['connectionCreated' + connection.id].triggerAll();
    }
  };

  this.triggerSessionConnected = function triggerSessionConnected(connections) {
    if (eventQueues.sessionConnected) {
      eventQueues.sessionConnected.triggerAll();
    }

    connections.forEach(function (connection) {
      this.triggerConnectionCreated(connection);
    }, this);
  };
};

var unconnectedStreams = {};

module.exports = function SessionDispatcher(session, sessionOpt) {
  var dispatcher = new Dispatcher();
  var sessionStateReceived = false;
  var delayedSessionEvents = new DelayedSessionEvents(dispatcher);

  dispatcher.on('reconnecting', function () {
    session._.reconnecting();
  });

  dispatcher.on('reconnected', function () {
    session._.reconnected();
  });

  dispatcher.on('close', function (reason) {
    var connection = session.connection;

    if (!connection) {
      return;
    }

    if (connection.destroyedReason()) {
      logging.debug('' + ('OT.Raptor.Socket: Socket was closed but the connection had already ' + 'been destroyed. Reason: ') + connection.destroyedReason());
      return;
    }

    connection.destroy(reason);
  });

  // This method adds connections to the session both on a connection#created and
  // on a session#read. In the case of session#read sessionRead is set to true and
  // we include our own connection.
  var addConnection = function addConnection(connection, sessionRead) {
    if (session.connections.has(connection.id)) {
      // Don't add a duplicate connection, since we add them not only on connection#created, but
      // also when stream#created or signal has an associated connection.
      return session.connections.get(connection.id);
    }

    connection = Connection.fromHash(connection);
    if (sessionRead || session.connection && connection.id !== session.connection.id) {
      session.connections.add(connection);
      delayedSessionEvents.triggerConnectionCreated(connection);
    }

    Object.keys(unconnectedStreams).forEach(function (streamId) {
      var stream = unconnectedStreams[streamId];
      if (stream && connection.id === stream.connection.id) {
        // dispatch streamCreated event now that the connectionCreated has been dispatched
        parseAndAddStreamToSession(stream, session);
        delete unconnectedStreams[stream.id];

        var payload = {
          debug: sessionRead ? 'connection came in session#read' : 'connection came in connection#created',
          streamId: stream.id,
          connectionId: connection.id
        };
        session.logEvent('streamCreated', 'warning', payload);
      }
    });

    return connection;
  };

  dispatcher.on('session#read', function (content, transactionId) {
    var connection = void 0;
    var state = {};

    state.streams = [];
    state.connections = [];
    state.archives = [];

    content.connection.forEach(function (connectionParams) {
      connection = addConnection(connectionParams, true);
      state.connections.push(connection);
    });

    content.stream.forEach(function (streamParams) {
      state.streams.push(parseAndAddStreamToSession(streamParams, session));
    });

    (content.archive || content.archives).forEach(function (archiveParams) {
      state.archives.push(parseAndAddArchiveToSession(archiveParams, session));
    });

    dispatcher.triggerCallback(transactionId, null, state);

    sessionStateReceived = true;
    delayedSessionEvents.triggerSessionConnected(session.connections);
  });

  dispatcher.on('connection#created', function (connection) {
    addConnection(connection);
  });

  dispatcher.on('connection#deleted', function (connection, reason) {
    connection = session.connections.get(connection);
    connection.destroy(reason);
  });

  dispatcher.on('stream#created', function (stream, transactionId) {
    if (sessionOpt.connectionEventsSuppressed) {
      addConnection(stream.connection);
    }

    var connectionId = stream.connectionId ? stream.connectionId : stream.connection.id;
    if (session.connections.has(connectionId)) {
      stream = parseAndAddStreamToSession(stream, session);
    } else {
      unconnectedStreams[stream.id] = stream;

      var payload = {
        debug: 'eventOrderError -- streamCreated event before connectionCreated',
        streamId: stream.id
      };
      session.logEvent('streamCreated', 'warning', payload);
    }

    if (stream.publisher) {
      stream.publisher.setStream(stream);
    }

    dispatcher.triggerCallback(transactionId, null, stream);
  });

  dispatcher.on('stream#deleted', function (streamId, reason) {
    var stream = session.streams.get(streamId);

    if (!stream) {
      logging.error('OT.Raptor.dispatch: A stream does not exist with the id of ' + streamId + ', for stream#deleted message!');
      // @todo error
      return;
    }

    stream.destroy(reason);
  });

  dispatcher.on('stream#updated', function (streamId, content) {
    var stream = session.streams.get(streamId);

    if (!stream) {
      logging.error('OT.Raptor.dispatch: A stream does not exist with the id of ' + streamId + ', for stream#updated message!');
      // @todo error
      return;
    }

    stream._.update(content);
  });

  dispatcher.on('streamChannel#updated', function (streamId, channelId, content) {
    var stream = void 0;
    if (!(streamId && (stream = session.streams.get(streamId)))) {
      logging.error('OT.Raptor.dispatch: Unable to determine streamId, or the stream does not ' + 'exist, for streamChannel message!');
      // @todo error
      return;
    }
    stream._.updateChannel(channelId, content);
  });

  // Dispatch JSEP messages
  //
  // generateoffer:
  // Request to generate a offer for another Peer (or Prism). This kicks
  // off the JSEP process.
  //
  // answer:
  // generate a response to another peers offer, this contains our constraints
  // and requirements.
  //
  // pranswer:
  // a provisional answer, i.e. not the final one.
  //
  // candidate
  //
  //

  var jsepHandler = function jsepHandler(method, streamId, fromAddress, message) {
    var subscriberFilter = void 0,
        actors = void 0;
    var hasStreamId = { streamId: streamId };
    var subscribers = sessionObjects.subscribers;
    var publishers = sessionObjects.publishers;

    if (message.params.subscriber) {
      subscriberFilter = { widgetId: message.params.subscriber };
    } else {
      // if we don't know the subscriber, we will just match the stream id
      subscriberFilter = hasStreamId;
    }

    // Determine which subscriber/publisher objects should receive this message.
    switch (method) {
      case 'offer':
        actors = [].concat(subscribers.where(subscriberFilter), publishers.where(hasStreamId)).slice(0, 1);
        break;

      case 'answer':
      case 'pranswer':
        actors = [].concat(publishers.where(hasStreamId), subscribers.where(subscriberFilter)).slice(0, 1);
        break;

      case 'generateoffer':
      case 'unsubscribe':
        actors = publishers.where(hasStreamId);
        break;

      case 'candidate':
        actors = [].concat(subscribers.where(subscriberFilter), publishers.where(hasStreamId));
        break;

      default:
        logging.debug('OT.Raptor.dispatch: jsep#' + method + ' is not currently implemented');
        return;
    }

    if (actors.length === 0) {
      return;
    }

    var fromConnection = session.connections.get(fromAddress);
    if (!fromConnection && fromAddress.match(/^symphony\./)) {
      fromConnection = Connection.fromHash({
        id: fromAddress,
        creationTime: Math.floor(OTHelpers.now())
      });

      session.connections.add(fromConnection);
    }

    actors.forEach(function (actor) {
      actor.processMessage(method, fromAddress, message);
    });
  };

  dispatcher.on('jsep#offer', jsepHandler.bind(null, 'offer'));
  dispatcher.on('jsep#answer', jsepHandler.bind(null, 'answer'));
  dispatcher.on('jsep#pranswer', jsepHandler.bind(null, 'pranswer'));
  dispatcher.on('jsep#generateoffer', jsepHandler.bind(null, 'generateoffer'));
  dispatcher.on('jsep#unsubscribe', jsepHandler.bind(null, 'unsubscribe'));
  dispatcher.on('jsep#candidate', jsepHandler.bind(null, 'candidate'));

  dispatcher.on('subscriberChannel#updated', function (streamId, channelId, content) {
    if (!streamId || !session.streams.has(streamId)) {
      logging.error('OT.Raptor.dispatch: Unable to determine streamId, or the stream does not ' + 'exist, for subscriberChannel#updated message!');
      // @todo error
      return;
    }

    session.streams.get(streamId)._.updateChannel(channelId, content);
  });

  dispatcher.on('subscriberChannel#update', function (subscriberId, streamId, content) {
    if (!streamId || !session.streams.has(streamId)) {
      logging.error('OT.Raptor.dispatch: Unable to determine streamId, or the stream does not ' + 'exist, for subscriberChannel#update message!');
      // @todo error
      return;
    }

    // Hint to update for congestion control from the Media Server
    if (!sessionObjects.subscribers.has(subscriberId)) {
      logging.error('OT.Raptor.dispatch: Unable to determine subscriberId, or the subscriber ' + 'does not exist, for subscriberChannel#update message!');
      // @todo error
      return;
    }

    // We assume that an update on a Subscriber channel is to disableVideo
    // we may need to be more specific in the future
    sessionObjects.subscribers.get(subscriberId).disableVideo(content.active);
  });

  // Note: subscriber#created and subscriber#deleted messages are available but we currently
  // don't have a use for them.

  dispatcher.on('signal', function (fromAddress, content) {
    if (sessionOpt.connectionEventsSuppressed) {
      addConnection(content.connection || content.fromConnection);
    }

    var signalType = content.type;
    var data = content.data;

    var fromConnection = session.connections.get(fromAddress);
    if (session.connection && fromAddress === session.connection.connectionId) {
      if (sessionStateReceived) {
        session._.dispatchSignal(fromConnection, signalType, data);
      } else {
        delayedSessionEvents.enqueue('sessionConnected', 'signal', fromAddress, signalType, data);
      }
    } else if (session.connections.get(fromAddress)) {
      session._.dispatchSignal(fromConnection, signalType, data);
    } else if (fromAddress === '') {
      // Server originated signal
      session._.dispatchSignal(null, signalType, data);
    } else {
      delayedSessionEvents.enqueue('connectionCreated' + fromAddress, 'signal', fromAddress, signalType, data);
    }
  });

  dispatcher.on('archive#created', function (archive) {
    parseAndAddArchiveToSession(archive, session);
  });

  dispatcher.on('archive#updated', function (archiveId, update) {
    var archive = session.archives.get(archiveId);

    if (!archive) {
      logging.error('OT.Raptor.dispatch: An archive does not exist with the id of ' + archiveId + ', for archive#updated message!');
      // @todo error
      return;
    }

    archive._.update(update);
  });

  return dispatcher;
};

},{"../../../common-js-helpers/OTHelpers.js":217,"../../archive.js":292,"../../connection.js":303,"../../logging.js":312,"../../session/objects.js":370,"../../stream.js":372,"../../stream_channel.js":373,"./delayed_event_queue.js":313,"./dispatcher.js":315}],323:[function(require,module,exports){
'use strict';

// @todo enable the following disabled rules see OPENTOK-31136 for more info
/* eslint-disable no-useless-escape, no-underscore-dangle, no-void, no-prototype-builtins */

var APIKEY = require('../../api_key.js');
var Connection = require('../../connection.js');
var Message = require('./message.js');
var OTHelpers = require('../../../common-js-helpers/OTHelpers.js');
var sessionTag = require('../../session/tag.js');

var MAX_SIGNAL_DATA_LENGTH = 8192;
var MAX_SIGNAL_TYPE_LENGTH = 128;

//
// Error Codes:
// 413 - Type too long
// 400 - Type is invalid
// 413 - Data too long
// 400 - Data is invalid (can't be parsed as JSON)
// 429 - Rate limit exceeded
// 500 - Websocket connection is down
// 404 - To connection does not exist
// 400 - To is invalid
//
module.exports = function Signal(sessionId, fromConnectionId, options) {
  var isInvalidType = function isInvalidType(type) {
    // Our format matches the unreserved characters from the URI RFC:
    // http://www.ietf.org/rfc/rfc3986
    return !/^[a-zA-Z0-9\-\._~]+$/.exec(type);
  };

  var validateTo = function validateTo(toAddress) {
    if (!toAddress) {
      return {
        code: 400,
        reason: 'The signal to field was invalid. Either set it to a OT.Connection, ' + 'OT.Session, or omit it entirely'
      };
    }

    if (!(toAddress instanceof Connection || toAddress._tag === sessionTag)) {
      return {
        code: 400,
        reason: 'The To field was invalid'
      };
    }

    return null;
  };

  var validateType = function validateType(type) {
    var error = null;

    if (type === null || type === void 0) {
      error = {
        code: 400,
        reason: 'The signal type was null or undefined. Either set it to a String value or ' + 'omit it'
      };
    } else if (type.length > MAX_SIGNAL_TYPE_LENGTH) {
      error = {
        code: 413,
        reason: 'The signal type was too long, the maximum length of it is ' + MAX_SIGNAL_TYPE_LENGTH + ' characters'
      };
    } else if (isInvalidType(type)) {
      error = {
        code: 400,
        reason: 'The signal type was invalid, it can only contain letters, ' + 'numbers, \'-\', \'_\', and \'~\'.'
      };
    }

    return error;
  };

  var validateData = function validateData(data) {
    var error = null;
    if (data === null || data === void 0) {
      error = {
        code: 400,
        reason: 'The signal data was null or undefined. Either set it to a String value or ' + 'omit it'
      };
    } else {
      try {
        if (JSON.stringify(data).length > MAX_SIGNAL_DATA_LENGTH) {
          error = {
            code: 413,
            reason: 'The data field was too long, the maximum size of it is ' + MAX_SIGNAL_DATA_LENGTH + ' characters'
          };
        }
      } catch (e) {
        error = { code: 400, reason: 'The data field was not valid JSON' };
      }
    }

    return error;
  };

  var validateRetryAfterReconnect = function validateRetryAfterReconnect(retryAfterReconnect) {
    var error = null;
    if (!(retryAfterReconnect === true || retryAfterReconnect === false)) {
      error = {
        code: 400,
        reason: 'The signal retryAfterReconnect was not true or false. Either set it to a Boolean ' + 'value or omit it'
      };
    }

    return error;
  };

  this.toRaptorMessage = function () {
    var to = this.to;

    if (to && typeof to !== 'string') {
      to = to.id;
    }

    return Message.signals.create(APIKEY.value, sessionId, to, this.type, this.data);
  };

  this.toHash = function () {
    return options;
  };

  this.error = null;

  this.retryAfterReconnect = true;

  if (options) {
    if (options.hasOwnProperty('data')) {
      this.data = OTHelpers.clone(options.data);
      this.error = validateData(this.data);
    }

    if (options.hasOwnProperty('to')) {
      this.to = options.to;

      if (!this.error) {
        this.error = validateTo(this.to);
      }
    }

    if (options.hasOwnProperty('type')) {
      if (!this.error) {
        this.error = validateType(options.type);
      }
      this.type = options.type;
    }

    if (options.hasOwnProperty('retryAfterReconnect')) {
      if (!this.error) {
        this.error = validateRetryAfterReconnect(options.retryAfterReconnect);
      }
      this.retryAfterReconnect = options.retryAfterReconnect;
    }
  }

  this.valid = this.error === null;
};

},{"../../../common-js-helpers/OTHelpers.js":217,"../../api_key.js":291,"../../connection.js":303,"../../session/tag.js":371,"./message.js":317}],324:[function(require,module,exports){
"use strict";

module.exports = function SignalError(code, message) {
  this.code = code;
  this.message = message;

  // Undocumented. Left in for backwards compatibility:
  this.reason = message;
};

},{}],325:[function(require,module,exports){
'use strict';

var deserializeMessage = require('./deserialize_message.js');

module.exports = function unboxFromRumorMessage(rumorMessage) {
  var message = deserializeMessage(rumorMessage.data);
  message.transactionId = rumorMessage.transactionId;
  message.fromAddress = rumorMessage.headers['X-TB-FROM-ADDRESS'];

  return message;
};

},{"./deserialize_message.js":314}],326:[function(require,module,exports){
(function (global){
'use strict';

// Unfortunately it looks like the text-encoding module always returns its implementations of
// TextEncoder and TextDecoder, so we wrap it here to expose the global (window) ones, if available.

var TextEncoding = require('text-encoding');

module.exports = {
  TextEncoder: global.TextEncoder || TextEncoding.TextEncoder,
  TextDecoder: global.TextDecoder || TextEncoding.TextDecoder
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"text-encoding":195}],327:[function(require,module,exports){
'use strict';

var Rumor = {};

Rumor.MessageType = require('./rumor_message_types.js');
Rumor.Message = require('./rumor_message.js');
Rumor.NativeSocket = require('./native_socket.js');
Rumor.SocketError = require('./socket_error.js');
Rumor.Socket = require('./rumor_socket.js');

module.exports = Rumor;

},{"./native_socket.js":328,"./rumor_message.js":329,"./rumor_message_types.js":330,"./rumor_socket.js":331,"./socket_error.js":333}],328:[function(require,module,exports){
'use strict';

// @todo enable the following disabled rules see OPENTOK-31136 for more info
/* eslint-disable one-var, prefer-const, max-len, no-shadow, no-void, no-param-reassign */

var logging = require('../../logging.js');
var Message = require('./rumor_message.js');

var BUFFER_DRAIN_INTERVAL = 100;

// The total number of times to retest the websocket's send buffer
var BUFFER_DRAIN_MAX_RETRIES = 10;

module.exports = function NativeSocket(TheWebSocket, messagingURL, events) {
  var webSocket = void 0,
      disconnectWhenSendBufferIsDrained = void 0,
      bufferDrainTimeout = void 0,
      // Timer to poll whether th send buffer has been drained
  close = void 0;

  webSocket = new TheWebSocket(messagingURL);
  webSocket.binaryType = 'arraybuffer';

  webSocket.onopen = events.onOpen;
  webSocket.onclose = events.onClose;
  webSocket.onerror = events.onError;

  webSocket.onmessage = function (message) {
    if (!Message) {
      // In IE 10/11, This can apparently be called after
      // the page is unloaded and OT is garbage-collected

      // TODO: To avoid a circular dependency, I've replaced !OT with !Message for the condition. If
      // OT is garbage collected, surely Message would be too. We should try to figure out what's
      // actually going on here, I find it hard to believe this is really what was happening. And
      // even if it did, the result should be throwing an exception after the page unloads anyway,
      // and that shouldn't matter.

      return;
    }

    var msg = Message.deserialize(message.data);
    events.onMessage(msg);
  };

  // Ensure that the WebSocket send buffer is fully drained before disconnecting
  // the socket. If the buffer doesn't drain after a certain length of time
  // we give up and close it anyway.
  disconnectWhenSendBufferIsDrained = function disconnectWhenSendBufferIsDrained(bufferDrainRetries) {
    if (!webSocket) {
      return;
    }

    if (bufferDrainRetries === void 0) {
      bufferDrainRetries = 0;
    }
    if (bufferDrainTimeout) {
      clearTimeout(bufferDrainTimeout);
    }

    if (webSocket.bufferedAmount > 0 && bufferDrainRetries + 1 <= BUFFER_DRAIN_MAX_RETRIES) {
      bufferDrainTimeout = setTimeout(disconnectWhenSendBufferIsDrained, BUFFER_DRAIN_INTERVAL, bufferDrainRetries + 1);
    } else {
      close();
    }
  };

  close = function close() {
    webSocket.close();
  };

  this.close = function (drainBuffer, removeEventHandlers) {
    if (removeEventHandlers) {
      var empty = function empty() {};
      webSocket.onopen = empty;
      webSocket.onclose = empty;
      webSocket.onerror = empty;
      webSocket.onmessage = empty;
    }
    if (drainBuffer) {
      disconnectWhenSendBufferIsDrained();
    } else {
      close();
    }
  };

  this.send = function (msg) {
    try {
      webSocket.send(msg.serialize());
    } catch (err) {
      if (webSocket.readyState === WebSocket.OPEN) {
        // This is a known bug in Firefox:
        // https://bugzilla.mozilla.org/show_bug.cgi?id=1204727
        logging.debug('webSocket.send threw exception even though it was open:', err);
      } else {
        throw err;
      }
    }
  };

  this.isClosed = function () {
    return webSocket.readyState === 3;
  };
};

},{"../../logging.js":312,"./rumor_message.js":329}],329:[function(require,module,exports){
(function (global){
'use strict';

// @todo enable the following disabled rules see OPENTOK-31136 for more info
/* eslint-disable one-var, no-plusplus, no-restricted-syntax, no-prototype-builtins */
/* eslint-disable no-continue, prefer-const, no-bitwise, no-mixed-operators, no-param-reassign */

var uuid = require('uuid');
var encoding = require('./encoding.js');
var RumorMessageTypes = require('./rumor_message_types.js');

//
//
// @references
// * https://tbwiki.tokbox.com/index.php/Rumor_Message_Packet
// * https://tbwiki.tokbox.com/index.php/Rumor_Protocol
//
var RumorMessage = function RumorMessage(type, toAddress, headers, data) {
  this.type = type;
  this.toAddress = toAddress;
  this.headers = headers;
  this.data = data;

  this.fromAddress = this.headers['X-TB-FROM-ADDRESS'];
  this.transactionId = this.headers['TRANSACTION-ID'];
  this.status = this.headers.STATUS;

  // Only status messages will have a status header. So a missing status header
  // does not indicate an eror.
  this.isError = this.status && this.status[0] !== '2';
};

module.exports = RumorMessage;

RumorMessage.prototype.serialize = function () {
  var strArray = void 0,
      dataView = void 0,
      i = void 0,
      j = void 0;
  var offset = 8;
  var cBuf = 7;
  var address = [];
  var headerKey = [];
  var headerVal = [];

  // The number of addresses
  cBuf++;

  // Write out the address.
  for (i = 0; i < this.toAddress.length; i++) {
    /* jshint newcap:false */
    address.push(new encoding.TextEncoder('utf-8').encode(this.toAddress[i]));
    cBuf += 2;
    cBuf += address[i].length;
  }

  // The number of parameters
  cBuf++;

  // Write out the params
  i = 0;

  for (var key in this.headers) {
    // eslint-disable-line one-var
    if (!this.headers.hasOwnProperty(key)) {
      continue;
    }
    headerKey.push(new encoding.TextEncoder('utf-8').encode(key));
    headerVal.push(new encoding.TextEncoder('utf-8').encode(this.headers[key]));
    cBuf += 4;
    cBuf += headerKey[i].length;
    cBuf += headerVal[i].length;

    i++;
  }

  dataView = new encoding.TextEncoder('utf-8').encode(this.data);
  cBuf += dataView.length;

  // Let's allocate a binary blob of this size
  var buffer = new ArrayBuffer(cBuf);
  var uint8View = new Uint8Array(buffer, 0, cBuf);

  // We don't include the header in the lenght.
  cBuf -= 4;

  // Write out size (in network order)
  uint8View[0] = (cBuf & 0xFF000000) >>> 24;
  uint8View[1] = (cBuf & 0x00FF0000) >>> 16;
  uint8View[2] = (cBuf & 0x0000FF00) >>> 8;
  uint8View[3] = (cBuf & 0x000000FF) >>> 0;

  // Write out reserved bytes
  uint8View[4] = 0;
  uint8View[5] = 0;

  // Write out message type
  uint8View[6] = this.type;
  uint8View[7] = this.toAddress.length;

  // Now just copy over the encoded values..
  for (i = 0; i < address.length; i++) {
    strArray = address[i];
    uint8View[offset++] = strArray.length >> 8 & 0xFF;
    uint8View[offset++] = strArray.length >> 0 & 0xFF;
    for (j = 0; j < strArray.length; j++) {
      uint8View[offset++] = strArray[j];
    }
  }

  uint8View[offset++] = headerKey.length;

  // Write out the params
  for (i = 0; i < headerKey.length; i++) {
    strArray = headerKey[i];
    uint8View[offset++] = strArray.length >> 8 & 0xFF;
    uint8View[offset++] = strArray.length >> 0 & 0xFF;
    for (j = 0; j < strArray.length; j++) {
      uint8View[offset++] = strArray[j];
    }

    strArray = headerVal[i];
    uint8View[offset++] = strArray.length >> 8 & 0xFF;
    uint8View[offset++] = strArray.length >> 0 & 0xFF;
    for (j = 0; j < strArray.length; j++) {
      uint8View[offset++] = strArray[j];
    }
  }

  // And finally the data
  for (i = 0; i < dataView.length; i++) {
    uint8View[offset++] = dataView[i];
  }

  return buffer;
};

function toArrayBuffer(buffer) {
  var ab = new ArrayBuffer(buffer.length);
  var view = new Uint8Array(ab);
  for (var i = 0; i < buffer.length; ++i) {
    view[i] = buffer[i];
  }
  return ab;
}

RumorMessage.deserialize = function (buffer) {
  if (global.Buffer && global.Buffer.isBuffer(buffer)) {
    buffer = toArrayBuffer(buffer);
  }

  var type = void 0,
      strView = void 0,
      headerlen = void 0,
      headers = void 0,
      keyStr = void 0,
      valStr = void 0,
      length = void 0,
      i = void 0;
  var offset = 8;
  var uint8View = new Uint8Array(buffer);

  type = uint8View[6];
  var address = [];

  for (i = 0; i < uint8View[7]; i++) {
    length = uint8View[offset++] << 8;
    length += uint8View[offset++];
    strView = new Uint8Array(buffer, offset, length);
    /* jshint newcap:false */
    address[i] = new encoding.TextDecoder('utf-8').decode(strView);
    offset += length;
  }

  headerlen = uint8View[offset++];
  headers = {};

  for (i = 0; i < headerlen; i++) {
    length = uint8View[offset++] << 8;
    length += uint8View[offset++];
    strView = new Uint8Array(buffer, offset, length);
    keyStr = new encoding.TextDecoder('utf-8').decode(strView);
    offset += length;

    length = uint8View[offset++] << 8;
    length += uint8View[offset++];
    strView = new Uint8Array(buffer, offset, length);
    valStr = new encoding.TextDecoder('utf-8').decode(strView);
    headers[keyStr] = valStr;
    offset += length;
  }

  var dataView = new Uint8Array(buffer, offset);
  var data = new encoding.TextDecoder('utf-8').decode(dataView);

  return new RumorMessage(type, address, headers, data);
};

RumorMessage.Connect = function (uniqueId, notifyDisconnectAddress) {
  var headers = {
    uniqueId: uniqueId,
    'TRANSACTION-ID': uuid(),
    notifyDisconnectAddress: notifyDisconnectAddress
  };

  return new RumorMessage(RumorMessageTypes.CONNECT, [], headers, '');
};

RumorMessage.Disconnect = function (reconnect) {
  return new RumorMessage(RumorMessageTypes.DISCONNECT, [], { reconnect: reconnect }, '');
};

RumorMessage.Subscribe = function (topics) {
  return new RumorMessage(RumorMessageTypes.SUBSCRIBE, topics, {}, '');
};

RumorMessage.Unsubscribe = function (topics) {
  return new RumorMessage(RumorMessageTypes.UNSUBSCRIBE, topics, {}, '');
};

RumorMessage.Publish = function (topics, message, headers) {
  return new RumorMessage(RumorMessageTypes.MESSAGE, topics, headers || {}, message || '');
};

RumorMessage.Status = function (topics, headers) {
  return new RumorMessage(RumorMessageTypes.STATUS, topics, headers || {}, '');
};

// This message is used to implement keepalives on the persistent
// socket connection between the client and server. Every time the
// client sends a PING to the server, the server will respond with
// a PONG.
RumorMessage.Ping = function () {
  return new RumorMessage(RumorMessageTypes.PING, [], {}, '');
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./encoding.js":326,"./rumor_message_types.js":330,"uuid":200}],330:[function(require,module,exports){
"use strict";

// Rumor Messaging for JS
//
// https://tbwiki.tokbox.com/index.php/Rumor_:_Messaging_FrameWork
//
// @todo Rumor {
//     Add error codes for all the error cases
//     Add Dependability commands
// }

module.exports = {
  // This is used to subscribe to address/addresses. The address/addresses the
  // client specifies here is registered on the server. Once any message is sent to
  // that address/addresses, the client receives that message.
  SUBSCRIBE: 0,

  // This is used to unsubscribe to address / addresses. Once the client unsubscribe
  // to an address, it will stop getting messages sent to that address.
  UNSUBSCRIBE: 1,

  // This is used to send messages to arbitrary address/ addresses. Messages can be
  // anything and Rumor will not care about what is included.
  MESSAGE: 2,

  // This will be the first message that the client sends to the server. It includes
  // the uniqueId for that client connection and a disconnect_notify address that will
  // be notified once the client disconnects.
  CONNECT: 3,

  // This will be the message used by the server to notify an address that a
  // client disconnected.
  DISCONNECT: 4,

  // Enhancements to support Keepalives
  PING: 7,
  PONG: 8,
  STATUS: 9
};

},{}],331:[function(require,module,exports){
'use strict';

// @todo enable the following disabled rules see OPENTOK-31136 for more info
/* eslint-disable no-mixed-operators, one-var, no-underscore-dangle, no-use-before-define */
/* eslint-disable max-len, prefer-rest-params, no-void, no-param-reassign, no-plusplus */

var uuid = require('uuid');
var isDOMUnloaded = require('../../../helpers/is_dom_unloaded.js');
var Message = require('./rumor_message.js');
var OTHelpers = require('../../../common-js-helpers/OTHelpers.js');
var logging = require('../../logging.js');
var NativeSocket = require('./native_socket.js');
var RumorMessageTypes = require('./rumor_message_types.js');
var RumorMessage = require('./rumor_message.js');
var SocketError = require('./socket_error.js');
var socketCloseErrors = require('./socket_close_errors.js');
var ws = require('ws');

var WEB_SOCKET_KEEP_ALIVE_INTERVAL = 2000;

// Magic Connectivity Timeout Constant: We wait 2*the keep alive interval,
// on the third keep alive we trigger the timeout if we haven't received the
// server pong.
var WEB_SOCKET_CONNECTIVITY_TIMEOUT = 3 * WEB_SOCKET_KEEP_ALIVE_INTERVAL - 100;
var WEB_SOCKET_CONNECTIVITY_TIMEOUT_NO_RECONNECT = 25 * WEB_SOCKET_KEEP_ALIVE_INTERVAL - 100;

// The TheWebSocket bit is purely to make testing simpler, it defaults to WebSocket
// so in normal operation you would omit it.
var RumorSocket = function RumorSocket(options) {
  var webSocket = void 0,
      onOpen = void 0,
      onError = void 0,
      onClose = void 0,
      onReconnecting = void 0,
      onReconnectAttempt = void 0,
      onReconnectFailure = void 0,
      onReconnected = void 0,
      onMessage = void 0,
      connectCallback = void 0,
      connectTimeout = void 0,
      reconnectTimeout = void 0,
      reconnectThreshold = void 0,
      lastMessageTimestamp = void 0,
      // The timestamp of the last message received
  keepAliveTimer = void 0; // Timer for the connectivity checks
  var rumorSocket = this;
  var reconnectAttempts = 0;
  var states = ['disconnected', 'error', 'connected', 'connecting', 'disconnecting', 'reconnecting'];
  var socketID = uuid();
  var receivedTransactionIDs = [];
  var messagingURL = options.messagingURL;
  var notifyDisconnectAddress = options.notifyDisconnectAddress;
  var connectionId = options.connectionId;
  var enableReconnection = options.enableReconnection;
  var TheWebSocket = options.TheWebSocket || ws;
  var everConnected = false;

  rumorSocket._connectivityTimeout = enableReconnection ? WEB_SOCKET_CONNECTIVITY_TIMEOUT : WEB_SOCKET_CONNECTIVITY_TIMEOUT_NO_RECONNECT;

  rumorSocket._keepAliveInterval = WEB_SOCKET_KEEP_ALIVE_INTERVAL;

  // pendingMessages is pre-populated to connect to rumor by registering our connection id
  // and the app server aQddress to notify if we disconnect, this will be sent on the first
  // successful connection.
  var pendingMessages = [{
    rumorMessage: RumorMessage.Connect(connectionId, notifyDisconnectAddress),
    completion: function completion() {}
  }];

  var clearPendingMessagesWithoutRetry = function clearPendingMessagesWithoutRetry() {
    var messagesToClear = pendingMessages.filter(function (message) {
      return !message.retryAfterReconnect;
    });

    pendingMessages = pendingMessages.filter(function (message) {
      return message.retryAfterReconnect;
    });

    messagesToClear.forEach(function (message) {
      var error = new Error('Not connected.');
      error.code = 500;
      message.completion(error);
    });
  };

  var clearPendingMessages = function clearPendingMessages() {
    pendingMessages.forEach(function (message) {
      var error = new Error('Not connected.');
      error.code = 500;
      message.completion(error);
    });
  };

  // // Private API
  var stateChanged = function stateChanged(newState) {
    switch (newState) {
      case 'disconnected':
      case 'error':
        reconnectThreshold = undefined;
        webSocket = null;
        clearPendingMessages();
        if (onClose) {
          var error = void 0;
          if (hasLostConnectivity()) {
            error = new Error(socketCloseErrors.messages[socketCloseErrors.codes.CLOSE_CONNECTIVITY_LOSS]);
            error.code = socketCloseErrors.codes.CLOSE_CONNECTIVITY_LOSS;
          }
          onClose(error);
        }
        break;
      case 'reconnecting':
        if (onReconnecting && everConnected) {
          onReconnecting();
        }

        if (rumorSocket.is('disconnected')) {
          // This means some called disconnect in an onReconnecting
          // handler, in that case we don't want to continue trying
          // to reconnect.
          return;
        }
        reconnectAttempts = 0;
        reconnectThreshold = Date.now() + RumorSocket.RECONNECT_TIMEOUT;
        break;
      case 'connected':
        if (onReconnected && everConnected) {
          onReconnected();
        } else {
          everConnected = true;
        }

        reconnectThreshold = undefined;
        break;
      default:
    }
  };

  var setState = OTHelpers.statable(rumorSocket, states, 'disconnected', stateChanged);

  var validateCallback = function validateCallback(name, callback) {
    if (callback === null || !OTHelpers.isFunction(callback)) {
      throw new Error('The RumorSocket ' + name + ' callback must be a valid function or null');
    }
  };

  var connectCallbackOnce = function connectCallbackOnce() {
    if (!connectCallback) {
      return;
    }
    var args = Array.prototype.slice.call(arguments);
    var callback = connectCallback;
    connectCallback = void 0;
    callback.apply(undefined, args);
  };

  var raiseError = function raiseError(code, extraDetail) {
    code = code || socketCloseErrors.codes.CLOSE_FALLBACK_CODE;

    var messageFromCode = socketCloseErrors.messages[code] || 'No message available from code.';
    var message = messageFromCode + (extraDetail ? ' ' + extraDetail : '');

    logging.error('RumorSocket: ' + message);

    var socketError = new SocketError(code, message);

    clearTimeout(connectTimeout);

    if (rumorSocket.is('reconnecting') && onReconnectFailure) {
      onReconnectFailure(socketError);
    }

    var fatalErrorCode = code === socketCloseErrors.codes.CLOSE_UNEXPECTED_CONDITION || code === socketCloseErrors.codes.CLOSE_UNSUPPORTED;

    if (rumorSocket.isNot('reconnecting', 'disconnecting', 'disconnected')) {
      if (enableReconnection && !fatalErrorCode) {
        logging.debug('Initial connectivity loss detected at ' + new Date());
        setState('reconnecting');
      } else {
        logging.debug('Connectivity loss detected at ' + new Date());
      }
    }

    if (rumorSocket.is('disconnected', 'disconnecting')) {
      // This probably means someone one called disconnect in an onReconnecting
      // handler, in that case we don't want to continue trying
      // to reconnect.
      return;
    }

    if (!enableReconnection || Date.now() >= reconnectThreshold || fatalErrorCode) {
      if (fatalErrorCode) {
        logging.debug('Connectivity not restored because of a fatal error.');
      }

      if (!enableReconnection) {
        logging.debug('Reconnections are disabled, will not attempt to reconnect.');
      } else if (Date.now() >= reconnectThreshold) {
        logging.debug('Connectivity not restored within ' + RumorSocket.RECONNECT_TIMEOUT + 'ms, we have disconnected.');
      }

      setState('error');

      if (connectCallback) {
        connectCallbackOnce(socketError, void 0);
      } else if (onError) {
        onError(socketError);
      }
    } else {
      logging.debug('Scheduling reconnection in ' + RumorSocket.RECONNECT_RETRY + 'ms. ' + ('Remaining time: ' + (reconnectThreshold - Date.now()) + 'ms.'));
      reconnectTimeout = setTimeout(connect, RumorSocket.RECONNECT_RETRY);
      reconnectAttempts++;
      if (onReconnectAttempt) {
        onReconnectAttempt();
      }
    }
  };

  var hasLostConnectivity = function hasLostConnectivity() {
    if (!lastMessageTimestamp) {
      return false;
    }

    return OTHelpers.now() - lastMessageTimestamp >= rumorSocket._connectivityTimeout;
  };

  var sendKeepAlive = function sendKeepAlive() {
    if (!rumorSocket.is('connected')) {
      return;
    }

    if (hasLostConnectivity()) {
      webSocket.send(Message.Disconnect('1'));
      webSocket.close(true, true);
      webSocketDisconnected({ code: socketCloseErrors.codes.CLOSE_CONNECTIVITY_LOSS });
    } else {
      webSocket.send(Message.Ping());
      keepAliveTimer = setTimeout(sendKeepAlive, rumorSocket._keepAliveInterval);
    }
  };

  var sendAck = function sendAck(msg) {
    webSocket.send(Message.Status([msg.fromAddress], {
      'TRANSACTION-ID': msg.headers['TRANSACTION-ID'],
      'X-TB-FROM-ADDRESS': connectionId
    }));
  };

  // // Private Event Handlers
  var webSocketConnected = function webSocketConnected() {
    clearTimeout(connectTimeout);

    if (rumorSocket.isNot('connecting', 'reconnecting')) {
      logging.debug('webSocketConnected reached in state other than connecting (' + rumorSocket.currentState + ')');
      return;
    }

    logging.debug('Sending ' + pendingMessages.length + ' pending messages');
    pendingMessages.forEach(function (message) {
      webSocket.send(message.rumorMessage);
    });

    pendingMessages = pendingMessages.filter(function (message) {
      return message.rumorMessage.type !== RumorMessageTypes.CONNECT;
    });

    setState('connected');

    connectCallbackOnce(void 0, connectionId);

    if (onOpen) {
      onOpen(connectionId);
    }

    keepAliveTimer = setTimeout(function () {
      lastMessageTimestamp = OTHelpers.now();
      sendKeepAlive();
    }, rumorSocket._keepAliveInterval);
  };

  var webSocketConnectTimedOut = function webSocketConnectTimedOut() {
    var webSocketWas = webSocket;
    raiseError(socketCloseErrors.codes.CLOSE_TIMEOUT);
    // This will prevent a socket eventually connecting
    // But call it _after_ the error just in case any of
    // the callbacks fire synchronously, breaking the error
    // handling code.
    try {
      webSocketWas.close(false, true);
    } catch (err) {
      logging.debug('webSocket.close() raised an exception: ' + (err.message || err));
    }
  };

  var webSocketError = function webSocketError() {};

  var webSocketDisconnected = function webSocketDisconnected(closeEvent) {
    logging.debug('OT.Rumor.Socket: webSocketDisconnected (code: ' + closeEvent.code + ')');

    clearTimeout(connectTimeout);
    clearTimeout(keepAliveTimer);

    if (isDOMUnloaded()) {
      // Sometimes we receive the web socket close event after
      // the DOM has already been partially or fully unloaded
      // if that's the case here then it's not really safe, or
      // desirable, to continue.
      return;
    }

    clearPendingMessagesWithoutRetry();

    if (rumorSocket.isNot('disconnecting') && closeEvent.code !== 1000 && closeEvent.code !== 1001) {
      if (closeEvent.code) {
        raiseError(closeEvent.code);
      } else {
        raiseError(socketCloseErrors.codes.CLOSE_FALLBACK_CODE, closeEvent.reason || closeEvent.message);
      }
    }

    if (rumorSocket.isNot('error', 'reconnecting')) {
      setState('disconnected');
    }
  };

  var webSocketReceivedMessage = function webSocketReceivedMessage(msg) {
    lastMessageTimestamp = OTHelpers.now();

    if (msg.type !== RumorMessageTypes.PONG) {
      logging.debug('OT.Rumor.Socket webSocketReceivedMessage:', msg);
      if (msg.transactionId) {
        // remove pending message
        pendingMessages = pendingMessages.filter(function (pendingMessage) {
          if (pendingMessage.rumorMessage.transactionId === msg.transactionId) {
            logging.debug('Marking', msg.transactionId, ' as received');
            pendingMessage.completion(undefined, msg);
          }

          return pendingMessage.rumorMessage.transactionId !== msg.transactionId;
        });
      }

      if (msg.transactionId && msg.type !== RumorMessageTypes.STATUS) {
        // 1) ack it!
        sendAck(msg);

        // Have we seen this transaction before?
        if (receivedTransactionIDs.indexOf(msg.transactionId) >= 0) {
          // We've handled this transactionId before, but the ACK
          // must have been lost. That's ok, we've told the server
          // so we can just ignore this message now.
          return;
        }

        receivedTransactionIDs.push(msg.transactionId);
      }

      if (onMessage) {
        onMessage(msg);
      }
    }
  };

  var connect = function connect() {
    if (rumorSocket.is('connecting', 'connected')) {
      logging.error('Rumor.Socket cannot connect when it is already connecting or connected.');
      return;
    }

    if (!rumorSocket.is('reconnecting')) {
      setState('connecting');
    } else {
      logging.debug('Attempting reconnection...');
    }

    var attempt = uuid();

    var events = {
      onOpen: webSocketConnected,
      onClose: webSocketDisconnected,
      onError: webSocketError,
      onMessage: webSocketReceivedMessage
    };

    var fullMessagingURL = messagingURL;
    if (enableReconnection) {
      fullMessagingURL = [messagingURL, messagingURL.indexOf('?') >= 0 ? '&' : '?', 'socketId=' + socketID, rumorSocket.is('reconnecting') ? '&reconnect=true' : '', '&attempt=' + attempt].join('');
    }

    try {
      webSocket = new NativeSocket(TheWebSocket, fullMessagingURL, events);

      connectTimeout = setTimeout(webSocketConnectTimedOut, RumorSocket.CONNECT_TIMEOUT);
    } catch (e) {
      logging.error(e);

      raiseError(socketCloseErrors.codes.CLOSE_CONNECT_EXCEPTION);
    }
  };

  // // Public API

  rumorSocket.publish = function (topics, message, headers, retryAfterReconnect, completion) {
    completion = completion || function () {};

    if (!rumorSocket.is('connected') && !retryAfterReconnect) {
      var error = new Error('Not connected.');
      error.code = 500;
      completion(error);
      return;
    }

    var rumorMessage = Message.Publish(topics, message, headers);

    pendingMessages.push({
      rumorMessage: rumorMessage,
      retryAfterReconnect: retryAfterReconnect,
      completion: completion
    });

    if (rumorSocket.is('connected')) {
      webSocket.send(rumorMessage);
    }
  };

  rumorSocket.subscribe = function (topics) {
    webSocket.send(Message.Subscribe(topics));
  };

  rumorSocket.unsubscribe = function (topics) {
    webSocket.send(Message.Unsubscribe(topics));
  };

  rumorSocket.connect = function (complete) {
    if (rumorSocket.is('connecting', 'connected')) {
      if (typeof complete === 'function') {
        complete(new SocketError(socketCloseErrors.codes.ALREADY_CONNECTED_CONNECTING, 'Rumor.Socket cannot connect when it is already connecting or connected.'));
      } else {
        logging.error('Rumor.Socket cannot connect when it is already connecting or connected.');
      }
    } else {
      connectCallback = complete;
      connect();
    }
  };

  rumorSocket.disconnect = function (drainSocketBuffer) {
    clearTimeout(connectTimeout);
    clearTimeout(keepAliveTimer);
    clearTimeout(reconnectTimeout);

    if (!webSocket) {
      if (rumorSocket.isNot('error')) {
        setState('disconnected');
      }
      return;
    }

    if (webSocket.isClosed()) {
      if (rumorSocket.isNot('error')) {
        setState('disconnected');
      }
    } else {
      if (rumorSocket.is('connected')) {
        // Look! We are nice to the rumor server ;-)
        webSocket.send(Message.Disconnect());
      }

      setState('disconnecting');

      // Wait until the socket is ready to close
      webSocket.close(drainSocketBuffer);
    }
  };

  rumorSocket.status = function (toAddress, transactionId) {
    webSocket.send(Message.Status(toAddress, {
      'TRANSACTION-ID': transactionId,
      'X-TB-FROM-ADDRESS': connectionId
    }));
  };

  rumorSocket.reconnectRetriesCount = function () {
    return reconnectAttempts;
  };

  rumorSocket.messageQueueSize = function () {
    return pendingMessages.length;
  };

  OTHelpers.defineProperties(rumorSocket, {
    id: {
      get: function get() {
        return connectionId;
      }
    },

    socketID: {
      get: function get() {
        return socketID;
      }
    },

    onOpen: {
      set: function set(callback) {
        validateCallback('onOpen', callback);
        onOpen = callback;
      },
      get: function get() {
        return onOpen;
      }
    },

    onError: {
      set: function set(callback) {
        validateCallback('onError', callback);
        onError = callback;
      },
      get: function get() {
        return onError;
      }
    },

    onClose: {
      set: function set(callback) {
        validateCallback('onClose', callback);
        onClose = callback;
      },
      get: function get() {
        return onClose;
      }
    },

    onMessage: {
      set: function set(callback) {
        validateCallback('onMessage', callback);
        onMessage = callback;
      },
      get: function get() {
        return onMessage;
      }
    },

    onReconnecting: {
      set: function set(callback) {
        validateCallback('onReconnecting', callback);
        onReconnecting = callback;
      },
      get: function get() {
        return onReconnecting;
      }
    },

    onReconnectAttempt: {
      set: function set(callback) {
        validateCallback('onReconnectAttempt', callback);
        onReconnectAttempt = callback;
      },
      get: function get() {
        return onReconnectAttempt;
      }
    },

    onReconnectFailure: {
      set: function set(callback) {
        validateCallback('onReconnectFailure', callback);
        onReconnectFailure = callback;
      },
      get: function get() {
        return onReconnectFailure;
      }
    },

    onReconnected: {
      set: function set(callback) {
        validateCallback('reconnected', callback);
        onReconnected = callback;
      },
      get: function get() {
        return onReconnected;
      }
    }
  });
};

// The number of ms to wait for the websocket to connect
RumorSocket.CONNECT_TIMEOUT = 15000;
RumorSocket.RECONNECT_TIMEOUT = 60000;
RumorSocket.RECONNECT_RETRY = 500;

module.exports = RumorSocket;

},{"../../../common-js-helpers/OTHelpers.js":217,"../../../helpers/is_dom_unloaded.js":269,"../../logging.js":312,"./native_socket.js":328,"./rumor_message.js":329,"./rumor_message_types.js":330,"./socket_close_errors.js":332,"./socket_error.js":333,"uuid":200,"ws":215}],332:[function(require,module,exports){
'use strict';

// https://tools.ietf.org/html/rfc6455#section-7.4.1
// https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent#Close_codes

module.exports = {
  messages: {
    1002: 'The endpoint is terminating the connection due to a protocol error. ' + '(CLOSE_PROTOCOL_ERROR)',
    1003: 'The connection is being terminated because the endpoint has indicated ' + 'that reconnections are not available. (CLOSE_UNSUPPORTED)',
    1005: 'Indicates that no status code was provided even though one was expected. ' + '(CLOSE_NO_STATUS)',
    1006: 'Used to indicate that a connection was closed abnormally (that is, with no ' + 'close frame being sent) when a status code is expected. (CLOSE_ABNORMAL)',
    1007: 'Indicates that an endpoint is terminating the connection because it has received ' + 'data within a message that was not consistent with the type of the message (e.g., ' + 'non-UTF-8 [RFC3629] data within a text message)',
    1008: 'Indicates that an endpoint is terminating the connection because it has received a ' + 'message that violates its policy.  This is a generic status code that can be returned ' + 'when there is no other more suitable status code (e.g., 1003 or 1009) or if there is a ' + 'need to hide specific details about the policy',
    1009: 'Indicates that an endpoint is terminating the connection because it has received a ' + 'message that is too big for it to process (CLOSE_TOO_LARGE)',
    1011: 'Indicates that a server is terminating the connection because it encountered an ' + 'unexpected condition that prevented it from fulfilling the request',

    // .... codes in the 4000-4999 range are available for use by applications.
    4001: 'Connectivity loss was detected as it was too long since the socket received the ' + 'last PONG message',
    4010: 'Timed out while waiting for the Rumor socket to connect.',
    4020: 'Error code unavailable.',
    4030: 'Exception was thrown during Rumor connection, possibly because of a blocked port.'
  },
  codes: {
    CLOSE_PROTOCOL_ERROR: 1002,
    CLOSE_UNSUPPORTED: 1003,
    CLOSE_NO_STATUS: 1005,
    CLOSE_ABNORMAL: 1006,
    CLOSE_INCONSISTENT_DATA: 1007,
    CLOSE_POLICY_VIOLATION: 1008,
    CLOSE_TOO_LARGE: 1009,
    CLOSE_UNEXPECTED_CONDITION: 1011,
    CLOSE_CONNECTIVITY_LOSS: 4001,
    CLOSE_TIMEOUT: 4010,
    CLOSE_FALLBACK_CODE: 4020,
    CLOSE_CONNECT_EXCEPTION: 4030,
    ALREADY_CONNECTED_CONNECTING: null
  }
};

},{}],333:[function(require,module,exports){
"use strict";

module.exports = function (code, message) {
  this.code = code;
  this.message = message;
};

},{}],334:[function(require,module,exports){
'use strict';

// @todo enable the following disabled rules see OPENTOK-31136 for more info
/* eslint-disable no-underscore-dangle, no-param-reassign */

var analytics = require('./analytics.js');
var APIKEY = require('./api_key.js');
var logging = require('./logging.js');
var OTHelpers = require('../common-js-helpers/OTHelpers.js');

var Events = require('./events.js')();

/**
 * The Error class is used to define the error object passed into completion handlers.
 * Each of the following methods, which execute asynchronously, includes a
 * <code>completionHandler</code> parameter:
 *
 * <ul>
 *   <li><a href="OT.html#initPublisher">OT.initPublisher()</a></li>
 *   <li><a href="OT.html#reportIssue">OT.reportIssue()</a></li>
 *   <li><a href="Session.html#connect">Session.connect()</a></li>
 *   <li><a href="Session.html#forceDisconnect">Session.forceDisconnect()</a></li>
 *   <li><a href="Session.html#forceUnpublish">Session.forceUnpublish()</a></li>
 *   <li><a href="Session.html#publish">Session.publish()</a></li>
 *   <li><a href="Session.html#subscribe">Session.subscribe()</a></li>
 *   <li><a href="Subscriber.html#getStats">Subscriber.getStats()</a></li>
 * </ul>
 *
 * <p>
 * The <code>completionHandler</code> parameter is a function that is called when the call to
 * the asynchronous method succeeds or fails. If the asynchronous call fails, the completion
 * handler function is passed an error object (defined by the Error class). The <code>code</code>
 * and <code>message</code> properties of the error object provide details about the error.
 *
 * <p>
 * <b>Deprecation notice:</b>
 * <code>OT.Error</code> will not be defined in an upcoming version of OpenTok. When this happens,
 * errors emitted by the SDK will simply be instances of standard <code>Error</code> objects.
 * If your code currently checks <code>if (error instanceof OT.Error)</code> please replace it
 * <code>if (/^OT_/.test(error.name))</code>. (The <code>name</code> property for all OpenTok
 * errors with begins with <code>'OT_'</code>.) Note however that this code is for the
 * purposes of smoothly upgrading, and it may be more appropriate for your code to simply compare
 * against the specific error you want to handle, such as
 * <code>if (error.name === 'OT_USER_MEDIA_ACCESS_DENIED')</code>.
 *
 * @property {Number} code Deprecated &mdash; the error code. Use the <code>name</code> property,
 * not the <code>code</code> property, to identify the error programatically.
 *
 *   <p>
 *   In the event of an error, the <code>code</code> value of the <code>error</code> parameter can
 *   have one of the following values:
 * </p>
 *
 * <p>Errors when calling <code>Session.connect()</code>:</p>
 *
 * <table class="docs_table"><tbody>
 * <tr>
 *   <td><b><code>code</code></b></td>
 *   <td><b>Description</b></td>
 * </tr>
 * <tr>
 *   <td>1004</td>
 *   <td>Authentication error. Check the error message for details. This error can result if you
 *     pass in an expired token when trying to connect to a session. It can also occur if you pass
 *     in an invalid token or API key. Make sure that you are generating the token using the
 *     current version of one of the
 *     <a href="http://tokbox.com/opentok/libraries/server">OpenTok server SDKs</a>.</td>
 * </tr>
 * <tr>
 *   <td>1005</td>
 *   <td>Invalid Session ID. Make sure you generate the session ID using the current version of
 *     one of the <a href="http://tokbox.com/opentok/libraries/server">OpenTok server
 *     SDKs</a>.</td>
 * </tr>
 * <tr>
 *   <td>1006</td>
 *   <td>Connect Failed. Unable to connect to the session. You may want to have the client check
 *     the network connection.</td>
 * </tr>
 * <tr>
 *  <td>1026</td>
 *  <td>Terms of service violation: export compliance. See the
 *    <a href="https://tokbox.com/support/tos">Terms of Service</a>.</td>
 * </tr>
 * <tr>
 *  <td>1027</td>
 *  <td>Connection limit exceeded. The client tried to connect to a session that has exceeded
 *  limit for simultaneous connections.</td>
 * </tr>
 * <tr>
 *   <td>2001</td>
 *   <td>Connect Failed. Unexpected response from the OpenTok server. Try connecting again
 *     later.</td>
 * </tr>
 * </tbody></table>
 *
 * <p>Errors when calling <code>Session.forceDisconnect()</code>:</p>
 *
 * <table class="docs_table"><tbody>
 * <tr>
 *   <td><b>
 *       <code>code</code>
 *     </b></td>
 *   <td><b>Description</b></td>
 * </tr>
 * <tr>
 *   <td>1010</td>
 *   <td>The client is not connected to the OpenTok session. Check that client connects
 *     successfully and has not disconnected before calling forceDisconnect().</td>
 * </tr>
 * <tr>
 *   <td>1520</td>
 *   <td>Unable to force disconnect. The client's token does not have the role set to moderator.
 *     Once the client has connected to the session, the <code>capabilities</code> property of
 *     the Session object lists the client's capabilities.</td>
 * </tr>
 * </tbody></table>
 *
 * <p>Errors when calling <code>Session.forceUnpublish()</code>:</p>
 *
 * <table class="docs_table"><tbody>
 * <tr>
 *   <td><b><code>code</code></b></td>
 *   <td><b>Description</b></td>
 * </tr>
 * <tr>
 *   <td>1010</td>
 *   <td>The client is not connected to the OpenTok session. Check that client connects
 *     successfully and has not disconnected before calling forceUnpublish().</td>
 * </tr>
 * <tr>
 *   <td>1530</td>
 *   <td>Unable to force unpublish. The client's token does not have the role set to moderator.
 *     Once the client has connected to the session, the <code>capabilities</code> property of
 *     the Session object lists the client's capabilities.</td>
 * </tr>
 * <tr>
 *   <td>1535</td>
 *   <td>Force Unpublish on an invalid stream. Make sure that the stream has not left the
 *     session before you call the <code>forceUnpublish()</code> method.</td>
 * </tr>
 * </tbody></table>
 *
 * <p>Errors when calling <code>Session.publish()</code>:</p>
 *
 * <table class="docs_table"><tbody>
 * <tr>
 *   <td><b><code>code</code></b></td>
 *   <td><b>Description</b></td>
 * </tr>
 * <tr>
 *   <td>1010</td>
 *   <td>The client is not connected to the OpenTok session. Check that the client connects
 *     successfully before trying to publish. And check that the client has not disconnected
 *     before trying to publish.</td>
 * </tr>
 * <tr>
 *   <td>1500</td>
 *   <td>Unable to Publish. This can be caused by the following:
 *
 *   <ul>
 *     <li>The client's token does not have the role set to publish or
 *     moderator. Once the client has connected to the session, the <code>capabilities</code>
 *     property of the Session object lists the client's capabilities.</li>
 *
 *     <li>The end-user has denied access to the camera or microphone.</li>
 *
 *     <li>The page is loaded on HTTP in Chrome, which requires HTTPS to access the camera and
 *     microphone.</li>
 *   </ul>
 * </td>
 * </tr>
 * <tr>
 *   <td>1553</td>
 *   <td>WebRTC ICE workflow error. This is an error that occurs when trying to establish
 *   communication between clients in the session. Try publishing again or reconnecting to
 *   the session.</td>
 * </tr>
 * <tr>
 *   <td>1601</td>
 *   <td>Internal error -- WebRTC publisher error. Try republishing or reconnecting to the
 *     session.</td>
 * </tr>
 * <tr>
 *   <td>2001</td>
 *   <td>Publish Failed. Unexpected response from the OpenTok server. Try publishing again
 *     later.</td>
 * </tr>
 * </tbody></table>
 *
 * <p>Errors when calling <code>Session.signal()</code>:</p>
 *
 * <table class="docs_table" style="width:100%"><tbody>
 * <tr>
 *   <td><b><code>code</code></b></td>
 *   <td><b>Description</b></td>
 * </tr>
 * <tr>
 *     <td>400</td>
 *     <td>One of the signal properties &mdash; data, type, or to &mdash;
 *                 is invalid. Or the data cannot be parsed as JSON.</td>
 * </tr>
 * <tr>
 *   <td>404</td> <td>The to connection does not exist.</td>
 * </tr>
 * <tr>
 *   <td>413</td> <td>The type string exceeds the maximum length (128 bytes),
 *     or the data string exceeds the maximum size (8 kB).</td>
 * </tr>
 * <tr>
 *   <td>500</td>
 *   <td>The client is not connected to the OpenTok session. Check that the client connects
 *     successfully before trying to signal. And check that the client has not disconnected before
 *     trying to signal.</td>
 * </tr>
 * <tr>
 *   <td>2001</td>
 *   <td>Signal Failed. Unexpected response from the OpenTok server. Try sending the signal again
 *     later.</td>
 * </tr>
 * </tbody></table>
 *
 * <p>Errors when calling <code>Session.subscribe()</code>:</p>
 *
 * <table class="docs_table" style="width:100%"><tbody>
 * <tr>
 *   <td><b>
 *       <code>code</code>
 *     </b></td>
 *   <td><b>Description</b></td>
 * </tr>
 * <tr>
 *   <td>1013</td>
 *   <td>WebRTC PeerConnection error. Try resubscribing to the stream or
 *     reconnecting to the session.</td>
 * </tr>
 * <tr>
 *   <td>1554</td>
 *   <td>WebRTC ICE workflow error. This is an error that occurs when trying to establish
 *   communication between clients in the session. Try resubscribing to the stream or
 *   reconnecting to the session.</td>
 * </tr>
 * <tr>
 *   <td>1600</td>
 *   <td>Internal error -- WebRTC subscriber error. Try resubscribing to the stream or
 *     reconnecting to the session.</td>
 * </tr>
 * <tr>
 *  <td>1605</td>
 *  <td>Stream limit exceeded. The client tried to subscribe to a stream in a session
 *  that has exceeded the limit for simultaneous streams.</td>
 * </tr>
 * <tr>
 *   <td>2001</td>
 *   <td>Subscribe Failed. Unexpected response from the OpenTok server. Try subscribing again
 *     later.</td>
 * </tr>
 * </tbody></table>
 *
 * <p>Errors when calling <code>OT.initPublisher()</code>:</p>
 *
 * <table class="docs_table"><tbody>
 * <tr>
 *   <td><b><code>code</code></b></td>
 *   <td><b>Description</b></td>
 * </tr>
 * <tr>
 *   <td>1004</td>
 *   <td>Authentication error. Check the error message for details. This error can result if you
 *     pass in an expired token when trying to connect to a session. It can also occur if you
 *     pass in an invalid token or API key. Make sure that you are generating the token using
 *     the current version of one of the
 *     <a href="http://tokbox.com/opentok/libraries/server">OpenTok server SDKs</a>.</td>
 * </tr>
 * <tr>
 *   <td>1550</td>
 *   <td>Screen sharing is not supported (and you set the <code>videoSource</code> property
 *     of the <code>options</code> parameter of <code>OT.initPublisher()</code> to
 *     <code>"application"</code>, <code>"screen"</code>, or <code>"window"</code>).
 *     Before calling <code>OT.initPublisher()</code>, you can call
 *     <a href="OT.html#checkScreenSharingCapability">OT.checkScreenSharingCapability()</a>
 *     to check if screen sharing is supported.</td>
 * </tr>
 * <tr>
 *   <td>1551</td>
 *   <td>A screen-sharing extension needs to be registered but it is not. This error can occur
 *     when you set the <code>videoSource</code> property of the <code>options</code> parameter
 *     of <code>OT.initPublisher()</code> to <code>"application"</code>, <code>"screen"</code>,
 *     or <code>"window"</code>. Before calling <code>OT.initPublisher()</code>, you can call
 *     <a href="OT.html#checkScreenSharingCapability">OT.checkScreenSharingCapability()</a>
 *     to check if screen sharing requires an extension to be registered.</td>
 * </tr>
 * <tr>
 *   <td>1552</td>
 *   <td>A screen-sharing extension is required, but it is not installed. This error can occur
 *     when you set the <code>videoSource</code> property of the <code>options</code> parameter
 *     of <code>OT.initPublisher()</code> to <code>"screen"</code>. Before calling
 *     <code>OT.initPublisher()</code>, you can call
 *     <a href="OT.html#checkScreenSharingCapability">OT.checkScreenSharingCapability()</a>
 *     to check if screen sharing requires an extension to be installed.</td>
 * </tr>
 * </tbody></table>
 *
 * <p>Errors when calling <code>OT.reportIssue()</code>:</p>
 *
 * <table class="docs_table"><tbody>
 * <tr>
 *   <td><b><code>code</code></b></td>
 *   <td><b>Description</b></td>
 * </tr>
 * <tr>
 *   <td>2011</td>
 *   <td>Error calling OT.reportIssue(). Check the client's network connection.</td>
 * </tr>
 * </tbody></table>
 *
 * <p>General errors that can occur when calling any method:</p>
 *
 * <table class="docs_table" style="width:100%"><tbody>
 * <tr>
 *   <td><b><code>code</code></b></td>
 *   <td><b>Description</b></td>
 * </tr>
 * <tr>
 *   <td>1011</td>
 *   <td>Invalid Parameter. Check that you have passed valid parameter values into the method
 *     call.</td>
 * </tr>
 * <tr>
 *   <td>2000</td>
 *   <td>Internal Error. Try reconnecting to the OpenTok session and trying the action again.</td>
 * </tr>
 * </tbody></table>
 *
 * @property {String} message The message string provides details about the error.
 *
 * <p>
 * Use the <code>name</code> property (not the <code>message</code> property) to identify the error
 * programatically.
 *
 * @property {String} name A string identifying the error. Use this property (not the
 * <code>code</code> property) to identify the error.
 *
 * <p>Note that for all errors, this string starts with <code>'OT_'</code>.
 *
 * <p>This property is undefined for unexpected errors.
 *
 * <p>Errors that can occur when calling <code>OT.initPublisher()</code>:</p>
 *
 * <table class="docs_table" style="width:100%"><tbody>
 * <tr>
 *   <td><b><code>name</code></b></td>
 *   <td><b>Description</b></td>
 * </tr>
 * <tr>
 *   <td><code>'OT_HARDWARE_UNAVAILABLE'</code></td>
 *   <td>The hardware to fulfill the user media request appears to exist but could not be acquired.
 *   It might be in use by another application.</td>
 * </tr>
 * <tr>
 *   <td><code>'OT_INVALID_PARAMETER'</code></td>
 *   <td>One or more parameters was not valid or not provided.</td>
 * </tr>
 * <tr>
 *   <td><code>'OT_MEDIA_ERR_ABORTED'</code></td>
 *   <td>The fetching of the stream for the video element has been aborted.</td>
 * </tr>
 * <tr>
 *   <td><code>'OT_MEDIA_ERR_DECODE'</code></td>
 *   <td>A decoding error occurred while trying to play the stream in the video element.</td>
 * </tr>
 * <tr>
 *   <td><code>'OT_MEDIA_ERR_NETWORK'</code></td>
 *   <td>A network error caused the stream to stop being fetched.</td>
 * </tr>
 * <tr>
 *   <td><code>'OT_MEDIA_ERR_SRC_NOT_SUPPORTED'</code></td>
 *   <td>The stream has been detected to be not suitable for playback.</td>
 * </tr>
 * <tr>
 *   <td><code>'OT_NOT_SUPPORTED'</code></td>
 *   <td>Something in the user media request is not supported.</td>
 * </tr>
 * <tr>
 *   <td><code>'OT_NO_DEVICES_FOUND'</code></td>
 *   <td>No devices were found to provide the media stream.</td>
 * </tr>
 * <tr>
 *   <td><code>'OT_NO_VALID_CONSTRAINTS'</code></td>
 *   <td>Video and audio were both disabled. You need to enable at least one.</td>
 * </tr>
 * <tr>
 *   <td><code>'OT_SCREEN_SHARING_NOT_SUPPORTED'</code></td>
 *   <td>Screen sharing is not supported in the browser.</td>
 * </tr>
 * <tr>
 *   <td><code>'OT_SCREEN_SHARING_EXTENSION_NOT_REGISTERED'</code></td>
 *   <td>Screen-sharing support in this browser requires an extension, but one has not been
 *   registered.</td>
 * </tr>
 * <tr>
 *   <td><code>'OT_SCREEN_SHARING_EXTENSION_NOT_INSTALLED'</code></td>
 *   <td>Screen-sharing support in this browser requires an extension, but the extension is not
 *   installed.</td>
 * </tr>
 * </table>
 *
 * <p>Errors that can occur when calling <code>OT.reportIssue()</code>:</p>
 *
 * <table class="docs_table" style="width:100%"><tbody>
 * <tr>
 *   <td><b><code>name</code></b></td>
 *   <td><b>Description</b></td>
 * </tr>
 * <tr>
 *   <td><code>'OT_REPORT_ISSUE_FAILED'</code></td>
 *   <td>Error calling OT.reportIssue(). Check the client\'s network connection.</td>
 * </tr>
 * </table>
 *
 * <p>Errors that can occur when calling <code>Session.connect()</code>:</p>
 *
 * <table class="docs_table" style="width:100%"><tbody>
 * <tr>
 *   <td><b><code>name</code></b></td>
 *   <td><b>Description</b></td>
 * </tr>
 * <tr>
 *   <td><code>'OT_AUTHENTICATION_ERROR'</code></td>
 *   <td>The API key does not match the token or session.</td>
 * </tr>
 * <tr>
 *   <td><code>'OT_BADLY_FORMED_RESPONSE'</code></td>
 *   <td>The JSON response from the OpenTok server was badly formed.</td>
 * </tr>
 * <tr>
 *   <td><code>'OT_CONNECT_FAILED'</code></td>
 *   <td>Failed to connect to session.</td>
 * </tr>
 * <tr>
 *   <td><code>'OT_CONNECTION_LIMIT_EXCEEDED'</code></td>
 *   <td>The client tried to connect to a session that has exceeded the limit for
 *   simultaneous connections.</td>
 * </tr>
 * <tr>
 *   <td><code>'OT_EMPTY_RESPONSE_BODY'</code></td>
 *   <td>Received an unexpected empty response from the OpenTok server.</td>
 * </tr>
 * <tr>
 *   <td><code>'OT_INVALID_SESSION_ID'</code></td>
 *   <td>The session ID was invalid.</td>
 * </tr>
 * <tr>
 *   <td><code>'OT_INVALID_PARAMETER'</code></td>
 *   <td>One or more parameters was not valid or not provided.</td>
 * </tr>
 * <tr>
 *   <td><code>'OT_NOT_CONNECTED'</code></td>
 *   <td>Couldn't perform action because you are not connected to the network.</td>
 * </tr>
 * <tr>
 *   <td><code>'OT_TERMS_OF_SERVICE_FAILURE'</code></td>
 *   <td>Couldn't connect due to a terms of service violation.</td>
 * </tr>
 * <tr>
 *   <td><code>'OT_INVALID_HTTP_STATUS'</code></td>
 *   <td>Received an unexpected HTTP status.</td>
 * </tr>
 * <tr>
 *   <td><code>'OT_XDOMAIN_OR_PARSING_ERROR'</code></td>
 *   <td>There was a cross domain error or the server responded with invalid JSON.</td>
 * </tr>
 * </table>
 *
 * <p>Errors that can occur when calling <code>Session.forceDisconnect()</code>:</p>
 *
 * <table class="docs_table" style="width:100%"><tbody>
 * <tr>
 *   <td><b><code>name</code></b></td>
 *   <td><b>Description</b></td>
 * </tr>
 * <tr>
 *   <td><code>'OT_INVALID_PARAMETER'</code></td>
 *   <td>One or more parameters was not valid or not provided.</td>
 * </tr>
 * <tr>
 *   <td><code>'OT_NOT_CONNECTED'</code></td>
 *   <td>Couldn't perform action because you are not connected to the network.</td>
 * </tr>
 * <tr>
 *   <td><code>'OT_PERMISSION_DENIED'</code></td>
 *   <td>This token does not allow this action. The role must be at least moderator.</td>
 * </tr>
 * </table>
 *
 * <p>Errors that can occur when calling <code>Session.forceUnpublish()</code>:</p>
 *
 * <table class="docs_table" style="width:100%"><tbody>
 * <tr>
 *   <td><b><code>name</code></b></td>
 *   <td><b>Description</b></td>
 * </tr>
 * <tr>
 *   <td><code>'OT_INVALID_PARAMETER'</code></td>
 *   <td>One or more parameters was not valid or not provided.</td>
 * </tr>
 * <tr>
 *   <td><code>'OT_NOT_CONNECTED'</code></td>
 *   <td>Couldn't perform action because you are not connected to the network.</td>
 * </tr>
 * <tr>
 *   <td><code>'OT_PERMISSION_DENIED'</code></td>
 *   <td>This token does not allow this action. The role must be at least moderator.</td>
 * </tr>
 * </table>
 *
 * <p>Errors that can occur when calling <code>Session.publish()</code>:</p>
 *
 * <table class="docs_table" style="width:100%"><tbody>
 * <tr>
 *   <td><b><code>name</code></b></td>
 *   <td><b>Description</b></td>
 * </tr>
 * <tr>
 *   <td><code>'OT_CHROME_MICROPHONE_ACQUISITION_ERROR'</code></td>
 *   <td>Chrome fails to get access to the microphone, due to a Chrome error. To work
 *   around this issue, the end-user must restart Chrome and reload your site. This is a
 *   <a href="https://bugs.chromium.org/p/webrtc/issues/detail?id=4799">known issue</a>
 *   to be fixed in Chrome.</td>
 * </tr>
 * <tr>
 *   <td><code>'OT_CONSTRAINTS_NOT_SATISFIED'</code></td>
 *   <td>The constraints for getting user media could not be satisfied.</td>
 * </tr>
 * <tr>
 *   <td><code>'OT_CREATE_PEER_CONNECTION_FAILED'</code></td>
 *   <td>Failed to create a connection between this client and the subscriber or the
 *   OpenTok Media Router.</td>
 * </tr>
 * <tr>
 *   <td><code>'OT_HARDWARE_UNAVAILABLE'</code></td>
 *   <td>The hardware to fulfill the user media request appears to exist but could not be acquired.
 *   It might be in use by another application.</td>
 * </tr>
 * <tr>
 *   <td><code>'OT_ICE_WORKFLOW_FAILED'</code></td>
 *   <td>Something went wrong while establishing WebRTC connectivity.</td>
 * </tr>
 * <tr>
 *   <td><code>'OT_INVALID_PARAMETER'</code></td>
 *   <td>One or more parameters was not valid or not provided.</td>
 * </tr>
 * <tr>
 *   <td><code>'OT_MEDIA_ERR_ABORTED'</code></td>
 *   <td>The fetching of the stream for the video element has been aborted.</td>
 * </tr>
 * <tr>
 *   <td><code>'OT_MEDIA_ERR_DECODE'</code></td>
 *   <td>A decoding error occurred while trying to play the stream in the video element.</td>
 * </tr>
 * <tr>
 *   <td><code>'OT_MEDIA_ERR_NETWORK'</code></td>
 *   <td>A network error caused the stream to stop being fetched.</td>
 * </tr>
 * <tr>
 *   <td><code>'OT_MEDIA_ERR_SRC_NOT_SUPPORTED'</code></td>
 *   <td>The stream has been detected to be not suitable for playback.</td>
 * </tr>
 * <tr>
 *   <td><code>'OT_NO_DEVICES_FOUND'</code></td>
 *   <td>No devices were found to provide the media stream.</td>
 * </tr>
 * <tr>
 *   <td><code>'OT_NO_VALID_CONSTRAINTS'</code></td>
 *   <td>Video and audio were both disabled. You need to enable at least one.</td>
 * </tr>
 * <tr>
 *   <td><code>'OT_NOT_CONNECTED'</code></td>
 *   <td>Couldn't perform action because you are not connected to the network.</td>
 * </tr>
 * <tr>
 *   <td><code>'OT_NOT_SUPPORTED'</code></td>
 *   <td>Something in the user media request is not supported.</td>
 * </tr>
 * <tr>
 *   <td><code>'OT_PERMISSION_DENIED'</code></td>
 *   <td>This token does not allow publishing. The role must be at least publisher to enable
 *   this funcitonality.</td>
 * </tr>
 * <tr>
 *   <td><code>'OT_SCREEN_SHARING_NOT_SUPPORTED'</code></td>
 *   <td>Screen sharing is not supported in the browser.</td>
 * </tr>
 * <tr>
 *   <td><code>'OT_SCREEN_SHARING_EXTENSION_NOT_REGISTERED'</code></td>
 *   <td>Screen-sharing support in this browser requires an extension, but one has not been
 *   registered.</td>
 * </tr>
 * <tr>
 *   <td><code>'OT_SCREEN_SHARING_EXTENSION_NOT_INSTALLED'</code></td>
 *   <td>Screen-sharing support in this browser requires an extension, but the extension is not
 *   installed.</td>
 * </tr>
 * <tr>
 *   <td><code>'OT_SET_REMOTE_DESCRIPTION_FAILED'</code></td>
 *   <td>The WebRTC connection failed during setDescription.</td>
 * </tr>
 * <tr>
 *   <td><code>'OT_STREAM_CREATE_FAILED'</code></td>
 *   <td>Failed to create the stream in the server model.</td>
 * </tr>
 * <tr>
 *   <td><code>'OT_TIMEOUT'</code></td>
 *   <td>Could not publish in a reasonable amount of time.</td>
 * </tr>
 * <tr>
 *   <td><code>'OT_USER_MEDIA_ACCESS_DENIED'</code></td>
 *   <td>The end-user denied access to screen sharing.</td>
 * </tr>
 * <tr>
 *   <td><code>'OT_UNEXPECTED_SERVER_RESPONSE'</code></td>
 *   <td>This indicates an unexpected error from the OpenTok server.</td>
 * </tr>
 * </table>
 *
 * <p>Errors that can occur when calling <code>Session.signal()</code>:</p>
 *
 * <table class="docs_table" style="width:100%"><tbody>
 * <tr>
 *   <td><b><code>name</code></b></td>
 *   <td><b>Description</b></td>
 * </tr>
 * <tr>
 *   <td><code>'OT_INVALID_PARAMETER'</code></td>
 *   <td>One or more parameters was not valid or not provided.</td>
 * </tr>
 * <tr>
 *   <td><code>'OT_NOT_CONNECTED'</code></td>
 *   <td>Couldn't perform action because you are not connected to the network.</td>
 * </tr>
 * <tr>
 *   <td><code>'OT_NOT_FOUND'</code></td>
 *   <td>A resource was not found.</td>
 * </tr>
 * <tr>
 *   <td><code>'OT_RATE_LIMIT_EXCEEDED'</code></td>
 *   <td>The signal could not be sent due to the rate limit.</td>
 * </tr>
 * </table>
 *
 * <p>Errors that can occur when calling <code>Session.subscribe()</code>:</p>
 *
 * <table class="docs_table" style="width:100%"><tbody>
 * <tr>
 *   <td><b><code>name</code></b></td>
 *   <td><b>Description</b></td>
 * </tr>
 * <tr>
 *   <td><code>'OT_CREATE_PEER_CONNECTION_FAILED'</code></td>
 *   <td>Failed to create a connection between this client and the stream's publisher or the
 *   OpenTok Media Router.</td>
 * </tr>
 * <tr>
 *   <td><code>'OT_DISCONNECTED'</code></td>
 *   <td>Action failed because the client is not connected to the session.</td>
 * </tr>
 * <tr>
 *   <td><code>'OT_INVALID_PARAMETER'</code></td>
 *   <td>One or more parameters was not valid or not provided.</td>
 * </tr>
 * <tr>
 *   <td><code>'OT_ICE_WORKFLOW_FAILED'</code></td>
 *   <td>Something went wrong while establishing WebRTC connectivity.</td>
 * </tr>
 * <tr>
 *   <td><code>'OT_MEDIA_ERR_ABORTED'</code></td>
 *   <td>The fetching of the stream for the video element has been aborted.</td>
 * </tr>
 * <tr>
 *   <td><code>'OT_MEDIA_ERR_DECODE'</code></td>
 *   <td>A decoding error occurred while trying to play the stream in the video element.</td>
 * </tr>
 * <tr>
 *   <td><code>'OT_MEDIA_ERR_NETWORK'</code></td>
 *   <td>A network error caused the stream to stop being fetched.</td>
 * </tr>
 * <tr>
 *   <td><code>'OT_MEDIA_ERR_SRC_NOT_SUPPORTED'</code></td>
 *   <td>The stream has been detected to be not suitable for playback.</td>
 * </tr>
 * <tr>
 *   <td><code>'OT_NOT_CONNECTED'</code></td>
 *   <td>Couldn't perform action because you are not connected to the network.</td>
 * </tr>
 * <tr>
 *   <td><code>'OT_SET_REMOTE_DESCRIPTION_FAILED'</code></td>
 *   <td>The WebRTC connection failed during setDescription.</td>
 * </tr>
 * <tr>
 *   <td><code>'OT_STREAM_DESTROYED'</code></td>
 *   <td>The stream was destroyed before it could be subscribed to.</td>
 * </tr>
 * <tr>
 *   <td><code>'OT_STREAM_LIMIT_EXCEEDED'</code></td>
 *   <td>The client tried to subscribe to a stream in a session that has exceeded the limit
 *   for simultaneous streams.</td>
 * </tr>
 * <tr>
 *   <td><code>'OT_STREAM_NOT_FOUND'</code></td>
 *   <td>Couldn't subscribe to the stream because it was not found.</td>
 * </tr>
 * </table>
 *
 * <p>Errors that can occur when calling <code>Subscriber.getStats()</code>:</p>
 *
 * <table class="docs_table" style="width:100%"><tbody>
 * <tr>
 *   <td><b><code>name</code></b></td>
 *   <td><b>Description</b></td>
 * </tr>
 * <tr>
 *   <td><code>'OT_NOT_CONNECTED'</code></td>
 *   <td>Couldn't perform action because you are not connected to the network.</td>
 * </tr>
 * </table>
 *
 * @class Error
 * @augments Event
 */

var OTErrorClass = function OTErrorClass(code, message) {
  Error.call(this);

  this.code = code;
  this.message = message;
};

OTErrorClass.prototype = Object.create(Error.prototype);
OTErrorClass.prototype.constructor = OTErrorClass;

module.exports = OTErrorClass;

OTHelpers.eventing(OTErrorClass);

var errorsCodesToTitle = {
  1004: 'Authentication error',
  1005: 'Invalid Session ID',
  1006: 'Connect Failed',
  1007: 'Connect Rejected',
  1008: 'Connect Time-out',
  1009: 'Security Error',
  1010: 'Not Connected',
  1011: 'Invalid Parameter',
  1012: 'Peer-to-peer Stream Play Failed',
  1013: 'Connection Failed',
  1014: 'API Response Failure',
  1015: 'PeerConnection not connected, cannot call this method',
  1021: 'Request Timeout',
  1026: 'Terms of Service Violation: Export Compliance',
  1027: 'Connection Limit Exceeded',
  1500: 'Unable to Publish',
  1503: 'No TURN server found',
  1520: 'Unable to Force Disconnect',
  1530: 'Unable to Force Unpublish',
  1553: 'ICEWorkflow failed',
  1600: 'createOffer, createAnswer, setLocalDescription, setRemoteDescription',
  1605: 'Stream Limit Exceeded',
  2000: 'Internal Error',
  2001: 'Unexpected Server Response',
  4000: 'WebSocket Connection Failed',
  4001: 'WebSocket Network Disconnected'
};

function _exceptionHandler(component, msg, errorCode, context) {
  var title = OTErrorClass.getTitleByCode(errorCode);
  var contextCopy = context ? OTHelpers.clone(context) : {};

  logging.error('OT.exception :: title: ' + title + ' (' + errorCode + ') msg: ' + msg);

  if (!contextCopy.partnerId) {
    contextCopy.partnerId = APIKEY.value;
  }

  try {
    analytics.logError(errorCode, 'tb.exception', title, { details: msg }, contextCopy);
    var event = new Events.ExceptionEvent(Events.Event.names.EXCEPTION, msg, title, errorCode, component, component);

    // Augment the event object with a stacktrace for error reporting purposes
    try {
      throw new Error();
    } catch (caughtError) {
      event.stack = caughtError.stack;
    }

    OTErrorClass.dispatchEvent(event);
  } catch (err) {
    logging.error('OT.exception :: Failed to dispatch exception - ' + err.toString());
    // Don't throw an error because this is asynchronous
    // don't do an exceptionHandler because that would be recursive
  }
}

/**
 * Get the title of an error by error code
 *
 * @property {Number|String} code The error code to lookup
 * @return {String} The title of the message with that code
 *
 * @example
 *
 * OTError.getTitleByCode(1006) === 'Connect Failed'
 */
OTErrorClass.getTitleByCode = function (code) {
  return errorsCodesToTitle[+code];
};

// @todo redo this when we have time to tidy up
//
// @example
//
//  OTError.handleJsException("Descriptive error message", 2000, {
//      session: session,
//      target: stream|publisher|subscriber|session|etc
//  });
//
OTErrorClass.handleJsException = function (errorMsg, code, options) {
  options = options || {};

  var session = options.session;
  var context = void 0;

  if (session) {
    context = {
      sessionId: session.sessionId,
      p2p: session && session.sessionInfo ? session.sessionInfo.p2pEnabled : null,
      messagingServer: session && session.sessionInfo ? session.messagingServer : null
    };

    if (session.isConnected() && session.connection) {
      context.connectionId = session.connection.connectionId;
    }

    if (!options.target) {
      options.target = session;
    }
  } else if (options.sessionId) {
    context = {
      sessionId: options.sessionId
    };

    if (!options.target) {
      options.target = null;
    }
  }

  _exceptionHandler(options.target, errorMsg, code, context);
};

},{"../common-js-helpers/OTHelpers.js":217,"./analytics.js":289,"./api_key.js":291,"./events.js":306,"./logging.js":312}],335:[function(require,module,exports){
'use strict';

var logging = require('../logging.js');

module.exports = function (transforms, localRemote, offerAnswer, transformOptions, sdp) {
  var transform = transforms[localRemote][offerAnswer];
  var type = localRemote + ' ' + offerAnswer;

  var pubSub = type === 'local offer' || type === 'remote answer' ? 'publisher' : 'subscriber';

  var logPrefix = 'sdpTransforms (' + pubSub + '): ' + localRemote + ' ' + offerAnswer;

  var createdReceived = localRemote === 'local' ? 'created' : 'received';
  logging.debug(logPrefix + ': ' + createdReceived + ':\n' + sdp);

  var transformedSdp = transform(transformOptions, sdp);

  if (transformedSdp === sdp) {
    logging.debug(logPrefix + ': not modified');
  } else {
    logging.debug(logPrefix + ': modified to:\n' + transformedSdp);
  }

  return transformedSdp;
};

},{"../logging.js":312}],336:[function(require,module,exports){
'use strict';

// @todo enable the following disabled rules see OPENTOK-31136 for more info
/* eslint-disable no-plusplus, no-cond-assign, no-underscore-dangle, no-restricted-syntax */
/* eslint-disable no-prototype-builtins */

var OTHelpers = require('../../common-js-helpers/OTHelpers.js');
var logging = require('../logging.js');

// Wraps up a native RTCDataChannelEvent object for the message event. This is
// so we never accidentally leak the native DataChannel.
//
// @constructor
// @private
//
//
var DataChannelMessageEvent = function DataChannelMessageEvent(event) {
  this.data = event.data;
  this.source = event.source;
  this.lastEventId = event.lastEventId;
  this.origin = event.origin;
  this.timeStamp = event.timeStamp;
  this.type = event.type;
  this.ports = event.ports;
  this.path = event.path;
};

// DataChannel is a wrapper of the native browser RTCDataChannel object.
//
// It exposes an interface that is very similar to the native one except
// for the following differences:
//  * eventing is handled in a way that is consistent with the OpenTok API
//  * calls to the send method that occur before the channel is open will be
//    buffered until the channel is open (as opposed to throwing an exception)
//
// By design, there is (almost) no direct access to the native object. This is to ensure
// that we can control the underlying implementation as needed.
//
// NOTE: IT TURNS OUT THAT FF HASN'T IMPLEMENT THE LATEST PUBLISHED DATACHANNELS
// SPEC YET, SO THE INFO ABOUT maxRetransmitTime AND maxRetransmits IS WRONG. INSTEAD
// THERE IS A SINGLE PROPERTY YOU PROVIDE WHEN CREATING THE CHANNEL WHICH CONTROLS WHETHER
// THE CHANNEL IS RELAIBLE OF NOT.
//
// Two properties that will have a large bearing on channel behaviour are maxRetransmitTime
// and maxRetransmits. Descriptions of those properties are below. They are set when creating
// the initial native RTCDataChannel.
//
// maxRetransmitTime of type unsigned short, readonly , nullable
//   The RTCDataChannel.maxRetransmitTime attribute returns the length of the time global
//   (in milliseconds) during which retransmissions may occur in unreliable mode, or null if
//   unset. The attribute MUST return the value to which it was set when the RTCDataChannel was
//   created.
//
// maxRetransmits of type unsigned short, readonly , nullable
//   The RTCDataChannel.maxRetransmits attribute returns the maximum number of retransmissions
//   that are attempted in unreliable mode, or null if unset. The attribute MUST return the value
//   to which it was set when the RTCDataChannel was created.
//
// @reference http://www.w3.org/TR/webrtc/#peer-to-peer-data-api
//
// @param [RTCDataChannel] dataChannel A native data channel.
//
//
// @constructor
// @private
//
module.exports = function DataChannel(dataChannel) {
  var api = {};

  // / Private Data

  var bufferedMessages = [];

  var qosData = {
    sentMessages: 0,
    recvMessages: 0
  };

  // / Private API

  var bufferMessage = function bufferMessage(data) {
    bufferedMessages.push(data);
    return api;
  };

  var sendMessage = function sendMessage(data) {
    dataChannel.send(data);
    qosData.sentMessages++;

    return api;
  };

  var flushBufferedMessages = function flushBufferedMessages() {
    var data = void 0;

    while (data = bufferedMessages.shift()) {
      api.send(data);
    }
  };

  var onOpen = function onOpen() {
    api.send = sendMessage;
    flushBufferedMessages();
  };

  var onClose = function onClose(event) {
    api.send = bufferMessage;
    api.trigger('close', event);
  };

  var onError = function onError(event) {
    logging.error('Data Channel Error:', event);
  };

  var onMessage = function onMessage(domEvent) {
    var event = new DataChannelMessageEvent(domEvent);
    qosData.recvMessages++;

    api.trigger('message', event);
  };

  // / Public API

  OTHelpers.eventing(api, true);

  api.label = dataChannel.label;
  api.id = dataChannel.id;
  // api.maxRetransmitTime = dataChannel.maxRetransmitTime;
  // api.maxRetransmits = dataChannel.maxRetransmits;
  api.reliable = dataChannel.reliable;
  api.negotiated = dataChannel.negotiated;
  api.ordered = dataChannel.ordered;
  api.protocol = dataChannel.protocol;
  api._channel = dataChannel;

  api.close = function () {
    dataChannel.close();
  };

  api.equals = function (label, options) {
    if (api.label !== label) {
      return false;
    }

    for (var key in options) {
      if (options.hasOwnProperty(key)) {
        if (api[key] !== options[key]) {
          return false;
        }
      }
    }

    return true;
  };

  api.getQosData = function () {
    return qosData;
  };

  // Send initially just buffers all messages until
  // the channel is open.
  api.send = bufferMessage;

  // / Init
  dataChannel.addEventListener('open', onOpen, false);
  dataChannel.addEventListener('close', onClose, false);
  dataChannel.addEventListener('error', onError, false);
  dataChannel.addEventListener('message', onMessage, false);

  return api;
};

},{"../../common-js-helpers/OTHelpers.js":217,"../logging.js":312}],337:[function(require,module,exports){
'use strict';

var OTPlugin = require('../../otplugin/otplugin.js');
var OTHelpers = require('../../common-js-helpers/OTHelpers.js');
var toArray = require('lodash/toArray');

/**
 * @returns {function(RTCPeerConnection, function(DOMError, Array<RTCStats>))}
 */
module.exports = function getStatsAdapter() {
  // /
  // Get Stats using the older API. Used by all current versions
  // of Chrome.
  //
  function getStatsOldAPI(peerConnection, completion) {
    peerConnection.getStats(function (rtcStatsReport) {
      var stats = [];
      rtcStatsReport.result().forEach(function (rtcStat) {
        var stat = {};

        rtcStat.names().forEach(function (name) {
          stat[name] = rtcStat.stat(name);
        });

        // fake the structure of the "new" RTC stat object
        stat.id = rtcStat.id;
        stat.type = rtcStat.type;
        stat.timestamp = rtcStat.timestamp;
        stats.push(stat);
      });

      completion(null, stats);
    });
  }

  // /
  // Get Stats using the newer API.
  //
  function getStatsNewAPI(peerConnection, completion) {
    peerConnection.getStats(null).then(function (rtcStatsReport) {
      var stats = [];
      // Firefox <= 45 can't use rtcStatsReport.values OPENTOK-32755
      if (typeof rtcStatsReport.values === 'function') {
        stats = toArray(rtcStatsReport.values());
      } else if (typeof rtcStatsReport.forEach !== 'function') {
        stats = Object.keys(stats).map(function (key) {
          return stats[key];
        });
      } else {
        rtcStatsReport.forEach(function (rtcStats) {
          stats.push(rtcStats);
        });
      }
      completion(null, stats);
    }).catch(completion);
  }

  if (['Firefox', 'Edge', 'Safari'].indexOf(OTHelpers.browserVersion().name) !== -1 || OTPlugin.isInstalled()) {
    return getStatsNewAPI;
  }

  return getStatsOldAPI;
};

},{"../../common-js-helpers/OTHelpers.js":217,"../../otplugin/otplugin.js":390,"lodash/toArray":178}],338:[function(require,module,exports){
'use strict';

// @todo enable the following disabled rules see OPENTOK-31136 for more info
/* eslint-disable no-prototype-builtins */

var OTHelpers = require('../../common-js-helpers/OTHelpers.js');

var getStatsHelpers = {};
module.exports = getStatsHelpers;

getStatsHelpers.isVideoStat = function (stat) {
  // Chrome implementation only has this property for RTP video stat
  return stat.hasOwnProperty('googFrameWidthReceived') || stat.hasOwnProperty('googFrameWidthInput') || stat.mediaType === 'video' || stat.id !== undefined && stat.id.toLowerCase().indexOf('video') !== -1;
};

getStatsHelpers.isAudioStat = function (stat) {
  // Chrome implementation only has this property for RTP audio stat
  return stat.hasOwnProperty('audioInputLevel') || stat.hasOwnProperty('audioOutputLevel') || stat.mediaType === 'audio' || stat.id !== undefined && stat.id.toLowerCase().indexOf('audio') !== -1;
};

getStatsHelpers.isInboundStat = function (stat) {
  return stat.hasOwnProperty('bytesReceived') || stat.hasOwnProperty('packetsReceived');
};

getStatsHelpers.parseStatCategory = function (stat) {
  var statCategory = {
    packetsLost: 0,
    packetsReceived: 0,
    bytesReceived: 0
    // frameRate is only set for video stat
  };

  if (stat.hasOwnProperty('packetsReceived')) {
    statCategory.packetsReceived = parseInt(stat.packetsReceived, 10);
  }
  if (stat.hasOwnProperty('packetsLost')) {
    statCategory.packetsLost = parseInt(stat.packetsLost, 10);
  }
  if (stat.hasOwnProperty('bytesReceived')) {
    statCategory.bytesReceived = parseInt(stat.bytesReceived, 10);
  }

  if (getStatsHelpers.isVideoStat(stat)) {
    if (stat.hasOwnProperty('framerateMean')) {
      statCategory.frameRate = Number(stat.framerateMean);
    } else if (stat.hasOwnProperty('googFrameRateOutput')) {
      statCategory.frameRate = Number(stat.googFrameRateOutput);
    } else if (stat.hasOwnProperty('googFrameRateInput')) {
      statCategory.frameRate = Number(stat.googFrameRateInput);
    }
  }

  return statCategory;
};

getStatsHelpers.normalizeTimestamp = function (timestamp) {
  var now = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Date.now();

  if (OTHelpers.isObject(timestamp) && 'getTime' in timestamp) {
    // Chrome as of 39 delivers a "kind of Date" object for timestamps
    // we duck check it and get the timestamp
    return timestamp.getTime();
  }

  if (Math.abs(timestamp / (1000 * now) - 1) < 0.05) {
    // If the timestamp is within 5% of 1000x now, we assume its unit is microseconds and
    // divide by 1000 to correct for this.
    return timestamp / 1000;
  }

  return timestamp;
};

},{"../../common-js-helpers/OTHelpers.js":217}],339:[function(require,module,exports){
'use strict';

// @todo enable the following disabled rules see OPENTOK-31136 for more info
/* eslint-disable no-underscore-dangle */

var Bluebird = require('bluebird');
var promisify = require('./promisify.js');

/*
 * Process incoming Ice Candidates from a remote connection.
 *
 * @constructor
 * @private
 *
 * @param {PeerConection} peerConnection The PeerConnection we want to add the
 * Ice Candidates to.
 *
 * @description The Ice Candidates cannot be processed until the PeerConnection
 * has local and remote descriptions, if candidates are added too early they
 * will be put in a pending list. Once the PeerConnection is ready the pending
 * candidates will be applied.
 *
 * **note:** We assume that the PeerConnection has implemented the promisified
 * versions of addIceCandidate.
 *
 *
 * @example
 *
 *  const iceProcessor = new IceCandidateProcessor(pc);
 *  iceProcessor.process(iceMessage1);
 *  iceProcessor.process(iceMessage2);
 *  iceProcessor.process(iceMessage3);
 *
 *
 */
var IceCandidateProcessor = function IceCandidateProcessor(peerConnection) {
  this.pending = [];
  this._processBinding = this.maybeProcessPending.bind(this);

  if (peerConnection) {
    this.setPeerConnection(peerConnection);
  }
};

IceCandidateProcessor.prototype.setPeerConnection = function (peerConnection) {
  if (this.pc) {
    throw new Error('Peer connection already set');
  }

  this.pc = peerConnection;
  this._forwardIceCandidate = promisify(this.pc, 'addIceCandidate');
  this.pc.addEventListener('signalingstatechange', this._processBinding);
  this.maybeProcessPending();
};

/**
 * Returns true if the PeerConnection is ready to accept IceCandidates.
 *
 * @return {Boolean} True if IceCandidates can be applied, false otherwise
 *
 * @method #canAddCandidates
 * @memberof IceCandidateProcessor
 *
 */
IceCandidateProcessor.prototype.canAddCandidates = function () {
  // localDescription and removeDescription are nullable, so you would expect
  // that they would be null when those descriptions have not yet been applied
  // Chrome (as of 48) seems to instead give you a RTCSessionDescription with
  // type and sdp properties set to "".
  //
  // Because of this we need to ensure that type exists and contains something.
  //
  // We first check that the peer connection is not closed to prevent
  // Firefox from throwing an InvalidStateError. See OPENTOK-29358
  //
  return !!(this.pc && this.pc.iceConnectionState !== 'closed' && this.pc.localDescription && this.pc.localDescription.type && this.pc.remoteDescription && this.pc.remoteDescription.type);
};

/**
 * Add an RTCIceCandidate to the PeerConnection. If the PeerConnection is ready
 * it will be applied immediately, otherwise it will be buffered until later.
 *
 * @param {RTCIceCandidate} iceCandidate The candidate to add.
 *
 * @returns {Promise} A promise that is resolved when the candidate is applied.
 *
 * @method #addIceCandidate
 * @memberof IceCandidateProcessor
 *
 */
IceCandidateProcessor.prototype.addIceCandidate = function (iceCandidate) {
  if (this.canAddCandidates()) {
    return this._forwardIceCandidate(iceCandidate);
  }

  var pending = this.pending;

  return new Bluebird.Promise(function (resolve, reject) {
    pending.push({
      iceCandidate: iceCandidate,
      resolve: resolve,
      reject: reject
    });
  });
};

/**
 * Called to attempt to process any pending candidates.
 *
 * @description This will be called automatically when needed so there's no
 * reason to call it yourself. You totally could, but surely you have better
 * things to do?
 *
 * @param {RTCIceCandidate} iceCandidate The candidate to add.
 *
 * @returns {Promise} A promise that is resolved when the candidate is applied.
 *
 * @method #addIceCandidate
 * @memberof IceCandidateProcessor
 *
 */
IceCandidateProcessor.prototype.maybeProcessPending = function () {
  if (this.canAddCandidates()) {
    this.process();
  }
};

IceCandidateProcessor.prototype.process = function () {
  while (this.pending.length) {
    var pending = this.pending.shift();
    this._forwardIceCandidate(pending.iceCandidate).then(pending.resolve).catch(pending.reject);
  }
};

IceCandidateProcessor.prototype.destroy = function () {
  if (this.pc) {
    this.pc.removeEventListener('signalingstatechange', this._processBinding);
  }

  this._processBinding = null;
  this.pc = null;
};

module.exports = IceCandidateProcessor;

},{"./promisify.js":343,"bluebird":2}],340:[function(require,module,exports){
'use strict';

// @todo enable the following disabled rules see OPENTOK-31136 for more info
/* eslint-disable no-param-reassign */

var applySdpTransform = require('./applySdpTransform.js');
var logging = require('../logging.js');
var SDPHelpers = require('./sdp_helpers.js');

// Attempt to completely process +offer+. This will:
// * set the offer as the remote description
// * create an answer and
// * set the new answer as the location description
//
// If there are no issues, the +success+ callback will be executed on completion.
// Errors during any step will result in the +failure+ callback being executed.
//
module.exports = function offerProcessor(peerConnection, NativeRTCSessionDescription, sdpTransforms, offer, success, failure) {
  var generateErrorCallback = function generateErrorCallback(message, prefix) {
    return function (errorReason) {
      logging.error(message);
      logging.error(errorReason);

      if (failure) {
        failure(message, errorReason, prefix);
      }
    };
  };

  var setLocalDescription = function setLocalDescription(answer) {
    var enableStereo = SDPHelpers.hasSendStereo(offer.sdp);
    var audioBitrate = SDPHelpers.getAudioBitrate(offer.sdp);

    var newAnswer = new NativeRTCSessionDescription({
      type: answer.type,
      sdp: applySdpTransform(sdpTransforms, 'local', 'answer', { enableStereo: enableStereo, audioBitrate: audioBitrate }, answer.sdp)
    });

    peerConnection.setLocalDescription(newAnswer).then(function () {
      return success(newAnswer);
    }).catch(generateErrorCallback('Error while setting LocalDescription', 'SetLocalDescription'));
  };

  var createAnswer = function createAnswer() {
    peerConnection.createAnswer().then(setLocalDescription).catch(generateErrorCallback('Error while setting createAnswer', 'CreateAnswer'));
  };

  var newOffer = new NativeRTCSessionDescription({
    type: offer.type,
    sdp: applySdpTransform(sdpTransforms, 'remote', 'offer', {}, offer.sdp)
  });

  var errorCallback = generateErrorCallback('Error while setting RemoteDescription', 'SetRemoteDescription');

  peerConnection.setRemoteDescription(newOffer).then(createAnswer).catch(errorCallback);
};

},{"../logging.js":312,"./applySdpTransform.js":335,"./sdp_helpers.js":347}],341:[function(require,module,exports){
(function (global){
'use strict';

// @todo enable the following disabled rules see OPENTOK-31136 for more info
/* eslint-disable one-var, no-underscore-dangle, no-use-before-define, no-param-reassign */
/* eslint-disable no-shadow, max-len, no-var, vars-on-top, global-require */

var bluebird = require('bluebird');
var debounce = require('lodash/debounce');
var merge = require('lodash/merge');
var omit = require('lodash/omit');

var environmentLoader = require('../environment_loader.js');
var eventing = require('../../common-js-helpers/behaviours/eventing.js');
var OTHelpersError = require('../../common-js-helpers/error.js');
var RaptorConstants = require('../messaging/raptor/raptor_constants.js');

module.exports = function PeerConnectionFactory() {
  var deps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var applySdpTransform = deps.applySdpTransform || require('./applySdpTransform.js');
  var createPeerConnection = deps.createPeerConnection || require('../../helpers/create_peer_connection.js');
  var env = deps.env || require('../../common-js-helpers/env.js');
  var sdpTransformDefaults = deps.sdpTransformDefaults || require('./sdpTransformDefaults.js');
  var getStatsAdapter = deps.getStatsAdapter || require('./get_stats_adapter.js');
  var IceCandidateProcessor = deps.IceCandidateProcessor || require('./ice_candidate_processor');
  var logging = deps.logging || require('../logging.js');
  var offerProcessor = deps.offerProcessor || require('./offer_processor.js');
  var PeerConnectionChannels = deps.PeerConnectionChannels || require('./peer_connection_channels.js');
  var subscribeProcessor = deps.subscribeProcessor || require('./subscribe_processor.js');
  var Qos = deps.Qos || require('./qos.js');
  var webkitAudioWorkaround = deps.webkitAudioWorkaround || require('../../helpers/webkitAudioWorkaround.js');
  var window = deps.global || global;

  var NativeRTCIceCandidate = deps.NativeRTCIceCandidate || function () {
    var OTPlugin = require('../../otplugin/otplugin.js');

    return OTPlugin.isInstalled() && OTPlugin.RTCIceCandidate || window.RTCIceCandidate;
  }();

  var NativeRTCSessionDescription = deps.NativeRTCSessionDescription || function () {
    var OTPlugin = require('../../otplugin/otplugin.js');

    return OTPlugin.isInstalled() && OTPlugin.RTCSessionDescription || window.RTCSessionDescription;
  }();

  // Helper function to forward Ice Candidates via +sendMessage+
  var iceCandidateForwarder = function iceCandidateForwarder(sendMessage) {
    var sdpMids = {};
    return function (event) {
      if (event.candidate) {
        // It would be better to read the mids from the SDP
        sdpMids[event.candidate.sdpMid] = event.candidate.sdpMLineIndex;
        sendMessage(RaptorConstants.Actions.CANDIDATE, {
          candidate: event.candidate.candidate,
          sdpMid: event.candidate.sdpMid || '',

          // This is only needed for P2P interop between Safari and FF
          // See https://bugs.webkit.org/show_bug.cgi?id=173530
          sdpMLineIndex: env.name === 'Safari' && event.candidate.sdpMid === 'video' ? 1 : event.candidate.sdpMLineIndex || 0
        });
      } else {
        logging.debug('IceCandidateForwarder: No more ICE candidates.');
      }
    };
  };

  /*
  * Negotiates a WebRTC PeerConnection.
  *
  * Responsible for:
  * * offer-answer exchange
  * * iceCandidates
  * * notification of remote streams being added/removed
  *
  */
  return function PeerConnection() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var clientCandidates = options.clientCandidates,
        isPublisher = options.isPublisher,
        _options$logAnalytics = options.logAnalyticsEvent,
        logAnalyticsEvent = _options$logAnalytics === undefined ? function () {} : _options$logAnalytics,
        offerOverrides = options.offerOverrides,
        answerOverrides = options.answerOverrides,
        sdpTransformOptions = options.sdpTransformOptions;


    var api = {};

    var sdpTransforms = merge({}, sdpTransformDefaults, sdpTransformOptions);

    var shouldFilterCandidate = function shouldFilterCandidate(candidate) {
      return clientCandidates === 'relayed' && candidate != null && candidate.candidate.indexOf('typ relay') === -1;
    };

    var config = omit(options, ['isPublisher', 'logAnalyticsEvent', 'offerOverrides', 'answerOverrides', 'sendMessage', 'sdpTransformOptions']);

    var _peerConnection = void 0,
        _channels = void 0,
        _offer = void 0,
        _answer = void 0;
    var _peerConnectionCompletionHandlers = [];

    var _simulcastEnabled = function () {
      var value = config.overrideSimulcastEnabled || false;

      return {
        get: function get() {
          return value;
        },
        set: function set(newValueParam) {
          var newValue = Boolean(newValueParam) && config.capableSimulcastStreams > 1;

          if (newValue !== value && config.overrideSimulcastEnabled === undefined) {
            value = newValue;
            api.generateOffer();
          }
        }
      };
    }();

    var _iceRestartNeeded = function () {
      var value = false;

      return {
        get: function get() {
          return value;
        },
        set: function set(newValueParam) {
          var newValue = Boolean(newValueParam);

          if (newValue !== value) {
            value = newValue;

            if (value) {
              api.generateOffer();
            }
          }
        }
      };
    }();

    var _getStatsAdapter = getStatsAdapter();
    var _sendMessage = options.sendMessage;

    // OPENTOK-27106: This _readyToSendOffer mechanism is a workaround for a P2P IE->FF issue where
    // ice candidates sometimes take an excessive amount of time (~10 seconds) to be generated by the
    // IE plugin. FF will time out if there is a delay like this between receiving the offer and
    // receiving ice candidates, so the workaround holds back sending the offer until an ice candidate
    // appears.
    var _readyToSendOffer = {};

    _readyToSendOffer.promise = new bluebird.Promise(function (resolve, reject) {
      _readyToSendOffer.resolve = resolve;
      _readyToSendOffer.reject = reject;
    });

    var _iceProcessor = new IceCandidateProcessor();

    var _state = 'new';

    Object.defineProperty(api, 'signalingState', {
      get: function get() {
        return _peerConnection.signalingState;
      },
      set: function set(val) {
        // obviously they should not be doing this, but we'll mimic what the browser does.
        _peerConnection.signalingState = val;
        return val;
      }
    });

    eventing(api);

    if (env.name !== 'IE') {
      _readyToSendOffer.resolve();
    }

    // if ice servers doesn't exist Firefox will throw an exception. Chrome
    // interprets this as 'Use my default STUN servers' whereas FF reads it
    // as 'Don't use STUN at all'. *Grumble*
    if (!config.iceServers) {
      config.iceServers = [];
    }

    // Create and initialise the PeerConnection object. This deals with
    // any differences between the various browser implementations and
    // our own OTPlugin version.
    //
    // +completion+ is the function is call once we've either successfully
    // created the PeerConnection or on failure.
    //
    // +localWebRtcStream+ will be null unless the callee is representing
    // a publisher. This is an unfortunate implementation limitation
    // of OTPlugin, it's not used for vanilla WebRTC. Hopefully this can
    // be tidied up later.
    //
    var internalCreatePeerConnection = function internalCreatePeerConnection(completion, localWebRtcStream) {
      logging.debug('PeerConnection.internalCreatePeerConnection: called');

      if (_peerConnection) {
        logging.debug('PeerConnection.internalCreatePeerConnection: resolving synchronously');
        completion.call(null, null, _peerConnection);
        return;
      }

      _peerConnectionCompletionHandlers.push(completion);

      if (_peerConnectionCompletionHandlers.length > 1) {
        // The PeerConnection is already being setup, just wait for
        // it to be ready.
        return;
      }

      var pcConstraints = {
        optional: [
        // This should be unnecessary, but the plugin has issues if we remove it. This needs
        // to be investigated.
        { DtlsSrtpKeyAgreement: true }]
      };

      logging.debug('Creating peer connection config "' + JSON.stringify(config) + '".');

      if (!config.iceServers || config.iceServers.length === 0) {
        // This should never happen unless something is misconfigured
        logging.error('No ice servers present');
        logAnalyticsEvent('Error', 'noIceServers');
      }

      if (clientCandidates === 'relayed') {
        config.iceServers = config.iceServers.filter(function (iceServer) {
          return iceServer.url.indexOf('turn:') > -1;
        });
        config.iceServers.forEach(function (iceServer) {
          if (iceServer.urls) {
            // eslint-disable-next-line no-param-reassign
            iceServer.urls = iceServer.urls.filter(function (url) {
              return url.indexOf('turn:') > -1;
            });
          }
        });
        config.iceTransportPolicy = 'relay';
      }

      createPeerConnection({
        window: window,
        config: config,
        constraints: pcConstraints,
        webRTCStream: localWebRtcStream,
        completion: attachEventsToPeerConnection
      });
    };

    // An auxiliary function to internalCreatePeerConnection. This binds the various event
    // callbacks once the peer connection is created.
    //
    // +err+ will be non-null if an err occured while creating the PeerConnection
    // +pc+ will be the PeerConnection object itself.
    //
    var attachEventsToPeerConnection = function attachEventsToPeerConnection(err, pc) {
      if (err) {
        triggerError('Failed to create PeerConnection, exception: ' + err.toString(), 'NewPeerConnection');

        _peerConnectionCompletionHandlers = [];
        return;
      }

      logging.debug('OT attachEventsToPeerConnection');
      _peerConnection = pc;
      _iceProcessor.setPeerConnection(pc);
      _channels = new PeerConnectionChannels(_peerConnection);
      if (config.channels) {
        _channels.addMany(config.channels);
      }

      var forwarder = iceCandidateForwarder(_sendMessage);

      _peerConnection.addEventListener('icecandidate', function (event) {
        _readyToSendOffer.resolve();
        if (shouldFilterCandidate(event.candidate)) {
          logging.debug('Ignore candidate', event.candidate.candidate);
          return;
        }
        forwarder(event);
      }, false);

      // Work around the fact that the safari adapter shim only
      // fires 'addstream' event if onaddstream has been set
      // https://github.com/opentok/webrtc-js/pull/2266#issuecomment-305647862
      _peerConnection.onaddstream = function () {};

      _peerConnection.addEventListener('addstream', onRemoteStreamAdded, false);
      _peerConnection.addEventListener('removestream', onRemoteStreamRemoved, false);
      _peerConnection.addEventListener('signalingstatechange', routeStateChanged, false);
      _peerConnection.addEventListener('negotiationneeded', function () {
        if (isPublisher) {
          api.generateOffer();
        }
      });

      _peerConnection.addEventListener('iceconnectionstatechange', function () {
        if (_peerConnection.iceConnectionState === 'connected') {
          api.emit('iceConnected');
        }
      });

      var _previousIceState = _peerConnection.iceConnectionState;
      _peerConnection.addEventListener('iceconnectionstatechange', function (event) {
        var newIceState = event.target.iceConnectionState;
        api.trigger('iceConnectionStateChange', newIceState);

        if (_previousIceState !== 'disconnected' && newIceState === 'failed') {
          // the sequence disconnected => failure would indicate an abrupt disconnection (e.g. remote
          // peer closed the browser) or a network problem. We don't want to log that has a connection
          // establishment failure. This behavior is seen only in Chrome 47+

          triggerError('The stream was unable to connect due to a network error.' + ' Make sure your connection isn\'t blocked by a firewall.', 'ICEWorkflow');
        } else {
          logAnalyticsEvent('attachEventsToPeerConnection', 'iceconnectionstatechange', newIceState);
        }

        _previousIceState = newIceState;
      }, false);

      triggerPeerConnectionCompletion(null);
    };

    var triggerPeerConnectionCompletion = function triggerPeerConnectionCompletion() {
      while (_peerConnectionCompletionHandlers.length) {
        _peerConnectionCompletionHandlers.shift().call(null);
      }
    };

    // Clean up the Peer Connection and trigger the close event.
    // This function can be called safely multiple times, it will
    // only trigger the close event once (per PeerConnection object)
    var tearDownPeerConnection = function tearDownPeerConnection() {
      // Our connection is dead, stop processing ICE candidates
      if (_iceProcessor) {
        _iceProcessor.destroy();
        _iceProcessor = null;
      }

      qos.stopCollecting();

      if (_peerConnection !== null) {
        if (_peerConnection.destroy) {
          // OTPlugin defines a destroy method on PCs. This allows
          // the plugin to release any resources that it's holding.
          _peerConnection.destroy();
        }

        _peerConnection = null;
        api.trigger('close');
      }
    };

    var routeStateChanged = function routeStateChanged(event) {
      var newState = event.target.signalingState;

      api.emit('signalingStateChange', newState);

      if (newState === 'stable') {
        api.emit('signalingStateStable');
      }

      if (newState && newState !== _state) {
        _state = newState;
        logging.debug('PeerConnection.stateChange: ' + _state);

        switch (_state) {
          case 'closed':
            tearDownPeerConnection();
            break;
          default:
        }
      }
    };

    environmentLoader.onUnload(tearDownPeerConnection);

    var qosCallback = function qosCallback(parsedStats) {
      parsedStats.dataChannels = _channels.sampleQos();
      api.trigger('qos', { parsedStats: parsedStats, simulcastEnabled: _simulcastEnabled.get() });
    };

    var getRemoteStreams = function getRemoteStreams() {
      var streams = void 0;

      if (_peerConnection.getRemoteStreams) {
        streams = _peerConnection.getRemoteStreams();
      } else if (_peerConnection.remoteStreams) {
        streams = _peerConnection.remoteStreams;
      } else {
        throw new Error('Invalid Peer Connection object implements no ' + 'method for retrieving remote streams');
      }

      // Force streams to be an Array, rather than a 'Sequence' object,
      // which is browser dependent and does not behaviour like an Array
      // in every case.
      return Array.prototype.slice.call(streams);
    };

    // / PeerConnection signaling
    var onRemoteStreamAdded = function onRemoteStreamAdded(event) {
      api.trigger('streamAdded', webkitAudioWorkaround(event.stream));
    };

    var onRemoteStreamRemoved = function onRemoteStreamRemoved(event) {
      api.trigger('streamRemoved', event.stream);
    };

    // ICE Negotiation messages

    // Relays a SDP payload (+sdp+), that is part of a message of type +messageType+
    // via the registered message delegators
    var relaySDP = function relaySDP(messageType, sdp) {
      _sendMessage(messageType, sdp);
    };

    // Process an offer that
    var processOffer = function processOffer(message) {
      var offer = new NativeRTCSessionDescription({ type: 'offer', sdp: message.content.sdp });

      // Relays +answer+ Answer
      var relayAnswer = function relayAnswer(answer) {
        _iceProcessor.process();
        relaySDP(RaptorConstants.Actions.ANSWER, answer);
        qos.startCollecting(_peerConnection);
      };

      var reportError = function reportError(message, errorReason, prefix) {
        triggerError('PeerConnection.offerProcessor ' + message + ': ' + errorReason, prefix);
      };

      internalCreatePeerConnection(function () {
        offerProcessor(_peerConnection, NativeRTCSessionDescription, sdpTransforms, offer, relayAnswer, reportError);
      });
    };

    var processAnswer = function processAnswer(message) {
      if (!message.content.sdp) {
        logging.error('PeerConnection.processMessage: Weird answer message, no SDP.');
        return;
      }

      _answer = new NativeRTCSessionDescription({
        type: 'answer',
        sdp: applySdpTransform(sdpTransforms, 'remote', 'answer', answerOverrides, message.content.sdp)
      });

      (function () {
        var success = function success() {
          logging.debug('PeerConnection.processAnswer: setRemoteDescription Success');
          _iceProcessor.process();
        };
        var failure = function failure(errorReason) {
          triggerError('Error while setting RemoteDescription ' + errorReason, 'SetRemoteDescription');
        };
        _peerConnection.setRemoteDescription(_answer).then(success).catch(failure);
      })();

      qos.startCollecting(_peerConnection);
    };

    var processSubscribe = function processSubscribe() {
      logging.debug('PeerConnection.processSubscribe: Sending offer to subscriber.');

      var simulcastStreams = _simulcastEnabled.get() ? config.capableSimulcastStreams : 1;

      internalCreatePeerConnection(function () {
        subscribeProcessor(_peerConnection, NativeRTCSessionDescription, sdpTransforms, simulcastStreams, offerOverrides, { iceRestart: _iceRestartNeeded.get() },

        // Success: Relay Offer
        function (offer) {
          logging.debug('PeerConnection.processSubscribe: got offer, waiting for ' + '_readyToSendOffer');

          _offer = offer;
          _readyToSendOffer.promise.then(function () {
            logging.debug('PeerConnection.processSubscribe: sending offer');
            relaySDP(RaptorConstants.Actions.OFFER, _offer);
          });
        },

        // Failure
        function (message, errorReason, prefix) {
          triggerError('subscribeProcessor ' + message + ': ' + errorReason, prefix);
        });

        _iceRestartNeeded.set(false);
      });
    };

    api.generateOffer = debounce(processSubscribe, 100);

    var triggerError = function triggerError(errorReason, prefix) {
      logging.error(errorReason, 'in state', !_peerConnection ? '(none)' : {
        connectionState: _peerConnection.connectionState,
        iceConnectionState: _peerConnection.iceConnectionState,
        iceGatheringState: _peerConnection.iceGatheringState,
        signalingState: _peerConnection.signalingState
      });

      api.trigger('error', errorReason, prefix);
    };

    /*
    * Add a track to the underlying PeerConnection
    *
    * @param {object} track - the track to add
    * @param {object} stream - the stream to add it to
    * @return {RTCRtpSender}
    */
    api.addTrack = function (track, stream) {
      return new bluebird.Promise(function (resolve, reject) {
        internalCreatePeerConnection(function (err) {
          if (err) {
            return reject(err);
          }
          resolve();
          return undefined;
        });
      }).then(function () {
        if (_peerConnection.addTrack) {
          return _peerConnection.addTrack(track, stream);
        }

        var pcStream = _peerConnection.getLocalStreams()[0];
        if (pcStream === undefined) {
          throw new Error('PeerConnection has no existing streams, cannot addTrack');
        }
        pcStream.addTrack(track);
        api.generateOffer();
        return undefined;
      }).then(function () {
        return new bluebird.Promise(function (resolve) {
          api.once('signalingStateStable', function () {
            resolve();
          });
        }).timeout(15000, 'Renegotiation timed out');
      });
    };

    function FakeRTCRtpSender(track) {
      this.track = track;
    }

    /**
     * Remove a track from the underlying PeerConnection
     *
     * @param {RTCRtpSender} RTCRtpSender - the RTCRtpSender to remove
     */
    api.removeTrack = function (RTCRtpSender) {
      return bluebird.resolve().then(function () {
        if (RTCRtpSender instanceof FakeRTCRtpSender) {
          _peerConnection.getLocalStreams()[0].removeTrack(RTCRtpSender.track);
          api.generateOffer();
          return bluebird.resolve();
        }
        return _peerConnection.removeTrack(RTCRtpSender);
      }).then(function () {
        return new bluebird.Promise(function (resolve) {
          api.once('signalingStateStable', function () {
            resolve();
          });
        });
      }).timeout(15000, 'Renegotiation timed out');
    };

    api.addLocalStream = function (webRTCStream) {
      internalCreatePeerConnection(function () {
        _peerConnection.addStream(webRTCStream);
      }, webRTCStream);
    };

    api.getLocalStreams = function () {
      return _peerConnection.getLocalStreams();
    };

    api.getSenders = function () {
      if (_peerConnection.getSenders) {
        return _peerConnection.getSenders();
      }

      return _peerConnection.getLocalStreams()[0].getTracks().map(function (track) {
        return new FakeRTCRtpSender(track);
      });
    };

    api.disconnect = function () {
      if (_iceProcessor) {
        _iceProcessor.destroy();
        _iceProcessor = null;
      }

      if (_peerConnection && _peerConnection.signalingState && _peerConnection.signalingState.toLowerCase() !== 'closed') {
        _peerConnection.close();

        if (env.name === 'Firefox') {
          // FF seems to never go into the closed signalingState when the close
          // method is called on a PeerConnection. This means that we need to call
          // our cleanup code manually.
          //
          // * https://bugzilla.mozilla.org/show_bug.cgi?id=989936
          //
          setTimeout(tearDownPeerConnection);
        }
      }

      api.off();
    };

    api.iceRestart = function () {
      return _iceRestartNeeded.set(true);
    };

    api.processMessage = function (type, message) {
      logging.debug('PeerConnection.processMessage: Received ' + type + ' from ' + message.fromAddress);

      logging.debug(message);

      switch (type) {
        case 'generateoffer':
          if (message.content && message.content.simulcastEnabled !== undefined) {
            _simulcastEnabled.set(message.content.simulcastEnabled);
          }

          api.generateOffer();
          break;

        case 'offer':
          processOffer(message);
          break;

        case 'answer':
        case 'pranswer':
          processAnswer(message);
          break;

        case 'candidate':
          var iceCandidate = new NativeRTCIceCandidate(message.content);
          if (shouldFilterCandidate(iceCandidate)) {
            logging.debug('Ignore candidate', iceCandidate.candidate);
            return api;
          }

          _iceProcessor.addIceCandidate(iceCandidate).catch(function (err) {
            triggerError('Error while adding ICE candidate: ' + JSON.stringify(iceCandidate) + ': ' + err.toString(), 'ICEWorkflow');
          });

          break;

        default:
          logging.debug('PeerConnection.processMessage: Received an unexpected message of type ' + type + ' from ' + message.fromAddress + ': ' + JSON.stringify(message));
      }

      return api;
    };

    api.setIceServers = function (iceServers) {
      if (iceServers) {
        config.iceServers = iceServers;
      }
    };

    api.remoteStreams = function () {
      return _peerConnection ? getRemoteStreams() : [];
    };

    api.remoteTracks = function () {
      if (!_peerConnection) {
        return [];
      }

      if (_peerConnection.getReceivers) {
        return Array.prototype.slice.apply(_peerConnection.getReceivers()).map(function (receiver) {
          return receiver.track;
        });
      }

      return Array.prototype.concat.apply([], getRemoteStreams().map(function (stream) {
        return stream.getTracks();
      }));
    };

    api.remoteDescription = function () {
      return _peerConnection.remoteDescription;
    };

    /*
    * @param {function(DOMError, Array<RTCStats>)} callback
    */
    api.getStats = function (callback) {
      if (!_peerConnection) {
        callback(new OTHelpersError('Cannot call getStats before there is a connection.', 'NotConnectedError', {
          code: 1015
        }));
        return;
      }
      _getStatsAdapter(_peerConnection, callback);
    };

    var waitForChannel = function waitForChannel(timesToWait, label, options, completion) {
      var err = void 0;
      var channel = _channels.get(label, options);

      if (!channel) {
        if (timesToWait > 0) {
          setTimeout(waitForChannel.bind(null, timesToWait - 1, label, options, completion), 200);

          return;
        }

        err = new OTHelpersError('' + ('A channel with that label and options could not be found. ' + 'Label:') + label + '. Options: ' + JSON.stringify(options));
      }

      completion(err, channel);
    };

    api.getDataChannel = function (label, options, completion) {
      if (!_peerConnection) {
        completion(new OTHelpersError('Cannot create a DataChannel before there is a connection.'));
        return;
      }
      // Wait up to 20 sec for the channel to appear, then fail
      waitForChannel(100, label, options, completion);
    };

    api.iceConnectionStateIsConnected = function () {
      return ['connected', 'completed'].indexOf(_peerConnection.iceConnectionState) > -1;
    };

    api._demoOnlyFindAndReplaceTrack = function (oldTrack, newTrack) {
      return bluebird.resolve().then(function () {
        var sender = _peerConnection.getSenders().filter(function (s) {
          return s.track === oldTrack;
        })[0];

        if (!sender) {
          throw new Error('Sender not found');
        }

        return sender.replaceTrack(newTrack);
      });
    };

    var qos = new Qos(qosCallback, isPublisher);

    return api;
  };
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../common-js-helpers/behaviours/eventing.js":220,"../../common-js-helpers/env.js":233,"../../common-js-helpers/error.js":234,"../../helpers/create_peer_connection.js":249,"../../helpers/webkitAudioWorkaround.js":285,"../../otplugin/otplugin.js":390,"../environment_loader.js":305,"../logging.js":312,"../messaging/raptor/raptor_constants.js":319,"./applySdpTransform.js":335,"./get_stats_adapter.js":337,"./ice_candidate_processor":339,"./offer_processor.js":340,"./peer_connection_channels.js":342,"./qos.js":345,"./sdpTransformDefaults.js":346,"./subscribe_processor.js":349,"bluebird":2,"lodash/debounce":149,"lodash/merge":171,"lodash/omit":173}],342:[function(require,module,exports){
'use strict';

// @todo enable the following disabled rules see OPENTOK-31136 for more info
/* eslint-disable no-restricted-syntax, no-prototype-builtins */

var DataChannel = require('./data_channel.js');
var OTHelpers = require('../../common-js-helpers/OTHelpers.js');

// Contains a collection of DataChannels for a particular RTCPeerConnection
//
// @param [RTCPeerConnection] pc A native peer connection object
//
// @constructor
// @private
//
module.exports = function PeerConnectionChannels(pc) {
  // / Private Data
  var channels = [];
  var api = {};

  var lastQos = {
    sentMessages: 0,
    recvMessages: 0
  };

  // / Private API

  var remove = function remove(channel) {
    channels.filter(function (c) {
      return channel !== c;
    });
  };

  var add = function add(nativeChannel) {
    var channel = new DataChannel(nativeChannel);
    channels.push(channel);

    channel.on('close', function () {
      remove(channel);
    });

    return channel;
  };

  // / Public API

  api.add = function (label, options) {
    return add(pc.createDataChannel(label, options));
  };

  api.addMany = function (newChannels) {
    for (var label in newChannels) {
      if (newChannels.hasOwnProperty(label)) {
        api.add(label, newChannels[label]);
      }
    }
  };

  api.get = function (label, options) {
    return OTHelpers.find(channels, function (channel) {
      return channel.equals(label, options);
    });
  };

  api.getOrAdd = function (label, options) {
    var channel = api.get(label, options);
    if (!channel) {
      channel = api.add(label, options);
    }

    return channel;
  };

  api.getQosData = function () {
    var qosData = {
      sentMessages: 0,
      recvMessages: 0
    };

    channels.forEach(function (channel) {
      qosData.sentMessages += channel.getQosData().sentMessages;
      qosData.recvMessages += channel.getQosData().recvMessages;
    });

    return qosData;
  };

  api.sampleQos = function () {
    var newQos = api.getQosData();

    var sampleQos = {
      sentMessages: newQos.sentMessages - lastQos.sentMessages,
      recvMessages: newQos.recvMessages - lastQos.recvMessages
    };

    lastQos = newQos;

    return sampleQos;
  };

  api.destroy = function () {
    channels.forEach(function (channel) {
      channel.close();
    });

    channels = [];
  };

  // / Init

  pc.addEventListener('datachannel', function (event) {
    add(event.channel);
  }, false);

  return api;
};

},{"../../common-js-helpers/OTHelpers.js":217,"./data_channel.js":336}],343:[function(require,module,exports){
'use strict';

var Bluebird = require('bluebird');

// Adapts a function that returns or promise or takes success and error
// callbacks, and returns a function that always returns a promise.

// This is used to provide backwards compatibility for WebRTC implementations,
// which used to use success and error callbacks, and now return promises.

module.exports = function promisify(context, methodName) {
  var method = context[methodName];

  return function (input) {
    return new Bluebird.Promise(function (resolve, reject) {
      var result = method.apply(context, [input, resolve, reject]);

      if (result && typeof result.then === 'function') {
        resolve(result);
      }
    });
  };
};

},{"bluebird":2}],344:[function(require,module,exports){
'use strict';

// @todo enable the following disabled rules see OPENTOK-31136 for more info
/* eslint-disable no-param-reassign, global-require, no-underscore-dangle */

var assign = require('lodash/assign');

module.exports = function PublisherPeerConnectionFactory() {
  var deps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var OTHelpers = deps.OTHelpers || require('../../common-js-helpers/OTHelpers.js');
  var PeerConnection = deps.PeerConnection || require('./peer_connection.js')();
  var RaptorConstants = deps.RaptorConstants || require('../messaging/raptor/raptor_constants.js');
  var setCertificates = deps.setCertificates || require('./set_certificates.js')();
  var watchAudioAcquisition = deps.watchAudioAcquisition || require('./watchAudioAcquisition.js');

  /**
   * @typedef {object} PublisherPeerConnectionConfig
   * @property {function(string, string=, object=, object=, boolean=)} logAnalyticsEvent
   * @property {Connection} remoteConnection
   * @property {Raptor.Socket} socket
   * @property {boolean} reconnection
   * @property {MediaStream} webRTCStream
   * @property {object<string, object>} channels
   * @property {boolean} capableSimulcastStreams
   * @property {boolean} overrideSimulcastEnabled
   * @property {string} subscriberUri
   * @property {object<string, object>} offerOverrides
   * @property {object<string, object>} answerOverrides
   */

  /**
   * Abstracts PeerConnection related stuff away from Publisher.
   *
   * Responsible for:
   * * setting up the underlying PeerConnection (delegates to PeerConnections)
   * * triggering a connected event when the Peer connection is opened
   * * triggering a disconnected event when the Peer connection is closed
   * * providing a destroy method
   * * providing a processMessage method
   *
   * Once the PeerConnection is connected and the video element playing it triggers
   * the connected event
   *
   * Triggers the following events
   * * connected
   * * disconnected
   *
   * @class PublisherPeerConnection
   * @constructor
   *
   * @param {PublisherPeerConnectionConfig} config
   */
  return function PublisherPeerConnection(_ref) {
    var clientCandidates = _ref.clientCandidates,
        iceServers = _ref.iceServers,
        remoteConnectionId = _ref.remoteConnectionId,
        socket = _ref.socket,
        webRTCStream = _ref.webRTCStream,
        channels = _ref.channels,
        capableSimulcastStreams = _ref.capableSimulcastStreams,
        overrideSimulcastEnabled = _ref.overrideSimulcastEnabled,
        uri = _ref.subscriberUri,
        logAnalyticsEvent = _ref.logAnalyticsEvent,
        offerOverrides = _ref.offerOverrides,
        answerOverrides = _ref.answerOverrides;

    var _publisherPeerConnection = this;
    var _peerConnection = void 0;
    var _hasRelayCandidates = false;
    var _awaitingIceRestart = false;
    var _cancelWatchAudioAcquisition = function noop() {};

    // Private
    var _onPeerClosed = function _onPeerClosed() {
      this.destroy();
      if (_awaitingIceRestart) {
        this.trigger('iceRestartFailure', this);
      }
      this.trigger('disconnected', this);
    };

    var _onPeerError = function _onPeerError(errorReason, prefix) {
      this.trigger('error', null, errorReason, this, prefix);
    };

    var _onIceConnectionStateChange = function _onIceConnectionStateChange(evt) {
      if (_awaitingIceRestart && _peerConnection.iceConnectionStateIsConnected()) {
        _awaitingIceRestart = false;
        this.trigger('iceRestartSuccess');
      }

      // watch for the Chrome bug where audio can't be acquired
      // can not use iceConnectionStateIsConnected since it is too broad
      if (evt === 'connected') {
        if (OTHelpers.env.name === 'Chrome') {
          // cancel any pending watcher (in case of ice restart for example)
          _cancelWatchAudioAcquisition();
          _cancelWatchAudioAcquisition = watchAudioAcquisition(_peerConnection.getStats.bind(_peerConnection), function () {
            _publisherPeerConnection.trigger('audioAcquisitionProblem');
          });
        }
      }
    };

    var _relayMessageToPeer = function (type, payload) {
      if (!_hasRelayCandidates) {
        var extractCandidates = type === RaptorConstants.Actions.CANDIDATE || type === RaptorConstants.Actions.OFFER || type === RaptorConstants.Actions.ANSWER || type === RaptorConstants.Actions.PRANSWER;

        if (extractCandidates) {
          var message = type === RaptorConstants.Actions.CANDIDATE ? payload.candidate : payload.sdp;

          _hasRelayCandidates = message.indexOf('typ relay') !== -1;
        }
      }

      switch (type) {
        case RaptorConstants.Actions.ANSWER:
        case RaptorConstants.Actions.PRANSWER:
          socket.jsepAnswer(uri, payload.sdp);

          break;

        case RaptorConstants.Actions.OFFER:
          this.trigger('connected');
          socket.jsepOffer(uri, payload.sdp);

          break;

        case RaptorConstants.Actions.CANDIDATE:
          socket.jsepCandidate(uri, payload);

          break;

        default:
      }
    }.bind(this);

    OTHelpers.eventing(this);

    // / Public API

    this.getDataChannel = function (label, options, completion) {
      _peerConnection.getDataChannel(label, options, completion);
    };

    this.destroy = function () {
      _cancelWatchAudioAcquisition();

      // Clean up our PeerConnection
      if (_peerConnection) {
        _peerConnection.disconnect();
        _peerConnection.off();
      }

      _peerConnection = null;
    };

    this.processMessage = function (type, message) {
      _peerConnection.processMessage(type, message);
    };

    this.addTrack = function (track, stream, callback) {
      return _peerConnection.addTrack(track, stream, callback);
    };

    this.removeTrack = function (RTCRtpSender) {
      return _peerConnection.removeTrack(RTCRtpSender);
    };

    this.getLocalStreams = function () {
      return _peerConnection.getLocalStreams();
    };

    // Init
    this.init = function (rumorIceServers, completion) {
      var _this = this;

      var pcConfig = {
        iceServers: iceServers || rumorIceServers,
        channels: channels,
        capableSimulcastStreams: capableSimulcastStreams,
        overrideSimulcastEnabled: overrideSimulcastEnabled
      };

      setCertificates(pcConfig, function (err, pcConfigWithCerts) {
        if (err) {
          completion(err);
          return;
        }

        var peerConnectionConfig = assign({
          clientCandidates: clientCandidates,
          logAnalyticsEvent: logAnalyticsEvent,
          isPublisher: true,
          offerOverrides: offerOverrides,
          answerOverrides: answerOverrides
        }, pcConfigWithCerts);

        _peerConnection = new PeerConnection(assign({ sendMessage: _relayMessageToPeer }, peerConnectionConfig));

        _peerConnection.on({
          close: _onPeerClosed,
          error: _onPeerError,
          qos: function qos(_qos) {
            return _this.trigger('qos', _qos);
          },
          iceConnectionStateChange: _onIceConnectionStateChange
        }, _publisherPeerConnection);

        _peerConnection.addLocalStream(webRTCStream);
        completion(undefined, _publisherPeerConnection);
      });

      this.remoteConnectionId = remoteConnectionId;

      this.hasRelayCandidates = function () {
        return _hasRelayCandidates;
      };
    };

    this.getSenders = function () {
      return _peerConnection.getSenders();
    };

    this.iceRestart = function () {
      _awaitingIceRestart = true;
      return _peerConnection.iceRestart();
    };

    this.iceConnectionStateIsConnected = function () {
      return _peerConnection.iceConnectionStateIsConnected();
    };

    this._demoOnlyFindAndReplaceTrack = function (oldTrack, newTrack) {
      _peerConnection._demoOnlyFindAndReplaceTrack(oldTrack, newTrack);
    };
  };
};

},{"../../common-js-helpers/OTHelpers.js":217,"../messaging/raptor/raptor_constants.js":319,"./peer_connection.js":341,"./set_certificates.js":348,"./watchAudioAcquisition.js":351,"lodash/assign":142}],345:[function(require,module,exports){
'use strict';

// @todo enable the following disabled rules see OPENTOK-31136 for more info
/* eslint-disable no-param-reassign, no-plusplus, no-void, no-use-before-define, one-var */
/* eslint-disable no-restricted-syntax, no-prototype-builtins, no-underscore-dangle */

var OTPlugin = require('../../otplugin/otplugin.js');
var OTHelpers = require('../../common-js-helpers/OTHelpers.js');
var logging = require('../logging.js');

var requiredPublisherKeys = ['audioCodec', 'audioSentBytes', 'audioSentPackets', 'audioSentPacketsLost', 'videoCodec', 'videoHeight', 'videoHeightInput', 'videoSentBytes', 'videoFrameRateSent', 'videoSentPackets', 'videoRtt', 'videoSentPacketsLost', 'videoWidthInput', 'videoWidth'];

var requiredSubscriberKeys = ['audioCodec', 'audioRecvBytes', 'audioRecvPackets', 'audioRecvPacketsLost', 'videoCodec', 'videoHeight', 'videoRecvBytes', 'videoRecvPackets', 'videoRecvPacketsLost', 'videoFrameRateReceived', 'videoRtt', 'videoWidth'];

//
// There are three implementations of stats parsing in this file.
// 1. For Chrome: Chrome is currently using an older version of the API
// 2. For OTPlugin: The plugin is using a newer version of the API that
//    exists in the latest WebRTC codebase
// 3. For Firefox: FF is using a version that looks a lot closer to the
//    current spec.
//
// I've attempted to keep the three implementations from sharing any code,
// accordingly you'll notice a bunch of duplication between the three.
//
// This is acceptable as the goal is to be able to remove each implementation
// as it's no longer needed without any risk of affecting the others. If there
// was shared code between them then each removal would require an audit of
// all the others.
//
//

// /
// Get Stats using the older API. Used by all current versions
// of Chrome.
//
var parseStatsOldAPI = function parseStatsOldAPI(peerConnection, prevStats, currentStats, isPublisher, completion) {
  /* this parses a result if there it contains the video bitrate */
  var parseVideoStats = function parseVideoStats(result) {
    if (result.stat('googFrameRateSent')) {
      currentStats.videoSentBytes = Number(result.stat('bytesSent'));
      currentStats.videoSentPackets = Number(result.stat('packetsSent'));
      currentStats.videoSentPacketsLost = Number(result.stat('packetsLost'));
      currentStats.videoRtt = Number(result.stat('googRtt'));
      currentStats.videoFrameRate = Number(result.stat('googFrameRateInput'));
      currentStats.videoWidth = Number(result.stat('googFrameWidthSent'));
      currentStats.videoHeight = Number(result.stat('googFrameHeightSent'));
      currentStats.videoFrameRateSent = Number(result.stat('googFrameRateSent'));
      currentStats.videoWidthInput = Number(result.stat('googFrameWidthInput'));
      currentStats.videoHeightInput = Number(result.stat('googFrameHeightInput'));
      currentStats.videoCodec = result.stat('googCodecName');
    } else if (result.stat('googFrameRateReceived')) {
      currentStats.videoRecvBytes = Number(result.stat('bytesReceived'));
      currentStats.videoRecvPackets = Number(result.stat('packetsReceived'));
      currentStats.videoRecvPacketsLost = Number(result.stat('packetsLost'));
      currentStats.videoFrameRate = Number(result.stat('googFrameRateOutput'));
      currentStats.videoFrameRateReceived = Number(result.stat('googFrameRateReceived'));
      currentStats.videoFrameRateDecoded = Number(result.stat('googFrameRateDecoded'));
      currentStats.videoWidth = Number(result.stat('googFrameWidthReceived'));
      currentStats.videoHeight = Number(result.stat('googFrameHeightReceived'));
      currentStats.videoCodec = result.stat('googCodecName');
    }

    return null;
  };

  var parseAudioStats = function parseAudioStats(result) {
    if (result.stat('audioInputLevel')) {
      currentStats.audioSentPackets = Number(result.stat('packetsSent'));
      currentStats.audioSentPacketsLost = Number(result.stat('packetsLost'));
      currentStats.audioSentBytes = Number(result.stat('bytesSent'));
      currentStats.audioCodec = result.stat('googCodecName');
      currentStats.audioRtt = Number(result.stat('googRtt'));
    } else if (result.stat('audioOutputLevel')) {
      currentStats.audioRecvPackets = Number(result.stat('packetsReceived'));
      currentStats.audioRecvPacketsLost = Number(result.stat('packetsLost'));
      currentStats.audioRecvBytes = Number(result.stat('bytesReceived'));
      currentStats.audioCodec = result.stat('googCodecName');
    }
  };

  function getProtocolFromPriority(priority) {
    switch (priority >> 24) {// eslint-disable-line no-bitwise
      case 0:
        return 'TURN/TLS';
      case 1:
        return 'TURN/TCP';
      case 2:
        return 'TURN/UDP';
      default:
        return '';
    }
  }

  var parseStatsReports = function parseStatsReports(stats) {
    if (stats.result) {
      var resultList = stats.result();

      var getCandidate = function getCandidate(type, fromStat) {
        return resultList.filter(function (x) {
          return x.id === fromStat.stat(type);
        })[0];
      };
      var getLocalCandidate = function getLocalCandidate(fromStat) {
        return getCandidate('localCandidateId', fromStat);
      };
      var getRemoteCandidate = function getRemoteCandidate(fromStat) {
        return getCandidate('remoteCandidateId', fromStat);
      };

      for (var resultIndex = 0; resultIndex < resultList.length; resultIndex++) {
        var result = resultList[resultIndex];

        if (result.stat) {
          if (result.stat('googActiveConnection') === 'true') {
            if (result.stat('googChannelId').indexOf('audio') > -1) {
              currentStats.audioLocalAddress = result.stat('googLocalAddress');
              currentStats.audioRemoteAddress = result.stat('googRemoteAddress');
              currentStats.audioLocalCandidateType = result.stat('googLocalCandidateType');
              currentStats.audioRemoteCandidateType = result.stat('googRemoteCandidateType');
              currentStats.audioTransportType = result.stat('googTransportType');
              currentStats.audioLocalRelayProtocol = getProtocolFromPriority(getLocalCandidate(result).stat('priority'));
              currentStats.audioRemoteRelayProtocol = getProtocolFromPriority(getRemoteCandidate(result).stat('priority'));
            } else if (result.stat('googChannelId').indexOf('video') > -1) {
              currentStats.videoLocalAddress = result.stat('googLocalAddress');
              currentStats.videoRemoteAddress = result.stat('googRemoteAddress');
              currentStats.videoLocalCandidateType = result.stat('googLocalCandidateType');
              currentStats.videoRemoteCandidateType = result.stat('googRemoteCandidateType');
              currentStats.videoTransportType = result.stat('googTransportType');
              currentStats.videoLocalRelayProtocol = getProtocolFromPriority(getLocalCandidate(result).stat('priority'));
              currentStats.videoRemoteRelayProtocol = getProtocolFromPriority(getRemoteCandidate(result).stat('priority'));
            }
          }

          parseAudioStats(result);
          parseVideoStats(result);
        }
      }

      // For audio-video publishers in Chrome, there are no corresponding video reports for these

      if ('videoCodec' in currentStats && !currentStats.videoLocalAddress) {
        ['LocalAddress', 'RemoteAddress', 'LocalCandidateType', 'RemoteCandidateType', 'TransportType', 'LocalRelayProtocol', 'RemoteRelayProtocol'].forEach(function (keySuffix) {
          currentStats['video' + keySuffix] = currentStats['audio' + keySuffix];
        });
      }
    }

    completion(null, currentStats);
  };

  peerConnection.getStats(parseStatsReports);
};

// /
// Get Stats for the OT Plugin, newer than Chromes version, but
// still not in sync with the spec.
//
var parseStatsOTPlugin = function parseStatsOTPlugin(peerConnection, prevStats, currentStats, isPublisher, completion) {
  var onStatsError = function onStatsError(error) {
    completion(error);
  };

  // /
  // From the Audio Tracks
  // * audioBytesTransferred
  //
  var parseAudioStats = function parseAudioStats(statsReport) {
    if (statsReport.audioInputLevel) {
      currentStats.audioSentBytes = Number(statsReport.bytesSent);
      currentStats.audioSentPackets = Number(statsReport.packetsSent);
      currentStats.audioSentPacketsLost = Number(statsReport.packetsLost);
      currentStats.audioRtt = Number(statsReport.googRtt);
      currentStats.audioCodec = statsReport.googCodecName;
    } else if (statsReport.audioOutputLevel) {
      currentStats.audioRecvBytes = Number(statsReport.bytesReceived);
      currentStats.audioRecvPackets = Number(statsReport.packetsReceived);
      currentStats.audioRecvPacketsLost = Number(statsReport.packetsLost);
      currentStats.audioCodec = statsReport.googCodecName;
    }
  };

  // /
  // From the Video Tracks
  // * frameRate
  // * videoBytesTransferred
  //
  var parseVideoStats = function parseVideoStats(statsReport) {
    if (statsReport.googFrameHeightSent) {
      currentStats.videoSentBytes = Number(statsReport.bytesSent);
      currentStats.videoSentPackets = Number(statsReport.packetsSent);
      currentStats.videoSentPacketsLost = Number(statsReport.packetsLost);
      currentStats.videoRtt = Number(statsReport.googRtt);
      currentStats.videoCodec = statsReport.googCodecName;
      currentStats.videoWidth = Number(statsReport.googFrameWidthSent);
      currentStats.videoHeight = Number(statsReport.googFrameHeightSent);
      currentStats.videoFrameRateSent = Number(statsReport.googFrameRateSent);
      currentStats.videoWidthInput = Number(statsReport.googFrameWidthInput);
      currentStats.videoHeightInput = Number(statsReport.googFrameHeightInput);
    } else if (statsReport.googFrameHeightReceived) {
      currentStats.videoRecvBytes = Number(statsReport.bytesReceived);
      currentStats.videoRecvPackets = Number(statsReport.packetsReceived);
      currentStats.videoRecvPacketsLost = Number(statsReport.packetsLost);
      currentStats.videoRtt = Number(statsReport.googRtt);
      currentStats.videoCodec = statsReport.googCodecName;
      currentStats.videoFrameRateReceived = Number(statsReport.googFrameRateReceived);
      currentStats.videoFrameRateDecoded = Number(statsReport.googFrameRateDecoded);
      currentStats.videoWidth = Number(statsReport.googFrameWidthReceived);
      currentStats.videoHeight = Number(statsReport.googFrameHeightReceived);
    }

    if (statsReport.googFrameRateInput) {
      currentStats.videoFrameRate = Number(statsReport.googFrameRateInput);
    } else if (statsReport.googFrameRateOutput) {
      currentStats.videoFrameRate = Number(statsReport.googFrameRateOutput);
    }
  };

  var isStatsForVideoTrack = function isStatsForVideoTrack(statsReport) {
    return statsReport.googFrameHeightSent !== void 0 || statsReport.googFrameHeightReceived !== void 0 || currentStats.videoBytesTransferred !== void 0 || statsReport.googFrameRateSent !== void 0;
  };

  var isStatsForIceCandidate = function isStatsForIceCandidate(statsReport) {
    return statsReport.googActiveConnection === 'true';
  };

  peerConnection.getStats(null, function (statsReports) {
    statsReports.forEach(function (statsReport) {
      if (isStatsForIceCandidate(statsReport)) {
        if (statsReport.googChannelId.indexOf('audio') > -1) {
          currentStats.audioLocalAddress = statsReport.googLocalAddress;
          currentStats.audioRemoteAddress = statsReport.googRemoteAddress;
          currentStats.audioLocalCandidateType = statsReport.googLocalCandidateType;
          currentStats.audioRemoteCandidateType = statsReport.googRemoteCandidateType;
          currentStats.audioTransportType = statsReport.googTransportType;
        } else if (statsReport.googChannelId.indexOf('video') > -1) {
          currentStats.videoLocalAddress = statsReport.googLocalAddress;
          currentStats.videoRemoteAddress = statsReport.googRemoteAddress;
          currentStats.videoLocalCandidateType = statsReport.googLocalCandidateType;
          currentStats.videoRemoteCandidateType = statsReport.googRemoteCandidateType;
          currentStats.videoTransportType = statsReport.googTransportType;
        }
      } else if (isStatsForVideoTrack(statsReport)) {
        parseVideoStats(statsReport);
      } else {
        parseAudioStats(statsReport);
      }
    });

    // For publishers with audio, there are no corresponding video reports for these
    if (currentStats.videoFrameRateSent && !currentStats.videoLocalAddress) {
      currentStats.videoLocalAddress = currentStats.audioLocalAddress;
      currentStats.videoRemoteAddress = currentStats.audioRemoteAddress;
      currentStats.videoLocalCandidateType = currentStats.audioLocalCandidateType;
      currentStats.videoRemoteCandidateType = currentStats.audioLocalCandidateType;
      currentStats.videoTransportType = currentStats.audioTransportType;
    }

    extendStats(currentStats, isPublisher);
    completion(null, currentStats);
  }, onStatsError);
};

// /
// Get Stats using the newer API.
//
var parseStatsNewAPI = function parseStatsNewAPI(peerConnection, prevStats, currentStats, isPublisher, completion) {
  var onStatsError = function onStatsError(error) {
    completion(error);
  };

  var parseAudioStats = function parseAudioStats(result, strippedType) {
    if (strippedType === 'outboundrtp') {
      currentStats.audioSentPackets = result.packetsSent;
      currentStats.audioSentPacketsLost = result.packetsLost;
      currentStats.audioSentBytes = result.bytesSent;
    } else if (strippedType === 'inboundrtp') {
      currentStats.audioRecvPackets = result.packetsReceived;
      currentStats.audioRecvPacketsLost = result.packetsLost;
      currentStats.audioRecvBytes = result.bytesReceived;
    }
  };

  var parseVideoStats = function parseVideoStats(result, strippedType) {
    if (typeof result.framerateMean === 'number') {
      currentStats.videoFrameRate = Number(result.framerateMean);
    }

    if (strippedType === 'outboundrtp') {
      currentStats.videoSentPackets = result.packetsSent;
      currentStats.videoSentPacketsLost = result.packetsLost;
      currentStats.videoSentBytes = result.bytesSent;
    } else if (strippedType === 'inboundrtp') {
      currentStats.videoRecvPackets = result.packetsReceived;
      currentStats.videoRecvPacketsLost = result.packetsLost;
      currentStats.videoRecvBytes = result.bytesReceived;
    }
  };

  peerConnection.getStats(null).then(function (stats) {
    var localCandidateType = void 0,
        remoteCandidateType = void 0,
        localAddress = void 0,
        remoteAddress = void 0,
        transportType = void 0,
        frameWidth = void 0,
        frameHeight = void 0;

    var statsLoop = function statsLoop(res) {
      var strippedType = res.type.toLowerCase().replace(/[^a-z]/g, '');
      var lowercaseId = res.id.toLowerCase();
      if (strippedType === 'outboundrtp' || strippedType === 'inboundrtp') {
        if (lowercaseId.indexOf('rtp') !== -1) {
          if (lowercaseId.indexOf('audio') !== -1) {
            parseAudioStats(res, strippedType);
          } else if (lowercaseId.indexOf('video') !== -1) {
            parseVideoStats(res, strippedType);
          }
        }
        if (res.hasOwnProperty('mozRtt')) {
          // mozRtt comes on the rtcp stats and so won't be caught above
          if (res.mediaType === 'video') {
            currentStats.videoRtt = res.mozRtt;
          } else if (res.mediaType === 'audio') {
            currentStats.audioRtt = res.mozRtt;
          }
        }
      } else if (res.type === 'localcandidate') {
        localCandidateType = res.candidateType;
        localAddress = res.ipAddress + ':' + res.portNumber;
        transportType = res.transport;
      } else if (res.type === 'remotecandidate') {
        remoteCandidateType = res.candidateType;
        remoteAddress = res.ipAddress + ':' + res.portNumber;
      } else if (res.type === 'track' && lowercaseId.indexOf('video') !== 0) {
        frameWidth = res.frameWidth;
        frameHeight = res.frameHeight;

        if (typeof res.framesPerSecond === 'number') {
          currentStats.videoFrameRate = res.framesPerSecond;
        }
      }
    };

    // Firefox <= 45 can't use for of loop OPENTOK-32755
    if (typeof stats[Symbol.iterator] === 'function') {
      for (var _iterator = stats, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
        var _ref;

        if (_isArray) {
          if (_i >= _iterator.length) break;
          _ref = _iterator[_i++];
        } else {
          _i = _iterator.next();
          if (_i.done) break;
          _ref = _i.value;
        }

        var el = _ref;

        var res = Array.isArray(el) ? el[1] : el;
        statsLoop(res);
      }
    } else {
      for (var key in stats) {
        if (stats.hasOwnProperty(key)) {
          statsLoop(stats[key]);
        }
      }
    }

    if (currentStats.audioRecvBytes || currentStats.audioSentBytes) {
      currentStats.audioLocalCandidateType = localCandidateType;
      currentStats.audioLocalAddress = localAddress;
      currentStats.audioRemoteCandidateType = remoteCandidateType;
      currentStats.audioRemoteAddress = remoteAddress;
      currentStats.audioTransportType = transportType;
    }

    if (currentStats.videoRecvBytes || currentStats.videoSentBytes) {
      currentStats.videoLocalCandidateType = localCandidateType;
      currentStats.videoLocalAddress = localAddress;
      currentStats.videoRemoteCandidateType = remoteCandidateType;
      currentStats.videoRemoteAddress = remoteAddress;
      currentStats.videoTransportType = transportType;
    }

    extendStats(currentStats, isPublisher);
    currentStats.videoWidth = currentStats.videoWidth || frameWidth;
    currentStats.videoHeight = currentStats.videoHeight || frameHeight;
    completion(null, currentStats);
  }).catch(onStatsError);
};

var _parseQOS = function parseQOS(peerConnection, prevStats, currentStats, isPublisher, completion) {
  if (OTPlugin.isInstalled()) {
    _parseQOS = parseStatsOTPlugin;
    return parseStatsOTPlugin(peerConnection, prevStats, currentStats, isPublisher, completion);
  } else if (['Firefox', 'Edge', 'Safari'].indexOf(OTHelpers.env.name) !== -1) {
    _parseQOS = parseStatsNewAPI;
    return parseStatsNewAPI(peerConnection, prevStats, currentStats, isPublisher, completion);
  }

  _parseQOS = parseStatsOldAPI;
  return parseStatsOldAPI(peerConnection, prevStats, currentStats, isPublisher, completion);
};

var extendStats = function extendStats(stats, isPublisher) {
  var requiredKeys = isPublisher ? requiredPublisherKeys : requiredSubscriberKeys;
  requiredKeys.forEach(function (key) {
    if (!stats.hasOwnProperty(key)) {
      stats[key] = null;
    }
  });
};

var Qos = function Qos(qosCallback, isPublisher) {
  var _peerConnection = void 0;
  var _creationTime = OTHelpers.now();

  var calculateQOS = function calculateQOS(prevStats, interval) {
    if (!_peerConnection) {
      // We don't have a PeerConnection yet, or we did and
      // it's been closed. Either way we're done.

      // @todo if we don't have a _peerConnection yet, but we expect one in the
      // future, are we really done?
      return;
    }

    var now = OTHelpers.now();

    var currentStats = {
      timeStamp: now,
      duration: Math.round((now - _creationTime) / 1000),
      period: Math.round((now - prevStats.timeStamp) / 1000)
    };

    var onParsedStats = function onParsedStats(err, parsedStats) {
      if (err) {
        logging.error('Failed to Parse QOS Stats:', err);
        return;
      }

      var periodicStats = OTHelpers.clone(currentStats);

      // The following stats are reported with cumulative values:
      var periodicDataKeys = ['audioSentBytes', 'audioSentPackets', 'audioSentPacketsLost', 'videoSentBytes', 'videoSentPackets', 'videoSentPacketsLost', 'audioRecvBytes', 'audioRecvPackets', 'audioRecvPacketsLost', 'videoRecvBytes', 'videoRecvPackets', 'videoRecvPacketsLost'];

      // This adjusts the QoS values to be periodic, rather than cumulative:
      periodicDataKeys.forEach(function (dataKey) {
        periodicStats[dataKey] = prevStats && prevStats[dataKey] ? currentStats[dataKey] - prevStats[dataKey] : currentStats[dataKey];
      });

      qosCallback(periodicStats, prevStats);

      var nextInterval = interval === Qos.INITIAL_INTERVAL ? Qos.INTERVAL - Qos.INITIAL_INTERVAL : Qos.INTERVAL;

      // Recalculate the stats
      setTimeout(calculateQOS.bind(null, parsedStats, nextInterval), interval);
    };

    _parseQOS(_peerConnection, prevStats, currentStats, isPublisher, onParsedStats);
  };

  this.startCollecting = function (peerConnection) {
    if (!peerConnection || !peerConnection.getStats) {
      // this peerConnection doesn't support getStats, bail
      return;
    }

    if (_peerConnection) {
      _peerConnection = peerConnection;
    } else {
      _peerConnection = peerConnection;
      calculateQOS({ timeStamp: OTHelpers.now() }, Qos.INITIAL_INTERVAL);
    }
  };

  this.stopCollecting = function () {
    _peerConnection = null;
  };
};

// Send stats after 1 sec
Qos.INITIAL_INTERVAL = 1000;
// Recalculate the stats every 30 sec
Qos.INTERVAL = 30000;

module.exports = Qos;

},{"../../common-js-helpers/OTHelpers.js":217,"../../otplugin/otplugin.js":390,"../logging.js":312}],346:[function(require,module,exports){
'use strict';

var SDPHelpers = require('./sdp_helpers.js');

module.exports = {
  local: {
    offer: function offer(opt, sdpParam) {
      var sdp = sdpParam;

      if (opt) {
        var simulcastStreams = opt.simulcastStreams,
            audioBitrate = opt.audioBitrate;


        if (simulcastStreams > 1) {
          sdp = SDPHelpers.enableSimulcast(sdp, simulcastStreams);
        }

        if (audioBitrate > 0) {
          sdp = SDPHelpers.setAudioBitrate(sdp, audioBitrate);
        }
      }

      sdp = SDPHelpers.modifyReceiveStereo(sdp, false);
      sdp = SDPHelpers.modifySendStereo(sdp, Boolean(opt && opt.enableStereo));
      sdp = SDPHelpers.deprioritizeH264(sdp);

      return sdp;
    },
    answer: function answer(opt, sdpParam) {
      var sdp = sdpParam;

      if (opt && opt.audioBitrate > 0) {
        sdp = SDPHelpers.setAudioBitrate(sdp, opt.audioBitrate);
      }

      sdp = SDPHelpers.modifyReceiveStereo(sdp, Boolean(opt && opt.enableStereo));
      sdp = SDPHelpers.modifySendStereo(sdp, false);

      return sdp;
    }
  },
  remote: {
    offer: function offer(opt, sdp) {
      if (sdp.indexOf('a=rtcp-fb') === -1) {
        var rtcpFbLine = 'a=rtcp-fb:* ccm fir\r\na=rtcp-fb:* nack ';
        return sdp.replace(/^m=video(.*)$/gmi, 'm=video$1\r\n' + rtcpFbLine);
      }

      return sdp;
    },
    answer: function answer(opt, sdpParam) {
      var sdp = sdpParam;

      if (opt && opt.audioBitrate > 0) {
        sdp = SDPHelpers.setAudioBitrate(sdp, opt.audioBitrate);
      }

      return sdp;
    }
  }
};

},{"./sdp_helpers.js":347}],347:[function(require,module,exports){
'use strict';

// @todo enable the following disabled rules see OPENTOK-31136 for more info
/* eslint-disable no-void, one-var, prefer-const, no-plusplus, no-shadow, vars-on-top, no-var */
/* eslint-disable no-mixed-operators */

var logging = require('../logging.js');
var OTHelpers = require('../../common-js-helpers/OTHelpers.js');

var START_MEDIA_SSRC = 10000;
var START_RTX_SSRC = 20000;

// Here are the structure of the rtpmap attribute and the media line, most of the
// complex Regular Expressions in this code are matching against one of these two
// formats:
// * a=rtpmap:<payload type> <encoding name>/<clock rate> [/<encoding parameters>]
// * m=<media> <port>/<number of ports> <proto> <fmts>
//
// References:
// * https://tools.ietf.org/html/rfc4566
// * http://en.wikipedia.org/wiki/Session_Description_Protocol
//
//

var SDPHelpers = {};
module.exports = SDPHelpers;

// Search through sdpLines to find the Media Line of type +mediaType+.
SDPHelpers.getMLineIndex = function getMLineIndex(sdpLines, mediaType) {
  var targetMLine = 'm=' + mediaType;

  // Find the index of the media line for +type+
  return OTHelpers.findIndex(sdpLines, function (line) {
    if (line.indexOf(targetMLine) !== -1) {
      return true;
    }

    return false;
  });
};

// Grab a M line of a particular +mediaType+ from sdpLines.
SDPHelpers.getMLine = function getMLine(sdpLines, mediaType) {
  var mLineIndex = SDPHelpers.getMLineIndex(sdpLines, mediaType);
  return mLineIndex > -1 ? sdpLines[mLineIndex] : void 0;
};

SDPHelpers.hasMLinePayloadType = function hasMLinePayloadType(sdpLines, mediaType, payloadType) {
  var mLine = SDPHelpers.getMLine(sdpLines, mediaType);
  var payloadTypes = SDPHelpers.getMLinePayloadTypes(mLine, mediaType);

  return payloadTypes.indexOf(payloadType) > -1;
};

// Extract the payload types for a give Media Line.
//
SDPHelpers.getMLinePayloadTypes = function getMLinePayloadTypes(mediaLine, mediaType) {
  var mLineSelector = new RegExp('^m=' + mediaType + ' \\d+(/\\d+)? [a-zA-Z0-9/]+(( [a-zA-Z0-9/]+)+)$', 'i');

  // Get all payload types that the line supports
  var payloadTypes = mediaLine.match(mLineSelector);
  if (!payloadTypes || payloadTypes.length < 2) {
    // Error, invalid M line?
    return [];
  }

  return payloadTypes[2].trim().split(' ');
};

SDPHelpers.removeTypesFromMLine = function removeTypesFromMLine(mediaLine, payloadTypes) {
  var typesSuffix = /[0-9 ]*$/.exec(mediaLine)[0];

  var newTypes = typesSuffix.split(' ').filter(function (type) {
    return type !== '' && payloadTypes.indexOf(type) === -1;
  });

  return mediaLine.replace(typesSuffix, ' ' + newTypes.join(' '));
};

// Remove all references to a particular encodingName from a particular media type
//
SDPHelpers.removeMediaEncoding = function removeMediaEncoding(sdp, mediaType, encodingName) {
  var payloadTypes = void 0,
      i = void 0,
      j = void 0,
      parts = void 0;
  var sdpLines = sdp.split('\r\n');
  var mLineIndex = SDPHelpers.getMLineIndex(sdpLines, mediaType);
  var mLine = mLineIndex > -1 ? sdpLines[mLineIndex] : void 0;
  var typesToRemove = [];

  if (mLineIndex === -1) {
    // Error, missing M line
    return sdpLines.join('\r\n');
  }

  // Get all payload types that the line supports
  payloadTypes = SDPHelpers.getMLinePayloadTypes(mLine, mediaType);
  if (payloadTypes.length === 0) {
    // Error, invalid M line?
    return sdpLines.join('\r\n');
  }

  // Find the payloadTypes of the codecs.
  // Allows multiple matches e.g. for CN.
  for (i = mLineIndex; i < sdpLines.length; i++) {
    if (sdpLines[i].indexOf('a=rtpmap:') === 0) {
      parts = sdpLines[i].split(' ');
      if (parts.length === 2 && parts[1].indexOf(encodingName + '/') === 0) {
        typesToRemove.push(parts[0].substr(9));
      }
    }
  }

  if (!typesToRemove.length) {
    // Not found.
    return sdpLines.join('\r\n');
  }

  // Also find any rtx which reference the removed codec.
  for (i = mLineIndex; i < sdpLines.length; i++) {
    if (sdpLines[i].indexOf('a=fmtp:') === 0) {
      parts = sdpLines[i].split(' ');
      for (j = 0; j < typesToRemove.length; j++) {
        if (parts.length === 2 && parts[1] === 'apt=' + typesToRemove[j]) {
          typesToRemove.push(parts[0].substr(7));
        }
      }
    }
  }

  // Remove any rtpmap, fmtp or rtcp-fb.
  sdpLines = sdpLines.filter(function (line) {
    for (var _i = 0; _i < typesToRemove.length; _i++) {
      if (line.indexOf('a=rtpmap:' + typesToRemove[_i] + ' ') === 0 || line.indexOf('a=fmtp:' + typesToRemove[_i] + ' ') === 0 || line.indexOf('a=rtcp-fb:' + typesToRemove[_i] + ' ') === 0) {
        return false;
      }
    }
    return true;
  });

  if (typesToRemove.length > 0 && mLineIndex > -1) {
    // Remove all the payload types and we've removed from the media line
    sdpLines[mLineIndex] = SDPHelpers.removeTypesFromMLine(mLine, typesToRemove);
  }

  return sdpLines.join('\r\n');
};

SDPHelpers.removeVideoCodec = function removeVideoCodec(sdp, codec) {
  return SDPHelpers.removeMediaEncoding(sdp, 'video', codec);
};

// Used to identify whether Video media (for a given set of SDP) supports
// retransmissions.
//
// The algorithm to do could be summarised as:
//
// IF ssrc-group:FID exists AND IT HAS AT LEAST TWO IDS THEN
//    we are using RTX
// ELSE IF "a=rtpmap: (\\d+):rtxPayloadId(/\\d+)? rtx/90000"
//          AND SDPHelpers.hasMLinePayloadType(sdpLines, 'Video', rtxPayloadId)
//    we are using RTX
// ELSE
//    we are not using RTX
//
// The ELSE IF clause basically covers the case where ssrc-group:FID
// is probably malformed or missing. In that case we verify whether
// we want RTX by looking at whether it's mentioned in the video
// media line instead.
//
var isUsingRTX = function isUsingRTX(sdpLines, videoAttrs) {
  var groupFID = videoAttrs.filterByName('ssrc-group:FID');
  var missingFID = groupFID.length === 0;

  if (!missingFID) {
    groupFID = groupFID[0].value.split(' ');
  } else {
    groupFID = [];
  }

  switch (groupFID.length) {
    case 0:
    case 1:
      // possibly no RTX, double check for the RTX payload type and that
      // the Video Media line contains that payload type
      //
      // Details: Look for a rtpmap line for rtx/90000
      //  If there is one, grab the payload ID for rtx
      //    Look to see if that payload ID is listed under the payload types for the m=Video line
      //      If it is: RTX
      //  else: No RTX for you

      var rtxAttr = videoAttrs.find(function (attr) {
        return attr.name.indexOf('rtpmap:') === 0 && attr.value.indexOf('rtx/90000') > -1;
      });

      if (!rtxAttr) {
        return false;
      }

      var rtxPayloadId = rtxAttr.name.split(':')[1];
      if (rtxPayloadId.indexOf('/') > -1) {
        rtxPayloadId = rtxPayloadId.split('/')[0];
      }
      return SDPHelpers.hasMLinePayloadType(sdpLines, 'video', rtxPayloadId);

    default:
      // two or more: definitely RTX
      logging.debug('SDP Helpers: There are more than two FIDs, RTX is definitely enabled');
      return true;
  }
};

// This returns an Array, which is decorated with several
// SDP specific helper methods.
//
SDPHelpers.getAttributesForMediaType = function getAttributesForMediaType(sdpLines, mediaType) {
  var ssrcStartIndex = void 0,
      ssrcEndIndex = void 0,
      regResult = void 0,
      ssrc = void 0,
      ssrcGroup = void 0,
      msidMatch = void 0,
      msid = void 0,
      mid = void 0,
      midIndex = void 0;
  var mLineIndex = SDPHelpers.getMLineIndex(sdpLines, mediaType);
  var matchOtherMLines = new RegExp('m=(?!' + mediaType + ').+ ', 'i');
  var matchSSRCLines = new RegExp('a=ssrc:\\d+ .*', 'i');
  var matchSSRCGroup = new RegExp('a=ssrc-group:FID (\\d+).*?', 'i');
  var matchAttrLine = new RegExp('a=([a-z0-9:/-]+) (.*)', 'i');
  var attrs = [];

  for (var i = mLineIndex + 1; i < sdpLines.length; i++) {
    if (matchOtherMLines.test(sdpLines[i])) {
      break;
    }

    // Get the ssrc
    ssrcGroup = sdpLines[i].match(matchSSRCGroup);
    if (ssrcGroup) {
      ssrcStartIndex = i;
      ssrc = ssrcGroup[1];
    }

    // Get the msid
    msidMatch = sdpLines[i].match('a=ssrc:' + ssrc + ' msid:(.+)');
    if (msidMatch) {
      msid = msidMatch[1];
    }

    // find where the ssrc lines end
    var isSSRCLine = matchSSRCLines.test(sdpLines[i]);
    if (ssrcStartIndex !== undefined && ssrcEndIndex === undefined && !isSSRCLine || i === sdpLines.length - 1) {
      ssrcEndIndex = i;
    }

    var midMatch = sdpLines[i].match(/a=mid:(.+)/);
    if (midMatch) {
      mid = midMatch[1];
      midIndex = i;
    }

    regResult = matchAttrLine.exec(sdpLines[i]);
    if (regResult && regResult.length === 3) {
      attrs.push({
        lineIndex: i,
        name: regResult[1],
        value: regResult[2]
      });
    }
  }

  // / The next section decorates the attributes array
  // / with some useful helpers.

  // Store references to the start and end indices
  // of the media section for this mediaType
  attrs.ssrcStartIndex = ssrcStartIndex;
  attrs.ssrcEndIndex = ssrcEndIndex;
  attrs.msid = msid;

  attrs.mid = mid;
  attrs.midIndex = midIndex;

  // Add filter support is
  if (!Array.prototype.filter) {
    attrs.filter = OTHelpers.filter.bind(OTHelpers, attrs);
  }

  if (!Array.prototype.find) {
    attrs.find = OTHelpers.find.bind(OTHelpers, attrs);
  }

  attrs.isUsingRTX = isUsingRTX.bind(null, sdpLines, attrs);

  attrs.filterByName = function (name) {
    return this.filter(function (attr) {
      return attr.name === name;
    });
  };

  attrs.getRtpNumber = function (mediaEncoding) {
    var namePattern = new RegExp('rtpmap:(.+)');

    return OTHelpers.find(attrs.map(function (attr) {
      var nameMatch = attr.name.match(namePattern);
      if (nameMatch && attr.value.indexOf(mediaEncoding) >= 0) {
        return nameMatch[1];
      }
      return null;
    }), function (attr) {
      return attr !== null;
    });
  };

  return attrs;
};

var modifyStereo = function modifyStereo(type, sdp, enable) {
  var sdpLines = sdp.split('\r\n');
  if (!SDPHelpers.getMLine(sdpLines, 'audio')) {
    logging.debug('No audio m-line, not enabling stereo.');
    return sdp;
  }
  var audioAttrs = SDPHelpers.getAttributesForMediaType(sdpLines, 'audio');

  var rtpNumber = audioAttrs.getRtpNumber('opus');
  if (!rtpNumber) {
    logging.debug('Could not find rtp number for opus, not enabling stereo.');
    return sdp;
  }

  var fmtpAttr = audioAttrs.find(function (attr) {
    return attr.name === 'fmtp:' + rtpNumber;
  });

  if (!fmtpAttr) {
    logging.debug('Could not find a=fmtp line for opus, not enabling stereo.');
    return sdp;
  }

  var line = sdpLines[fmtpAttr.lineIndex];
  var pattern = void 0;

  switch (type) {
    case 'send':
      pattern = /sprop-stereo=\d+(\s*;?\s*)/;
      if (pattern.test(fmtpAttr.value)) {
        line = line.replace(pattern, enable ? 'sprop-stereo=1$1' : '');
      } else if (enable) {
        line += '; sprop-stereo=1';
      }
      break;

    case 'receive':
      pattern = /([^-])stereo=\d+(\s*;?\s*)/;
      if (pattern.test(fmtpAttr.value)) {
        line = line.replace(pattern, enable ? '$1stereo=1$2' : '$1');
      } else if (enable) {
        line += '; stereo=1';
      }
      break;

    default:
      throw new Error('Invalid type ' + type + ' passed into enableStereo');
  }

  // Trim any trailing whitespace and semicolons
  line = line.replace(/[;\s]*$/, '');

  sdpLines[fmtpAttr.lineIndex] = line;

  return sdpLines.join('\r\n');
};

SDPHelpers.modifySendStereo = modifyStereo.bind(null, 'send');
SDPHelpers.modifyReceiveStereo = modifyStereo.bind(null, 'receive');

SDPHelpers.setAudioBitrate = function (sdp, audioBitrate) {
  var existingValue = SDPHelpers.getAudioBitrate(sdp);
  if (existingValue !== undefined) {
    logging.debug('Audio bitrate already set to ' + existingValue + ', not setting audio bitrate');
    return sdp;
  }
  var sdpLines = sdp.split('\r\n');
  if (!SDPHelpers.getMLine(sdpLines, 'audio')) {
    logging.debug('No audio m-line, not setting audio bitrate.');
    return sdp;
  }
  var audioAttrs = SDPHelpers.getAttributesForMediaType(sdpLines, 'audio');

  if (!audioAttrs.midIndex) {
    logging.debug('No audio mid line, not setting audio bitrate.');
    return sdp;
  }

  // SDP expects audio bitrate in kbit/s
  var audioBitrateKbps = Math.floor(audioBitrate / 1000);
  sdpLines.splice(audioAttrs.midIndex + 1, 0, 'b=AS:' + audioBitrateKbps);

  return sdpLines.join('\r\n');
};

SDPHelpers.hasSendStereo = function (sdp) {
  return (/[\s;]sprop-stereo=1/.test(sdp)
  );
};
SDPHelpers.getAudioBitrate = function (sdp) {
  var result = sdp.match(/\sb=AS:(\d+)/);
  if (result) {
    return Number(result[1]) * 1000;
  }
  return undefined;
};

// Modifies +sdp+ to enable Simulcast for +numberOfStreams+.
//
// Ok, here's the plan:
//  - add the 'a=ssrc-group:SIM' line, it will have numberOfStreams ssrcs
//  - if RTX then add one 'a=ssrc-group:FID', we need to add numberOfStreams lines
//  - add numberOfStreams 'a=ssrc:...' lines for the media ssrc
//  - if RTX then add numberOfStreams 'a=ssrc:...' lines for the RTX ssrc
//
// Re: media and rtx ssrcs:
// We just generate these. The Mantis folk would like us to use sequential numbers
// here for ease of debugging. We can use the same starting number each time as well.
// We should confirm with Oscar/Jose that whether we need to verify that the numbers
// that we choose don't clash with any other ones in the SDP.
//
// I think we do need to check but I can't remember.
//
// Re: The format of the 'a=ssrc:' lines
// Just use the following pattern:
//   a=ssrc:<Media or RTX SSRC> cname:localCname
//   a=ssrc:<Media or RTX SSRC> msid:<MSID>
//
// It doesn't matter that they are all the same and are static.
//
//
SDPHelpers.enableSimulcast = function enableSimulcast(sdp, numberOfStreams) {
  var linesToAdd = void 0,
      i = void 0;
  var sdpLines = sdp.split('\r\n');
  if (!SDPHelpers.getMLine(sdpLines, 'video')) {
    logging.debug('No video m-line, not enabling simulcast.');
    return sdp;
  }
  var videoAttrs = SDPHelpers.getAttributesForMediaType(sdpLines, 'video');

  if (videoAttrs.filterByName('ssrc-group:SIM').length > 0) {
    logging.debug('Simulcast is already enabled in this SDP, not attempting to enable again.');
    return sdp;
  }

  if (!videoAttrs.msid) {
    logging.debug('No local stream attached, not enabling simulcast.');
    return sdp;
  }

  var usingRTX = videoAttrs.isUsingRTX();
  var mediaSSRC = [];
  var rtxSSRC = [];

  // generate new media (and rtx if needed) ssrcs
  for (i = 0; i < numberOfStreams; ++i) {
    mediaSSRC.push(START_MEDIA_SSRC + i);
    if (usingRTX) {
      rtxSSRC.push(START_RTX_SSRC + i);
    }
  }

  linesToAdd = ['a=ssrc-group:SIM ' + mediaSSRC.join(' ')];

  if (usingRTX) {
    for (i = 0; i < numberOfStreams; ++i) {
      linesToAdd.push('a=ssrc-group:FID ' + mediaSSRC[i] + ' ' + rtxSSRC[i]);
    }
  }

  for (i = 0; i < numberOfStreams; ++i) {
    linesToAdd.push('a=ssrc:' + mediaSSRC[i] + ' cname:localCname', 'a=ssrc:' + mediaSSRC[i] + ' msid:' + videoAttrs.msid);
  }

  if (usingRTX) {
    for (i = 0; i < numberOfStreams; ++i) {
      linesToAdd.push('a=ssrc:' + rtxSSRC[i] + ' cname:localCname', 'a=ssrc:' + rtxSSRC[i] + ' msid:' + videoAttrs.msid);
    }
  }

  // Replace the previous video ssrc section with our new video ssrc section by
  // deleting the old ssrcs section and inserting the new lines
  linesToAdd.unshift(videoAttrs.ssrcStartIndex, videoAttrs.ssrcEndIndex - videoAttrs.ssrcStartIndex);
  sdpLines.splice.apply(sdpLines, linesToAdd);

  return sdpLines.join('\r\n');
};

SDPHelpers.deprioritizeH264 = function deprioritizeH264(sdp) {
  var lines = sdp.split('\r\n');

  var mLineIndex = SDPHelpers.getMLineIndex(lines, 'video');

  if (mLineIndex === -1) {
    return sdp;
  }

  var payloadTypes = SDPHelpers.getMLinePayloadTypes(lines[mLineIndex], 'video');

  var h264Lines = lines.filter(function (line) {
    return (/^a=.* H264/.test(line)
    );
  });

  if (h264Lines.length === 0) {
    return sdp;
  }

  var h264TypeCodes = null;

  try {
    h264TypeCodes = h264Lines.map(function (line) {
      return line.split(':')[1].split(' ')[0];
    });
  } catch (error) {
    logging.error('Something went wrong getting the h264 type code:', {
      lines: h264Lines,
      error: error
    });

    return sdp;
  }

  var newPayloadTypes = payloadTypes.filter(function (t) {
    return h264TypeCodes.indexOf(t) === -1;
  });
  newPayloadTypes.push.apply(newPayloadTypes, h264TypeCodes);

  var newMLine = lines[mLineIndex].replace(payloadTypes.join(' '), newPayloadTypes.join(' '));
  lines[mLineIndex] = newMLine;

  return lines.join('\r\n');
};

},{"../../common-js-helpers/OTHelpers.js":217,"../logging.js":312}],348:[function(require,module,exports){
(function (global){
'use strict';

// @todo enable the following disabled rules see OPENTOK-31136 for more info
/* eslint-disable global-require, no-param-reassign */

module.exports = function setCertificatesFactory() {
  var deps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var OTHelpers = deps.OTHelpers || require('../../common-js-helpers/OTHelpers.js');
  var window = deps.global || global;

  var RTCPeerConnection = window.RTCPeerConnection;


  return function setCertificates(pcConfig, completion) {
    if (OTHelpers.env.name === 'Firefox' && RTCPeerConnection && RTCPeerConnection.generateCertificate) {
      RTCPeerConnection.generateCertificate({
        name: 'RSASSA-PKCS1-v1_5',
        hash: 'SHA-256',
        modulusLength: 2048,
        publicExponent: new Uint8Array([1, 0, 1])
      }).catch(function (err) {
        completion(err);
      }).then(function (cert) {
        pcConfig.certificates = [cert];
        completion(undefined, pcConfig);
      });
    } else {
      setTimeout(function () {
        completion(undefined, pcConfig);
      });
    }
  };
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../common-js-helpers/OTHelpers.js":217}],349:[function(require,module,exports){
'use strict';

// @todo enable the following disabled rules see OPENTOK-31136 for more info
/* eslint-disable no-param-reassign */

var assign = require('lodash/assign');
var applySdpTransform = require('./applySdpTransform.js');
var logging = require('../logging.js');

// Attempt to completely process a subscribe message. This will:
// * create an Offer
// * set the new offer as the location description
//
// If there are no issues, the +success+ callback will be executed on completion.
// Errors during any step will result in the +failure+ callback being executed.
//
module.exports = function subscribeProcessor(peerConnection, NativeRTCSessionDescription, sdpTransforms, simulcastStreams, offerOverrides, offerConstraints, success, failure) {
  var generateErrorCallback = function generateErrorCallback(message, prefix) {
    return function (errorReason) {
      logging.error(message, errorReason);

      if (failure) {
        failure(message, errorReason, prefix);
      }
    };
  };

  var setLocalDescription = function setLocalDescription(offer) {
    logging.debug('subscribeProcessor: offer created', offer);

    var newOffer = new NativeRTCSessionDescription({
      type: offer.type,
      sdp: applySdpTransform(sdpTransforms, 'local', 'offer', assign({ simulcastStreams: simulcastStreams }, offerOverrides || {}), offer.sdp)
    });

    logging.debug('subscribeProcessor: setting local description');

    peerConnection.setLocalDescription(newOffer).then(function () {
      return success(newOffer);
    }).catch(generateErrorCallback('Error while setting LocalDescription', 'SetLocalDescription'));
  };

  logging.debug('subscribeProcessor: creating offer');

  peerConnection.createOffer(offerConstraints).then(setLocalDescription).catch(generateErrorCallback('Error while creating Offer', 'CreateOffer'));
};

},{"../logging.js":312,"./applySdpTransform.js":335,"lodash/assign":142}],350:[function(require,module,exports){
'use strict';

// @todo enable the following disabled rules see OPENTOK-31136 for more info
/* eslint-disable global-require, no-underscore-dangle, no-param-reassign, no-void, no-shadow */

var assign = require('lodash/assign');

module.exports = function SubscriberPeerConnectionFactory() {
  var deps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var ExceptionCodes = deps.ExceptionCodes || require('../exception_codes.js');
  var OTHelpers = deps.OTHelpers || require('../../common-js-helpers/OTHelpers.js');
  var parseIceServers = deps.parseIceServers || require('../messaging/raptor/parse_ice_servers.js').parseIceServers;
  var PeerConnection = deps.PeerConnection || require('./peer_connection.js')();
  var RaptorConstants = deps.RaptorConstants || require('../messaging/raptor/raptor_constants.js');
  var setCertificates = deps.setCertificates || require('./set_certificates.js')();

  /*
   * Abstracts PeerConnection related stuff away from Subscriber.
   *
   * Responsible for:
   * * setting up the underlying PeerConnection (delegates to PeerConnections)
   * * triggering a connected event when the Peer connection is opened
   * * triggering a disconnected event when the Peer connection is closed
   * * creating a video element when a stream is added
   * * responding to stream removed intelligently
   * * providing a destroy method
   * * providing a processMessage method
   *
   * Once the PeerConnection is connected and the video element playing it
   * triggers the connected event
   *
   * Triggers the following events
   * * connected
   * * disconnected
   * * remoteStreamAdded
   * * remoteStreamRemoved
   * * error
   *
   */

  return function SubscriberPeerConnection(_ref) {
    var clientCandidates = _ref.clientCandidates,
        iceServers = _ref.iceServers,
        socket = _ref.socket,
        stream = _ref.stream,
        subscriberId = _ref.subscriberId,
        subscriberUri = _ref.subscriberUri,
        properties = _ref.properties,
        logAnalyticsEvent = _ref.logAnalyticsEvent;

    var _subscriberPeerConnection = this;
    var _peerConnection = void 0;
    var _destroyed = false;
    var _hasRelayCandidates = false;
    var _awaitingIceRestart = false;

    // Private
    var _onPeerClosed = function _onPeerClosed() {
      this.destroy();
      if (_awaitingIceRestart) {
        this.trigger('iceRestartFailure', this);
      }
      this.trigger('disconnected', this);
    };

    var _onRemoteStreamAdded = function _onRemoteStreamAdded(remoteRTCStream) {
      this.trigger('remoteStreamAdded', remoteRTCStream, this);
    };

    var _onRemoteStreamRemoved = function _onRemoteStreamRemoved(remoteRTCStream) {
      this.trigger('remoteStreamRemoved', remoteRTCStream, this);
    };

    // Note: All Peer errors are fatal right now.
    var _onPeerError = function _onPeerError(errorReason, prefix) {
      this.trigger('error', null, errorReason, this, prefix);
    };

    var _onIceConnectionStateChange = function _onIceConnectionStateChange(state) {
      if (_awaitingIceRestart && (state === 'connected' || state === 'completed')) {
        _awaitingIceRestart = false;
        this.trigger('iceRestartSuccess');
      }
      this.trigger('iceConnectionStateChange', state);
    };

    var _onsignalingStateChange = function _onsignalingStateChange(state) {
      this.trigger('signalingStateChange', state);
    };

    var _onsignalingStateStable = function _onsignalingStateStable(state) {
      this.trigger('signalingStateStable', state);
    };

    var _relayMessageToPeer = function sendMessageToPeer(type, payload) {
      if (!_hasRelayCandidates) {
        var extractCandidates = type === RaptorConstants.Actions.CANDIDATE || type === RaptorConstants.Actions.OFFER || type === RaptorConstants.Actions.ANSWER || type === RaptorConstants.Actions.PRANSWER;

        if (extractCandidates) {
          var message = type === RaptorConstants.Actions.CANDIDATE ? payload.candidate : payload.sdp;

          _hasRelayCandidates = message.indexOf('typ relay') !== -1;
        }
      }

      switch (type) {
        case RaptorConstants.Actions.ANSWER:
        case RaptorConstants.Actions.PRANSWER:
          this.trigger('connected');
          socket.jsepAnswer(subscriberUri, payload.sdp);
          break;

        case RaptorConstants.Actions.OFFER:
          socket.jsepOffer(subscriberUri, payload.sdp);
          break;

        case RaptorConstants.Actions.CANDIDATE:
          socket.jsepCandidate(subscriberUri, payload);
          break;

        default:
      }
    }.bind(this);

    OTHelpers.eventing(this);

    // Public
    this.destroy = function () {
      if (_destroyed) {
        return;
      }
      _destroyed = true;

      if (_peerConnection) {
        // Unsubscribe us from the stream, if it hasn't already been destroyed
        if (socket.is('connected') && !stream.destroyed) {
          // Notify the server components
          socket.subscriberDestroy(stream.id, subscriberId);
        }

        // Ref: OPENTOK-2458 disable all audio tracks before removing it.
        this.subscribeToAudio(false);
        _peerConnection.disconnect();
      }

      _peerConnection = null;
      this.off();
    };

    this.getDataChannel = function (label, options, completion) {
      _peerConnection.getDataChannel(label, options, completion);
    };

    this.processMessage = function (type, message) {
      _peerConnection.processMessage(type, message);
    };

    this.remoteDescription = function () {
      return _peerConnection.remoteDescription();
    };

    this.getStats = function (callback) {
      if (_peerConnection) {
        _peerConnection.getStats(callback);
      } else {
        callback(new OTHelpers.Error('Subscriber is not connected cannot getStats', 'NotConnectedError', {
          code: 1015
        }));
      }
    };

    // Helper method used by subscribeToAudio/subscribeToVideo
    var _createSetEnabledForTracks = function _createSetEnabledForTracks(kind) {
      return function (enabled) {
        if (!_peerConnection) {
          // We haven't created the peer connection yet, so there are no remote streams right now.
          // Subscriber will try again after onRemoteStreamAdded so this works out ok.
          return;
        }

        _peerConnection.remoteTracks().forEach(function (track) {
          if (track.kind === kind && track.enabled !== enabled) {
            track.enabled = enabled;
          }
        });
      };
    };

    this.subscribeToAudio = _createSetEnabledForTracks('audio');
    this.subscribeToVideo = _createSetEnabledForTracks('video');

    this.hasRelayCandidates = function () {
      return _hasRelayCandidates;
    };

    this.iceRestart = function () {
      _awaitingIceRestart = true;
      return _peerConnection.iceRestart();
    };

    this.iceConnectionStateIsConnected = function () {
      return _peerConnection.iceConnectionStateIsConnected();
    };

    // Init
    this.init = function (completion) {
      var _this = this;

      var pcConfig = {
        iceServers: iceServers
      };

      setCertificates(pcConfig, function (err, pcConfigWithCerts) {
        if (err) {
          completion(err);
          return;
        }

        var peerConnectionConfig = assign({
          logAnalyticsEvent: logAnalyticsEvent,
          clientCandidates: clientCandidates
        }, pcConfigWithCerts);

        _peerConnection = new PeerConnection(assign({ sendMessage: _relayMessageToPeer }, peerConnectionConfig));

        _peerConnection.on({
          iceConnected: function iceConnected() {
            return _subscriberPeerConnection.emit('iceConnected');
          },
          close: _onPeerClosed,
          streamAdded: _onRemoteStreamAdded,
          streamRemoved: _onRemoteStreamRemoved,
          signalingStateChange: _onsignalingStateChange,
          signalingStateStable: _onsignalingStateStable,
          error: _onPeerError,
          qos: function qos(_qos) {
            return _this.trigger('qos', _qos);
          },
          iceConnectionStateChange: _onIceConnectionStateChange
        }, _subscriberPeerConnection);

        // If there are already remoteStreams, add them immediately
        // (Using .remoteTracks to avoid deprecated .remoteStreams where possible.
        // FIXME: Is this even possible anyway? How could we already have remote streams in the same
        // tick the peer connection was created?)
        if (_peerConnection.remoteTracks().length > 0) {
          _peerConnection.remoteStreams().forEach(_onRemoteStreamAdded, _subscriberPeerConnection);
        } else {
          // We only bother with the PeerConnection negotiation if we don't already
          // have a remote stream.

          var channelsToSubscribeTo = void 0;

          if (properties.subscribeToVideo || properties.subscribeToAudio) {
            var audio = stream.getChannelsOfType('audio');
            var video = stream.getChannelsOfType('video');

            channelsToSubscribeTo = audio.map(function (channel) {
              return {
                id: channel.id,
                type: channel.type,
                active: properties.subscribeToAudio
              };
            }).concat(video.map(function (channel) {
              var props = {
                id: channel.id,
                type: channel.type,
                active: properties.subscribeToVideo,
                restrictFrameRate: properties.restrictFrameRate !== void 0 ? properties.restrictFrameRate : false
              };

              if (properties.preferredFrameRate !== void 0) {
                props.preferredFrameRate = parseFloat(properties.preferredFrameRate);
              }

              if (properties.preferredHeight !== void 0) {
                props.preferredHeight = parseInt(properties.preferredHeight, 10);
              }

              if (properties.preferredWidth !== void 0) {
                props.preferredWidth = parseInt(properties.preferredWidth, 10);
              }

              return props;
            }));
          }

          socket.subscriberCreate(stream.id, subscriberId, channelsToSubscribeTo, function (err, message) {
            if (err) {
              var msg = 'subscriberCreate failed with unexpected code ' + err.code;
              var code = Number(err.code);

              if (code === 404) {
                msg = 'stream not found';
              }

              if (code === 409 && err.message === 'streamLimitExceeded') {
                code = ExceptionCodes.STREAM_LIMIT_EXCEEDED;
                msg = 'The limit for concurrent streams in the session has been reached';
              }

              _subscriberPeerConnection.trigger('error', code, msg, _subscriberPeerConnection, 'Subscribe');
            }
            if (_peerConnection && !iceServers) {
              _peerConnection.setIceServers(parseIceServers(message));
            }
          });

          completion(undefined, _subscriberPeerConnection);
        }
      });
    };
  };
};

},{"../../common-js-helpers/OTHelpers.js":217,"../exception_codes.js":307,"../messaging/raptor/parse_ice_servers.js":318,"../messaging/raptor/raptor_constants.js":319,"./peer_connection.js":341,"./set_certificates.js":348,"lodash/assign":142}],351:[function(require,module,exports){
'use strict';

// @todo enable the following disabled rules see OPENTOK-31136 for more info
/* eslint-disable max-len, no-plusplus */

/*
 * Installs a watcher that will calls the given callback if the audio acquisition seems to not
 * work porperly.
 *
 * It waits 3 seconds and poll getStats to find any sign of audio bytes sent. If it can't find any
 * it signals the anomaly by executing the given function.
 *
 * @param {function(cb: function(DOMError, Array<RTCStats>))} getStats the function to call to get the stats
 * @param {function} warningCb to be called when a potential problem is detected
 * @returns {function} cancel the watch
 */
module.exports = function watchAudioAcquisition(getStats, warningCb) {
  // detection of Chrome failure to acquire audio
  // inspired by https://medium.com/the-making-of-appear-in/working-around-webrtc-bugs-d4f6fdb763f
  var to = setTimeout(function () {
    getStats(function (error, rtcStatsItems) {
      if (error) {
        return;
      }

      for (var idxStats = 0; idxStats < rtcStatsItems.length; idxStats++) {
        var rtcStats = rtcStatsItems[idxStats];
        if (rtcStats.id.indexOf('_send') !== -1 && rtcStats.type === 'ssrc' && rtcStats.mediaType === 'audio' && parseInt(rtcStats.bytesSent, 10) === 0) {
          // abnormal condition detected
          warningCb();
        }
      }
    });
  }, 3000);

  return function cancel() {
    clearTimeout(to);
  };
};

},{}],352:[function(require,module,exports){
'use strict';

module.exports = function calculateCapableSimulcastStreams(opt) {
  if (opt.browserName !== 'Chrome' || opt.isScreenSharing || opt.sessionInfo.p2pEnabled || !opt.constraints.video) {
    // We only support simulcast on Chrome, and when not using
    // screensharing.
    return 1;
  }

  // HD and above gets three streams. Otherwise they get 2.
  if (opt.videoDimensions.width > 640 && opt.videoDimensions.height > 480) {
    return 3;
  }

  return 2;
};

},{}],353:[function(require,module,exports){
'use strict';

// @todo enable the following disabled rules see OPENTOK-31136 for more info
/* eslint-disable no-param-reassign, global-require, one-var */

var bluebird = require('bluebird');

module.exports = function createChromeMixinFactory() {
  var deps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var Archiving = deps.Archiving || require('../chrome/archiving.js');
  var AudioLevelMeter = deps.AudioLevelMeter || require('../chrome/audio_level_meter.js');
  var AudioLevelTransformer = deps.AudioLevelTransformer || require('../audio_level_transformer');
  var BackingBar = deps.BackingBar || require('../chrome/backing_bar.js');
  var Chrome = deps.Chrome || require('../chrome/chrome.js');
  var MuteButton = deps.MuteButton || require('../chrome/mute_button.js')();
  var NamePanel = deps.NamePanel || require('../chrome/name_panel.js');
  var StylableComponent = deps.StylableComponent || require('../styling/stylable_component.js');

  return function createChromeMixin(publisher, options) {
    var name = options.name;
    var publishAudio = options.publishAudio;
    var publishVideo = options.publishVideo;
    var audioSource = options.audioSource;
    var showControls = options.showControls;
    var isScreenSharing = options.isScreenSharing;
    var logAnalyticsEvent = options.logAnalyticsEvent;

    var audioLevelMeter = void 0,
        chrome = void 0,
        widgetView = void 0;

    var chromeMixin = {};

    // If mode is false, then that is the mode. If mode is true then we'll
    // definitely display  the button, but we'll defer the model to the
    // Publishers buttonDisplayMode style property.
    var chromeButtonMode = function chromeButtonMode(mode) {
      if (mode === false) {
        return 'off';
      }

      var defaultMode = publisher.getStyle('buttonDisplayMode');

      // The default model is false, but it's overridden by +mode+ being true
      if (defaultMode === false) {
        return 'on';
      }

      // defaultMode is either true or auto.
      return defaultMode;
    };

    var uiPromise = new bluebird.Promise(function (resolve, reject) {
      chromeMixin.init = function (widgetViewParam) {
        if (!publisher.getStyle('showArchiveStatus')) {
          logAnalyticsEvent('showArchiveStatus', 'createChrome', { mode: 'off' });
        }

        var widgets = {
          backingBar: new BackingBar({
            nameMode: !name ? 'off' : publisher.getStyle('nameDisplayMode'),
            muteMode: chromeButtonMode(publisher.getStyle('buttonDisplayMode'))
          }),

          name: new NamePanel({
            name: name,
            mode: publisher.getStyle('nameDisplayMode')
          }),

          archive: new Archiving({
            show: publisher.getStyle('showArchiveStatus') && publisher.getStyle('showArchiveStatus') !== 'off',
            archiving: false
          })
        };

        if (!(audioSource === null || audioSource === false)) {
          widgets.muteButton = new MuteButton({
            muted: publishAudio === false,
            mode: chromeButtonMode.call(publisher, publisher.getStyle('buttonDisplayMode'))
          });
        }

        audioLevelMeter = new AudioLevelMeter({
          mode: publisher.getStyle('audioLevelDisplayMode')
        });

        var audioLevelTransformer = new AudioLevelTransformer();

        var audioLevelUpdatedHandler = function audioLevelUpdatedHandler(evt) {
          var audioLevel = audioLevelTransformer.transform(evt.audioLevel);

          // @FIXME
          // We force the audio level value to be zero here if audio is disabled
          // because the AudioLevelMeter cannot currently differentiate
          // between video being disabled and audio being disabled.
          // To be fixed as part of OPENTOK-29865
          if (!publishAudio) {
            audioLevel = 0;
          }

          audioLevelMeter.setValue(audioLevel);
        };

        audioLevelMeter.watchVisibilityChanged(function (visible) {
          if (visible) {
            publisher.on('audioLevelUpdated', audioLevelUpdatedHandler);
          } else {
            publisher.off('audioLevelUpdated', audioLevelUpdatedHandler);
          }
        });

        audioLevelMeter.audioOnly(!publishVideo && publishAudio);

        widgets.audioLevel = audioLevelMeter;

        if (widgetViewParam && widgetViewParam.domElement) {
          widgetView = widgetViewParam;

          chrome = new Chrome({
            parent: widgetView.domElement
          }).set(widgets).on({
            muted: function muted() {
              return publisher.publishAudio(false);
            },
            unmuted: function unmuted() {
              return publisher.publishAudio(true);
            }
          });

          resolve();
        }
      };

      chromeMixin.reset = function () {
        // reject in case the chrome creating was still pending
        reject(new Error('Chrome still being created'));

        if (chrome) {
          chrome.destroy();
          chrome = null;
        }
      };
    });

    chromeMixin.setAudioOnly = function (value) {
      if (audioLevelMeter) {
        audioLevelMeter.audioOnly(value);
      }
    };

    chromeMixin.setArchivingStatus = function (status) {
      if (chrome) {
        chrome.archive.setArchiving(status);
      }
    };

    chromeMixin.setMuted = function (muted) {
      if (chrome) {
        chrome.muteButton.muted(muted);
      }
    };

    StylableComponent(publisher, {
      showArchiveStatus: true,
      nameDisplayMode: 'auto',
      buttonDisplayMode: 'auto',
      audioLevelDisplayMode: isScreenSharing ? 'off' : 'auto',
      archiveStatusDisplayMode: 'auto',
      backgroundImageURI: null
    }, showControls, function (payload) {
      logAnalyticsEvent('SetStyle', 'Publisher', payload, null, 0.1);
    });

    publisher.on('styleValueChanged', function (key, value) {
      // enlist style change for when the the chrome is created
      uiPromise.then(function () {
        switch (key) {
          case 'nameDisplayMode':
            chrome.name.setDisplayMode(value);
            chrome.backingBar.setNameMode(value);
            break;

          case 'showArchiveStatus':
            logAnalyticsEvent('showArchiveStatus', 'styleChange', { mode: value ? 'on' : 'off' });
            chrome.archive.setShowArchiveStatus(value);
            break;

          case 'archiveStatusDisplayMode':
            chrome.archive.setShowArchiveStatus(value !== 'off');
            break;

          case 'buttonDisplayMode':
            chrome.muteButton.setDisplayMode(value);
            chrome.backingBar.setMuteMode(value);
            break;

          case 'audioLevelDisplayMode':
            chrome.audioLevel.setDisplayMode(value);
            break;

          case 'backgroundImageURI':
            widgetView.setBackgroundImageURI(value);
            break;

          default:
        }
      });
    });

    return chromeMixin;
  };
};

},{"../audio_level_transformer":293,"../chrome/archiving.js":295,"../chrome/audio_level_meter.js":296,"../chrome/backing_bar.js":297,"../chrome/chrome.js":299,"../chrome/mute_button.js":300,"../chrome/name_panel.js":301,"../styling/stylable_component.js":375,"bluebird":2}],354:[function(require,module,exports){
'use strict';

var merge = require('lodash/merge');

var normalizeConstraintInput = require('./normalizeConstraintInput.js');

function createSourceConstraint(media, enableRenegotiation, usingOptionalMandatoryStyle) {
  if (!media.publish && enableRenegotiation) {
    // FIXME: I'm still not quite happy with how this works. With renegotiation, when publish
    // changes to true we shouldn't have to recalculate constraints. I think Publisher should handle
    // this override instead and this component shouldn't know anything about renegotiation.
    // Related: OPENTOK-31082
    return false;
  }

  if (typeof media.source === 'boolean') {
    return media.source;
  }

  if (usingOptionalMandatoryStyle) {
    return { mandatory: { sourceId: media.source } };
  }

  return { deviceId: { exact: media.source } };
}

function generateAudioConstraints(opt) {
  var constraints = createSourceConstraint(opt.audio, opt.enableRenegotiation, opt.usingOptionalMandatoryStyle);

  if (constraints === false) {
    return false;
  }

  var usingOptionalMandatoryStyle = opt.usingOptionalMandatoryStyle,
      disableAudioProcessing = opt.disableAudioProcessing,
      prefixedAudioConstraints = opt.prefixedAudioConstraints;


  if ((disableAudioProcessing || prefixedAudioConstraints) && constraints === true) {
    constraints = {};
  }

  if (disableAudioProcessing) {
    // Chrome uses optional/mandatory style because a boolean is equivalent to an ideal value
    // See https://bugs.chromium.org/p/chromium/issues/detail?id=700223#c3
    if (usingOptionalMandatoryStyle) {
      merge(constraints, { optional: [] });

      constraints.optional.push({ echoCancellation: false });
    } else {
      constraints.echoCancellation = false;
    }
  }

  if (prefixedAudioConstraints) {
    if (usingOptionalMandatoryStyle) {
      merge(constraints, { optional: [] });

      Object.keys(prefixedAudioConstraints).forEach(function (key) {
        var _constraints$optional;

        constraints.optional.push((_constraints$optional = {}, _constraints$optional[key] = prefixedAudioConstraints[key], _constraints$optional));
      });
    } else {
      merge(constraints, prefixedAudioConstraints);
    }
  }

  return constraints;
}

function generateVideoConstraints(opt) {
  var constraints = createSourceConstraint(opt.video, opt.enableRenegotiation, opt.usingOptionalMandatoryStyle);

  if (constraints === false) {
    return false;
  }

  var videoDimensions = opt.videoDimensions,
      frameRate = opt.frameRate,
      maxResolution = opt.maxResolution,
      usingOptionalMandatoryStyle = opt.usingOptionalMandatoryStyle;


  if ((videoDimensions || frameRate || maxResolution) && constraints === true) {
    constraints = {};
  }

  if (videoDimensions) {
    var width = videoDimensions.width;
    var height = videoDimensions.height;

    if (usingOptionalMandatoryStyle) {
      merge(constraints, { optional: [] });

      constraints.optional.push({ minWidth: width }, { maxWidth: width }, { minHeight: height }, { maxHeight: height });
    } else {
      merge(constraints, {
        width: { ideal: width },
        height: { ideal: height }
      });
    }
  }

  if (frameRate) {
    if (usingOptionalMandatoryStyle) {
      merge(constraints, { optional: [] });

      constraints.optional.push({ minFrameRate: frameRate }, { maxFrameRate: frameRate });
    } else {
      merge(constraints, {
        frameRate: { ideal: frameRate }
      });
    }
  }

  if (maxResolution) {
    if (usingOptionalMandatoryStyle) {
      merge(constraints, {
        mandatory: {
          maxWidth: maxResolution.width,
          maxHeight: maxResolution.height
        }
      });
    } else {
      merge(constraints, {
        width: { max: maxResolution.width },
        height: { max: maxResolution.height }
      });
    }
  }

  return constraints;
}

function generateConstraints(opt) {
  return {
    audio: generateAudioConstraints(opt),
    video: generateVideoConstraints(opt)
  };
}

module.exports = function generateConstraintInfo(opt) {
  var normOpt = normalizeConstraintInput(opt);
  var constraints = generateConstraints(normOpt);

  return {
    constraints: constraints,
    publishAudio: normOpt.audio.publish,
    publishVideo: normOpt.video.publish,
    frameRate: normOpt.frameRate,
    videoDimensions: normOpt.videoDimensions,
    audioDeviceId: typeof normOpt.audio.source === 'string' ? normOpt.audio.source : undefined,
    videoDeviceId: typeof normOpt.video.source === 'string' ? normOpt.video.source : undefined
  };
};

},{"./normalizeConstraintInput.js":359,"lodash/merge":171}],355:[function(require,module,exports){
(function (global){
'use strict';

// @todo enable the following disabled rules see OPENTOK-31136 for more info
/* eslint-disable global-require, one-var */
/* eslint-disable no-use-before-define, no-prototype-builtins, no-underscore-dangle */

var assign = require('lodash/assign');
var Bluebird = require('bluebird');
var cloneDeep = require('lodash/cloneDeep');
var pick = require('lodash/pick');
var uuid = require('uuid');
var capitalize = require('lodash/capitalize');

module.exports = function PublisherFactory() {
  var deps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var analytics = deps.analytics || require('../analytics.js');
  var APIKEY = deps.APIKEY || require('../api_key.js');
  var calculateCapableSimulcastStreams = deps.calculateCapableSimulcastStreams || require('./calculateCapableSimulcastStreams.js');
  var ConnectivityAttemptPinger = deps.ConnectivityAttemptPinger || require('../../helpers/connectivity_attempt_pinger.js');
  var createChromeMixin = deps.createChromeMixin || require('./createChromeMixin.js')();
  var deviceHelpers = deps.deviceHelpers || require('../../helpers/device_helpers.js')();
  var EnvironmentLoader = deps.EnvironmentLoader || require('../environment_loader.js');
  var Errors = deps.Errors || require('../Errors.js');
  var Events = deps.Events || require('../events.js')();
  var ExceptionCodes = deps.ExceptionCodes || require('../exception_codes.js');
  var generateConstraintInfo = deps.generateConstraintInfo || require('./generateConstraintInfo.js');
  var getUserMedia = deps.getUserMedia || require('../../helpers/get_user_media.js')();
  var interpretPeerConnectionError = deps.interpretPeerConnectionError || require('../interpretPeerConnectionError.js')();
  var IntervalRunner = deps.IntervalRunner || require('../interval_runner.js')();
  var logging = deps.logging || require('../logging.js');
  var Microphone = deps.Microphone || require('./microphone.js')();
  var otError = deps.otError || require('../../helpers/otError.js')();
  var OTErrorClass = deps.OTErrorClass || require('../ot_error_class.js');
  var OTHelpers = deps.OTHelpers || require('../../common-js-helpers/OTHelpers.js');
  var OTPlugin = deps.OTPlugin || require('../../otplugin/otplugin.js');
  var otProperties = deps.otProperties || require('../../helpers/otProperties.js');
  var parseIceServers = deps.parseIceServers || require('../messaging/raptor/parse_ice_servers.js').parseIceServers;
  var PUBLISH_MAX_DELAY = deps.PUBLISH_MAX_DELAY || require('./max_delay.js');
  var PublisherPeerConnection = deps.PublisherPeerConnection || require('../peer_connection/publisher_peer_connection.js')();
  var PublishingState = deps.PublishingState || require('./state.js')();
  var screenSharing = deps.screenSharing || require('../screensharing/screen_sharing.js')();
  var StreamChannel = deps.StreamChannel || require('../stream_channel.js');
  var systemRequirements = deps.systemRequirements || require('../system_requirements.js');
  var VideoOrientation = deps.VideoOrientation || require('../../helpers/video_orientation.js')();
  var WidgetView = deps.WidgetView || require('../../helpers/widget_view.js')();

  /**
   * The Publisher object  provides the mechanism through which control of the
   * published stream is accomplished. Calling the <code>OT.initPublisher()</code> method
   * creates a Publisher object. </p>
   *
   *  <p>The following code instantiates a session, and publishes an audio-video stream
   *  upon connection to the session: </p>
   *
   *  <pre>
   *  var apiKey = ''; // Replace with your API key. See https://tokbox.com/account
   *  var sessionID = ''; // Replace with your own session ID.
   *                      // See https://tokbox.com/developer/guides/create-session/.
   *  var token = ''; // Replace with a generated token that has been assigned the moderator role.
   *                  // See https://tokbox.com/developer/guides/create-token/.
   *
   *  var session = OT.initSession(apiKey, sessionID);
   *  session.connect(token, function(error) {
   *    if (error) {
   *      console.log(error.message);
   *    } else {
   *      // This example assumes that a DOM element with the ID 'publisherElement' exists
   *      var publisherProperties = {width: 400, height:300, name:"Bob's stream"};
   *      publisher = OT.initPublisher('publisherElement', publisherProperties);
   *      session.publish(publisher);
   *    }
   *  });
   *  </pre>
   *
   *      <p>This example creates a Publisher object and adds its video to a DOM element
   *      with the ID <code>publisherElement</code> by calling the <code>OT.initPublisher()</code>
   *      method. It then publishes a stream to the session by calling
   *      the <code>publish()</code> method of the Session object.</p>
   *
   * @property {Boolean} accessAllowed Whether the user has granted access to the camera
   * and microphone. The Publisher object dispatches an <code>accessAllowed</code> event when
   * the user grants access. The Publisher object dispatches an <code>accessDenied</code> event
   * when the user denies access.
   * @property {Element} element The HTML DOM element containing the Publisher. (<i>Note:</i>
   * when you set the <code>insertDefaultUI</code> option to <code>false</code> in the call to
   * <a href="OT.html#initPublisher">OT.initPublisher</a>, the <code>element</code> property
   * is undefined.)
   * @property {String} id The DOM ID of the Publisher.
   * @property {Stream} stream The {@link Stream} object corresponding the stream of
   * the Publisher.
   * @property {Session} session The {@link Session} to which the Publisher belongs.
   *
   * @see <a href="OT.html#initPublisher">OT.initPublisher</a>
   * @see <a href="Session.html#publish">Session.publish()</a>
   *
   * @class Publisher
   * @augments EventDispatcher
   */
  var Publisher = function Publisher() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    // Check that the client meets the minimum requirements, if they don't the upgrade
    // flow will be triggered.
    if (!systemRequirements.check()) {
      systemRequirements.upgrade();
    }

    var widgetView = void 0,
        videoElementFacade = void 0,
        lastRequestedStreamId = void 0,
        webRTCStream = void 0,
        publishStartTime = void 0,
        microphone = void 0,
        state = void 0,
        rumorIceServers = void 0,
        connectivityAttemptPinger = void 0,
        attemptStartTime = void 0,
        audioDevices = void 0,
        videoDevices = void 0,
        selectedVideoInputDeviceId = void 0,
        selectedAudioInputDeviceId = void 0;

    var guid = uuid();
    var peerConnectionsAsync = {};
    var loaded = false;
    var isScreenSharing = options && (options.videoSource === 'screen' || options.videoSource === 'window' || options.videoSource === 'tab' || options.videoSource === 'browser' || options.videoSource === 'application');
    var previousAnalyticsStats = {};
    var self = this;
    var audioAcquisitionProblemDetected = false;

    // We whitelist property keys for logging purposes
    var validProperties = ['audioDeviceId', 'audioFallbackEnabled', 'audioSource', 'channels', 'classNames', 'constraints', 'disableAudioProcessing', 'enableRenegotiation', 'enableStereo', 'fitMode', 'frameRate', 'height', 'insertDefaultUI', 'insertMode', 'audioBitrate', 'maxResolution', 'minVideoBitrate', 'mirror', 'name', 'publishAudio', 'publishVideo', 'resolution', 'showControls', 'style', 'usePreviousDeviceSelection', 'videoDeviceId', 'videoDimensions', 'videoSource', 'width'];

    var properties = OTHelpers.defaults(options, {
      mirror: !isScreenSharing,
      publishAudio: true,
      publishVideo: true,
      showControls: true,
      fitMode: isScreenSharing ? 'contain' : 'cover',
      audioFallbackEnabled: !isScreenSharing,
      insertDefaultUI: true,
      enableRenegotiation: false,
      enableStereo: false,
      disableAudioProcessing: false
    });

    if (!properties.constraints) {
      var constraintInfo = generateConstraintInfo({
        isScreenSharing: isScreenSharing,

        audioSource: properties.audioSource,
        publishAudio: properties.publishAudio,

        videoSource: properties.videoSource,
        publishVideo: properties.publishVideo,
        resolution: properties.resolution,
        maxResolution: properties.maxResolution,
        frameRate: properties.frameRate,

        enableRenegotiation: properties.enableRenegotiation,
        disableAudioProcessing: properties.disableAudioProcessing,
        env: OTHelpers.env,

        usingOptionalMandatoryStyle: isScreenSharing || !(global.navigator.mediaDevices && global.navigator.mediaDevices.getUserMedia) ||

        // Chrome doesn't accept ideal constraints and advanced
        // constraints are ignored by Firefox and broken by adapter.js
        // so we revert to optional/mandatory style in Chrome, at
        // least until Chrome implements ideal constraints, which
        // could happen as early as Chrome 58.
        // See OPENTOK-32149, OPENTOK-32129 and OPENTOK-32655
        OTHelpers.env.name === 'Chrome'
      });

      assign(properties, constraintInfo);
    } else {
      logging.warn('You have passed your own constraints not using ours');
    }

    OTHelpers.eventing(this);

    if (!isScreenSharing) {
      var audioLevelRunner = new IntervalRunner(function () {
        if (videoElementFacade) {
          videoElementFacade.getAudioInputLevel().then(function (audioInputLevel) {
            global.requestAnimationFrame(function () {
              self.dispatchEvent(new Events.AudioLevelUpdatedEvent(audioInputLevel));
            });
          });
        }
      }, 60);

      this.on({
        'audioLevelUpdated:added': function audioLevelUpdatedAdded(count) {
          if (count === 1) {
            audioLevelRunner.start();
          }
        },
        'audioLevelUpdated:removed': function audioLevelUpdatedRemoved(count) {
          if (count === 0) {
            audioLevelRunner.stop();
          }
        }
      });
    }

    // / Private Methods
    var getAllPeerConnections = function getAllPeerConnections() {
      return Bluebird.all(Object.keys(peerConnectionsAsync).map(function (id) {
        return peerConnectionsAsync[id];
      }));
    };

    var logAnalyticsEvent = function logAnalyticsEvent(action, variation, payload, logOptions, throttle) {
      var stats = OTHelpers.extend({
        action: action,
        variation: variation,
        payload: payload,
        sessionId: self.session ? self.session.sessionId : null,
        connectionId: self.session && self.session.isConnected() ? self.session.connection.connectionId : null,
        partnerId: self.session ? self.session.apiKey : APIKEY.value,
        p2p: self.session && self.session.sessionInfo ? self.session.sessionInfo.p2pEnabled : null,
        messagingServer: self.session && self.session.sessionInfo ? self.session.sessionInfo.messagingServer : null,
        streamId: lastRequestedStreamId
      }, logOptions);

      if (variation === 'Failure') {
        stats = OTHelpers.extend(previousAnalyticsStats, stats);
      }
      previousAnalyticsStats = pick(stats, 'sessionId', 'connectionId', 'partnerId');

      analytics.logEvent(stats, throttle);
    };

    var logConnectivityEvent = function logConnectivityEvent(variation) {
      var payload = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var logOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      if (variation === 'Attempt' || !connectivityAttemptPinger) {
        attemptStartTime = new Date().getTime();
        connectivityAttemptPinger = new ConnectivityAttemptPinger({
          action: 'Publish',
          sessionId: self.session ? self.session.sessionId : null,
          connectionId: self.session && self.session.isConnected() ? self.session.connection.connectionId : null,
          partnerId: self.session ? self.session.apiKey : APIKEY.value,
          p2p: self.session && self.session.sessionInfo ? self.session.sessionInfo.p2pEnabled : null,
          messagingServer: self.session && self.session.sessionInfo ? self.session.sessionInfo.messagingServer : null,
          streamId: lastRequestedStreamId
        });
      }

      if (logOptions.failureReason !== 'Non-fatal') {
        if (variation === 'Failure') {
          // We don't want to log an invalid sequence in this case because it was a
          // non-fatal failure
          connectivityAttemptPinger.setVariation(variation);
        }

        if (variation === 'Failure' || variation === 'Success' || variation === 'Cancel') {
          OTHelpers.extend(logOptions, {
            attemptDuration: new Date().getTime() - attemptStartTime
          });
          OTHelpers.extend(payload, {
            videoInputDevices: videoDevices,
            audioInputDevices: audioDevices,
            videoInputDeviceCount: videoDevices ? videoDevices.length : undefined,
            audioInputDeviceCount: audioDevices ? audioDevices.length : undefined,
            selectedVideoInputDeviceId: selectedVideoInputDeviceId,
            selectedAudioInputDeviceId: selectedAudioInputDeviceId
          });
        }

        logAnalyticsEvent('Publish', variation, payload, logOptions);
      }
    };

    var logRepublish = function logRepublish(variation, payload) {
      logAnalyticsEvent('ICERestart', variation, payload);
    };

    var recordQOS = function recordQOS(_ref) {
      var remoteConnectionId = _ref.remoteConnectionId,
          parsedStats = _ref.parsedStats,
          simulcastEnabled = _ref.simulcastEnabled;

      var domElement = void 0;
      if (widgetView && widgetView.domElement) {
        domElement = widgetView.domElement;
      } else if (widgetView && widgetView.video() && widgetView.video().domElement()) {
        // If we're using insertDefaultUI=false then there is no container
        domElement = widgetView.video().domElement();
      }
      var QoSBlob = {
        widgetType: 'Publisher',
        sessionId: self.session ? self.session.sessionId : null,
        connectionId: self.session && self.session.isConnected() ? self.session.connection.connectionId : null,
        partnerId: self.session ? self.session.apiKey : APIKEY.value,
        streamId: lastRequestedStreamId,
        width: domElement ? Number(OTHelpers.width(domElement).replace('px', '')) : undefined,
        height: domElement ? Number(OTHelpers.height(domElement).replace('px', '')) : undefined,
        audioTrack: webRTCStream && webRTCStream.getAudioTracks().length > 0,
        hasAudio: properties.publishAudio,
        videoTrack: webRTCStream && webRTCStream.getVideoTracks().length > 0,
        hasVideo: properties.publishVideo,
        videoSource: isScreenSharing && options.videoSource || properties.constraints.video && 'Camera' || null,
        version: otProperties.version,
        mediaServerName: self.session ? self.session.sessionInfo.mediaServerName : null,
        apiServer: otProperties.apiURL,
        p2p: self.session ? self.session.sessionInfo.p2pEnabled : null,
        messagingServer: self.session ? self.session.sessionInfo.messagingServer : null,
        duration: publishStartTime ? Math.round((new Date().getTime() - publishStartTime.getTime()) / 1000) : 0,
        remoteConnectionId: remoteConnectionId,
        scalableVideo: simulcastEnabled
      };

      analytics.logQOS(OTHelpers.extend(QoSBlob, parsedStats));
      self.trigger('qos', parsedStats);
    };

    // Returns the video dimensions. Which could either be the ones that
    // the developer specific in the videoDimensions property, or just
    // whatever the video element reports.
    //
    // If all else fails then we'll just default to 640x480
    //
    var getVideoDimensions = function getVideoDimensions() {
      var streamWidth = void 0,
          streamHeight = void 0;

      // We set the streamWidth and streamHeight to be the minimum of the requested
      // resolution and the actual resolution.
      if (properties.videoDimensions) {
        streamWidth = Math.min(properties.videoDimensions.width, videoElementFacade && videoElementFacade.videoWidth() || 640);
        streamHeight = Math.min(properties.videoDimensions.height, videoElementFacade && videoElementFacade.videoHeight() || 480);
      } else {
        streamWidth = videoElementFacade && videoElementFacade.videoWidth() || 640;
        streamHeight = videoElementFacade && videoElementFacade.videoHeight() || 480;
      }

      return {
        width: streamWidth,
        height: streamHeight
      };
    };

    // / Private Events

    var stateChangeFailed = function stateChangeFailed(changeFailed) {
      logging.error('OT.Publisher State Change Failed: ', changeFailed.message);
      logging.debug(changeFailed);
    };

    var onLoaded = function onLoaded(facade) {
      if (state.isDestroyed()) {
        // The publisher was destroyed before loading finished
        videoElementFacade.destroy();
        return;
      }

      videoElementFacade = facade;

      logging.debug('OT.Publisher.onLoaded');

      state.set('MediaBound');

      // If we have a session and we haven't created the stream yet then
      // wait until that is complete before hiding the loading spinner
      widgetView.loading(self.session ? !self.stream : false);

      loaded = true;
    };

    var onLoadFailure = function onLoadFailure(plainError) {
      // eslint-disable-next-line no-param-reassign
      var err = otError(Errors.CONNECT_FAILED, plainError, ExceptionCodes.P2P_CONNECTION_FAILED);

      logConnectivityEvent('Failure', {}, {
        failureReason: 'PeerConnectionError',
        failureCode: err.code,
        failureMessage: err.message
      });

      state.set('Failed');

      // Note: The substring 'Publisher PeerConnection Error:' is part of our api contract for now.
      // https://tokbox.com/developer/guides/publish-stream/js/#troubleshooting
      // eslint-disable-next-line no-param-reassign
      err.message = 'OT.Publisher PeerConnection Error: ' + err.message;

      self.trigger('publishComplete', err);

      OTErrorClass.handleJsException(err.message, ExceptionCodes.P2P_CONNECTION_FAILED, {
        session: self.session,
        target: self
      });
    };

    // Clean up our LocalMediaStream
    var cleanupLocalStream = function cleanupLocalStream() {
      if (webRTCStream) {
        // Stop revokes our access cam and mic access for this instance
        // of localMediaStream.
        if (global.MediaStreamTrack && global.MediaStreamTrack.prototype.stop) {
          // Newer spec
          webRTCStream.getTracks().forEach(function (track) {
            track.stop();
          });
        } else {
          // Older spec
          webRTCStream.stop();
        }

        webRTCStream = null;
      }
    };

    var bindVideo = function bindVideo() {
      var videoContainerOptions = {
        muted: true,
        error: onVideoError
      };

      return Bluebird.promisify(function (callback) {
        return widgetView.bindVideo(webRTCStream, videoContainerOptions, callback);
      })().catch(function (err) {
        onLoadFailure(err);
        throw err;
      });
    };

    var onStreamAvailable = function onStreamAvailable(webOTStream) {
      logging.debug('OT.Publisher.onStreamAvailable');

      state.set('BindingMedia');

      cleanupLocalStream();
      webRTCStream = webOTStream;

      var findSelectedDeviceId = function findSelectedDeviceId(tracks, devices) {
        // Store the device labels to log later
        var selectedDeviceId = void 0;
        tracks.forEach(function (track) {
          if (track.hasOwnProperty('deviceId')) {
            // IE adds a deviceId property to the track
            selectedDeviceId = track.deviceId.toString();
          } else if (track.label && devices) {
            var selectedDevice = OTHelpers.find(devices, function (el) {
              return el.label === track.label;
            });
            if (selectedDevice) {
              selectedDeviceId = selectedDevice.deviceId;
            }
          }
        });
        return selectedDeviceId;
      };

      selectedVideoInputDeviceId = findSelectedDeviceId(webRTCStream.getVideoTracks(), videoDevices);
      selectedAudioInputDeviceId = findSelectedDeviceId(webRTCStream.getAudioTracks(), audioDevices);

      microphone = new Microphone(webRTCStream, !properties.publishAudio);
      self.publishVideo(properties.publishVideo && webRTCStream.getVideoTracks().length > 0);

      self.accessAllowed = true;
      self.dispatchEvent(new Events.Event(Events.Event.names.ACCESS_ALLOWED, false));
    };

    var onPublishingTimeout = function onPublishingTimeout(session) {
      logging.error('OT.Publisher.onPublishingTimeout');

      var errorName = void 0,
          errorMessage = void 0;
      if (audioAcquisitionProblemDetected) {
        errorName = Errors.CHROME_MICROPHONE_ACQUISITION_ERROR;
        errorMessage = 'Unable to publish because your browser failed to get access to your ' + 'microphone. You may need to fully quit and restart your browser to get it to work. ' + 'See https://bugs.chromium.org/p/webrtc/issues/detail?id=4799 for more details.';
      } else {
        errorName = Errors.TIMEOUT;
        errorMessage = 'Could not publish in a reasonable amount of time';
      }

      self.trigger('publishComplete', otError(errorName, new Error(errorMessage), ExceptionCodes.UNABLE_TO_PUBLISH));

      var logOptions = {
        failureReason: 'ICEWorkflow',
        failureCode: ExceptionCodes.UNABLE_TO_PUBLISH,
        failureMessage: 'OT.Publisher failed to publish in a reasonable amount of time (timeout)'
      };
      logConnectivityEvent('Failure', {}, logOptions);

      OTErrorClass.handleJsException(logOptions.failureReason, logOptions.failureCode, {
        session: self.session,
        target: self
      });

      if (session.isConnected() && self.streamId) {
        session._.streamDestroy(self.streamId);
      }

      // Disconnect immediately, rather than wait for the WebSocket to
      // reply to our destroyStream message.
      self.disconnect();

      self.session = null;

      // We're back to being a stand-alone publisher again.
      if (!state.isDestroyed()) {
        state.set('MediaBound');
      }

      if (connectivityAttemptPinger) {
        connectivityAttemptPinger.stop();
        connectivityAttemptPinger = null;
      }
    };

    var onStreamAvailableError = function onStreamAvailableError(plainError) {
      var names = Object.keys(Errors).map(function (shortName) {
        return Errors[shortName];
      });
      var error = otError(Object.keys(names).indexOf(plainError.name) > -1 ? plainError.name : Errors.MEDIA_ERR_ABORTED, plainError, ExceptionCodes.UNABLE_TO_PUBLISH);
      logging.error('OT.Publisher.onStreamAvailableError ' + error.name + ': ' + error.message);

      // eslint-disable-next-line no-param-reassign
      error.code = ExceptionCodes.UNABLE_TO_PUBLISH;

      state.set('Failed');
      self.trigger('publishComplete', error);

      if (widgetView) {
        widgetView.destroy();
      }

      var logOptions = {
        failureReason: 'GetUserMedia',
        failureCode: ExceptionCodes.UNABLE_TO_PUBLISH,
        failureMessage: 'OT.Publisher failed to access camera/mic: ' + error.message
      };
      logConnectivityEvent('Failure', {}, logOptions);

      OTErrorClass.handleJsException(logOptions.failureReason, logOptions.failureCode, {
        session: self.session,
        target: self
      });
    };

    var onScreenSharingError = function onScreenSharingError(errorParam) {
      var error = cloneDeep(errorParam);
      error.code = ExceptionCodes.UNABLE_TO_PUBLISH;

      if (error.name === Errors.USER_MEDIA_ACCESS_DENIED) {
        onAccessDenied(error);
        return;
      }

      logging.error('OT.Publisher.onScreenSharingError ' + error.message);
      state.set('Failed');

      error.message = 'Screensharing: ' + error.message;

      self.trigger('publishComplete', error);

      logConnectivityEvent('Failure', {}, {
        failureReason: 'ScreenSharing',
        failureMessage: error.message
      });

      if (widgetView) {
        widgetView.destroy();
      }
    };

    // The user has clicked the 'deny' button the the allow access dialog, or it's
    // set to always deny, or the access was denied due to HTTP restrictions;
    var onAccessDenied = function onAccessDenied(errorParam) {
      var error = cloneDeep(errorParam);

      if (OTHelpers.env.protocol !== 'https:') {
        if (isScreenSharing) {
          /*
           * in http:// the browser will deny permission without asking the
           * user. There is also no way to tell if it was denied by the
           * user, or prevented from the browser.
           */
          error.message += 'PermissionDeniedError Note: https:// is required for screen sharing.';
        } else if (OTHelpers.env.name === 'Chrome' && OTHelpers.env.hostName !== 'localhost') {
          error.message = 'Chrome requires HTTPS for camera and microphone access.';
        }
      }

      logging.error('OT.Publisher.onStreamAvailableError Permission Denied');

      state.set('Failed');

      // Note: The substring 'Publisher Access Denied:' is part of our api contract for now.
      // https://tokbox.com/developer/guides/publish-stream/js/#troubleshooting
      error.message = 'OT.Publisher Access Denied: Permission Denied: ' + error.message;
      error.code = ExceptionCodes.UNABLE_TO_PUBLISH;
      self.trigger('publishComplete', error);

      logConnectivityEvent('Cancel', { reason: 'AccessDenied' });

      self.dispatchEvent(new Events.Event(Events.Event.names.ACCESS_DENIED));

      if (widgetView) {
        widgetView.destroy();
      }
    };

    var onAccessDialogOpened = function onAccessDialogOpened() {
      logAnalyticsEvent('accessDialog', 'Opened');

      self.dispatchEvent(new Events.Event(Events.Event.names.ACCESS_DIALOG_OPENED, true));
    };

    var onAccessDialogClosed = function onAccessDialogClosed() {
      logAnalyticsEvent('accessDialog', 'Closed');

      self.dispatchEvent(new Events.Event(Events.Event.names.ACCESS_DIALOG_CLOSED, false));
    };

    var onVideoError = function onVideoError(plainErr) {
      // eslint-disable-next-line no-param-reassign
      var err = otError(Errors.MEDIA_ERR_DECODE, plainErr, ExceptionCodes.UNABLE_TO_PUBLISH);
      err.message = 'OT.Publisher while playing stream: ' + err.message;

      logging.error('OT.Publisher.onVideoError');
      logAnalyticsEvent('stream', null, { reason: err.message });

      // Check if attempting to publish *before* overwriting the state
      var isAttemptingToPublish = state.isAttemptingToPublish();
      state.set('Failed');

      if (isAttemptingToPublish) {
        self.trigger('publishComplete', err);
      } else {
        // FIXME: This emits a string instead of an error here for backwards compatibility despite
        // being undocumented. When possible we should remove access to this and other undocumented
        // events, and restore emitting actual errors here.
        self.trigger('error', err.message);
      }

      OTErrorClass.handleJsException(err.message, ExceptionCodes.UNABLE_TO_PUBLISH, {
        session: self.session,
        target: self
      });
    };

    var onPeerDisconnected = function onPeerDisconnected(peerConnection) {
      logging.debug('Subscriber has been disconnected from the Publisher\'s PeerConnection');

      self.cleanupSubscriber(peerConnection.remoteConnectionId);
    };

    var onPeerConnectionFailure = function onPeerConnectionFailure(code, reason, peerConnection, prefix) {
      if (prefix === 'ICEWorkflow' && self.session.sessionInfo.reconnection && loaded) {
        logging.debug('Ignoring peer connection failure due to possibility of reconnection.');
        return;
      }

      var remoteConnectionId = peerConnection && peerConnection.remoteConnectionId || '(not found)';

      var error = interpretPeerConnectionError(code, reason, prefix, remoteConnectionId, 'Publisher');

      var payload = {
        hasRelayCandidates: peerConnection.hasRelayCandidates()
      };

      var logOptions = {
        failureReason: prefix || 'PeerConnectionError',
        failureCode: error.code,
        failureMessage: error.message
      };

      if (state.isPublishing()) {
        // We're already publishing so this is a Non-fatal failure, must be p2p and one of our
        // peerconnections failed
        logOptions.reason = 'Non-fatal';
      } else {
        self.trigger('publishComplete', error);
      }

      logConnectivityEvent('Failure', payload, logOptions);

      OTErrorClass.handleJsException('OT.Publisher PeerConnection Error: ' + reason, error.code, {
        session: self.session,
        target: self
      });

      // We don't call cleanupSubscriber as it also logs a
      // disconnected analytics event, which we don't want in this
      // instance. The duplication is crufty though and should
      // be tidied up.

      delete peerConnectionsAsync[peerConnection.remoteConnectionId];
    };

    var onIceRestartSuccess = function onIceRestartSuccess(connectionId) {
      logRepublish('Success', { remoteConnectionId: connectionId });
    };

    var onIceRestartFailure = function onIceRestartFailure(connectionId) {
      logRepublish('Failure', {
        reason: 'ICEWorkflow',
        message: 'OT.Publisher PeerConnection Error: ' + 'The stream was unable to connect due to a network error.' + ' Make sure your connection isn\'t blocked by a firewall.',
        remoteConnectionId: connectionId
      });
    };

    // / Private Helpers

    // Assigns +stream+ to this publisher. The publisher listens
    // for a bunch of events on the stream so it can respond to
    // changes.
    var assignStream = function assignStream(stream) {
      self.stream = stream;
      self.stream.on('destroyed', self.disconnect, self);

      state.set('Publishing');
      widgetView.loading(!loaded);
      publishStartTime = new Date();

      self.trigger('publishComplete', null, self);

      self.dispatchEvent(new Events.StreamEvent('streamCreated', stream, null, false));

      logConnectivityEvent('Success');
    };

    /**
     * Provides the peer connection associatied to the given peerConnectionId.
     *
     * It there is no PC associated it creates a new one and stores it so that the next call returns
     * the same instance.
     *
     * @param remoteConnection
     * @param {string} peerConnectionId
     * @param {string} uri
     * @returns {Promise<Error, PublisherPeerConnection>}
     */
    var getConnectionForRemote = function getConnectionForRemote(remoteConnectionId, peerConnectionId, uri) {
      var peerConnection = peerConnectionsAsync[peerConnectionId];
      var startConnectingTime = OTHelpers.now();

      if (peerConnection) {
        return peerConnection;
      }

      logAnalyticsEvent('createPeerConnection', 'Attempt');

      // Calculate the number of streams to use. 1 for normal, >1 for Simulcast
      var capableSimulcastStreams = calculateCapableSimulcastStreams({
        browserName: OTHelpers.env.name,
        isScreenSharing: isScreenSharing,
        sessionInfo: self.session.sessionInfo,
        constraints: properties.constraints,
        videoDimensions: getVideoDimensions()
      });

      var maybeIceServersPromise = self.session._.getIceServers().catch(function (err) {
        if (err instanceof TypeError) {
          throw err; // Type errors are bad. Don't ignore those.
        }

        return undefined; // But otherwise, it's ok to not have ice servers from the session
      });

      peerConnectionsAsync[peerConnectionId] = maybeIceServersPromise.then(function (iceServers) {
        peerConnection = new PublisherPeerConnection({
          clientCandidates: self.session.sessionInfo.clientCandidates,
          iceServers: iceServers,
          remoteConnectionId: remoteConnectionId,
          socket: self.session._.getSocket(),
          webRTCStream: webRTCStream,
          channels: properties.channels,
          capableSimulcastStreams: capableSimulcastStreams,
          overrideSimulcastEnabled: options._enableSimulcast,
          subscriberUri: uri,
          logAnalyticsEvent: logAnalyticsEvent,
          offerOverrides: {
            enableStereo: properties.enableStereo,
            audioBitrate: properties.audioBitrate
          },
          // FIXME - Remove answerOverrides once b=AS is supported by Mantis
          answerOverrides: self.session.sessionInfo.p2pEnabled ? undefined : {
            audioBitrate: properties.audioBitrate
          }
        });

        peerConnection.on({
          connected: function connected() {
            var payload = {
              pcc: parseInt(OTHelpers.now() - startConnectingTime, 10),
              hasRelayCandidates: peerConnection.hasRelayCandidates()
            };
            logAnalyticsEvent('createPeerConnection', 'Success', payload);
          },

          disconnected: onPeerDisconnected,
          error: onPeerConnectionFailure,
          qos: function qos(_ref2) {
            var parsedStats = _ref2.parsedStats,
                simulcastEnabled = _ref2.simulcastEnabled;
            return recordQOS({ remoteConnectionId: remoteConnectionId, parsedStats: parsedStats, simulcastEnabled: simulcastEnabled });
          },
          iceRestartSuccess: onIceRestartSuccess.bind(undefined, peerConnectionId),
          iceRestartFailure: onIceRestartFailure.bind(undefined, peerConnectionId),
          audioAcquisitionProblem: function audioAcquisitionProblem() {
            // will be only triggered in Chrome
            audioAcquisitionProblemDetected = true;
            logAnalyticsEvent('audioAcquisitionProblem');
            self.trigger('audioAcquisitionProblem');
          }
        });

        return new Bluebird.Promise(function (resolve, reject) {
          peerConnection.init(rumorIceServers, function (err) {
            if (err) {
              return reject(err);
            }
            resolve(peerConnection);
            return undefined;
          });
        });
      });

      return peerConnectionsAsync[peerConnectionId];
    };

    var chromeMixin = createChromeMixin(self, {
      name: properties.name,
      publishAudio: properties.publishAudio,
      publishVideo: properties.publishVideo,
      audioSource: properties.audioSource,
      showControls: properties.showControls,
      isScreenSharing: isScreenSharing,
      logAnalyticsEvent: logAnalyticsEvent
    });

    var reset = function reset() {
      chromeMixin.reset();

      self.disconnect();

      microphone = null;

      if (videoElementFacade) {
        videoElementFacade.destroy();
        videoElementFacade = null;
      }

      cleanupLocalStream();

      if (widgetView) {
        widgetView.destroy();
        widgetView = null;
      }

      if (self.session) {
        self._.unpublishFromSession(self.session, 'reset');
      }

      self.id = null;
      self.stream = null;
      loaded = false;

      self.session = null;

      if (!state.isDestroyed()) {
        state.set('NotPublishing');
      }
    };

    var refreshAudioVideoUI = function refreshAudioVideoUI(hasVideo, hasAudio) {
      if (widgetView) {
        widgetView.audioOnly(!hasVideo);
        widgetView.showPoster(!hasVideo);
      }

      chromeMixin.setAudioOnly(!hasVideo && hasAudio);
    };

    this.publish = function (targetElement) {
      logging.debug('OT.Publisher: publish');

      if (state.isAttemptingToPublish() || state.isPublishing()) {
        reset();
      }
      state.set('GetUserMedia');

      if (properties.style) {
        self.setStyle(properties.style, null, true);
      }

      if (properties.name) {
        properties.name = properties.name.toString();
      }

      if (properties.hasOwnProperty('usePreviousDeviceSelection')) {
        if (OTHelpers.env.protocol !== 'https:') {
          logging.warn('Note: https:// is required for usePreviousDeviceSelection');
        }
        if (OTHelpers.env.name !== 'IE') {
          logging.warn('Note: usePreviousDeviceSelection only works in Internet Explorer');
        }
        if (OTPlugin.hasOwnProperty('settings')) {
          // If the usePreviousDeviceSelection property is passed in then use that
          OTPlugin.settings.usePreviousDeviceSelection = properties.usePreviousDeviceSelection;
        }
      }

      if (properties.minVideoBitrate !== undefined && (typeof properties.minVideoBitrate !== 'number' || isNaN(properties.minVideoBitrate) || properties.minVideoBitrate <= 0)) {
        logging.warn('Invalid minVideoBitrate passed to the Publisher. minVideoBitrate must ' + 'be a positive number');

        delete properties.minVideoBitrate;
      }

      if (properties.audioBitrate !== undefined && (typeof properties.audioBitrate !== 'number' || isNaN(properties.audioBitrate) || properties.audioBitrate < 6 * 1000 || properties.audioBitrate > 510 * 1000)) {
        logging.warn('Invalid audioBitrate passed to the Publisher. audioBitrate must ' + ('be a number between ' + 6 * 1000 + ' and ' + 510 * 1000 + ' bits per second'));

        delete properties.audioBitrate;
      }

      properties.classNames = 'OT_root OT_publisher';

      // Defer actually creating the publisher DOM nodes until we know
      // the DOM is actually loaded.
      EnvironmentLoader.onLoad(function () {
        widgetView = new WidgetView(targetElement, properties);
        self.id = widgetView.domId();
        self.element = widgetView.domElement;

        if (self.element) {
          // Only create the chrome if we have an element to insert it into
          // for insertDefautlUI:false we don't create the chrome
          chromeMixin.init(widgetView);
        }

        widgetView.on('videoDimensionsChanged', function (oldValue, newValue) {
          if (self.stream) {
            self.stream.setVideoDimensions(newValue.width, newValue.height);
          }
          self.dispatchEvent(new Events.VideoDimensionsChangedEvent(self, oldValue, newValue));
        });

        widgetView.on('mediaStopped', function (track) {
          var event = new Events.MediaStoppedEvent(self, track);

          self.dispatchEvent(event, function () {
            if (event.isDefaultPrevented()) {
              return;
            }

            if (track) {
              var kind = String(track.kind).toLowerCase();
              if (kind === 'audio' || kind === 'video') {
                self['publish' + capitalize(kind)](false);
              } else {
                logging.warn('Track with invalid kind has ended: ' + track.kind);
              }
              return;
            }

            if (self.session) {
              self._.unpublishFromSession(self.session, 'mediaStopped');
            } else {
              self.destroy('mediaStopped');
            }
          });
        });

        widgetView.on('videoElementCreated', function (element) {
          var event = new Events.VideoElementCreatedEvent(element);
          self.dispatchEvent(event);
        });

        function onConstraintsFound(constraints) {
          if (state.isDestroyed()) {
            return;
          }

          getUserMediaAndHandleEvents(constraints).then(function (stream) {
            onStreamAvailable(stream);
            return bindVideo();
          }).then(function (facade) {
            onLoaded(facade);

            if (!state.isDestroyed()) {
              self.trigger('initSuccess');
              self.trigger('loaded', self);
            }
          });
        }

        if (isScreenSharing) {
          screenSharing.getConstraints({
            onAccessDialogOpened: onAccessDialogOpened,
            onAccessDialogClosed: onAccessDialogClosed,
            videoSource: options.videoSource,
            constraints: properties.constraints
          }).then(function (constraints) {
            properties.constraints = constraints;
            onConstraintsFound(properties.constraints);
          }, onScreenSharingError);
        } else {
          deviceHelpers.shouldAskForDevices().then(function (devices) {
            if (!devices.video) {
              logging.warn('Setting video constraint to false, there are no video sources');
              properties.constraints.video = false;
            }
            if (!devices.audio) {
              logging.warn('Setting audio constraint to false, there are no audio sources');
              properties.constraints.audio = false;
            }
            videoDevices = devices.videoDevices;
            audioDevices = devices.audioDevices;
            onConstraintsFound(properties.constraints);
          });
        }
      });

      return self;
    };

    function addTrack(kind) {
      var tracks = webRTCStream.getTracks().filter(function (track) {
        return track.kind === kind;
      });

      return getAllPeerConnections().then(function (peerConnections) {
        return Bluebird.all(peerConnections.map(function (peerConnection) {
          return peerConnection.addTrack(tracks[0], webRTCStream);
        }));
      });
    }

    function removeTrack(kind) {
      return getAllPeerConnections().then(function (peerConnections) {
        return Bluebird.all(peerConnections.map(function (peerConnection) {
          var senders = peerConnection.getSenders().filter(function (sender) {
            return sender.track.kind === kind && sender.track.enabled;
          });

          if (senders.length) {
            return Bluebird.all(senders.map(function (sender) {
              return peerConnection.removeTrack(sender);
            }));
          }

          return undefined;
        }));
      });
    }

    /**
    * Starts publishing audio (if it is currently not being published)
    * when the <code>value</code> is <code>true</code>; stops publishing audio
    * (if it is currently being published) when the <code>value</code> is <code>false</code>.
    *
    * @param {Boolean} value Whether to start publishing audio (<code>true</code>)
    * or not (<code>false</code>).
    *
    * @see <a href="OT.html#initPublisher">OT.initPublisher()</a>
    * @see <a href="Stream.html#hasAudio">Stream.hasAudio</a>
    * @see StreamPropertyChangedEvent
    * @method #publishAudio
    * @memberOf Publisher
    */
    this.publishAudio = function (value, cbParam) {
      var callback = typeof cbParam === 'function' ? cbParam : function () {};

      properties.publishAudio = value;

      refreshAudioVideoUI(properties.publishVideo, properties.publishAudio);

      chromeMixin.setMuted(!value);

      if (!properties.enableRenegotiation && microphone) {
        microphone.muted(!value);
      }

      if (self.session && self.stream) {
        self.stream.setChannelActiveState('audio', value);
        if (properties.enableRenegotiation) {
          logAnalyticsEvent('publishAudioRenegotiation', 'Attempt', value);
          if (value && webRTCStream.getAudioTracks().length === 0) {
            properties.constraints.audio = properties.constraints.audio || true;

            var replaceTrackLogic = function replaceTrackLogic(peerConnection) {
              peerConnection.getSenders().forEach(peerConnection.removeTrack.bind(peerConnection));
              webRTCStream.getTracks().forEach(function (track) {
                peerConnection.addTrack(track, webRTCStream);
              });
            };

            getUserMediaAndHandleEvents(properties.constraints).then(setNewStream).then(bindVideo).then(replaceTracks.bind(null, replaceTrackLogic)).then(function () {
              logAnalyticsEvent('publishAudioRenegotiation', 'Success');
            }).then(callback.bind(undefined, null), function (err) {
              logAnalyticsEvent('publishAudioRenegotiation', 'Failure', err.message);
              callback(err);
            });
          } else {
            this.publishAudioTrack(value).then(function () {
              logAnalyticsEvent('publishAudioRenegotiation', 'Success');
            }).then(callback.bind(undefined, null), function (err) {
              logAnalyticsEvent('publishAudioRenegotiation', 'Failure');
              callback(err);
            });
          }
        } else {
          callback(null);
        }
      } else {
        // once publishComplete is complete, we can attempt to call publishAudio again as we will
        // now have access to the stream. this route also ensures the callback is called
        // appropriately
        // @todo this may cause issues with people toggling audio on and off under renegotiations
        // I have chosen to ignore it here, as the renegotiation code should handle this robustly
        // anyway!
        self.once('publishComplete', function () {
          self.publishAudio(properties.publishAudio, callback);
        });
      }

      return self;
    };

    this.publishAudioTrack = function (value) {
      return (value ? addTrack : removeTrack)('audio');
    };

    this.publishVideoTrack = function (value) {
      return (value ? addTrack : removeTrack)('video');
    };

    /**
    * Starts publishing video (if it is currently not being published)
    * when the <code>value</code> is <code>true</code>; stops publishing video
    * (if it is currently being published) when the <code>value</code> is <code>false</code>.
    *
    * @param {Boolean} value Whether to start publishing video (<code>true</code>)
    * or not (<code>false</code>).
    *
    * @see <a href="OT.html#initPublisher">OT.initPublisher()</a>
    * @see <a href="Stream.html#hasVideo">Stream.hasVideo</a>
    * @see StreamPropertyChangedEvent
    * @method #publishVideo
    * @memberOf Publisher
    */
    this.publishVideo = function (value, cbParam) {
      var callback = typeof cbParam === 'function' ? cbParam : function () {};

      var oldValue = properties.publishVideo;
      properties.publishVideo = value;

      if (self.session && self.stream && properties.publishVideo !== oldValue) {
        self.stream.setChannelActiveState('video', value);
      }

      refreshAudioVideoUI(properties.publishVideo, properties.publishAudio);

      if (properties.enableRenegotiation) {
        logAnalyticsEvent('publishVideoRenegotiation', 'Attempt', value);
        if (value && webRTCStream.getVideoTracks().length === 0) {
          properties.constraints.video = properties.constraints.video || true;

          var replaceTrackLogic = function replaceTrackLogic(peerConnection) {
            peerConnection.getSenders().forEach(peerConnection.removeTrack.bind(peerConnection));
            webRTCStream.getTracks().forEach(function (track) {
              peerConnection.addTrack(track, webRTCStream);
            });
          };

          getUserMediaAndHandleEvents(properties.constraints).then(setNewStream).then(bindVideo).then(replaceTracks.bind(null, replaceTrackLogic)).then(function () {
            logAnalyticsEvent('publishVideoRenegotiation', 'Success');
          }).then(callback.bind(undefined, null), function (err) {
            logAnalyticsEvent('publishVideoRenegotiation', 'Failure', err.message);
            callback(err);
          });
        } else {
          this.publishVideoTrack(value).then(function () {
            logAnalyticsEvent('publishVideoRenegotiation', 'Success');
          }).then(callback.bind(undefined, null), function (err) {
            logAnalyticsEvent('publishVideoRenegotiation', 'Failure', err.message);
            callback(err);
          });
        }
      } else {
        // We currently do this event if the value of publishVideo has not changed
        // This is because the state of the video tracks enabled flag may not match
        // the value of publishVideo at this point. This will be tidied up shortly.
        if (webRTCStream) {
          var videoTracks = webRTCStream.getVideoTracks();
          for (var i = 0, num = videoTracks.length; i < num; i += 1) {
            videoTracks[i].enabled = value;
          }
        }

        callback(null);
      }

      return self;
    };

    /**
    * Deletes the Publisher object and removes it from the HTML DOM.
    * <p>
    * The Publisher object dispatches a <code>destroyed</code> event when the DOM
    * element is removed.
    * </p>
    * @method #destroy
    * @memberOf Publisher
    * @return {Publisher} The Publisher.
    */
    this.destroy = function ( /* unused */reason, quiet) {
      if (state.isAttemptingToPublish()) {
        if (connectivityAttemptPinger) {
          connectivityAttemptPinger.stop();
          connectivityAttemptPinger = null;
        }
        if (self.session) {
          logConnectivityEvent('Cancel', { reason: 'destroy' });
        }
      }

      if (state.isDestroyed()) {
        return self;
      }
      state.set('Destroyed');

      reset();

      if (quiet !== true) {
        self.dispatchEvent(new Events.DestroyedEvent(Events.Event.names.PUBLISHER_DESTROYED, self, reason), self.off.bind(self));
      }

      return self;
    };

    /*
    * @methodOf Publisher
    * @private
    */
    this.disconnect = function () {
      // Close the connection to each of our subscribers
      Object.keys(peerConnectionsAsync).forEach(function (id) {
        self.cleanupSubscriber(id);
      });
    };

    this.cleanupSubscriber = function (peerConnectionId) {
      var peerConnectionAsync = peerConnectionsAsync[peerConnectionId];

      if (!peerConnectionAsync) {
        return;
      }

      delete peerConnectionsAsync[peerConnectionId];

      peerConnectionAsync.then(function (peerConnection) {
        peerConnection.destroy();
        logAnalyticsEvent('disconnect', 'PeerConnection', { subscriberConnection: peerConnectionId });
      });
    };

    this.processMessage = function (type, fromConnectionId, message) {
      var peerConnectionId = message.params && message.params.subscriber;

      // Symphony will not have a subscriberId so we'll fallback to using the connectionId for it.
      // Also fallback to the connectionId if it is equal to 'INVALID-STREAM' (See OPENTOK-30029).
      if (!peerConnectionId || peerConnectionId === 'INVALID-STREAM') {
        peerConnectionId = fromConnectionId;
      }

      logging.debug('OT.Publisher.processMessage: Received ' + type + ' from ' + peerConnectionId);
      logging.debug(message);

      switch (type) {
        case 'unsubscribe':
          self.cleanupSubscriber(peerConnectionId);
          break;

        default:
          getConnectionForRemote(fromConnectionId, peerConnectionId, message.uri).then(function (peerConnection) {
            peerConnection.processMessage(type, message);

            // Allow this runaway promise
            // http://bluebirdjs.com/docs/warning-explanations.html#warning-a-promise-was-created-in-a-handler-but-was-not-returned-from-it
            return null;
          }).catch(function (err) {
            logging.error('OT.Publisher failed to create a peerConnection', err);
          });
      }
    };

    /**
    * Returns the base-64-encoded string of PNG data representing the Publisher video.
    *
    *   <p>You can use the string as the value for a data URL scheme passed to the src parameter of
    *   an image file, as in the following:</p>
    *
    * <pre>
    *  var imgData = publisher.getImgData();
    *
    *  var img = document.createElement("img");
    *  img.setAttribute("src", "data:image/png;base64," + imgData);
    *  var imgWin = window.open("about:blank", "Screenshot");
    *  imgWin.document.write("&lt;body&gt;&lt;/body&gt;");
    *  imgWin.document.body.appendChild(img);
    * </pre>
    *
    * @method #getImgData
    * @memberOf Publisher
    * @return {String} The base-64 encoded string. Returns an empty string if there is no video.
    */

    this.getImgData = function () {
      if (!loaded) {
        logging.error('OT.Publisher.getImgData: Cannot getImgData before the Publisher is publishing.');

        return null;
      }

      return videoElementFacade.imgData();
    };

    var getUserMediaAndHandleEvents = function getUserMediaAndHandleEvents(constraints) {
      var request = getUserMedia(constraints);

      request.on('accessDialogOpened', onAccessDialogOpened);
      request.on('accessDialogClosed', onAccessDialogClosed);

      self.on('destroyed', function () {
        return request.release();
      });

      request.promise.catch(function (err) {
        if (err.name === Errors.USER_MEDIA_ACCESS_DENIED) {
          onAccessDenied(err);
        } else {
          onStreamAvailableError(err);
        }
      });

      return request.promise;
    };

    var setNewStream = function setNewStream(newStream) {
      cleanupLocalStream();
      webRTCStream = newStream;
      microphone = new Microphone(webRTCStream, !properties.publishAudio);
    };

    var defaultReplaceTrackLogic = function defaultReplaceTrackLogic(peerConnection) {
      peerConnection.getSenders().forEach(function (sender) {
        if (sender.track.kind === 'audio' && webRTCStream.getAudioTracks().length) {
          return sender.replaceTrack(webRTCStream.getAudioTracks()[0]);
        } else if (sender.track.kind === 'video' && webRTCStream.getVideoTracks().length) {
          return sender.replaceTrack(webRTCStream.getVideoTracks()[0]);
        }
        return undefined;
      });
    };

    var replaceTracks = function replaceTracks() {
      var replaceTrackLogic = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultReplaceTrackLogic;

      return getAllPeerConnections().then(function (peerConnections) {
        var tasks = [];
        peerConnections.map(replaceTrackLogic);
        return Bluebird.all(tasks);
      });
    };

    // API Compatibility layer for Flash Publisher, this could do with some tidyup.
    this._ = {
      publishToSession: function publishToSession(session) {
        // Add session property to Publisher
        self.session = session;

        var requestedStreamId = uuid();
        lastRequestedStreamId = requestedStreamId;
        self.streamId = requestedStreamId;

        logConnectivityEvent('Attempt', {
          dataChannels: properties.channels,
          properties: pick(properties, validProperties)
        });

        var loadedPromise = new Bluebird.Promise(function (resolve, reject) {
          if (loaded) {
            resolve();
            return;
          }

          self.once('initSuccess', resolve);
          self.once('destroyed', reject);
        });

        var completedPromise = new Bluebird.Promise(function (resolve, reject) {
          self.once('publishComplete', function (error) {
            if (error) {
              reject(error);
              return;
            }

            resolve();
          });
        });

        var processMessagingError = function processMessagingError(error) {
          // @todo Can we provide more specific errors for these codes? Are these still the only
          // codes that we expect?
          var expectedErrorCodes = [403, 404, 409];

          var publicError = expectedErrorCodes.indexOf(error.code) > -1 ? otError(Errors.STREAM_CREATE_FAILED, new Error('Failed to create stream in server model: ' + error.message), ExceptionCodes.UNABLE_TO_PUBLISH) : otError(Errors.UNEXPECTED_SERVER_RESPONSE, new Error('Unexpected server response: ' + error.message), ExceptionCodes.UNEXPECTED_SERVER_RESPONSE);

          logConnectivityEvent('Failure', {}, {
            failureReason: 'Publish',
            failureCode: publicError.code,
            failureMessage: publicError.message
          });
          if (state.isAttemptingToPublish()) {
            self.trigger('publishComplete', publicError);
          }

          OTErrorClass.handleJsException(error.message, publicError.code, {
            session: self.session,
            target: self
          });

          throw publicError;
        };

        var streamCreatedPromise = loadedPromise.then(function () {
          // Bail if this.session is gone, it means we were unpublished
          // before createStream could finish.
          if (!self.session) {
            return undefined;
          }

          // make sure we trigger an error if we are not getting any "ack" after a reasonable
          // amount of time
          var publishGuardingTo = setTimeout(function () {
            onPublishingTimeout(session);
          }, PUBLISH_MAX_DELAY);

          self.once('publishComplete', function () {
            clearTimeout(publishGuardingTo);
          });

          state.set('PublishingToSession');

          return videoElementFacade ? videoElementFacade.getLoadedResolution() : null;
        }).then(function (resolution) {
          var streamChannels = [];

          if (resolution) {
            streamChannels.push(new StreamChannel({
              id: 'video1',
              type: 'video',
              active: properties.publishVideo,
              orientation: VideoOrientation.ROTATED_NORMAL,
              frameRate: properties.frameRate,
              width: resolution.width,
              height: resolution.height,
              source: isScreenSharing ? 'screen' : 'camera',
              fitMode: properties.fitMode
            }));
          }

          if (!(properties.audioSource === null || properties.audioSource === false)) {
            streamChannels.push(new StreamChannel({
              id: 'audio1',
              type: 'audio',
              active: properties.publishAudio
            }));
          }

          return new Bluebird.Promise(function (resolve, reject) {
            session._.streamCreate(properties.name || '', requestedStreamId, properties.audioFallbackEnabled, streamChannels, properties.minVideoBitrate, function (messagingError, streamId, message) {
              if (messagingError) {
                reject(processMessagingError(messagingError));
                return;
              }

              resolve({ streamId: streamId, message: message });
            });
          });
        }).then(function (_ref3) {
          var streamId = _ref3.streamId,
              message = _ref3.message;

          if (streamId !== requestedStreamId) {
            throw new Error('streamId response does not match request');
          }

          self.streamId = streamId;
          rumorIceServers = parseIceServers(message);
        });

        return Bluebird.all([streamCreatedPromise, completedPromise]);
      },
      unpublishFromSession: function unpublishFromSession(session, reason) {
        if (!self.session || session.id !== self.session.id) {
          var selfSessionText = self.session && self.session.id || 'no session';

          logging.warn('The publisher ' + guid + ' is trying to unpublish from a session ' + session.id + ' it is not ' + ('attached to (it is attached to ' + selfSessionText + ')'));

          return self;
        }

        if (session.isConnected() && self.stream) {
          session._.streamDestroy(self.stream.id);
          self.stream.off('destroyed', self.disconnect, self);
        }

        // Disconnect immediately, rather than wait for the WebSocket to
        // reply to our destroyStream message.
        self.disconnect();
        if (state.isAttemptingToPublish()) {
          logConnectivityEvent('Cancel', { reason: 'unpublish' });
        }
        self.session = null;

        // We're back to being a stand-alone publisher again.
        if (!state.isDestroyed()) {
          state.set('MediaBound');
        }

        if (connectivityAttemptPinger) {
          connectivityAttemptPinger.stop();
          connectivityAttemptPinger = null;
        }
        logAnalyticsEvent('unpublish', 'Success', { sessionId: session.id });

        self._.streamDestroyed(reason);

        return self;
      },
      unpublishStreamFromSession: function unpublishStreamFromSession(stream, session, reason) {
        if (!lastRequestedStreamId || stream.id !== lastRequestedStreamId) {
          logging.warn('The publisher ' + guid + ' is trying to destroy a stream ' + stream.id + ' that is not attached to it (it has ' + (lastRequestedStreamId || 'no stream') + ' attached to it)');
          return self;
        }

        return self._.unpublishFromSession(session, reason);
      },
      streamDestroyed: function streamDestroyed(reason) {
        if (['reset'].indexOf(reason) < 0) {
          var event = new Events.StreamEvent('streamDestroyed', self.stream, reason, true);
          var defaultAction = function defaultAction() {
            if (!event.isDefaultPrevented()) {
              self.destroy();
            }
          };
          self.dispatchEvent(event, defaultAction);
        }
      },
      archivingStatus: function archivingStatus(status) {
        chromeMixin.setArchivingStatus(status);
        return status;
      },
      webRtcStream: function webRtcStream() {
        return webRTCStream;
      },
      switchTracks: function switchTracks() {
        return getUserMediaAndHandleEvents(properties.constraints).then(setNewStream).then(bindVideo).then(replaceTracks);
      },
      getDataChannel: function getDataChannel(label, getOptions, completion) {
        var pc = peerConnectionsAsync[Object.keys(peerConnectionsAsync)[0]];

        // @fixme this will fail if it's called before we have a PublisherPeerConnection.
        // I.e. before we have a subscriber.
        if (!pc) {
          completion(new OTHelpers.Error('Cannot create a DataChannel before there is a subscriber.'));
          return;
        }

        pc.then(function (peerConnection) {
          peerConnection.getDataChannel(label, getOptions, completion);
        });
      },
      iceRestart: function iceRestart(force) {
        getAllPeerConnections().then(function (peerConnections) {
          peerConnections.forEach(function (peerConnection) {
            var remoteConnectionId = peerConnection.remoteConnectionId;

            if (force || !peerConnection.iceConnectionStateIsConnected()) {
              logRepublish('Attempt', { remoteConnectionId: remoteConnectionId });
              peerConnection.iceRestart();
            } else {
              logging.debug('Publisher: Skipping ice restart for ' + remoteConnectionId + ', we are connected.');
            }
          });
        });
      },
      getState: function getState() {
        return state;
      },


      demoOnlyCycleVideo: function () {
        var videoIndex = 0;

        return function () {
          videoIndex += 1;

          return Bluebird.resolve().then(function () {
            return global.navigator.mediaDevices.enumerateDevices();
          }).then(function (devices) {
            var vidDevices = devices.filter(function (dev) {
              return dev.kind === 'videoinput';
            });
            var newVideoDevice = vidDevices[videoIndex % vidDevices.length];

            return global.navigator.mediaDevices.getUserMedia({
              audio: false,
              video: { deviceId: { exact: newVideoDevice.deviceId } }
            });
          }).then(function (newVideoStream) {
            var oldTrack = webRTCStream.getVideoTracks()[0];
            var newTrack = newVideoStream.getVideoTracks()[0];

            return getAllPeerConnections().then(function (pcs) {
              return Bluebird.all(pcs.map(function (pc) {
                return pc._demoOnlyFindAndReplaceTrack(oldTrack, newTrack);
              }));
            }).then(function () {
              webRTCStream.addTrack(newTrack);
              webRTCStream.removeTrack(oldTrack);

              if (OTHelpers.env.name === 'Firefox') {
                // Local video freezes on old stream without this for some reason
                Array.from(document.querySelectorAll('video')).forEach(function (vid) {
                  if (vid.srcObject === webRTCStream) {
                    vid.srcObject = vid.srcObject; // eslint-disable-line no-param-reassign
                  }
                });
              }
            });
          });
        };
      }()
    };

    this.detectDevices = function () {
      logging.warn('Publisher.detectDevices() is not implemented.');
    };

    this.detectMicActivity = function () {
      logging.warn('Publisher.detectMicActivity() is not implemented.');
    };

    this.getEchoCancellationMode = function () {
      logging.warn('Publisher.getEchoCancellationMode() is not implemented.');
      return 'fullDuplex';
    };

    this.setMicrophoneGain = function () {
      logging.warn('Publisher.setMicrophoneGain() is not implemented.');
    };

    this.getMicrophoneGain = function () {
      logging.warn('Publisher.getMicrophoneGain() is not implemented.');
      return 0.5;
    };

    this.setCamera = function () {
      logging.warn('Publisher.setCamera() is not implemented.');
    };

    this.setMicrophone = function () {
      logging.warn('Publisher.setMicrophone() is not implemented.');
    };

    // Platform methods:

    this.guid = function () {
      return guid;
    };

    this.videoElement = function () {
      return videoElementFacade.domElement();
    };

    this.setStream = assignStream;

    this.isWebRTC = true;

    this.isLoading = function () {
      return widgetView && widgetView.loading();
    };

    /**
    * Returns the width, in pixels, of the Publisher video. This may differ from the
    * <code>resolution</code> property passed in as the <code>properties</code> property
    * the options passed into the <code>OT.initPublisher()</code> method, if the browser
    * does not support the requested resolution.
    *
    * @method #videoWidth
    * @memberOf Publisher
    * @return {Number} the width, in pixels, of the Publisher video.
    */
    this.videoWidth = function () {
      return videoElementFacade && videoElementFacade.videoWidth();
    };

    /**
    * Returns the height, in pixels, of the Publisher video. This may differ from the
    * <code>resolution</code> property passed in as the <code>properties</code> property
    * the options passed into the <code>OT.initPublisher()</code> method, if the browser
    * does not support the requested resolution.
    *
    * @method #videoHeight
    * @memberOf Publisher
    * @return {Number} the height, in pixels, of the Publisher video.
    */
    this.videoHeight = function () {
      return videoElementFacade && videoElementFacade.videoHeight();
    };

    // Make read-only: element, guid, _.webRtcStream

    state = new PublishingState(stateChangeFailed);

    this.accessAllowed = false;

    /**
    * Dispatched when the user has clicked the Allow button, granting the
    * app access to the camera and microphone. The Publisher object has an
    * <code>accessAllowed</code> property which indicates whether the user
    * has granted access to the camera and microphone.
    * @see Event
    * @name accessAllowed
    * @event
    * @memberof Publisher
    */

    /**
    * Dispatched when the user has clicked the Deny button, preventing the
    * app from having access to the camera and microphone.
    * @see Event
    * @name accessDenied
    * @event
    * @memberof Publisher
    */

    /**
    * Dispatched when the Allow/Deny dialog box is opened. (This is the dialog box in which
    * the user can grant the app access to the camera and microphone.)
    * @see Event
    * @name accessDialogOpened
    * @event
    * @memberof Publisher
    */

    /**
    * Dispatched when the Allow/Deny box is closed. (This is the dialog box in which the
    * user can grant the app access to the camera and microphone.)
    * @see Event
    * @name accessDialogClosed
    * @event
    * @memberof Publisher
    */

    /**
    * Dispatched periodically to indicate the publisher's audio level. The event is dispatched
    * up to 60 times per second, depending on the browser. The <code>audioLevel</code> property
    * of the event is audio level, from 0 to 1.0. See {@link AudioLevelUpdatedEvent} for more
    * information.
    * <p>
    * The following example adjusts the value of a meter element that shows volume of the
    * publisher. Note that the audio level is adjusted logarithmically and a moving average
    * is applied:
    * <p>
    * <pre>
    * var movingAvg = null;
    * publisher.on('audioLevelUpdated', function(event) {
    *   if (movingAvg === null || movingAvg &lt;= event.audioLevel) {
    *     movingAvg = event.audioLevel;
    *   } else {
    *     movingAvg = 0.7 * movingAvg + 0.3 * event.audioLevel;
    *   }
    *
    *   // 1.5 scaling to map the -30 - 0 dBm range to [0,1]
    *   var logLevel = (Math.log(movingAvg) / Math.LN10) / 1.5 + 1;
    *   logLevel = Math.min(Math.max(logLevel, 0), 1);
    *   document.getElementById('publisherMeter').value = logLevel;
    * });
    * </pre>
    * <p>This example shows the algorithm used by the default audio level indicator displayed
    * in an audio-only Publisher.
    *
    * @name audioLevelUpdated
    * @event
    * @memberof Publisher
    * @see AudioLevelUpdatedEvent
    */

    /**
     * The publisher has started streaming to the session.
     * @name streamCreated
     * @event
     * @memberof Publisher
     * @see StreamEvent
     * @see <a href="Session.html#publish">Session.publish()</a>
     */

    /**
     * The publisher has stopped streaming to the session. The default behavior is that
     * the Publisher object is removed from the HTML DOM. The Publisher object dispatches a
     * <code>destroyed</code> event when the element is removed from the HTML DOM. If you call the
     * <code>preventDefault()</code> method of the event object in the event listener, the default
     * behavior is prevented, and you can, optionally, retain the Publisher for reuse or clean it up
     * using your own code.
     * @name streamDestroyed
     * @event
     * @memberof Publisher
     * @see StreamEvent
     */

    /**
    * Dispatched when the Publisher element is removed from the HTML DOM. When this event
    * is dispatched, you may choose to adjust or remove HTML DOM elements related to the publisher.
    * @name destroyed
    * @event
    * @memberof Publisher
    */

    /**
    * Dispatched when the video dimensions of the video change. This can only occur in when the
    * <code>stream.videoType</code> property is set to <code>"screen"</code> (for a screen-sharing
    * video stream), when the user resizes the window being captured. This event object has a
    * <code>newValue</code> property and an <code>oldValue</code> property, representing the new and
    * old dimensions of the video. Each of these has a <code>height</code> property and a
    * <code>width</code> property, representing the height and width, in pixels.
    * @name videoDimensionsChanged
    * @event
    * @memberof Publisher
    * @see VideoDimensionsChangedEvent
    */

    /**
    * Dispatched when the Publisher's video element is created. Add a listener for this event when
    * you set the <code>insertDefaultUI</code> option to <code>false</code> in the call to the
    * <a href="OT.html#initPublisher">OT.initPublisher()</a> method. The <code>element</code>
    * property of the event object is a reference to the Publisher's <code>video</code> element
    * (or in Internet Explorer the <code>object</code> element containing the video). Add it to
    * the HTML DOM to display the video. When you set the <code>insertDefaultUI</code> option to
    * <code>false</code>, the <code>video</code> (or <code>object</code>) element is not
    * automatically inserted into the DOM.
    * <p>
    * Add a listener for this event only if you have set the <code>insertDefaultUI</code> option to
    * <code>false</code>. If you have not set <code>insertDefaultUI</code> option to
    * <code>false</code>, do not move the <code>video</code> (or <code>object</code>) element in
    * in the HTML DOM. Doing so causes the Publisher object to be destroyed.
    *
    * @name videoElementCreated
    * @event
    * @memberof Publisher
    * @see VideoElementCreatedEvent
    */

    /**
     * The user publishing the stream has stopped sharing one or all media
     * types (video, audio and/or screen).
     * @name mediaStopped
     * @event
     * @memberof Publisher
     * @see MediaStoppedEvent
     */
  };

  return Publisher;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../common-js-helpers/OTHelpers.js":217,"../../helpers/connectivity_attempt_pinger.js":245,"../../helpers/device_helpers.js":251,"../../helpers/get_user_media.js":257,"../../helpers/otError.js":271,"../../helpers/otProperties.js":272,"../../helpers/video_orientation.js":284,"../../helpers/widget_view.js":286,"../../otplugin/otplugin.js":390,"../Errors.js":288,"../analytics.js":289,"../api_key.js":291,"../environment_loader.js":305,"../events.js":306,"../exception_codes.js":307,"../interpretPeerConnectionError.js":310,"../interval_runner.js":311,"../logging.js":312,"../messaging/raptor/parse_ice_servers.js":318,"../ot_error_class.js":334,"../peer_connection/publisher_peer_connection.js":344,"../screensharing/screen_sharing.js":366,"../stream_channel.js":373,"../system_requirements.js":380,"./calculateCapableSimulcastStreams.js":352,"./createChromeMixin.js":353,"./generateConstraintInfo.js":354,"./max_delay.js":357,"./microphone.js":358,"./state.js":360,"bluebird":2,"lodash/assign":142,"lodash/capitalize":144,"lodash/cloneDeep":147,"lodash/pick":175,"uuid":200}],356:[function(require,module,exports){
'use strict';

// @todo enable the following disabled rules see OPENTOK-31136 for more info
/* eslint-disable no-param-reassign, global-require, max-len,  prefer-rest-params */
/* eslint-disable no-use-before-define */

module.exports = function initPublisherFactory() {
  var deps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var Errors = deps.Errors || require('../Errors.js');
  var ExceptionCodes = deps.ExceptionCodes || require('../exception_codes.js');
  var logging = deps.logging || require('../logging.js');
  var otError = deps.otError || require('../../helpers/otError.js')();
  var OTHelpers = deps.OTHelpers || require('../../common-js-helpers/OTHelpers.js');
  var Publisher = deps.Publisher || require('./index.js')();
  var sessionObjects = deps.sessionObjects || require('../session/objects.js');

  /**
  * <p class="mSummary">
  *   Initializes and returns a Publisher object. You can then pass this Publisher
  *   object to <code>Session.publish()</code> to publish a stream to a session.
  * </p>
  * <p>
  *   <i>Note:</i> If you intend to reuse a Publisher object created using
  *   <code>OT.initPublisher()</code> to publish to different sessions sequentially,
  *   call either <code>Session.disconnect()</code> or <code>Session.unpublish()</code>.
  *   Do not call both. Then call the <code>preventDefault()</code> method of the
  *   <code>streamDestroyed</code> or <code>sessionDisconnected</code> event object to prevent the
  *   Publisher object from being removed from the page.
  * </p>
  *
  * @param {Object} targetElement (Optional) The DOM element or the <code>id</code> attribute of the
  * existing DOM element used to determine the location of the Publisher video in the HTML DOM. See
  * the <code>insertMode</code> property of the <code>properties</code> parameter. If you do not
  * specify a <code>targetElement</code>, the application appends a new DOM element to the HTML
  * <code>body</code>.
  *
  * <p>
  *       The application throws an error if an element with an ID set to the
  *       <code>targetElement</code> value does not exist in the HTML DOM.
  * </p>
  *
  * @param {Object} properties (Optional) This object contains the following properties (each of which
  * are optional):
  * </p>
  * <ul>
  * <li>
  *   <strong>audioBitrate</strong> (Number) &#151; The desired bitrate for the published audio,
  *   in bits per second. The supported range of values is 6,000 - 510,000. (Invalid values are
  *   ignored.) Set this value to enable high-quality audio (or to reduce bandwidth usage with
  *   lower-quality audio).
  *   <p>
  *   The following are recommended settings:
  *   <ul>
  *     <li>8,000 - 12,000 for narrowband (NB) speech</li>
  *     <li>16,000 - 20,000 for wideband (WB) speech</li>
  *     <li>28,000 - 40,000 for full-band (FB) speech</li>
  *     <li>48,000 - 64,000 for full-band (FB) music</li>
  *   </ul>
  *   </p>
  *   <p>
  *   The default value is 40,000.
  *   </p>
  *   <p>
  *     Currently, this setting is not supported in streams published in Firefox.
  *   </p>
  * </li>
  * <li>
  *   <strong>audioFallbackEnabled</strong> (Boolean) &#151; Whether the stream will use the
  *   audio-fallback feature (<code>true</code>) or not (<code>false</code>). The audio-fallback
  *   feature is available in sessions that use the OpenTok Media Router. With the audio-fallback
  *   feature enabled (the default), when the server determines that a stream's quality has degraded
  *   significantly for a specific subscriber, it disables the video in that subscriber in order to
  *   preserve audio quality. For streams that use a camera as a video source, the default setting is
  *   <code>true</code> (the audio-fallback feature is enabled). The default setting is
  *   <code>false</code> (the audio-fallback feature is disabled) for screen-sharing streams, which
  *   have the <code>videoSource</code> property set to <code>"application"</code>,
  *   <code>"screen"</code>, or <code>"window"</code> in the <code>OT.initPublisher()</code>
  *   options. For more information, see the Subscriber
  *   <a href="Subscriber.html#event:videoDisabled">videoDisabled</a> event and
  *   <a href="http://tokbox.com/opentok/tutorials/create-session/#media-mode">the OpenTok Media
  *   Router and media modes</a>.
  * </li>
  * <li>
  *   <strong>audioSource</strong> (String) &#151; The ID of the audio input device (such as a
  *    microphone) to be used by the publisher. You can obtain a list of available devices, including
  *    audio input devices, by calling the <a href="#getDevices">OT.getDevices()</a> method. Each
  *    device listed by the method has a unique device ID. If you pass in a device ID that does not
  *    match an existing audio input device, the call to <code>OT.initPublisher()</code> fails with an
  *    error (error code 1500, "Unable to Publish") passed to the completion handler function.
  *    <p>
  *    If you set this property to <code>null</code> or <code>false</code>, the browser does not
  *    request access to the microphone, and no audio is published.
  *    </p>
  * </li>
  * <li>
  *   <strong>disableAudioProcessing</strong> (Boolean) &#151; Whether to disable echo cancellation,
  *   automatic gain control, and noise suppression for the pubished audio. You may want to set
  *   this to <code>true</code> when publishing high-quality audio (by setting the
  *   <code>audioBitrate</code> property of the <code>OT.initPublisher()</code> options). The
  *   default value is <code>false</code>.
  * </li>
  * <li>
  *   <strong>fitMode</strong> (String) &#151; Determines how the video is displayed if the its
  *     dimensions do not match those of the DOM element. You can set this property to one of the
  *     following values:
  *     <p>
  *     <ul>
  *       <li>
  *         <code>"cover"</code> &mdash; The video is cropped if its dimensions do not match those of
  *         the DOM element. This is the default setting for videos publishing a camera feed.
  *       </li>
  *       <li>
  *         <code>"contain"</code> &mdash; The video is letterboxed if its dimensions do not match
  *         those of the DOM element. This is the default setting for screen-sharing videos.
  *       </li>
  *     </ul>
  * </li>
  * <li>
  *   <strong>frameRate</strong> (Number) &#151; The desired frame rate, in frames per second,
  *   of the video. Valid values are 30, 15, 7, and 1. The published stream will use the closest
  *   value supported on the publishing client. The frame rate can differ slightly from the value
  *   you set, depending on the browser of the client. And the video will only use the desired
  *   frame rate if the client configuration supports it.
  *   <br><br><p>If the publisher specifies a frame rate, the actual frame rate of the video stream
  *   is set as the <code>frameRate</code> property of the Stream object, though the actual frame rate
  *   will vary based on changing network and system conditions. If the developer does not specify a
  *   frame rate, this property is undefined.
  *   <p>
  *   For sessions that use the OpenTok Media Router (sessions with
  *   the <a href="http://tokbox.com/opentok/tutorials/create-session/#media-mode">media mode</a>
  *   set to routed, lowering the frame rate proportionally reduces the maximum bandwidth the stream
  *   uses. However, in sessions with the media mode set to relayed, lowering the frame rate does not
  *   reduce the stream's bandwidth.
  *   </p>
  *   <p>
  *   You can also restrict the frame rate of a Subscriber's video stream. To restrict the frame rate
  *   a Subscriber, call the <code>restrictFrameRate()</code> method of the subscriber, passing in
  *   <code>true</code>.
  *   (See <a href="Subscriber.html#restrictFrameRate">Subscriber.restrictFrameRate()</a>.)
  *   </p>
  * </li>
  * <li>
  *   <strong>height</strong> (Number) &#151; The desired initial height of the displayed Publisher
  *   video in the HTML page (default: 198 pixels). You can specify the number of pixels as either
  *   a number (such as 300) or a string ending in "px" (such as "300px"). Or you can specify a
  *   percentage of the size of the parent element, with a string ending in "%" (such as "100%").
  *   <i>Note:</i> To resize the publisher video, adjust the CSS of the publisher's DOM element
  *   (the <code>element</code> property of the Publisher object) or (if the height is specified as
  *   a percentage) its parent DOM element (see
  *   <a href="https://tokbox.com/developer/guides/customize-ui/js/#video_resize_reposition">Resizing
  *   or repositioning a video</a>).
  * </li>
  * <li>
  *   <strong>insertDefaultUI</strong> (Boolean) &#151; Whether to use the default OpenTok UI
  *   (<code>true</code>, the default) or not (<code>false</code>). The default UI element contains
  *   user interface controls, a video loading indicator, and automatic video cropping or
  *   letterboxing, in addition to the video. (If you leave <code>insertDefaultUI</code> set to
  *   <code>true</code>, you can control individual UI settings using the <code>fitMode</code>,
  *   <code>showControls</code>, and <code>style</code> options.)
  *   <p>
  *   If you set this option to <code>false</code>, OpenTok.js does not insert a default UI element
  *   in the HTML DOM, and the <code>element</code> property of the Publisher object is undefined.
  *   Instead, the Publisher object dispatches a
  *   <a href="Publisher.html#event:videoElementCreated">videoElementCreated</a> event when
  *   the <code>video</code> element (or in Internet Explorer the <code>object</code> element
  *   containing the video) is created. The <code>element</code> property of the event object is a
  *   reference to the Publisher's <code>video</code> (or <code>object</code>) element. Add it to
  *   the HTML DOM to display the video.
  *   <p>
  *   Set this option to <code>false</code> if you want to move the Publisher's <code>video</code>
  *   (or <code>object</code>) element in the HTML DOM.
  *   <p>
  *   If you set this to <code>false</code>, do not set the <code>targetElement</code> parameter.
  *   (This results in an error passed into to the <code>OT.initPublisher()</code> callback
  *   function.) To add the video to the HTML DOM, add an event listener for the
  *   <code>videoElementCreated</code> event, and then add the <code>element</code> property of
  *   the event object into the HTML DOM.
  * </li>
  * <li>
  *   <strong>insertMode</strong> (String) &#151; Specifies how the Publisher object will be
  *   inserted in the HTML DOM. See the <code>targetElement</code> parameter. This string can
  *   have the following values:
  *   <p>
  *   <ul>
  *     <li><code>"replace"</code> &#151; The Publisher object replaces contents of the
  *       targetElement. This is the default.</li>
  *     <li><code>"after"</code> &#151; The Publisher object is a new element inserted after
  *       the targetElement in the HTML DOM. (Both the Publisher and targetElement have the
  *       same parent element.)</li>
  *     <li><code>"before"</code> &#151; The Publisher object is a new element inserted before
  *       the targetElement in the HTML DOM. (Both the Publisher and targetElement have the same
  *       parent element.)</li>
  *     <li><code>"append"</code> &#151; The Publisher object is a new element added as a child
  *       of the targetElement. If there are other child elements, the Publisher is appended as
  *       the last child element of the targetElement.</li>
  *   </ul></p>
  *   <p> Do not move the publisher element or its parent elements in the DOM
  *   heirarchy. Use CSS to resize or reposition the publisher video's element
  *   (the <code>element</code> property of the Publisher object) or its parent element (see
  *   <a href="https://tokbox.com/developer/guides/customize-ui/js/#video_resize_reposition">Resizing
  *   or repositioning a video</a>.</p>
  * </li>
  * <li>
  *   <strong>maxResolution</strong> (Object) &#151; Sets the maximum resolution to stream.
  *   This setting only applies to when the <code>videoSource</code> property is set to
  *   <code>"application"</code>, <code>"screen"</code>, or <code>"window"</code>
  *   (when the publisher is screen-sharing). The resolution of the
  *   stream will match the captured screen region unless the region is greater than the
  *   <code>maxResolution</code> setting. Set this to an object that has two properties:
  *   <code>width</code> and <code>height</code> (both numbers). The maximum value for each of
  *   the <code>width</code> and <code>height</code> properties is 1920, and the minimum value
  *   is 10.
  * </li>
  * <li>
  *   <strong>mirror</strong> (Boolean) &#151; Whether the publisher's video image
  *   is mirrored in the publisher's page. The default value is <code>true</code>
  *   (the video image is mirrored), except for a screen-sharing video (when the
  *   <code>videoSource</code> property is set to <code>"application"</code>,
  *   <code>"screen"</code>, or <code>"window"</code>
  *   (in which case the default is <code>false</code>). This property
  *   does not affect the display on subscribers' views of the video.
  * </li>
  * <li>
  *   <strong>name</strong> (String) &#151; The name for this stream. The name appears at
  *   the bottom of Subscriber videos. The default value is "" (an empty string). Setting
  *   this to a string longer than 1000 characters results in an runtime exception.
  * </li>
  * <li>
  *   <strong>publishAudio</strong> (Boolean) &#151; Whether to initially publish audio
  *   for the stream (default: <code>true</code>). This setting applies when you pass
  *   the Publisher object in a call to the <code>Session.publish()</code> method.
  * </li>
  * <li>
  *   <strong>publishVideo</strong> (Boolean) &#151; Whether to initially publish video
  *   for the stream (default: <code>true</code>). This setting applies when you pass
  *   the Publisher object in a call to the <code>Session.publish()</code> method.
  * </li>
  * <li>
  *   <strong>resolution</strong> (String) &#151; The desired resolution of the video. The format
  *   of the string is <code>"widthxheight"</code>, where the width and height are represented in
  *   pixels. Valid values are <code>"1280x720"</code>, <code>"640x480"</code>, and
  *   <code>"320x240"</code>. The published video will only use the desired resolution if the
  *   client configuration supports it. Some browsers and clients do not support each of these
  *   resolution settings.
  *   <br><br><p>
  *   The requested resolution of a video stream is set as the <code>videoDimensions.width</code> and
  *   <code>videoDimensions.height</code> properties of the Stream object.
  *   </p>
  *   <p>
  *   The default resolution for a stream (if you do not specify a resolution) is 640x480 pixels.
  *   If the client system cannot support the resolution you requested, the stream will use the
  *   next largest setting supported.
  *   </p>
  *   <p>
  *   The actual resolution used by the Publisher is returned by the <code>videoHeight()</code> and
  *   <code>videoWidth()</code> methods of the Publisher object. The actual resolution of a
  *   Subscriber video stream is returned by the <code>videoHeight()</code> and
  *   <code>videoWidth()</code> properties of the Subscriber object. These may differ from the values
  *   of the <code>resolution</code> property passed in as the <code>properties</code> property of the
  *   <code>OT.initPublisher()</code> method, if the browser does not support the requested
  *   resolution.
  *   </p>
  * </li>
  * <li>
  *   <strong>showControls</strong> (Boolean) &#151; Whether to display the built-in user interface
  *   controls (default: <code>true</code>) for the Publisher. These controls include the name
  *   display, the audio level indicator, and the microphone control button. You can turn off all user
  *   interface controls by setting this property to <code>false</code>. You can control the display
  *   of individual user interface controls by leaving this property set to <code>true</code> (the
  *   default) and setting individual properties of the <code>style</code> property.
  * </li>
  * <li>
  *   <strong>style</strong> (Object) &#151; An object containing properties that define the initial
  *   appearance of user interface controls of the Publisher. The <code>style</code> object includes
  *   the following properties:
  *     <ul>
  *       <li><code>audioLevelDisplayMode</code> (String) &mdash; How to display the audio level
  *       indicator. Possible values are: <code>"auto"</code> (the indicator is displayed when the
  *       video is disabled), <code>"off"</code> (the indicator is not displayed), and
  *       <code>"on"</code> (the indicator is always displayed).</li>
  *
  *       <li><code>archiveStatusDisplayMode</code> (String) &mdash; How to display the archive status
  *       indicator. Possible values are: <code>"auto"</code> (the indicator is displayed when the
  *       session is being recorded), <code>"off"</code> (the indicator is not displayed). If you
  *       disable the archive status display indicator, you can display your own user interface
  *       notifications based on the <code>archiveStarted</code> and <code>archiveStopped</code>
  *       events dispatched by the Session object.</li>
  *
  *       <li><code>backgroundImageURI</code> (String) &mdash; A URI for an image to display as
  *       the background image when a video is not displayed. (A video may not be displayed if
  *       you call <code>publishVideo(false)</code> on the Publisher object). You can pass an http
  *       or https URI to a PNG, JPEG, or non-animated GIF file location. You can also use the
  *       <code>data</code> URI scheme (instead of http or https) and pass in base-64-encrypted
  *       PNG data, such as that obtained from the
  *       <a href="Publisher.html#getImgData">Publisher.getImgData()</a> method. (For example,
  *       you could set the property to a value returned by calling <code>getImgData()</code> on
  *       a previous Publisher object.) If the URL or the image data is invalid, the property
  *       is ignored (the attempt to set the image fails silently).</li>
  *
  *       <li><code>buttonDisplayMode</code> (String) &mdash; How to display the microphone controls
  *       Possible values are: <code>"auto"</code> (controls are displayed when the stream is first
  *       displayed and when the user mouses over the display), <code>"off"</code> (controls are not
  *       displayed), and <code>"on"</code> (controls are always displayed).</li>
  *
  *       <li><code>nameDisplayMode</code> (String) &#151; Whether to display the stream name.
  *       Possible values are: <code>"auto"</code> (the name is displayed when the stream is first
  *       displayed and when the user mouses over the display), <code>"off"</code> (the name is not
  *       displayed), and <code>"on"</code> (the name is always displayed).</li>
  *   </ul>
  * </li>
  * <li>
  *   <strong>usePreviousDeviceSelection</strong> (Boolean) &#151; Used by the OpenTok Plugin for
  *   Internet Explorer only. When this is set to <code>true</code>), the Plugin uses the previously
  *   selected camera and microphone (from previous visits to a page in the same domain), if there
  *   are any. When set to <code>false</code> (the default) the Plugin prompts the user to select the
  *   the camera and microphone to use (regardless of a previous selection). This setting only applies
  *   to pages loaded over HTTPS. In HTTP, the Plugin always prompts the user to select the camera and
  *   microphone to use.
  * </li>
  * <li>
  *   <strong>videoSource</strong> (String) &#151; The ID of the video input device (such as a
  *    camera) to be used by the publisher. You can obtain a list of available devices, including
  *    video input devices, by calling the <a href="#getDevices">OT.getDevices()</a> method. Each
  *    device listed by the method has a unique device ID. If you pass in a device ID that does not
  *    match an existing video input device, the call to <code>OT.initPublisher()</code> fails with an
  *    error (error code 1500, "Unable to Publish") passed to the completion handler function.
  *    <p>
  *    If you set this property to <code>null</code> or <code>false</code>, the browser does not
  *    request access to the camera, and no video is published. In a voice-only call, set this
  *    property to <code>null</code> or <code>false</code> for each Publisher.
  *    </p>
  *   <p>
  *    To publish a screen-sharing stream, set this property to <code>"application"</code>,
  *    <code>"screen"</code>, or <code>"window"</code>. Call
  *    <a href="OT.html#checkScreenSharingCapability">OT.checkScreenSharingCapability()</a> to check
  *    if screen sharing is supported. When you set the <code>videoSource</code> property to
  *    <code>"application"</code>, <code>"screen"</code>, or <code>"window"</code>, the
  *    following are default values for other properties: <code>audioFallbackEnabled == false</code>,
  *    <code>maxResolution == {width: 1920, height: 1920}</code>, <code>mirror == false</code>,
  *    <code>scaleMode == "fit"</code>. Also, the default <code>scaleMode</code> setting for
  *    subscribers to the stream is <code>"fit"</code>.
  * </li>
  * <li>
  *   <strong>width</strong> (Number) &#151; The desired initial width of the displayed Publisher
  *   video in the HTML page (default: 264 pixels). You can specify the number of pixels as either
  *   a number (such as 400) or a string ending in "px" (such as "400px"). Or you can specify a
  *   percentage of the size of the parent element, with a string ending in "%" (such as "100%").
  *   <i>Note:</i> To resize the publisher video, adjust the CSS of the publisher's DOM element
  *   (the <code>element</code> property of the Publisher object) or (if the width is specified as
  *   a percentage) its parent DOM element (see
  *   <a href="https://tokbox.com/developer/guides/customize-ui/js/#video_resize_reposition">Resizing
  *   or repositioning a video</a>).
  * </li>
  * </ul>
  * @param {Function} completionHandler (Optional) A function to be called when the method succeeds
  * or fails in initializing a Publisher object. This function takes one parameter &mdash;
  * <code>error</code>. On success, the <code>error</code> object is set to <code>null</code>. On
  * failure, the <code>error</code> object has two properties: <code>code</code> (an integer) and
  * <code>message</code> (a string), which identify the cause of the failure. The method succeeds
  * when the user grants access to the camera and microphone. The method fails if the user denies
  * access to the camera and microphone. The <code>completionHandler</code> function is called
  * before the Publisher dispatches an <code>accessAllowed</code> (success) event or an
  * <code>accessDenied</code> (failure) event.
  * <p>
  * The following code adds a <code>completionHandler</code> when calling the
  * <code>OT.initPublisher()</code> method:
  * </p>
  * <pre>
  * var publisher = OT.initPublisher('publisher', null, function (error) {
  *   if (error) {
  *     console.log(error);
  *   } else {
  *     console.log("Publisher initialized.");
  *   }
  * });
  * </pre>
  *
  * @returns {Publisher} The Publisher object.
  * @see <a href="Session.html#publish">Session.publish()</a>
  * @method OT.initPublisher
  * @memberof OT
  */
  return function initPublisher(targetElement, properties, completionHandler) {
    logging.debug('OT.initPublisher(' + targetElement + ')');

    // To support legacy (apikey, targetElement, properties) users
    // we check to see if targetElement is actually an apikey. Which we ignore.
    if (typeof targetElement === 'string' && !document.getElementById(targetElement)) {
      targetElement = properties;
      properties = completionHandler;
      completionHandler = arguments[3];
    }

    if (typeof targetElement === 'function') {
      completionHandler = targetElement;
      properties = undefined;
      targetElement = undefined;
    } else if (OTHelpers.isObject(targetElement) && !OTHelpers.isElementNode(targetElement)) {
      completionHandler = properties;
      properties = targetElement;
      targetElement = undefined;
    }

    if (typeof properties === 'function') {
      completionHandler = properties;
      properties = undefined;
    }

    var errMsg = void 0;

    if (properties && !OTHelpers.isObject(properties)) {
      errMsg = 'properties argument to Publisher constructor, if provided, should be an object';
      properties = undefined;
    }

    if (properties && properties.insertDefaultUI === false && targetElement) {
      errMsg = 'You cannot specify a target element if insertDefaultUI is false';
    }

    var publisher = new Publisher(properties || {});
    sessionObjects.publishers.add(publisher);

    var triggerCallback = function triggerCallback() {
      if (completionHandler && OTHelpers.isFunction(completionHandler)) {
        completionHandler.apply(undefined, arguments);
        completionHandler = undefined;
      }
    };

    if (errMsg !== undefined) {
      logging.error(errMsg);

      triggerCallback(otError(Errors.INVALID_PARAMETER, new Error(errMsg), ExceptionCodes.INVALID_PARAMETER));
    }

    var removeInitSuccessAndCallComplete = function removeInitSuccessAndCallComplete(err) {
      publisher.off('publishComplete', removeHandlersAndCallComplete);
      triggerCallback(err);
    };

    var removeHandlersAndCallComplete = function removeHandlersAndCallComplete(err) {
      publisher.off('initSuccess', removeInitSuccessAndCallComplete);

      // We're only handling the error case here as we're just
      // initing the publisher, not actually attempting to publish.
      if (err) {
        triggerCallback(err);
      }
    };

    publisher.once('initSuccess', removeInitSuccessAndCallComplete);
    publisher.once('publishComplete', removeHandlersAndCallComplete);

    publisher.publish(targetElement);

    return publisher;
  };
};

},{"../../common-js-helpers/OTHelpers.js":217,"../../helpers/otError.js":271,"../Errors.js":288,"../exception_codes.js":307,"../logging.js":312,"../session/objects.js":370,"./index.js":355}],357:[function(require,module,exports){
"use strict";

module.exports = 15000;

},{}],358:[function(require,module,exports){
'use strict';

// @todo enable the following disabled rules see OPENTOK-31136 for more info
/* eslint-disable no-param-reassign, global-require, no-underscore-dangle, no-shadow */
/* eslint-disable no-plusplus */

module.exports = function MicrophoneFactory() {
  var deps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var OTHelpers = deps.OTHelpers || require('../../common-js-helpers/OTHelpers.js');

  /*
   * A Publishers Microphone.
   *
   * TODO
   * * bind to changes in mute/unmute/volume/etc and respond to them
   */
  return function Microphone(webRTCStream, muted) {
    var _muted = void 0;

    OTHelpers.defineProperties(this, {
      muted: {
        get: function get() {
          return _muted;
        },
        set: function set(muted) {
          if (_muted === muted) {
            return;
          }

          _muted = muted;

          var audioTracks = webRTCStream.getAudioTracks();

          for (var i = 0, num = audioTracks.length; i < num; ++i) {
            audioTracks[i].enabled = !_muted;
          }
        }
      }
    });

    // Set the initial value
    if (muted !== undefined) {
      this.muted(muted === true);
    } else if (webRTCStream.getAudioTracks().length) {
      this.muted(!webRTCStream.getAudioTracks()[0].enabled);
    } else {
      this.muted(false);
    }
  };
};

},{"../../common-js-helpers/OTHelpers.js":217}],359:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

// @todo enable the following disabled rules see OPENTOK-31136 for more info
/* eslint-disable no-underscore-dangle, no-confusing-arrow */

var assert = require('assert');

var capitalize = require('lodash/capitalize');

var defaultLogging = require('../logging.js');

var validResolutions = {
  '320x240': { width: 320, height: 240 },
  '320x180': { width: 320, height: 180 },
  '640x480': { width: 640, height: 480 },
  '640x360': { width: 640, height: 360 },
  '1280x720': { width: 1280, height: 720 },
  '1280x960': { width: 1280, height: 960 }
};

var validFrameRates = [1, 7, 15, 30];

function getLogging(opt) {
  return opt._inject && opt._inject.logging || defaultLogging;
}

function lookupParam(name, param, lookup, possibilities, logging) {
  if (param === undefined) {
    return undefined;
  }

  var result = lookup(param);

  if (!result) {
    logging.warn('Invalid ' + name + ' passed to the Publisher. Got: ' + param + ', expecting one of ' + possibilities);
  }

  return result;
}

function normalizeMediaParams(mediaType, opt) {
  var logging = getLogging(opt);

  var publish = function () {
    var param = opt['publish' + capitalize(mediaType)];

    if (param !== undefined) {
      return Boolean(param);
    }

    return true;
  }();

  var source = function () {
    var param = opt[mediaType + 'Source'];

    if (param === undefined) {
      return true;
    }

    if (param === null || param === false) {
      return false;
    }

    if ((typeof param === 'undefined' ? 'undefined' : _typeof(param)) === 'object') {
      if (typeof param.deviceId !== 'string') {
        logging.warn('Invalid ' + mediaType + 'Source passed to Publisher. Expected either a device ID or ' + 'device.');

        return true;
      }

      return param.deviceId;
    }

    if (typeof param !== 'string') {
      logging.warn('Ignoring invalid ' + mediaType + 'Source parameter');
      return true;
    }

    return param;
  }();

  if (mediaType === 'audio' && opt.isScreenSharing && source !== false) {
    getLogging(opt).warn('Invalid audioSource passed to Publisher - when using screen sharing no audioSource may be ' + 'used');

    source = false;
  }

  return { source: source, publish: publish };
}

function fixChromeBug707118(env, frameRate) {
  // OPENTOK-32592: 1fps with facetime camera causes chrome to lock up intermittently. Workaround
  // is just to use 2fps instead for now.
  // https://bugs.chromium.org/p/chromium/issues/detail?id=707118
  if (env.name === 'Chrome' && env.userAgent.indexOf('Mac OS X') !== -1 && frameRate === 1) {
    return 2;
  }

  return frameRate;
}

module.exports = function normalizeConstraintInput(opt) {
  var logging = getLogging(opt);

  var env = opt.env || {};

  if (opt.isScreenSharing) {
    assert(opt.usingOptionalMandatoryStyle, 'Screensharing only uses optional-mandatory constraints right now');
  }

  var prefixedAudioConstraints = void 0;
  if (opt.disableAudioProcessing && env.name === 'Firefox') {
    prefixedAudioConstraints = {
      mozAutoGainControl: false,
      mozNoiseSupression: false
    };
  }

  return {
    isScreenSharing: opt.isScreenSharing,

    // These will be of the form { source: string | boolean, publish: boolean }
    audio: normalizeMediaParams('audio', opt),
    video: normalizeMediaParams('video', opt),

    usingOptionalMandatoryStyle: opt.usingOptionalMandatoryStyle,
    enableRenegotiation: opt.enableRenegotiation,
    disableAudioProcessing: opt.disableAudioProcessing,
    prefixedAudioConstraints: prefixedAudioConstraints,

    videoDimensions: lookupParam('resolution', opt.resolution, function (param) {
      return validResolutions[param];
    }, '"' + Object.keys(validResolutions).join('", "') + '"', logging),

    frameRate: fixChromeBug707118(env, lookupParam('frameRate', opt.frameRate, function (param) {
      return validFrameRates.indexOf(param) !== -1 ? param : undefined;
    }, validFrameRates.join(','), logging)),

    maxResolution: function () {
      if (opt.maxResolution === undefined) {
        return opt.isScreenSharing ? { width: 1920, height: 1920 } : undefined;
      }

      var result = {
        width: opt.maxResolution.width,
        height: opt.maxResolution.height
      };

      Object.keys(result).forEach(function (dimensionName) {
        var dim = result[dimensionName];

        if (typeof dim !== 'number' || dim > 1920) {
          logging.warn('Invalid maxResolution passed to the Publisher. maxResolution.' + dimensionName + ' must be less than or equal to 1920');

          result[dimensionName] = 1920;
        }
      });

      return result;
    }()
  };
};

},{"../logging.js":312,"assert":1,"lodash/capitalize":144}],360:[function(require,module,exports){
'use strict';

// @todo enable the following disabled rules see OPENTOK-31136 for more info
/* eslint-disable no-param-reassign, global-require */

module.exports = function PublishingStateFactory() {
  var deps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var generateSimpleStateMachine = deps.generateSimpleStateMachine || require('../generate_simple_state_machine.js')();

  // Models a Publisher's publishing State
  //
  // Valid States:
  //    NotPublishing
  //    GetUserMedia
  //    BindingMedia
  //    MediaBound
  //    PublishingToSession
  //    Publishing
  //    Failed
  //    Destroyed
  //
  //
  // Valid Transitions:
  //    NotPublishing ->
  //        GetUserMedia
  //
  //    GetUserMedia ->
  //        BindingMedia
  //      | Failed                     (Failure Reasons -> stream error, constraints,
  //                                   (permission denied
  //      | NotPublishing              (destroy()
  //
  //
  //    BindingMedia ->
  //        MediaBound
  //      | Failed                     (Failure Reasons -> Anything to do with the media
  //                                   (being invalid, the media never plays
  //      | NotPublishing              (destroy()
  //
  //    MediaBound ->
  //        PublishingToSession        (MediaBound could transition to PublishingToSession
  //                                   (if a stand-alone publish is bound to a session
  //      | Failed                     (Failure Reasons -> media issues with a stand-alone publisher
  //      | NotPublishing              (destroy()
  //
  //    PublishingToSession
  //        Publishing
  //      | Failed
  //      | NotPublishing              (destroy()
  //      | MediaBound                 (disconnect()
  //
  //
  //    Publishing ->
  //        NotPublishing              (Unpublish
  //      | Failed                     (Failure Reasons -> loss of network, media error, anything
  //                                   (that causes *all* Peer Connections to fail (less than all
  //                                   (failing is just an error, all is failure)
  //      | NotPublishing              (destroy()
  //
  //    Failed ->
  //       Destroyed
  //
  //    Destroyed ->                   (Terminal state
  //
  //

  var validStates = ['NotPublishing', 'GetUserMedia', 'BindingMedia', 'MediaBound', 'PublishingToSession', 'Publishing', 'Failed', 'Destroyed'];

  var validTransitions = {
    NotPublishing: ['NotPublishing', 'GetUserMedia', 'Destroyed'],
    GetUserMedia: ['BindingMedia', 'Failed', 'NotPublishing', 'Destroyed'],
    BindingMedia: ['MediaBound', 'Failed', 'NotPublishing', 'Destroyed'],
    MediaBound: ['NotPublishing', 'PublishingToSession', 'Failed', 'Destroyed'],
    PublishingToSession: ['NotPublishing', 'Publishing', 'Failed', 'Destroyed', 'MediaBound'],
    Publishing: ['NotPublishing', 'MediaBound', 'Failed', 'Destroyed'],
    Failed: ['Destroyed'],
    Destroyed: []
  };

  var initialState = 'NotPublishing';

  var PublishingState = generateSimpleStateMachine(initialState, validStates, validTransitions);

  PublishingState.prototype.isDestroyed = function () {
    return this.current === 'Destroyed';
  };

  PublishingState.prototype.isAttemptingToPublish = function () {
    return ['GetUserMedia', 'BindingMedia', 'MediaBound', 'PublishingToSession'].indexOf(this.current) !== -1;
  };

  PublishingState.prototype.isPublishing = function () {
    return this.current === 'Publishing';
  };

  return PublishingState;
};

},{"../generate_simple_state_machine.js":308}],361:[function(require,module,exports){
'use strict';

// @todo enable the following disabled rules see OPENTOK-31136 for more info
/* eslint-disable no-param-reassign, global-require, max-len, no-plusplus */

module.exports = function () {
  var deps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var analytics = deps.analytics || require('./analytics.js');
  var errors = deps.errors || require('./Errors.js');
  var ExceptionCodes = deps.ExceptionCodes || require('./exception_codes.js');
  var OTHelpers = deps.OTHelpers || require('../common-js-helpers/OTHelpers.js');
  var otError = deps.otError || require('../helpers/otError.js')();
  var sessionObjects = deps.sessionObjects || require('./session/objects.js');
  var uuid = deps.uuid || require('uuid');

  /**
  * Report that your app experienced an issue. You can use the issue ID with
  * <a href="http://tokbox.com/developer/tools/Inspector">Inspector</a> or when discussing
  * an issue with the TokBox support team.
  *
  * @param completionHandler {Function} A function that is called when the call to this method
  * succeeds or fails. This function has two parameters. The first parameter is an
  * <a href="Error.html">Error</a> object that is set when the call to the <code>reportIssue()</code>
  * method fails (for example, if the client is not connected to the network) or <code>null</code>
  * when the call to the <code>reportIssue()</code> method succeeds. The second parameter is set to
  * the report ID (a unique string) when the call succeeds.
  *
  * @method OT.reportIssue
  * @memberof OT
  */
  return function reportIssue(completionHandler) {
    var reportIssueId = uuid();
    var sessionCount = sessionObjects.sessions.length();
    var completedLogEventCount = 0;
    var errorReported = false;

    function logEventCompletionHandler(error) {
      if (error) {
        if (completionHandler && !errorReported) {
          completionHandler(otError(errors.REPORT_ISSUE_FAILED, new Error('Error calling OT.reportIssue(). Check the client\'s network connection.'), ExceptionCodes.REPORT_ISSUE_ERROR));

          errorReported = true;
        }
      } else {
        completedLogEventCount++;
        if (completedLogEventCount >= sessionCount && completionHandler && !errorReported) {
          completionHandler(null, reportIssueId);
        }
      }
    }

    var eventOptions = {
      action: 'ReportIssue',
      payload: {
        reportIssueId: reportIssueId
      }
    };

    if (sessionCount === 0) {
      analytics.logEvent(eventOptions, null, logEventCompletionHandler);
    } else {
      sessionObjects.sessions.forEach(function (session) {
        var individualSessionEventOptions = OTHelpers.extend({
          sessionId: session.sessionId,
          partnerId: session.sessionInfo ? session.sessionInfo.partnerId : null,
          p2p: session.sessionInfo ? session.sessionInfo.p2pEnabled : null,
          messagingServer: session.sessionInfo ? session.sessionInfo.messagingServer : null
        }, eventOptions);
        analytics.logEvent(individualSessionEventOptions, null, logEventCompletionHandler);
      });
    }
  };
};

},{"../common-js-helpers/OTHelpers.js":217,"../helpers/otError.js":271,"./Errors.js":288,"./analytics.js":289,"./exception_codes.js":307,"./session/objects.js":370,"uuid":200}],362:[function(require,module,exports){
(function (global){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

// @todo enable the following disabled rules see OPENTOK-31136 for more info
/* eslint-disable no-param-reassign, global-require, no-void, prefer-rest-params, no-shadow */

var uuid = require('uuid');

module.exports = function chromeExtensionHelperFactory() {
  var deps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var context = deps.global || global;
  var Errors = deps.Errors || require('../Errors.js');
  var otError = deps.otError || require('../../helpers/otError.js')();

  var isSupportedInThisBrowser = !!context.navigator.webkitGetUserMedia && !context.navigator.userAgent.match(/android/i) && typeof context.chrome !== 'undefined';

  return {
    isSupportedInThisBrowser: isSupportedInThisBrowser,
    autoRegisters: false,
    extensionRequired: true,
    getConstraintsShowsPermissionUI: true,
    sources: {
      screen: true,
      application: false,
      window: false,
      browser: false
    },

    register: function register(extensionID, version) {
      if (version === 2) {
        return this.registerVersion2(extensionID);
      }
      return this.registerVersion1(extensionID);
    },
    registerVersion1: function registerVersion1(extensionID) {
      if (!extensionID) {
        throw new Error('initChromeScreenSharingExtensionHelper: extensionID is required.');
      }

      var isChrome = isSupportedInThisBrowser;

      var callbackRegistry = {};
      var isInstalled = void 0;

      var prefix = 'com.tokbox.screenSharing.' + extensionID;
      var request = function request(method, payload) {
        var res = { payload: payload, from: 'jsapi' };
        res[prefix] = method;
        return res;
      };

      var addCallback = function addCallback(fn, timeToWait) {
        var timeout = void 0;
        var requestId = uuid();

        callbackRegistry[requestId] = function () {
          clearTimeout(timeout);
          timeout = null;
          fn.apply(undefined, arguments);
        };
        if (timeToWait) {
          timeout = setTimeout(function () {
            delete callbackRegistry[requestId];
            fn(otError(Errors.TIMEOUT, new Error('Timeout waiting for response to screensharing request.')));
          }, timeToWait);
        }
        return requestId;
      };

      var isAvailable = function isAvailable(callback) {
        if (!callback) {
          throw new Error('isAvailable: callback is required.');
        }

        if (!isChrome) {
          setTimeout(callback.bind(null, false));
          return;
        }

        if (isInstalled !== void 0) {
          setTimeout(callback.bind(null, isInstalled));
        } else {
          var requestId = addCallback(function (event) {
            if (isInstalled !== true) {
              isInstalled = event === 'extensionLoaded';
            }
            callback(isInstalled);
          }, 2000);
          var post = request('isExtensionInstalled', { requestId: requestId });
          context.postMessage(post, '*');
        }
      };

      var getConstraints = function getConstraints(source, constraints, callback) {
        if (!callback) {
          throw new Error('getSourceId: callback is required');
        }
        isAvailable(function (isInstalled) {
          if (!isInstalled) {
            return callback(otError(Errors.SCREEN_SHARING_EXTENSION_NOT_INSTALLED, new Error('Extension is not installed')));
          }

          var requestId = addCallback(function (event, payload) {
            if ((typeof event === 'undefined' ? 'undefined' : _typeof(event)) === 'object' && event.name && event.stack) {
              // FIXME: The callback shouldn't be overloaded like this ('event' is actually an
              // error), but I'm adding tests and don't want to refactor right now without testing
              // more thorougly.
              var error = event;
              callback(error);
            } else if (event === 'permissionDenied') {
              callback(otError(Errors.USER_MEDIA_ACCESS_DENIED, new Error('User denied access to screensharing')));
            } else {
              if (!constraints.video) {
                constraints.video = {};
              }
              if (!constraints.video.mandatory) {
                constraints.video.mandatory = {};
              }
              constraints.video.mandatory.chromeMediaSource = 'desktop';
              constraints.video.mandatory.chromeMediaSourceId = payload.sourceId;
              callback(void 0, constraints);
            }
          });

          context.postMessage(request('getSourceId', { requestId: requestId, source: source }), '*');

          return undefined;
        });
      };

      context.addEventListener('message', function (event) {
        if (event.origin !== context.location.origin) {
          return;
        }

        if (!(event.data != null && _typeof(event.data) === 'object')) {
          return;
        }

        if (event.data.from !== 'extension') {
          return;
        }

        var method = event.data[prefix];
        var payload = event.data.payload;

        if (payload && payload.requestId) {
          var callback = callbackRegistry[payload.requestId];
          delete callbackRegistry[payload.requestId];
          if (callback) {
            callback(method, payload);
          }
        }

        if (method === 'extensionLoaded') {
          isInstalled = true;
        }
      });

      return {
        extensionAPIVersion: 1,
        extensionID: extensionID,
        isInstalled: isAvailable,
        getConstraints: getConstraints
      };
    },
    registerVersion2: function registerVersion2(extensionID) {
      var isChrome = isSupportedInThisBrowser && typeof context.chrome.runtime !== 'undefined';

      var isInstalled = function isInstalled(callback) {
        if (!callback) {
          throw new Error('isAvailable: callback is required.');
        }

        if (!isChrome) {
          setTimeout(callback.bind(null, false));
          return;
        }

        context.chrome.runtime.sendMessage(extensionID, {
          type: 'isInstalled'
        }, null, function (response) {
          setTimeout(callback.bind(null, !!response));
        });
      };

      var getConstraints = function getConstraints(source, constraints, callback) {
        if (!callback) {
          throw new Error('getSourceId: callback is required');
        }
        isInstalled(function (installed) {
          if (!installed) {
            return callback(otError(Errors.SCREEN_SHARING_EXTENSION_NOT_INSTALLED, new Error('Extension is not installed')));
          }

          context.chrome.runtime.sendMessage(extensionID, {
            type: 'getSourceId',
            source: source
          }, null, function (data) {
            if (data.error === 'permissionDenied') {
              callback(otError(Errors.USER_MEDIA_ACCESS_DENIED, new Error('User denied access to screensharing')));
            } else if (data.error) {
              callback(new Error('UnexpectError: ' + data.error));
            } else {
              if (!constraints.video) {
                constraints.video = {};
              }
              if (!constraints.video.mandatory) {
                constraints.video.mandatory = {};
              }
              constraints.video.mandatory.chromeMediaSource = 'desktop';
              constraints.video.mandatory.chromeMediaSourceId = data.sourceId;
              callback(void 0, constraints);
            }
          });
          return undefined;
        });
      };

      return {
        extensionAPIVersion: 2,
        extensionID: extensionID,
        isInstalled: isInstalled,
        getConstraints: getConstraints
      };
    }
  };
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../helpers/otError.js":271,"../Errors.js":288,"uuid":200}],363:[function(require,module,exports){
'use strict';

module.exports = function electronExtensionHelperFactory() {
  var deps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var desktopCapturer = null;

  try {
    // Using a dynamic require here because that's the way we get desktopCapturer in electron, and
    // that's not something to bundle in.
    // eslint-disable-next-line import/no-dynamic-require, global-require
    desktopCapturer = deps.desktopCapturer || require('elect' + 'ron').desktopCapturer;
  } catch (e) {
    // Ignore
  }

  return {
    isSupportedInThisBrowser: desktopCapturer !== null,
    autoRegisters: true,
    extensionRequired: false,
    getConstraintsShowsPermissionUI: false,
    sources: {
      screen: true,
      application: true,
      window: true,
      browser: true
    },

    register: function register() {
      return {
        isInstalled: function isInstalled(callback) {
          return callback(true);
        },
        getConstraints: function getConstraints(source, constraints, callback) {
          desktopCapturer.getSources({ types: [source] }, function (error, sources) {
            if (error) {
              callback(error);
              return;
            }

            // For now just pick the first source. In future we need to implement a selection
            // dialog.
            var foundSource = sources[0];

            if (!foundSource) {
              callback(new Error('Could not find Electron source for screensharing'));
              return;
            }

            callback(undefined, {
              audio: false,
              video: {
                mandatory: {
                  chromeMediaSource: source,
                  chromeMediaSourceId: foundSource.id
                }
              }
            });
          });
        }
      };
    }
  };
};

},{}],364:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

// @todo enable the following disabled rules see OPENTOK-31136 for more info
/* eslint-disable no-param-reassign, no-void */

var OTHelpers = require('../../common-js-helpers/OTHelpers.js');

module.exports = {
  isSupportedInThisBrowser: OTHelpers.env.name === 'Firefox',
  autoRegisters: true,
  extensionRequired: false,
  extensionInstalled: false,
  getConstraintsShowsPermissionUI: false,
  sources: {
    screen: true,
    application: OTHelpers.env.name === 'Firefox' && OTHelpers.env.version >= 34,
    window: OTHelpers.env.name === 'Firefox' && OTHelpers.env.version >= 34,
    browser: OTHelpers.env.name === 'Firefox' && OTHelpers.env.version >= 38
  },
  register: function register() {
    return {
      isInstalled: function isInstalled(callback) {
        // The extension sets widow.OTScreenSharing in pages loaded from a matching domain
        callback((typeof OTScreenSharing === 'undefined' ? 'undefined' : _typeof(OTScreenSharing)) === 'object');
      },
      getConstraints: function getConstraints(source, constraints, callback) {
        constraints.video = {
          mediaSource: source
        };

        // copy constraints under the video object and removed them from the root constraint object
        if (constraints.browserWindow) {
          constraints.video.browserWindow = constraints.browserWindow;
          delete constraints.browserWindow;
        }
        if (typeof constraints.scrollWithPage !== 'undefined') {
          constraints.video.scrollWithPage = constraints.scrollWithPage;
          delete constraints.scrollWithPage;
        }

        callback(void 0, constraints);
      }
    };
  }
};

},{"../../common-js-helpers/OTHelpers.js":217}],365:[function(require,module,exports){
'use strict';

// @todo enable the following disabled rules see OPENTOK-31136 for more info
/* eslint-disable no-param-reassign, no-void */

var OTPlugin = require('../../otplugin/otplugin.js');

module.exports = {
  isSupportedInThisBrowser: OTPlugin.isSupported(),
  autoRegisters: true,
  extensionRequired: true,
  getConstraintsShowsPermissionUI: false,
  sources: {
    screen: true,
    application: false,
    window: true,
    browser: false
  },
  register: function register() {
    return {
      isInstalled: function isInstalled(callback) {
        callback(OTPlugin.isInstalled());
      },
      getConstraints: function getConstraints(source, constraints, callback) {
        constraints.video.mandatory.chromeMediaSource = source;

        callback(void 0, constraints);
      }
    };
  }
};

},{"../../otplugin/otplugin.js":390}],366:[function(require,module,exports){
'use strict';

// @todo enable the following disabled rules see OPENTOK-31136 for more info
/* eslint-disable no-param-reassign, global-require, prefer-rest-params, prefer-spread */
/* eslint-disable max-len, no-void, no-shadow */

var Bluebird = require('bluebird');

module.exports = function screenSharingFactory() {
  var deps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var chromeExtensionHelper = deps.chromeExtensionHelper || require('./chrome_extension_helper.js')();
  var electronExtensionHelper = deps.electronExtensionHelper || require('./electron_extension_helper.js')();
  var Errors = deps.Errors || require('../Errors.js');
  var firefoxExtensionHelper = deps.firefoxExtensionHelper || require('./firefox_extension_helper.js');
  var ieExtensionHelper = deps.ieExtensionHelper || require('./ie_extension_helper.js');
  var otError = deps.otError || require('../../helpers/otError.js')();
  var OTHelpers = deps.OTHelpers || require('../../common-js-helpers/OTHelpers.js');

  var screenSharing = {};

  screenSharing.extensionByKind = {};
  screenSharing.extensionClasses = {};

  screenSharing.registerExtensionHelper = function (kind, helper) {
    screenSharing.extensionClasses[kind] = helper;
    if (helper.autoRegisters && helper.isSupportedInThisBrowser) {
      screenSharing.registerExtension(kind);
    }
  };

  /**
   * Register a Chrome extension for screen-sharing support.
   * <p>
   * Use the <code>OT.checkScreenSharingCapability()</code> method to check if an extension is
   * required, registered, and installed.
   * <p>
   * The OpenTok
   * <a href="https://github.com/opentok/screensharing-extensions">screensharing-extensions</a>
   * repo includes code for creating an extension for screen-sharing support.
   *
   * @param {String} kind Set this parameter to <code>"chrome"</code>. Currently, you can only
   * register a screen-sharing extension for Chrome.
   *
   * @param {String} id The ID for your Chrome screen-sharing extension. You can find this ID at
   * chrome://extensions.
   *
   * @param {Number} version The version of the Chrome screen-sharing extension from the
   * <a href="https://github.com/opentok/screensharing-extensions">screensharing-extensions</a> repo.
   * Set this if you are using version 2 or later. For example, if you are using version 2, set this
   * to 2. With version 2, the client can use the extension immediately after installing it, without
   * reloading the page.
   *
   * @see <a href="OT.html#initPublisher">OT.initPublisher()</a>
   * @see <a href="OT.html#checkScreenSharingCapability">OT.checkScreenSharingCapability()</a>
   * @method OT.registerScreenSharingExtension
   * @memberof OT
   */

  screenSharing.registerExtension = function (kind) {
    var initArgs = Array.prototype.slice.call(arguments, 1);

    if (screenSharing.extensionClasses[kind] == null) {
      throw new Error('Unsupported kind passed to OT.registerScreenSharingExtension');
    }

    var x = screenSharing.extensionClasses[kind].register.apply(screenSharing.extensionClasses[kind], initArgs);

    screenSharing.extensionByKind[kind] = x;
  };

  var screenSharingPickHelper = function screenSharingPickHelper() {
    var foundClass = OTHelpers.find(Object.keys(screenSharing.extensionClasses), function (cls) {
      return screenSharing.extensionClasses[cls].isSupportedInThisBrowser;
    });

    if (foundClass === void 0) {
      return {};
    }

    return {
      name: foundClass,
      proto: screenSharing.extensionClasses[foundClass],
      instance: screenSharing.extensionByKind[foundClass]
    };
  };

  screenSharing.pickHelper = function () {
    return screenSharingPickHelper();
  };

  /**
   * Checks for support for publishing screen-sharing streams on the client browser. The object
   * passed to the callback function defines whether screen sharing is supported, as well as whether
   * an extension is required, installed, and registered (if needed).
   * <p>
   * <pre>
   * OT.checkScreenSharingCapability(function(response) {
   *   if (!response.supported || response.extensionRegistered === false) {
   *     // This browser does not support screen sharing
   *   } else if (response.extensionInstalled === false) {
   *     // Prompt to install the extension
   *   } else {
   *     // Screen sharing is available.
   *   }
   * });
   * </pre>
   * <p>
   * To publish a screen-sharing video in Chrome, the client adds an extension
   * that enables publishing a screen-sharing video stream on your domain. Firefox 52+ and
   * the OpenTok plugin for Internet Explorer have screen-sharing capabilities built-in. The OpenTok
   * <a href="https://github.com/opentok/screensharing-extensions">screensharing-extensions</a>
   * sample includes code for creating Chrome extensions for screen-sharing support.
   * <p>
   * For more information, see the <a href="https://tokbox.com/developer/guides/screen-sharing/js/">
   * OpenTok Screen Sharing</a> developer guide.
   *
   * @param {function} callback The callback invoked with the support options object passed as
   * the parameter. This object has the following properties that indicate support for publishing
   * screen-sharing streams in the client:
   * <p>
   * <ul>
   *   <li>
   *     <code>extensionInstalled</code> (Boolean) &mdash;  In Chrome, this is set to
   *     <code>true</code> if the extension is installed and registered. In Firefox 52+,
   *     a screen-sharing extension is not required, and this property is set to <code>false</code>.
   *     (In older versions of Firefox, this property  is set to <code>true</code> if a
   *     screen-sharing extension is installed and it is set to work in the current page's domain.)
   *     This property is undefined in Internet Explorer.
   *   </li>
   *   <li>
   *     <code>supported</code> (Boolean) &mdash; Set to true if screen sharing is supported in the
   *     browser. Check the <code>extensionRequired</code> property to see if the browser requires
   *     an extension for screen sharing.
   *   </li>
   *   <li>
   *     <code>supportedSources</code> (Object) &mdash; An object with the following properties:
   *     <code>application</code>, <code>screen</code>, and <code>window</code>. Each property is
   *     a Boolean value indicating support. In Firefox, each of these properties is set to
   *     <code>true</code>. Currently in Chrome, only the <code>screen</code> property is
   *     set to <code>true</code>. In Internet Explorer (using the OpenTok plugin), only
   *     <code>screen</code> and <code>window</code> are set to <code>true</code>.
   *   </li>
   * </ul>
   * <p> The options parameter also includes the following properties, which apply to screen-sharing
   * support in Chrome (in all other browsers these properties are undefined):
   * <ul>
   *   <li>
   *     <code>extensionRequired</code> (String) &mdash; Set to <code>"chrome"</code> in Chrome,
   *     which requires a screen-sharing extension to be installed. This property is undefined in
   *     other browsers.
   *   </li>
   *   <li>
   *     <code>extensionRegistered</code> (Boolean) &mdash; In Chrome, this property is set to
   *     <code>true</code> if a screen-sharing extension is registered; otherwise it is set to
   *     <code>false</code>. In other browsers (which do not require an extension), this property is
   *     undefined. Use the <code>OT.registerScreenSharingExtension()</code> method to register a
   *     screen-sharing extension in Chrome.
   *   </li>
   * </ul>
   *
   * @see <a href="OT.html#initPublisher">OT.initPublisher()</a>
   * @see <a href="OT.html#registerScreenSharingExtension">OT.registerScreenSharingExtension()</a>
   * @method OT.checkScreenSharingCapability
   * @memberof OT
   */
  screenSharing.checkCapability = function (callback) {
    var response = {
      supported: false,
      extensionRequired: void 0,
      extensionRegistered: void 0,
      extensionInstalled: void 0,
      supportedSources: {}
    };

    // find a supported browser

    var helper = screenSharingPickHelper();

    if (helper.name === void 0) {
      setTimeout(callback.bind(null, response));
      return;
    }

    response.supported = true;
    response.extensionRequired = helper.proto.extensionRequired ? helper.name : void 0;

    response.supportedSources = {
      screen: helper.proto.sources.screen,
      application: helper.proto.sources.application,
      window: helper.proto.sources.window,
      browser: helper.proto.sources.browser
    };

    if (!helper.instance) {
      response.extensionRegistered = false;
      if (response.extensionRequired) {
        response.extensionInstalled = false;
      }
      setTimeout(callback.bind(null, response));
      return;
    }

    response.extensionRegistered = response.extensionRequired ? true : void 0;
    helper.instance.isInstalled(function (installed) {
      response.extensionInstalled = response.extensionRequired || OTHelpers.env.name === 'Firefox' ? installed : void 0;
      callback(response);
    });
  };

  screenSharing.registerExtensionHelper('chrome', chromeExtensionHelper);
  screenSharing.registerExtensionHelper('electron', electronExtensionHelper);
  screenSharing.registerExtensionHelper('firefox', firefoxExtensionHelper);
  screenSharing.registerExtensionHelper('OpenTokPlugin', ieExtensionHelper);

  screenSharing.getConstraints = function (opt) {
    var onAccessDialogOpened = opt.onAccessDialogOpened || function () {};
    var onAccessDialogClosed = opt.onAccessDialogClosed || function () {};
    var videoSource = opt.videoSource;
    var constraints = opt.constraints;

    return new Bluebird.Promise(function (resolve, reject) {
      screenSharing.checkCapability(function (response) {
        if (!response.supported) {
          reject(otError(Errors.SCREEN_SHARING_NOT_SUPPORTED, new Error('Screen Sharing is not supported in this browser')));
        } else if (response.extensionRegistered === false) {
          reject(otError(Errors.SCREEN_SHARING_EXTENSION_NOT_REGISTERED, new Error('Screen Sharing support in this browser requires an extension, but ' + 'one has not been registered.')));
        } else if (response.extensionRequired && response.extensionInstalled === false) {
          reject(otError(Errors.SCREEN_SHARING_EXTENSION_NOT_INSTALLED, new Error('Screen Sharing support in this browser requires an extension, but ' + 'the extension is not installed.')));
        } else {
          var helper = screenSharing.pickHelper();

          if (helper.proto.getConstraintsShowsPermissionUI) {
            onAccessDialogOpened();
          }

          helper.instance.getConstraints(videoSource, constraints, function (err, constraints) {
            if (helper.proto.getConstraintsShowsPermissionUI) {
              onAccessDialogClosed();
            }
            if (err) {
              reject(err);
            } else {
              resolve(constraints);
            }
          });
        }
      });
    });
  };

  return screenSharing;
};

},{"../../common-js-helpers/OTHelpers.js":217,"../../helpers/otError.js":271,"../Errors.js":288,"./chrome_extension_helper.js":362,"./electron_extension_helper.js":363,"./firefox_extension_helper.js":364,"./ie_extension_helper.js":365,"bluebird":2}],367:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

// @todo enable the following disabled rules see OPENTOK-31136 for more info
/* eslint-disable no-param-reassign, global-require, no-underscore-dangle, one-var */
/* eslint-disable no-use-before-define, max-len, no-var, vars-on-top, no-shadow, no-void */
/* eslint-disable no-prototype-builtins, newline-per-chained-call,  prefer-rest-params */

var Bluebird = require('bluebird');
var pick = require('lodash/pick');

module.exports = function SessionFactory() {
  var deps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var adaptIceServers = deps.adaptIceServers || require('../messaging/raptor/parse_ice_servers.js').adaptIceServers;
  var analytics = deps.analytics || require('../analytics.js');
  var APIKEY = deps.APIKEY || require('../api_key.js');
  var Capabilities = deps.Capabilities || require('../capabilities.js');
  var ConnectivityAttemptPinger = deps.ConnectivityAttemptPinger || require('../../helpers/connectivity_attempt_pinger.js');
  var convertAnvilErrorCode = deps.convertAnvilErrorCode || require('../../helpers/convertAnvilErrorCode.js');
  var convertRumorError = deps.convertRumorError || require('../../helpers/convertRumorError.js');
  var errors = deps.Errors || require('../Errors.js');
  var Events = deps.Events || require('../events.js')();
  var ExceptionCodes = deps.ExceptionCodes || require('../exception_codes.js');
  var hasIceRestartsCapability = deps.hasIceRestartsCapability || require('../../helpers/hasIceRestartsCapability.js');
  var logging = deps.logging || require('../logging.js');
  var omit = deps.omit || require('lodash/omit');
  var otError = deps.otError || require('../../helpers/otError.js')();
  var OTErrorClass = deps.OTErrorClass || require('../ot_error_class.js');
  var OTHelpers = deps.OTHelpers || require('../../common-js-helpers/OTHelpers.js');
  var OTPlugin = deps.OTPlugin || require('../../otplugin/otplugin.js');
  var otProperties = deps.otProperties || require('../../helpers/otProperties.js');
  var Publisher = deps.Publisher || require('../publisher')();
  var RaptorSocket = deps.RaptorSocket || require('../messaging/raptor/raptor_socket.js')();
  var SessionDispatcher = deps.SessionDispatcher || require('../messaging/raptor/session_dispatcher.js');
  var SessionInfo = deps.SessionInfo || require('./info.js');
  var sessionObjects = deps.sessionObjects || require('./objects.js');
  var sessionTag = deps.sessionTag || require('./tag.js');
  var socketCloseErrors = deps.socketCloseErrors || require('../messaging/rumor/socket_close_errors.js');
  var Subscriber = deps.Subscriber || require('../subscriber')();
  var systemRequirements = deps.systemRequirements || require('../system_requirements.js');
  var uuid = deps.uuid || require('uuid');

  var initPublisher = deps.initPublisher || require('../publisher/init.js')({
    Publisher: Publisher
  });

  /**
   * The Session object returned by the <code>OT.initSession()</code> method provides access to
   * much of the OpenTok functionality.
   *
   * @class Session
   * @augments EventDispatcher
   *
   * @property {Capabilities} capabilities A {@link Capabilities} object that includes information
   * about the capabilities of the client. All properties of the <code>capabilities</code> object
   * are undefined until you have connected to a session and the completion handler for the
   * <code>Session.connect()</code> method has been called without error.
   * @property {Connection} connection The {@link Connection} object for this session. The
   * connection property is only available once the completion handler for the
   * <code>Session.connect()</code> method has been called successfully. See the
   * <a href="#connect">Session.connect()</a> method and the {@link Connection} class.
   * @property {String} sessionId The session ID for this session. You pass this value into the
   * <code>OT.initSession()</code> method when you create the Session object. (Note: a Session
   * object is not connected to the OpenTok server until you call the connect() method of the
   * object and its completion handler is called without error. See the
   * <a href="OT.html#initSession">OT.initSession()</a> and
   * the <a href="#connect">Session.connect()</a>
   * methods.) For more information on sessions and session IDs, see
   * <a href="https://tokbox.com/opentok/tutorials/create-session/">Session creation</a>.
   */
  var Session = function Session(apiKey, sessionId, optParam) {
    var _this = this;

    var getStream = function getStream(stream) {
      return typeof stream === 'string' ? _this.streams.get(stream) || { id: stream } : stream;
    };

    var opt = optParam || {};

    OTHelpers.eventing(this);
    this._tag = sessionTag;

    // Check that the client meets the minimum requirements, if they don't the upgrade
    // flow will be triggered.
    if (!systemRequirements.check()) {
      systemRequirements.upgrade();
    }

    if (sessionId == null) {
      sessionId = apiKey;
      apiKey = null;
    }

    this.id = sessionId;
    this.sessionId = sessionId;

    var _socket = void 0,
        _connectivityAttemptPinger = void 0,
        _token = void 0,
        _p2p = void 0,
        _messagingServer = void 0,
        _attemptStartTime = void 0,
        _iceServerDetails = void 0;
    var _initialConnection = true;
    var _apiKey = apiKey;
    var _session = this;
    var _sessionId = sessionId;
    var _widgetId = uuid();
    var _connectionId = uuid();
    var _logging = logging;

    var setState = OTHelpers.statable(this, ['disconnected', 'connecting', 'connected', 'disconnecting'], 'disconnected');

    this.connection = null;
    this.connections = new OTHelpers.Collection();
    this.streams = new OTHelpers.Collection();
    this.archives = new OTHelpers.Collection();

    //--------------------------------------
    //  MESSAGE HANDLERS
    //--------------------------------------

    /*
     * The sessionConnectFailed event handler
     * @param {Error}
     */
    var sessionConnectFailed = function sessionConnectFailed(error) {
      setState('disconnected');

      if (!error.code) {
        error.code = ExceptionCodes.CONNECT_FAILED;
      }

      _logging.error((error.name || 'Unknown Error') + ': ' + error.message);

      this.trigger('sessionConnectFailed', error);

      OTErrorClass.handleJsException(error.message, error.code || ExceptionCodes.CONNECT_FAILED, { session: this });
    };

    var sessionDisconnectedHandler = function sessionDisconnectedHandler(event) {
      var reason = event.reason;
      this.logEvent('Connect', 'Disconnected', { reason: event.reason });

      var publicEvent = new Events.SessionDisconnectEvent('sessionDisconnected', reason);

      reset();
      disconnectComponents.call(this, reason);

      var defaultAction = function () {
        // Although part of the defaultAction for sessionDisconnected we have
        // chosen to still destroy Publishers within the session as there is
        // another mechanism to stop a Publisher from being destroyed.

        // Publishers use preventDefault on the Publisher streamDestroyed event
        destroyPublishers.call(this, publicEvent.reason);

        if (!publicEvent.isDefaultPrevented()) {
          destroySubscribers.call(this, publicEvent.reason);
        }
      }.bind(this);

      this.dispatchEvent(publicEvent, defaultAction);
    };

    var connectionCreatedHandler = function connectionCreatedHandler(connection) {
      // With connectionEventsSuppressed, connections objects are still added internally, but they
      // don't come from rumor messages, and can't have corresponding delete events, so we don't
      // emit created events.
      if (opt.connectionEventsSuppressed) {
        return;
      }

      // We don't broadcast events for the symphony connection
      if (connection.id.match(/^symphony\./)) {
        return;
      }

      this.dispatchEvent(new Events.ConnectionEvent(Events.Event.names.CONNECTION_CREATED, connection));
    };

    var connectionDestroyedHandler = function connectionDestroyedHandler(connection, reason) {
      // We don't broadcast events for the symphony connection
      if (connection.id.match(/^symphony\./)) {
        return;
      }

      // Don't delete the connection if it's ours. This only happens when
      // we're about to receive a session disconnected and session disconnected
      // will also clean up our connection.
      if (connection.id === _socket.id()) {
        return;
      }

      this.dispatchEvent(new Events.ConnectionEvent(Events.Event.names.CONNECTION_DESTROYED, connection, reason));
    };

    var streamCreatedHandler = function streamCreatedHandler(stream) {
      if (stream.connection.id !== this.connection.id) {
        this.dispatchEvent(new Events.StreamEvent(Events.Event.names.STREAM_CREATED, stream, null, false));
      }
    };

    var streamPropertyModifiedHandler = function streamPropertyModifiedHandler(event) {
      var stream = event.target;
      var propertyName = event.changedProperty;
      var newValue = event.newValue;

      if (propertyName === 'videoDisableWarning' || propertyName === 'audioDisableWarning') {
        return; // These are not public properties, skip top level event for them.
      }

      if (propertyName === 'videoDimensions') {
        newValue = { width: newValue.width, height: newValue.height };
      }

      this.dispatchEvent(new Events.StreamPropertyChangedEvent(Events.Event.names.STREAM_PROPERTY_CHANGED, stream, propertyName, event.oldValue, newValue));
    };

    var streamDestroyedHandler = function streamDestroyedHandler(stream, reason) {
      // if the stream is one of ours we delegate handling
      // to the publisher itself.
      if (stream.connection.id === this.connection.id) {
        sessionObjects.publishers.where({ streamId: stream.id }).forEach(function (publisher) {
          publisher._.unpublishStreamFromSession(stream, this, reason);
        }, this);

        return;
      }

      var event = new Events.StreamEvent('streamDestroyed', stream, reason, true);

      var defaultAction = function () {
        if (!event.isDefaultPrevented()) {
          // If we are subscribed to any of the streams we should unsubscribe
          sessionObjects.subscribers.where({ streamId: stream.id }).forEach(function (subscriber) {
            if (subscriber.session.id === this.id) {
              if (subscriber.stream) {
                subscriber.destroy('streamDestroyed');
              }
            }
          }, this);
        }
        // @TODO Add a else with a one time warning that this no longer cleans up the publisher
      }.bind(this);

      this.dispatchEvent(event, defaultAction);
    };

    var archiveCreatedHandler = function archiveCreatedHandler(archive) {
      this.dispatchEvent(new Events.ArchiveEvent('archiveStarted', archive));
    };

    var archiveDestroyedHandler = function archiveDestroyedHandler(archive) {
      this.dispatchEvent(new Events.ArchiveEvent('archiveDestroyed', archive));
    };

    var archiveUpdatedHandler = function archiveUpdatedHandler(event) {
      var archive = event.target;
      var propertyName = event.changedProperty;
      var newValue = event.newValue;

      if (propertyName === 'status' && newValue === 'stopped') {
        this.dispatchEvent(new Events.ArchiveEvent('archiveStopped', archive));
      } else {
        this.dispatchEvent(new Events.ArchiveEvent('archiveUpdated', archive));
      }
    };

    var init = function init() {
      _session.token = null;
      _token = null;
      setState('disconnected');
      _session.connection = null;
      _session.capabilities = new Capabilities([]);
      _session.connections.destroy();
      _session.streams.destroy();
      _session.archives.destroy();
    };

    // Put ourselves into a pristine state
    var reset = function reset() {
      // reset connection id now so that following calls to testNetwork and connect will share
      // the same new session id. We need to reset here because testNetwork might be call after
      // and it is always called before the session is connected
      // on initial connection we don't reset
      _connectionId = uuid();
      init();
    };

    var disconnectComponents = function disconnectComponents(reason) {
      sessionObjects.publishers.where({ session: this }).forEach(function (publisher) {
        publisher.disconnect(reason);
      });

      sessionObjects.subscribers.where({ session: this }).forEach(function (subscriber) {
        subscriber.disconnect();
      });
    };

    var destroyPublishers = function destroyPublishers(reason) {
      sessionObjects.publishers.where({ session: this }).forEach(function (publisher) {
        publisher._.streamDestroyed(reason);
      });
    };

    var destroySubscribers = function destroySubscribers(reason) {
      sessionObjects.subscribers.where({ session: this }).forEach(function (subscriber) {
        subscriber.destroy(reason);
      });
    };

    var connectMessenger = function connectMessenger() {
      var _this2 = this;

      _logging.debug('OT.Session: connecting to Raptor');

      var socketUrl = this.sessionInfo.messagingURL;
      var symphonyUrl = otProperties.symphonyAddresss || this.sessionInfo.symphonyAddress;

      _socket = new RaptorSocket(_connectionId, _widgetId, socketUrl, symphonyUrl, SessionDispatcher(this, opt));

      /*
       * Maps an error from RaptorSocket.connect to its corresponding name
       * @param {string} reason - Failure reason
       * @param {number} code - Error code
       * @return {string|undefined} Error name
       */
      function getErrorNameFromCode(reason, code) {
        switch (reason) {
          case 'WebSocketConnection':
            var name = OTHelpers.find(Object.keys(socketCloseErrors.codes), function (name) {
              return socketCloseErrors.codes[name] === code;
            });
            if (name) {
              return errors['SOCKET_' + name];
            }
            break;
          case 'ConnectToSession':
          case 'GetSessionState':
            switch (code) {
              case ExceptionCodes.CONNECT_FAILED:
                return errors.CONNECT_FAILED;
              case ExceptionCodes.UNEXPECTED_SERVER_RESPONSE:
                return errors.UNEXPECTED_SERVER_RESPONSE;
              case ExceptionCodes.CONNECTION_LIMIT_EXCEEDED:
                return errors.CONNECTION_LIMIT_EXCEEDED;
              default:
                break;
            }
            break;
          default:
            break;
        }
        return undefined;
      }

      var connectOpt = pick(opt, ['connectionEventsSuppressed']);

      _socket.connect(_token, this.sessionInfo, connectOpt, function (error, sessionState) {
        if (error) {
          var payload = omit(error, ['code', 'message', 'reason']);
          var options = void 0;

          if (error.reason === 'ConnectToSession' || error.reason === 'GetSessionState') {
            var converted = convertRumorError(error);
            error.code = converted.code;
            error.message = converted.message;

            _this2.logEvent('Connect', 'Failure', null, {
              failureReason: error.reason,
              failureCode: error.code,
              failureMessage: error.message,
              socketId: error.socketId
            });
          }

          if (error.code || error.message || error.reason) {
            options = {
              failureCode: error.code,
              failureMessage: error.message,
              failureReason: error.reason
            };
          }
          _socket = void 0;
          _this2.logConnectivityEvent('Failure', payload, options);

          var errorName = getErrorNameFromCode(error.reason, error.code);
          if (errorName) {
            error = otError(errorName, new Error(error.message), error.code);
          }

          sessionConnectFailed.call(_this2, error);
          return;
        }

        _logging.debug('OT.Session: Received session state from Raptor', sessionState);

        _this2.connection = _this2.connections.get(_socket.id());
        if (_this2.connection) {
          _this2.capabilities = _this2.connection.permissions;
        }

        setState('connected');

        _this2.logConnectivityEvent('Success', { connectionId: _this2.connection.id });

        // Listen for our own connection's destroyed event so we know when we've been disconnected.
        _this2.connection.on('destroyed', sessionDisconnectedHandler, _this2);

        _this2.dispatchEvent(new Events.SessionConnectEvent(Events.Event.names.SESSION_CONNECTED), function () {
          // Listen for connection updates
          _this2.connections.on({
            add: connectionCreatedHandler,
            remove: connectionDestroyedHandler
          }, _this2);

          // Listen for stream updates
          _this2.streams.on({
            add: streamCreatedHandler,
            remove: streamDestroyedHandler,
            update: streamPropertyModifiedHandler
          }, _this2);

          _this2.archives.on({
            add: archiveCreatedHandler,
            remove: archiveDestroyedHandler,
            update: archiveUpdatedHandler
          }, _this2);

          _this2.connections._triggerAddEvents(); // { id: this.connection.id }
          _this2.streams._triggerAddEvents(); // { id: this.stream.id }
          _this2.archives._triggerAddEvents();
        });
      });
    };

    var getSessionInfo = function getSessionInfo() {
      var _this3 = this;

      /*
       * Maps an error from SessionInfo.get to its corresponding name
       * @param {number} code - Error code
       * @return {string|undefined} Error name
       */
      function getErrorNameFromCode(code) {
        switch (code) {
          case ExceptionCodes.ANVIL_BADLY_FORMED_RESPONSE:
            return errors.BADLY_FORMED_RESPONSE;
          case ExceptionCodes.ANVIL_INVALID_HTTP_STATUS:
            return errors.INVALID_HTTP_STATUS;
          case ExceptionCodes.ANVIL_XDOMAIN_OR_PARSING_ERROR:
            return errors.XDOMAIN_OR_PARSING_ERROR;
          case ExceptionCodes.ANVIL_UNKNOWN_HTTP_ERROR:
            return errors.UNKNOWN_HTTP_ERROR;
          case ExceptionCodes.ANVIL_UNEXPECTED_ERROR_CODE:
            return errors.UNEXPECTED_ERROR_CODE;
          case ExceptionCodes.ANVIL_EMPTY_RESPONSE_BODY:
            return errors.EMPTY_RESPONSE_BODY;
          case ExceptionCodes.AUTHENTICATION_ERROR:
            return errors.AUTHENTICATION_ERROR;
          case ExceptionCodes.INVALID_SESSION_ID:
            return errors.INVALID_SESSION_ID;
          case ExceptionCodes.TERMS_OF_SERVICE_FAILURE:
            return errors.TERMS_OF_SERVICE_FAILURE;
          case ExceptionCodes.UNEXPECTED_SERVER_RESPONSE:
            return errors.UNEXPECTED_SERVER_RESPONSE;
          default:
            return undefined;
        }
      }

      if (this.is('connecting')) {
        this.logEvent('SessionInfo', 'Attempt');

        SessionInfo.get(sessionId, _token, _connectionId).then(onSessionInfoResponse, function (error) {
          var errorName = getErrorNameFromCode(error.code);
          error.code = convertAnvilErrorCode(error.code);

          _this3.logConnectivityEvent('Failure', null, {
            failureReason: 'GetSessionInfo',
            failureCode: error.code || 'No code',
            failureMessage: error.message
          });

          if (errorName) {
            var errorMessage = error.message + (error.code ? ' (' + error.code + ')' : '');
            error = otError(errorName, new Error(errorMessage), error.code);
          }

          sessionConnectFailed.call(_this3, error);
        });
      }
    };

    var onSessionInfoResponse = function (sessionInfo) {
      if (OTPlugin.hasOwnProperty('settings')) {
        OTPlugin.settings.usePreviousDeviceSelection = sessionInfo.rememberDeviceChoiceIE;
      }

      if (this.is('connecting')) {
        this.sessionInfo = sessionInfo;
        this._.setIceServers(this.sessionInfo.iceServers);
        _p2p = sessionInfo.p2pEnabled;
        _messagingServer = sessionInfo.messagingServer;
        this.logEvent('SessionInfo', 'Success', null, {
          features: {
            reconnection: OTHelpers.castToBoolean(sessionInfo.reconnection),
            renegotiation: OTHelpers.castToBoolean(hasIceRestartsCapability() && sessionInfo.renegotiation),
            simulcast: sessionInfo.simulcast === undefined ? false : sessionInfo.simulcast && OTHelpers.env.name === 'Chrome'
          }
        }, {
          messagingServer: sessionInfo.messagingServer
        });

        var overrides = otProperties.sessionInfoOverrides;
        if (overrides != null && (typeof overrides === 'undefined' ? 'undefined' : _typeof(overrides)) === 'object') {
          this.sessionInfo = OTHelpers.defaults(overrides, this.sessionInfo);
        }
        if (this.sessionInfo.partnerId && this.sessionInfo.partnerId !== _apiKey) {
          this.apiKey = this.sessionInfo.partnerId;
          _apiKey = this.sessionInfo.partnerId;

          var reason = 'Authentication Error: The API key does not match the token or session.';

          this.logEvent('SessionInfo', 'Failure', null, {
            failureCode: ExceptionCodes.AUTHENTICATION_ERROR,
            failureReason: 'Authentication',
            failureMessage: reason
          });

          sessionConnectFailed.call(this, otError(errors.AUTHENTICATION_ERROR, new Error(reason), ExceptionCodes.AUTHENTICATION_ERROR));
        } else {
          connectMessenger.call(this);
        }
      }
    }.bind(this);

    // Check whether we have permissions to perform the action.
    var permittedTo = function permittedTo(action) {
      return _this.capabilities.permittedTo(action);
    };

    var dispatchOTError = function dispatchOTError(error, completionHandler) {
      logging.error(error.name + ': ' + error.message);
      completionHandler(error);
      OTErrorClass.handleJsException(error.message, error.code, { session: _session });
    };

    this.logEvent = function (action, variation, payload, options) {
      var event = {
        action: action,
        variation: variation,
        payload: payload,
        sessionId: _sessionId,
        messagingServer: _messagingServer,
        p2p: _p2p,
        partnerId: _apiKey
      };

      event.connectionId = _connectionId;

      if (options) {
        event = OTHelpers.extend(options, event);
      }
      analytics.logEvent(event);
    };

    this.logConnectivityEvent = function (variation, payload, options) {
      if (variation === 'Attempt' || !_connectivityAttemptPinger) {
        _attemptStartTime = new Date().getTime();
        var pingerOptions = {
          action: 'Connect',
          sessionId: _sessionId,
          p2p: this.sessionInfo ? this.sessionInfo.p2pEnabled : null,
          messagingServer: this.sessionInfo ? this.sessionInfo.messagingServer : null,
          partnerId: _apiKey
        };
        if (this.connection && this.connection.id) {
          pingerOptions = this.connection.id;
          event.connectionId = this.connection.id;
        } else if (_connectionId) {
          pingerOptions.connectionId = _connectionId;
        }
        _connectivityAttemptPinger = new ConnectivityAttemptPinger(pingerOptions);
      }
      _connectivityAttemptPinger.setVariation(variation);
      if (variation === 'Failure' || variation === 'Success' || variation === 'Cancel') {
        if (!options) {
          options = {};
        }
        OTHelpers.extend(options, {
          attemptDuration: new Date().getTime() - _attemptStartTime
        });
      }
      this.logEvent('Connect', variation, payload, options);
    };

    /**
    * Connects to an OpenTok session.
    * <p>
    *  Upon a successful connection, the completion handler (the second parameter of the method) is
    *  invoked without an error object passed in. (If there is an error connecting, the completion
    *  handler is invoked with an error object.) Make sure that you have successfully connected to the
    *  session before calling other methods of the Session object.
    * </p>
    *  <p>
    *    The Session object dispatches a <code>connectionCreated</code> event when any client
    *    (including your own) connects to the session.
    *  </p>
    *
    *  <h5>
    *  Example
    *  </h5>
    *  <p>
    *  The following code initializes a session and sets up an event listener for when the session
    *  connects:
    *  </p>
    *  <pre>
    *  var apiKey = ""; // Replace with your API key. See https://tokbox.com/account
    *  var sessionID = ""; // Replace with your own session ID.
    *                      // See https://tokbox.com/developer/guides/create-session/.
    *  var token = ""; // Replace with a generated token.
    *                  // See https://tokbox.com/developer/guides/create-token/.
    *
    *  var session = OT.initSession(apiKey, sessionID);
    *  session.connect(token, function(error) {
    *    if (error) {
    *      console.log(error.message);
    *    } else {
    *      // You have connected to the session. You could publish a stream now.
    *    }
    *  });
    *  </pre>
    *  <p>
    *
    *  <h5>
    *  Events dispatched:
    *  </h5>
    *
    *  <p>
    *    <code>exception</code> (<a href="ExceptionEvent.html">ExceptionEvent</a>) &#151; Dispatched
    *    by the OT class locally in the event of an error.
    *  </p>
    *  <p>
    *    <code>connectionCreated</code> (<a href="ConnectionEvent.html">ConnectionEvent</a>) &#151;
    *      Dispatched by the Session object on all clients connected to the session.
    *  </p>
    *  <p>
    *    <code>sessionConnected</code> (<a href="SessionConnectEvent.html">SessionConnectEvent</a>)
    *      &#151; Dispatched locally by the Session object when the connection is established. However,
    *      you can pass a completion handler function in as the second parameter of the
    *      <code>connect()</code> and use this function instead of a listener for the
    *      <code>sessionConnected</code> event.
    *  </p>
    *
    * @param {String} token The session token. You generate a session token using our
    * <a href="https://tokbox.com/opentok/libraries/server/">server-side libraries</a> or at your
    * <a href="https://tokbox.com/account">TokBox account</a> page. For more information, see
    * <a href="https://tokbox.com/opentok/tutorials/create-token/">Connection token creation</a>.
    *
    * @param {Function} completionHandler (Optional) A function to be called when the call to the
    * <code>connect()</code> method succeeds or fails. This function takes one parameter &mdash;
    * <code>error</code> (see the <a href="Error.html">Error</a> object).
    * On success, the <code>completionHandler</code> function is not passed any
    * arguments. On error, the function is passed an <code>error</code> object parameter
    * (see the <a href="Error.html">Error</a> object). The
    * <code>error</code> object has two properties: <code>code</code> (an integer) and
    * <code>message</code> (a string), which identify the cause of the failure. The following
    * code adds a <code>completionHandler</code> when calling the <code>connect()</code> method:
    * <pre>
    * session.connect(token, function (error) {
    *   if (error) {
    *       console.log(error.message);
    *   } else {
    *     console.log("Connected to session.");
    *   }
    * });
    * </pre>
    * <p>
    * Note that upon connecting to the session, the Session object dispatches a
    * <code>sessionConnected</code> event in addition to calling the <code>completionHandler</code>.
    * The SessionConnectEvent object, which defines the <code>sessionConnected</code> event,
    * includes <code>connections</code> and <code>streams</code> properties, which
    * list the connections and streams in the session when you connect.
    * </p>
    *
    * @see SessionConnectEvent
    * @method #connect
    * @memberOf Session
    */
    this.connect = function (token) {
      if (arguments.length > 1 && (typeof arguments[0] === 'string' || typeof arguments[0] === 'number') && typeof arguments[1] === 'string') {
        if (apiKey == null) {
          _apiKey = token.toString();
        }
        token = arguments[1];
      }

      // The completion handler is always the last argument.
      var completionHandler = arguments[arguments.length - 1];

      if (this.is('connecting', 'connected')) {
        _logging.warn('OT.Session: Cannot connect, the session is already ' + this.state);
        return this;
      }

      init();
      setState('connecting');
      this.token = !OTHelpers.isFunction(token) && token;
      _token = !OTHelpers.isFunction(token) && token;

      // Get a new widget ID when reconnecting.
      if (_initialConnection) {
        _initialConnection = false;
      } else {
        _widgetId = uuid();
      }

      if (completionHandler && OTHelpers.isFunction(completionHandler)) {
        this.once('sessionConnected', completionHandler.bind(null, undefined));
        this.once('sessionConnectFailed', completionHandler);
      }

      if (_apiKey == null || OTHelpers.isFunction(_apiKey)) {
        setTimeout(sessionConnectFailed.bind(this, otError(errors.AUTHENTICATION_ERROR, new Error('API Key is undefined. You must pass an API Key to initSession.'), ExceptionCodes.AUTHENTICATION_ERROR)));

        return this;
      }

      this.logConnectivityEvent('Attempt');

      if (!_sessionId || OTHelpers.isObject(_sessionId) || Array.isArray(_sessionId)) {
        var errorMsg = void 0;
        if (!_sessionId) {
          errorMsg = 'SessionID is undefined. You must pass a sessionID to initSession.';
        } else {
          errorMsg = 'SessionID is not a string. You must use string as the session ID passed into ' + 'OT.initSession().';
          _sessionId = _sessionId.toString();
        }
        setTimeout(sessionConnectFailed.bind(this, otError(errors.INVALID_SESSION_ID, new Error(errorMsg), ExceptionCodes.INVALID_SESSION_ID)));

        this.logConnectivityEvent('Failure', null, {
          failureReason: 'ConnectToSession',
          failureCode: ExceptionCodes.INVALID_SESSION_ID,
          failureMessage: errorMsg
        });
        return this;
      }

      this.apiKey = _apiKey.toString();
      _apiKey = _apiKey.toString();

      // TODO: Ugly hack, make sure APIKEY is set
      if (APIKEY.value.length === 0) {
        APIKEY.value = _apiKey;
      }

      getSessionInfo.call(this);
      return this;
    };

    /**
    * Disconnects from the OpenTok session.
    *
    * <p>
    * Calling the <code>disconnect()</code> method ends your connection with the session. In the
    * course of terminating your connection, it also ceases publishing any stream(s) you were
    * publishing.
    * </p>
    * <p>
    * Session objects on remote clients dispatch <code>streamDestroyed</code> events for any
    * stream you were publishing. The Session object dispatches a <code>sessionDisconnected</code>
    * event locally. The Session objects on remote clients dispatch <code>connectionDestroyed</code>
    * events, letting other connections know you have left the session. The
    * {@link SessionDisconnectEvent} and {@link StreamEvent} objects that define the
    * <code>sessionDisconnect</code> and <code>connectionDestroyed</code> events each have a
    * <code>reason</code> property. The <code>reason</code> property lets the developer determine
    * whether the connection is being terminated voluntarily and whether any streams are being
    * destroyed as a byproduct of the underlying connection's voluntary destruction.
    * </p>
    * <p>
    * If the session is not currently connected, calling this method causes a warning to be logged.
    * See <a href="OT.html#setLogLevel">OT.setLogLevel()</a>.
    * </p>
    *
    * <p>
    * <i>Note:</i> If you intend to reuse a Publisher object created using
    * <code>OT.initPublisher()</code> to publish to different sessions sequentially, call either
    * <code>Session.disconnect()</code> or <code>Session.unpublish()</code>. Do not call both.
    * Then call the <code>preventDefault()</code> method of the Publisher's <code>streamDestroyed</code>
    * event object to prevent the Publisher object from being removed from the page. Be sure to
    * call <code>preventDefault()</code> only if the <code>connection.connectionId</code> property
    * of the Stream object in the event matches the <code>connection.connectionId</code> property of
    * your Session object (to ensure that you are preventing the default behavior for your published
    * streams, not for other streams that you subscribe to).
    * </p>
    *
    * <h5>
    * Events dispatched:
    * </h5>
    * <p>
    * <code>sessionDisconnected</code>
    * (<a href="SessionDisconnectEvent.html">SessionDisconnectEvent</a>)
    * &#151; Dispatched locally when the connection is disconnected.
    * </p>
    * <p>
    * <code>connectionDestroyed</code> (<a href="ConnectionEvent.html">ConnectionEvent</a>) &#151;
    * Dispatched on other clients, along with the <code>streamDestroyed</code> event (as warranted).
    * </p>
    *
    * <p>
    * <code>streamDestroyed</code> (<a href="StreamEvent.html">StreamEvent</a>) &#151;
    * Dispatched on other clients if streams are lost as a result of the session disconnecting.
    * </p>
    *
    * @method #disconnect
    * @memberOf Session
    */
    var disconnect = function disconnect(drainSocketBuffer) {
      if (_socket && _socket.isNot('disconnected')) {
        if (_socket.isNot('disconnecting')) {
          setState('disconnecting');
          _socket.disconnect(drainSocketBuffer);
        }
      } else {
        reset();
      }
    };

    this.disconnect = function (drainSocketBuffer) {
      disconnect(drainSocketBuffer !== void 0 ? drainSocketBuffer : true);
    };

    this.destroy = function (reason) {
      this.streams.destroy();
      this.connections.destroy();
      this.archives.destroy();
      disconnect(reason !== 'unloaded');
    };

    /**
    * The <code>publish()</code> method starts publishing an audio-video stream to the session.
    * The audio-video stream is captured from a local microphone and webcam. Upon successful
    * publishing, the Session objects on all connected clients dispatch the
    * <code>streamCreated</code> event.
    * </p>
    *
    * <!--JS-ONLY-->
    * <p>You pass a Publisher object as the one parameter of the method. You can initialize a
    * Publisher object by calling the <a href="OT.html#initPublisher">OT.initPublisher()</a>
    * method. Before calling <code>Session.publish()</code>.
    * </p>
    *
    * <p>This method takes an alternate form: <code>publish([targetElement:String,
    * properties:Object]):Publisher</code> &#151; In this form, you do <i>not</i> pass a Publisher
    * object into the function. Instead, you pass in a <code>targetElement</code> (the ID of the
    * DOM element that the Publisher will replace) and a <code>properties</code> object that
    * defines options for the Publisher (see <a href="OT.html#initPublisher">OT.initPublisher()</a>.)
    * The method returns a new Publisher object, which starts sending an audio-video stream to the
    * session. The remainder of this documentation describes the form that takes a single Publisher
    * object as a parameter.
    *
    * <p>
    *   A local display of the published stream is created on the web page by replacing
    *         the specified element in the DOM with a streaming video display. The video stream
    *         is automatically mirrored horizontally so that users see themselves and movement
    *         in their stream in a natural way. If the width and height of the display do not match
    *         the 4:3 aspect ratio of the video signal, the video stream is cropped to fit the
    *         display.
    * </p>
    *
    * <p>
    *   If calling this method creates a new Publisher object and the OpenTok library does not
    *   have access to the camera or microphone, the web page alerts the user to grant access
    *   to the camera and microphone.
    * </p>
    *
    * <p>
    * The OT object dispatches an <code>exception</code> event if the user's role does not
    * include permissions required to publish. For example, if the user's role is set to subscriber,
    * then they cannot publish. You define a user's role when you create the user token
    * (see <a href="https://tokbox.com/developer/guides/create-token/">Token creation overview</a>).
    * You pass the token string as a parameter of the <code>connect()</code> method of the Session
    * object. See <a href="ExceptionEvent.html">ExceptionEvent</a> and
    * <a href="OT.html#on">OT.on()</a>.
    * </p>
    *     <p>
    *     The application throws an error if the session is not connected.
    *     </p>
    *
    * <h5>Events dispatched:</h5>
    * <p>
    * <code>exception</code> (<a href="ExceptionEvent.html">ExceptionEvent</a>) &#151; Dispatched
    * by the OT object. This can occur when user's role does not allow publishing (the
    * <code>code</code> property of event object is set to 1500); it can also occur if the c
    * onnection fails to connect (the <code>code</code> property of event object is set to 1013).
    * WebRTC is a peer-to-peer protocol, and it is possible that connections will fail to connect.
    * The most common cause for failure is a firewall that the protocol cannot traverse.</li>
    * </p>
    * <p>
    * <code>streamCreated</code> (<a href="StreamEvent.html">StreamEvent</a>) &#151;
    * The stream has been published. The Session object dispatches this on all clients
    * subscribed to the stream, as well as on the publisher's client.
    * </p>
    *
    * <h5>Example</h5>
    *
    * <p>
    *   The following example publishes a video once the session connects:
    * </p>
    * <pre>
    * var apiKey = ""; // Replace with your API key. See https://tokbox.com/account
    * var sessionId = ""; // Replace with your own session ID.
    *                     // https://tokbox.com/developer/guides/create-session/.
    * var token = ""; // Replace with a generated token that has been assigned the publish role.
    *                 // See https://tokbox.com/developer/guides/create-token/.
    * var session = OT.initSession(apiKey, sessionID);
    * session.connect(token, function(error) {
    *   if (error) {
    *     console.log(error.message);
    *   } else {
    *     var publisherOptions = {width: 400, height:300, name:"Bob's stream"};
    *     // This assumes that there is a DOM element with the ID 'publisher':
    *     publisher = OT.initPublisher('publisher', publisherOptions);
    *     session.publish(publisher);
    *   }
    * });
    * </pre>
    *
    * @param {Publisher} publisher A Publisher object, which you initialize by calling the
    * <a href="OT.html#initPublisher">OT.initPublisher()</a> method.
    *
    * @param {Function} completionHandler (Optional) A function to be called when the call to the
    * <code>publish()</code> method succeeds or fails. This function takes one parameter &mdash;
    * <code>error</code>. On success, the <code>completionHandler</code> function is not passed any
    * arguments. On error, the function is passed an <code>error</code> object parameter
    * (see the <a href="Error.html">Error</a> object). The
    * <code>error</code> object has two properties: <code>code</code> (an integer) and
    * <code>message</code> (a string), which identify the cause of the failure. Calling
    * <code>publish()</code> fails if the role assigned to your token is not "publisher" or
    * "moderator"; in this case the <code>error.name</code> property is set to
    * <code>"OT_PERMISSION_DENIED"</code>. Calling <code>publish()</code> also fails if the
    * client fails to connect; in this case the <code>error.name</code> property is set to
    * <code>"OT_NOT_CONNECTED"</code>. The following code adds a completion handler when
    * calling the <code>publish()</code> method:
    * <pre>
    * session.publish(publisher, null, function (error) {
    *   if (error) {
    *     console.log(error.message);
    *   } else {
    *     console.log("Publishing a stream.");
    *   }
    * });
    * </pre>
    *
    * @returns The Publisher object for this stream.
    *
    * @method #publish
    * @memberOf Session
    */
    this.publish = function (publisher, properties, completionHandler) {
      if (typeof publisher === 'function') {
        completionHandler = publisher;
        publisher = undefined;
      }

      if (typeof properties === 'function') {
        completionHandler = properties;
        properties = undefined;
      }

      completionHandler = completionHandler || function () {};

      if (this.isNot('connected')) {
        analytics.logError(1010, 'OT.exception', 'We need to be connected before you can publish', null, {
          action: 'Publish',
          variation: 'Failure',
          failureReason: 'unconnected',
          failureCode: ExceptionCodes.NOT_CONNECTED,
          failureMessage: 'We need to be connected before you can publish',
          sessionId: _sessionId,
          streamId: publisher && publisher.stream ? publisher.stream.id : null,
          p2p: this.sessionInfo ? this.sessionInfo.p2pEnabled : undefined,
          messagingServer: this.sessionInfo ? this.sessionInfo.messagingServer : null,
          partnerId: _apiKey
        });

        dispatchOTError(otError(errors.NOT_CONNECTED, new Error('We need to be connected before you can publish'), ExceptionCodes.NOT_CONNECTED), completionHandler);

        return null;
      }

      if (!permittedTo('publish')) {
        var errorMessage = 'This token does not allow publishing. The role must be at least ' + '`publisher` to enable this functionality';
        var options = {
          failureReason: 'Permission',
          failureCode: ExceptionCodes.UNABLE_TO_PUBLISH,
          failureMessage: errorMessage
        };
        this.logEvent('Publish', 'Failure', null, options);

        dispatchOTError(otError(errors.PERMISSION_DENIED, new Error(errorMessage), ExceptionCodes.UNABLE_TO_PUBLISH), completionHandler);

        return null;
      }

      // If the user has passed in an ID of a element then we create a new publisher.
      if (!publisher || typeof publisher === 'string' || OTHelpers.isElementNode(publisher)) {
        // Initiate a new Publisher with the new session credentials
        publisher = initPublisher(publisher, properties);
      } else if (publisher instanceof Publisher) {
        // If the publisher already has a session attached to it we can
        if ('session' in publisher && publisher.session && 'sessionId' in publisher.session) {
          // send a warning message that we can't publish again.
          if (publisher.session.sessionId === this.sessionId) {
            _logging.warn('Cannot publish ' + publisher.guid() + ' again to ' + this.sessionId + '. Please call session.unpublish(publisher) first.');
          } else {
            _logging.warn('Cannot publish ' + publisher.guid() + ' publisher already attached to ' + publisher.session.sessionId + '. Please call session.unpublish(publisher) first.');
          }
        }
      } else {
        dispatchOTError(otError(errors.INVALID_PARAMETER, new Error('Session.publish :: First parameter passed in is neither a ' + 'string nor an instance of the Publisher'), ExceptionCodes.UNABLE_TO_PUBLISH), completionHandler);

        return undefined;
      }

      // Add publisher reference to the session
      publisher._.publishToSession(this).catch(function (err) {
        err.message = 'Session.publish :: ' + err.message;
        _logging.error(err.code, err.message);
        throw err;
      }).then(function () {
        return publisher;
      }).asCallback(completionHandler);

      // return the embed publisher
      return publisher;
    };

    /**
    * Ceases publishing the specified publisher's audio-video stream
    * to the session. By default, the local representation of the audio-video stream is
    * removed from the web page. Upon successful termination, the Session object on every
    * connected web page dispatches
    * a <code>streamDestroyed</code> event.
    * </p>
    *
    * <p>
    * To prevent the Publisher from being removed from the DOM, add an event listener for the
    * <code>streamDestroyed</code> event dispatched by the Publisher object and call the
    * <code>preventDefault()</code> method of the event object.
    * </p>
    *
    * <p>
    * <i>Note:</i> If you intend to reuse a Publisher object created using
    * <code>OT.initPublisher()</code> to publish to different sessions sequentially, call
    * either <code>Session.disconnect()</code> or <code>Session.unpublish()</code>. Do not call
    * both. Then call the <code>preventDefault()</code> method of the <code>streamDestroyed</code>
    * or <code>sessionDisconnected</code> event object to prevent the Publisher object from being
    * removed from the page. Be sure to call <code>preventDefault()</code> only if the
    * <code>connection.connectionId</code> property of the Stream object in the event matches the
    * <code>connection.connectionId</code> property of your Session object (to ensure that you are
    * preventing the default behavior for your published streams, not for other streams that you
    * subscribe to).
    * </p>
    *
    * <h5>Events dispatched:</h5>
    *
    * <p>
    * <code>streamDestroyed</code> (<a href="StreamEvent.html">StreamEvent</a>) &#151;
    * The stream associated with the Publisher has been destroyed. Dispatched on by the
    * Publisher on on the Publisher's browser. Dispatched by the Session object on
    * all other connections subscribing to the publisher's stream.
    * </p>
    *
    * <h5>Example</h5>
    *
    * The following example publishes a stream to a session and adds a Disconnect link to the
    * web page. Clicking this link causes the stream to stop being published.
    *
    * <pre>
    * &lt;script&gt;
    *   var apiKey = ""; // Replace with your API key. See https://tokbox.com/account
    *   var sessionID = ""; // Replace with your own session ID.
    *                    // See https://tokbox.com/developer/guides/create-session/.
    *   var token = ""; // Replace with a generated token.
    *                   // See https://tokbox.com/developer/guides/create-token/.
    *   var publisher;
    *   var session = OT.initSession(apiKey, sessionID);
    *   session.connect(token, function(error) {
    *     if (error) {
    *       console.log(error.message);
    *     } else {
    *       // This assumes that there is a DOM element with the ID 'publisher':
    *       publisher = OT.initPublisher('publisher');
    *       session.publish(publisher);
    *     }
    *   });
    *
    *   function unpublish() {
    *     session.unpublish(publisher);
    *   }
    * &lt;/script&gt;
    *
    * &lt;body&gt;
    *
    *     &lt;div id="publisherContainer/&gt;
    *     &lt;br/&gt;
    *
    *     &lt;a href="javascript:unpublish()"&gt;Stop Publishing&lt;/a&gt;
    *
    * &lt;/body&gt;
    *
    * </pre>
    *
    * @see <a href="#publish">publish()</a>
    *
    * @see <a href="StreamEvent.html">streamDestroyed event</a>
    *
    * @param {Publisher} publisher</span> The Publisher object to stop streaming.
    *
    * @method #unpublish
    * @memberOf Session
    */
    this.unpublish = function (publisher) {
      if (!publisher) {
        _logging.error('OT.Session.unpublish: publisher parameter missing.');
        return;
      }

      // Unpublish the localMedia publisher
      publisher._.unpublishFromSession(this, 'unpublished');
    };

    /**
    * Subscribes to a stream that is available to the session. You can get an array of
    * available streams from the <code>streams</code> property of the <code>sessionConnected</code>
    * and <code>streamCreated</code> events (see
    * <a href="SessionConnectEvent.html">SessionConnectEvent</a> and
    * <a href="StreamEvent.html">StreamEvent</a>).
    * </p>
    * <p>
    * The subscribed stream is displayed on the local web page by replacing the specified element
    * in the DOM with a streaming video display. If the width and height of the display do not
    * match the 4:3 aspect ratio of the video signal, the video stream is cropped to fit
    * the display. If the stream lacks a video component, a blank screen with an audio indicator
    * is displayed in place of the video stream.
    * </p>
    *
    * <p>
    * The application throws an error if the session is not connected<!--JS-ONLY--> or if the
    * <code>targetElement</code> does not exist in the HTML DOM<!--/JS-ONLY-->.
    * </p>
    *
    * <h5>Example</h5>
    *
    * The following code subscribes to other clients' streams:
    *
    * <pre>
    * var apiKey = ""; // Replace with your API key. See https://tokbox.com/account
    * var sessionID = ""; // Replace with your own session ID.
    *                     // See https://tokbox.com/developer/guides/create-session/.
    * var token = ""; // Replace with a generated token.
    *                 // See https://tokbox.com/developer/guides/create-token/.
    *
    * var session = OT.initSession(apiKey, sessionID);
    * session.on("streamCreated", function(event) {
    *   subscriber = session.subscribe(event.stream, targetElement);
    * });
    * session.connect(token);
    * </pre>
    *
    * @param {Stream} stream The Stream object representing the stream to which we are trying to
    * subscribe.
    *
    * @param {Object} targetElement (Optional) The DOM element or the <code>id</code> attribute of
    * the existing DOM element used to determine the location of the Subscriber video in the HTML
    * DOM. See the <code>insertMode</code> property of the <code>properties</code> parameter. If
    * you do not specify a <code>targetElement</code>, the application appends a new DOM element
    * to the HTML <code>body</code>.
    *
    * @param {Object} properties This is an object that contains the following properties:
    *    <ul>
    *       <li><code>audioVolume</code> (Number) &#151; The desired audio volume, between 0 and
    *       100, when the Subscriber is first opened (default: 50). After you subscribe to the
    *       stream, you can adjust the volume by calling the
    *       <a href="Subscriber.html#setAudioVolume"><code>setAudioVolume()</code> method</a> of the
    *       Subscriber object. This volume setting affects local playback only; it does not affect
    *       the stream's volume on other clients.</li>
    *
    *       <li>
    *         <code>fitMode</code> (String) &#151; Determines how the video is displayed if the its
    *           dimensions do not match those of the DOM element. You can set this property to one of
    *           the following values:
    *           <p>
    *           <ul>
    *             <li>
    *               <code>"cover"</code> &mdash; The video is cropped if its dimensions do not match
    *               those of the DOM element. This is the default setting for videos that have a
    *               camera as the source (for Stream objects with the <code>videoType</code> property
    *               set to <code>"camera"</code>).
    *             </li>
    *             <li>
    *               <code>"contain"</code> &mdash; The video is letterboxed if its dimensions do not
    *               match those of the DOM element. This is the default setting for screen-sharing
    *               videos (for Stream objects with the <code>videoType</code> property set to
    *               <code>"screen"</code>).
    *             </li>
    *           </ul>
    *       </li>
    *
    *       <li>
    *       <code>height</code> (Number) &#151; The desired initial height of the displayed
    *       video in the HTML page (default: 198 pixels). You can specify the number of pixels as
    *       either a number (such as 300) or a string ending in "px" (such as "300px"). Or you can
    *       specify a percentage of the size of the parent element, with a string ending in "%"
    *       (such as "100%"). <i>Note:</i> To resize the video, adjust the CSS of the subscriber's
    *       DOM element (the <code>element</code> property of the Subscriber object) or (if the
    *       height is specified as a percentage) its parent DOM element (see
    *       <a href="https://tokbox.com/developer/guides/customize-ui/js/#video_resize_reposition">
    *       Resizing or repositioning a video</a>).
    *       </li>
    *       <li>
    *       <strong>insertDefaultUI</strong> (Boolean) &#151; Whether to use the default OpenTok UI
    *       (<code>true</code>, the default) or not (<code>false</code>). The default UI element
    *       contains user interface controls, a video loading indicator, and automatic video cropping
    *       or letterboxing, in addition to the video. (If you leave <code>insertDefaultUI</code>
    *       set to <code>true</code>, you can control individual UI settings using the
    *       <code>fitMode</code>, <code>showControls</code>, and <code>style</code> options.)
    *       <p>
    *       If you set this option to <code>false</code>, OpenTok.js does not insert a default UI
    *       element in the HTML DOM, and the <code>element</code> property of the Subscriber object is
    *       undefined. The Subscriber object dispatches a
    *       <a href="Subscriber.html#event:videoElementCreated">videoElementCreated</a> event when
    *       the <code>video</code> element (or in Internet Explorer the <code>object</code> element
    *       containing the video) is created. The <code>element</code> property of the event object
    *       is a reference to the Subscriber's <code>video</code> (or <code>object</code>) element.
    *       Add it to the HTML DOM to display the video.
    *       <p>
    *       Set this option to <code>false</code> if you want to move the Publisher's
    *       <code>video</code> element (or its <code>object</code> element in Internet Explorer) in
    *       the HTML DOM.
    *       <p>
    *       If you set this to <code>false</code>, do not set the <code>targetElement</code>
    *       parameter. (This results in an error passed into to the <code>OT.initPublisher()</code>
    *       callback function.) To add the video to the HTML DOM, add an event listener for the
    *       <code>videoElementCreated</code> event, and then add the <code>element</code> property of
    *       the event object into the HTML DOM.
    *       </li>
    *       <li>
    *         <code>insertMode</code> (String) &#151; Specifies how the Subscriber object will
    *         be inserted in the HTML DOM. See the <code>targetElement</code> parameter. This
    *         string can have the following values:
    *         <p>
    *         <ul>
    *           <li><code>"replace"</code> &#151; The Subscriber object replaces contents of the
    *             targetElement. This is the default.</li>
    *           <li><code>"after"</code> &#151; The Subscriber object is a new element inserted
    *             after the targetElement in the HTML DOM. (Both the Subscriber and targetElement
    *             have the same parent element.)</li>
    *           <li><code>"before"</code> &#151; The Subscriber object is a new element inserted
    *             before the targetElement in the HTML DOM. (Both the Subsciber and targetElement
    *             have the same parent element.)</li>
    *           <li><code>"append"</code> &#151; The Subscriber object is a new element added as a
    *             child of the targetElement. If there are other child elements, the Subscriber is
    *             appended as the last child element of the targetElement.</li>
    *         </ul></p>
    *   <p> Do not move the publisher element or its parent elements in the DOM
    *   heirarchy. Use CSS to resize or reposition the publisher video's element
    *   (the <code>element</code> property of the Publisher object) or its parent element (see
    *   <a href="https://tokbox.com/developer/guides/customize-ui/js/#video_resize_reposition">
    *   Resizing or repositioning a video</a>).</p>
    *   </li>
    *   <li>
    *   <code>preferredFrameRate</code> (Number) &#151; The preferred frame rate of the subscriber's
    *   video. Lowering the preferred frame rate lowers video quality on the subscribing client,
    *   but it also reduces network and CPU usage. You may want to use a lower frame rate for
    *   subscribers to a stream that is less important than other streams.
    *   <p>
    *   Not every frame rate is available to a subscriber. When you set the preferred frame rate for
    *   the subscriber, OpenTok.js picks the best frame rate available that matches your setting.
    *   The frame rates available are based on the value of the Subscriber object's
    *   <code>stream.frameRate</code> property, which represents the maximum value available for the
    *   stream. The actual frame rates available depend, dynamically, on network and CPU resources
    *   available to the publisher and subscriber.
    *   <p>
    *   You can dynamically change the preferred frame rate used by calling the
    *   <code>setPreferredFrameRate()</code> method of the Subscriber object.
    *   </li>
    *   <li>
    *   <code>preferredResolution</code> (Object) &#151; The preferred resolution of the subscriber's
    *   video. Set this to an object with two properties: <code>width</code> and <code>height</code>
    *   (both numbers), such as <code>{width: 320, height: 240}</code>. Lowering the preferred video
    *   resolution lowers video quality on the subscribing client, but it also reduces network and CPU
    *   usage. You may want to use a lower resolution based on the dimensions of subscriber's video on
    *   the web page. You may want to use a resolution for subscribers to a stream that is less
    *   important (and smaller) than other streams.
    *   <p>
    *   Not every resolution is available to a subscriber. When you set the preferred resolution,
    *   OpenTok.js and the video encoder pick the best resolution available that matches your
    *   setting. The resolutions available depend on the resolution of the published stream.
    *   The Subscriber object's <code>stream.resolution</code> property  represents the highest
    *   resolution available for the stream. Each of the resolutions available for a stream will use
    *   the same aspect ratio. The actual resolutions available depend, dynamically, on network
    *   and CPU resources available to the publisher and subscriber.
    *   <p>
    *   You can dynamically change the preferred video resolution used by calling the
    *   <code>setPreferredResolution()</code> method of the Subscriber object.
    *   </li>
    *   <li>
    *   <code>showControls</code> (Boolean) &#151; Whether to display the built-in user interface
    *   controls for the Subscriber (default: <code>true</code>). These controls include the name
    *   display, the audio level indicator, the speaker control button, the video disabled indicator,
    *   and the video disabled warning icon. You can turn off all user interface controls by setting
    *   this property to <code>false</code>. You can control the display of individual user interface
    *   controls by leaving this property set to <code>true</code> (the default) and setting
    *   individual properties of the <code>style</code> property.
    *   </li>
    *   <li>
    *   <code>style</code> (Object) &#151; An object containing properties that define the initial
    *   appearance of user interface controls of the Subscriber. The <code>style</code> object
    *   includes the following properties:
    *     <ul>
    *       <li><code>audioLevelDisplayMode</code> (String) &mdash; How to display the audio level
    *       indicator. Possible values are: <code>"auto"</code> (the indicator is displayed when the
    *       video is disabled), <code>"off"</code> (the indicator is not displayed), and
    *       <code>"on"</code> (the indicator is always displayed).</li>
    *
    *       <li><code>backgroundImageURI</code> (String) &mdash; A URI for an image to display as
    *       the background image when a video is not displayed. (A video may not be displayed if
    *       you call <code>subscribeToVideo(false)</code> on the Subscriber object). You can pass an
    *       http or https URI to a PNG, JPEG, or non-animated GIF file location. You can also use the
    *       <code>data</code> URI scheme (instead of http or https) and pass in base-64-encrypted
    *       PNG data, such as that obtained from the
    *       <a href="Subscriber.html#getImgData">Subscriber.getImgData()</a> method. (For example,
    *       you could set the property to a value returned by calling <code>getImgData()</code> on
    *       a previous Subscriber object.) If the URL or the image data is invalid, the
    *       property is ignored (the attempt to set the image fails silently).</li>
    *
    *       <li><code>buttonDisplayMode</code> (String) &mdash; How to display the speaker controls
    *       Possible values are: <code>"auto"</code> (controls are displayed when the stream is first
    *       displayed and when the user mouses over the display), <code>"off"</code> (controls are not
    *       displayed), and <code>"on"</code> (controls are always displayed).</li>
    *
    *       <li><code>nameDisplayMode</code> (String) &#151; Whether to display the stream name.
    *       Possible values are: <code>"auto"</code> (the name is displayed when the stream is first
    *       displayed and when the user mouses over the display), <code>"off"</code> (the name is not
    *       displayed), and <code>"on"</code> (the name is always displayed).</li>
    *
    *       <li><code>videoDisabledDisplayMode</code> (String) &#151; Whether to display the video
    *       disabled indicator and video disabled warning icons for a Subscriber. These icons
    *       indicate that the video has been disabled (or is in risk of being disabled for
    *       the warning icon) due to poor stream quality. This style only applies to the Subscriber
    *       object. Possible values are: <code>"auto"</code> (the icons are automatically when the
    *       displayed video is disabled or in risk of being disabled due to poor stream quality),
    *       <code>"off"</code> (do not display the icons), and <code>"on"</code> (display the
    *       icons). The default setting is <code>"auto"</code></li>
    *   </ul>
    *   </li>
    *
    *       <li><code>subscribeToAudio</code> (Boolean) &#151; Whether to initially subscribe to audio
    *       (if available) for the stream (default: <code>true</code>).</li>
    *
    *       <li><code>subscribeToVideo</code> (Boolean) &#151; Whether to initially subscribe to video
    *       (if available) for the stream (default: <code>true</code>).</li>
    *
    *       <li><code>testNetwork</code> (Boolean) &#151; Whether, when subscribing to a stream
    *       published by the local client, you want to have the stream come from the OpenTok Media
    *       Router (<code>true</code>) or if you want the DOM to simply to display the local camera's
    *       video (<code>false</code>). Set this to <code>true</code> when you want to use the
    *       <a href="Subscriber.html#getStats">Subscriber.getStats()</a> method to check statistics
    *       for a stream you publish. This setting only applies to streams published by the local
    *       client in a session that uses the OpenTok Media Router (sessions with the
    *       <a href="http://tokbox.com/opentok/tutorials/create-session/#media-mode">media mode</a>
    *       set to routed), not in sessions with the media mode set to relayed. The default value is
    *       <code>false</code>.</li>
    *
    *       <li>
    *       <code>width</code> (Number) &#151; The desired initial width of the displayed
    *       video in the HTML page (default: 264 pixels). You can specify the number of pixels as
    *       either a number (such as 400) or a string ending in "px" (such as "400px"). Or you can
    *       specify a percentage of the size of the parent element, with a string ending in "%"
    *       (such as "100%"). <i>Note:</i> To resize the video, adjust the CSS of the subscriber's
    *       DOM element (the <code>element</code> property of the Subscriber object) or (if the
    *       width is specified as a percentage) its parent DOM element (see
    *       <a href="https://tokbox.com/developer/guides/customize-ui/js/#video_resize_reposition">
    *       Resizing or repositioning a video</a>).
    *       </li>
    *
    *    </ul>
    *
    * @param {Function} completionHandler (Optional) A function to be called when the call to the
    * <code>subscribe()</code> method succeeds or fails. This function takes one parameter &mdash;
    * <code>error</code>. On success, the <code>completionHandler</code> function is not passed any
    * arguments. On error, the function is passed an <code>error</code> object, defined by the
    * <a href="Error.html">Error</a> class, has two properties: <code>code</code> (an integer) and
    * <code>message</code> (a string), which identify the cause of the failure. The following
    * code adds a <code>completionHandler</code> when calling the <code>subscribe()</code> method:
    * <pre>
    * session.subscribe(stream, "subscriber", null, function (error) {
    *   if (error) {
    *     console.log(error.message);
    *   } else {
    *     console.log("Subscribed to stream: " + stream.id);
    *   }
    * });
    * </pre>
    *
    * @signature subscribe(stream, targetElement, properties, completionHandler)
    * @returns {Subscriber} The Subscriber object for this stream. Stream control functions
    * are exposed through the Subscriber object.
    * @method #subscribe
    * @memberOf Session
    */
    this.subscribe = function (stream, targetElement, properties, completionHandler) {
      if (typeof targetElement === 'function') {
        completionHandler = targetElement;
        targetElement = undefined;
        properties = undefined;
      }

      if (typeof properties === 'function') {
        completionHandler = properties;
        properties = undefined;
      }

      completionHandler = completionHandler || function () {};

      if (!this.connection || !this.connection.connectionId) {
        dispatchOTError(otError(errors.NOT_CONNECTED, new Error('Session.subscribe :: Connection required to subscribe'), ExceptionCodes.UNABLE_TO_SUBSCRIBE), completionHandler);

        return undefined;
      }

      if (!stream) {
        dispatchOTError(otError(errors.INVALID_PARAMETER, new Error('Session.subscribe :: stream cannot be null'), ExceptionCodes.UNABLE_TO_SUBSCRIBE), completionHandler);

        return undefined;
      }

      if (!stream.hasOwnProperty('streamId')) {
        dispatchOTError(otError(errors.INVALID_PARAMETER, new Error('Session.subscribe :: invalid stream object'), ExceptionCodes.UNABLE_TO_SUBSCRIBE), completionHandler);

        return undefined;
      }

      if (properties && properties.insertDefaultUI === false && targetElement) {
        dispatchOTError(otError(errors.INVALID_PARAMETER, new Error('You cannot specify a target element if insertDefaultUI is false'), ExceptionCodes.INVALID_PARAMETER), completionHandler);

        return undefined;
      }

      if (targetElement && targetElement.insertDefaultUI === false) {
        // You can omit the targetElement property if you set insertDefaultUI to false
        properties = targetElement;
        targetElement = undefined;
      }

      var subscriber = new Subscriber(targetElement, OTHelpers.extend(properties || {}, {
        stream: stream,
        session: this
      }), function (err) {
        if (err) {
          dispatchOTError(err, completionHandler);
          return;
        }

        completionHandler(null, subscriber);
      });

      sessionObjects.subscribers.add(subscriber);

      return subscriber;
    };

    /**
    * Stops subscribing to a stream in the session. the display of the audio-video stream is
    * removed from the local web page.
    *
    * <h5>Example</h5>
    * <p>
    * The following code subscribes to other clients' streams. For each stream, the code also
    * adds an Unsubscribe link.
    * </p>
    * <pre>
    * var apiKey = ""; // Replace with your API key. See See https://tokbox.com/account
    * var sessionID = ""; // Replace with your own session ID.
    *                     // See https://tokbox.com/developer/guides/create-session/.
    * var token = ""; // Replace with a generated token.
    *                 // See https://tokbox.com/developer/guides/create-token/.
    * var streams = [];
    *
    * var session = OT.initSession(apiKey, sessionID);
    * session.on("streamCreated", function(event) {
    *     var stream = event.stream;
    *     displayStream(stream);
    * });
    * session.connect(token);
    *
    * function displayStream(stream) {
    *     var div = document.createElement('div');
    *     div.setAttribute('id', 'stream' + stream.streamId);
    *
    *     var subscriber = session.subscribe(stream, div);
    *     subscribers.push(subscriber);
    *
    *     var aLink = document.createElement('a');
    *     aLink.setAttribute('href', 'javascript: unsubscribe("' + subscriber.id + '")');
    *     aLink.innerHTML = "Unsubscribe";
    *
    *     var streamsContainer = document.getElementById('streamsContainer');
    *     streamsContainer.appendChild(div);
    *     streamsContainer.appendChild(aLink);
    *
    *     streams = event.streams;
    * }
    *
    * function unsubscribe(subscriberId) {
    *     console.log("unsubscribe called");
    *     for (var i = 0; i &lt; subscribers.length; i++) {
    *         var subscriber = subscribers[i];
    *         if (subscriber.id == subscriberId) {
    *             session.unsubscribe(subscriber);
    *         }
    *     }
    * }
    * </pre>
    *
    * @param {Subscriber} subscriber The Subscriber object to unsubcribe.
    *
    * @see <a href="#subscribe">subscribe()</a>
    *
    * @method #unsubscribe
    * @memberOf Session
    */
    this.unsubscribe = function (subscriber) {
      if (!subscriber) {
        var errorMsg = 'OT.Session.unsubscribe: subscriber cannot be null';
        _logging.error(errorMsg);
        throw new Error(errorMsg);
      }

      if (!subscriber.stream) {
        _logging.warn('OT.Session.unsubscribe:: tried to unsubscribe a subscriber that had no stream');
        return false;
      }

      _logging.debug('OT.Session.unsubscribe: subscriber ' + subscriber.id);

      subscriber.destroy();

      return true;
    };

    /**
    * Returns an array of local Subscriber objects for a given stream.
    *
    * @param {Stream} stream The stream for which you want to find subscribers.
    *
    * @returns {Array} An array of {@link Subscriber} objects for the specified stream.
    *
    * @see <a href="#unsubscribe">unsubscribe()</a>
    * @see <a href="Subscriber.html">Subscriber</a>
    * @see <a href="StreamEvent.html">StreamEvent</a>
    * @method #getSubscribersForStream
    * @memberOf Session
    */
    this.getSubscribersForStream = function (stream) {
      return sessionObjects.subscribers.where({ streamId: stream.id });
    };

    /**
    * Returns the local Publisher object for a given stream.
    *
    * @param { Stream } stream The stream for which you want to find the Publisher.
    *
    * @returns { Publisher } A Publisher object for the specified stream. Returns
    * <code>null</code> if there is no local Publisher object
    * for the specified stream.
    *
    * @see <a href="#forceUnpublish">forceUnpublish()</a>
    * @see <a href="Subscriber.html">Subscriber</a>
    * @see <a href="StreamEvent.html">StreamEvent</a>
    *
    * @method #getPublisherForStream
    * @memberOf Session
    */
    this.getPublisherForStream = function (stream) {
      var streamId = void 0,
          errorMsg = void 0;

      if (typeof stream === 'string') {
        streamId = stream;
      } else if ((typeof stream === 'undefined' ? 'undefined' : _typeof(stream)) === 'object' && stream && stream.hasOwnProperty('id')) {
        streamId = stream.id;
      } else {
        errorMsg = 'Session.getPublisherForStream :: Invalid stream type';
        _logging.error(errorMsg);
        throw new Error(errorMsg);
      }

      return sessionObjects.publishers.where({ streamId: streamId })[0];
    };

    // Private Session API: for internal OT use only

    this._ = {
      getSocket: function getSocket() {
        return _socket;
      },


      reconnecting: function () {
        this.dispatchEvent(new Events.SessionReconnectingEvent());
      }.bind(this),

      reconnected: function () {
        this.dispatchEvent(new Events.SessionReconnectedEvent());

        if (this.sessionInfo.renegotiation) {
          sessionObjects.publishers.where({ session: this }).forEach(function (publisher) {
            publisher._.iceRestart();
          });
          sessionObjects.subscribers.where({ session: this }).forEach(function (subscriber) {
            subscriber._.iceRestart();
          });
        }
      }.bind(this),

      // session.on("signal", function(SignalEvent))
      // session.on("signal:{type}", function(SignalEvent))
      dispatchSignal: function (fromConnection, type, data) {
        var event = new Events.SignalEvent(type, data, fromConnection);
        event.target = this;

        // signal a "signal" event
        // NOTE: trigger doesn't support defaultAction, and therefore preventDefault.
        this.trigger(Events.Event.names.SIGNAL, event);

        // signal an "signal:{type}" event" if there was a custom type
        if (type) {
          this.dispatchEvent(event);
        }
      }.bind(this),

      subscriberChannelUpdate: function subscriberChannelUpdate(stream, subscriber, channel, attributes) {
        return _socket.subscriberChannelUpdate(stream.id, subscriber.widgetId, channel.id, attributes);
      },
      streamCreate: function streamCreate(name, streamId, audioFallbackEnabled, channels, minBitrate, completion) {
        _socket.streamCreate(name, streamId, audioFallbackEnabled, channels, minBitrate, void 0, // Do not expose maxBitrate to the end user
        completion);
      },
      streamDestroy: function streamDestroy(streamId) {
        _socket.streamDestroy(streamId);
      },
      streamChannelUpdate: function streamChannelUpdate(stream, channel, attributes) {
        _socket.streamChannelUpdate(stream.id, channel.id, attributes);
      },


      // allow these variables to be overridden in unit tests
      // it's dirty, but I figure it can be cleaned up when we implement proper DI for our unit tests
      setSocket: function setSocket(newSocket) {
        _socket = newSocket;
      },
      setLogging: function setLogging(newLogging) {
        _logging = newLogging;
      },


      setState: setState,

      setIceServers: function setIceServers(iceServers) {
        if (!iceServers) {
          return;
        }

        _iceServerDetails = {
          iceServers: adaptIceServers(iceServers),
          timestamp: Date.now()
        };
      },
      getIceServers: function getIceServers() {
        var timeElapsed = !_iceServerDetails ? Infinity : Date.now() - _iceServerDetails.timestamp;
        var validDuration = 24 * 60 * 60 * 1000; // 24 hours
        var validTimeRemaining = validDuration - timeElapsed;
        var fiveMinutes = 5 * 60 * 1000;

        if (validTimeRemaining > fiveMinutes) {
          return Bluebird.resolve(_iceServerDetails.iceServers);
        }

        if (!_token) {
          return Bluebird.reject(new Error('Don\'t have a token for getting ice servers'));
        }

        return SessionInfo.get(sessionId, _token, _connectionId).then(function (sessionInfo) {
          _session._.setIceServers(sessionInfo.iceServers);

          if (!_iceServerDetails) {
            throw new Error('No ice servers provided by getSessionInfo');
          }

          return _iceServerDetails.iceServers;
        });
      }
    };

    /**
    * Sends a signal to each client or a specified client in the session. Specify a
    * <code>to</code> property of the <code>signal</code> parameter to limit the signal to
    * be sent to a specific client; otherwise the signal is sent to each client connected to
    * the session.
    * <p>
    * The following example sends a signal of type "foo" with a specified data payload ("hello")
    * to all clients connected to the session:
    * <pre>
    * session.signal({
    *     type: "foo",
    *     data: "hello"
    *   },
    *   function(error) {
    *     if (error) {
    *       console.log("signal error: " + error.message);
    *     } else {
    *       console.log("signal sent");
    *     }
    *   }
    * );
    * </pre>
    * <p>
    * Calling this method without specifying a recipient client (by setting the <code>to</code>
    * property of the <code>signal</code> parameter) results in multiple signals sent (one to each
    * client in the session). For information on charges for signaling, see the
    * <a href="http://tokbox.com/pricing">OpenTok pricing</a> page.
    * <p>
    * The following example sends a signal of type "foo" with a data payload ("hello") to a
    * specific client connected to the session:
    * <pre>
    * session.signal({
    *     type: "foo",
    *     to: recipientConnection; // a Connection object
    *     data: "hello"
    *   },
    *   function(error) {
    *     if (error) {
    *       console.log("signal error: " + error.message);
    *     } else {
    *       console.log("signal sent");
    *     }
    *   }
    * );
    * </pre>
    * <p>
    * Add an event handler for the <code>signal</code> event to listen for all signals sent in
    * the session. Add an event handler for the <code>signal:type</code> event to listen for
    * signals of a specified type only (replace <code>type</code>, in <code>signal:type</code>,
    * with the type of signal to listen for). The Session object dispatches these events. (See
    * <a href="#events">events</a>.)
    *
    * @param {Object} signal An object that contains the following properties defining the signal:
    * <ul>
    *   <li><code>data</code> &mdash; (String) The data to send. The limit to the length of data
    *     string is 8kB. Do not set the data string to <code>null</code> or
    *     <code>undefined</code>.</li>
    *   <li><code>retryAfterReconnect</code>&mdash; (Boolean) Upon reconnecting to the session,
    *     whether to send any signals that were initiated while disconnected. If your client loses its
    *     connection to the OpenTok session, due to a drop in network connectivity, the client
    *     attempts to reconnect to the session, and the Session object dispatches a
    *     <code>reconnecting</code> event. By default, signals initiated while disconnected are
    *     sent when (and if) the client reconnects to the OpenTok session. You can prevent this by
    *     setting the <code>retryAfterReconnect</code> property to <code>false</code>. (The default
    *     value is <code>true</code>.)
    *   <li><code>to</code> &mdash; (Connection) A <a href="Connection.html">Connection</a>
    *      object corresponding to the client that the message is to be sent to. If you do not
    *      specify this property, the signal is sent to all clients connected to the session.</li>
    *   <li><code>type</code> &mdash; (String) The type of the signal. You can use the type to
    *     filter signals when setting an event handler for the <code>signal:type</code> event
    *     (where you replace <code>type</code> with the type string). The maximum length of the
    *     <code>type</code> string is 128 characters, and it must contain only letters (A-Z and a-z),
    *     numbers (0-9), '-', '_', and '~'.</li>
    *   </li>
    * </ul>
    *
    * <p>Each property is optional. If you set none of the properties, you will send a signal
    * with no data or type to each client connected to the session.</p>
    *
    * @param {Function} completionHandler (Optional) A function that is called when sending the signal
    * succeeds or fails. This function takes one parameter &mdash; <code>error</code>.
    * On success, the <code>completionHandler</code> function is not passed any
    * arguments. On error, the function is passed an <code>error</code> object, defined by the
    * <a href="Error.html">Error</a> class. The <code>error</code> object has the following
    * properties:
    *
    * <ul>
    *   <li><code>code</code> &mdash; (Number) An error code, which can be one of the following:
    *     <table class="docs_table">
    *         <tr>
    *           <td>400</td> <td>One of the signal properties is invalid.</td>
    *         </tr>
    *         <tr>
    *           <td>404</td> <td>The client specified by the <code>to</code> property is not connected
    *                        to the session.</td>
    *         </tr>
    *         <tr>
    *           <td>413</td> <td>The <code>type</code> string exceeds the maximum length (128 bytes),
    *                        or the <code>data</code> string exceeds the maximum size (8 kB).</td>
    *         </tr>
    *         <tr>
    *           <td>500</td> <td>You are not connected to the OpenTok session.</td>
    *         </tr>
    *      </table>
    *   </li>
    *   <li><code>message</code> &mdash; (String) A description of the error.</li>
    * </ul>
    *
    * <p>Note that the <code>completionHandler</code> success result (<code>error == null</code>)
    * indicates that the options passed into the <code>Session.signal()</code> method are valid
    * and the signal was sent. It does <i>not</i> indicate that the signal was successfully
    * received by any of the intended recipients.
    *
    * @method #signal
    * @memberOf Session
    * @see <a href="#event:signal">signal</a> and <a href="#event:signal:type">signal:type</a> events
    */
    this.signal = function (options, completion) {
      var _options = options;
      var _completion = completion || function () {};

      if (OTHelpers.isFunction(_options)) {
        _completion = _options;
        _options = null;
      }

      if (this.isNot('connected')) {
        var notConnectedErrorMsg = 'Unable to send signal - you are not connected to the session.';
        dispatchOTError(otError(errors.NOT_CONNECTED, new Error(notConnectedErrorMsg), 500), _completion);
        return;
      }

      function getErrorNameFromCode(code) {
        switch (code) {
          case 400:
          case 413:
            return errors.INVALID_PARAMETER;
          case 429:
            return errors.RATE_LIMIT_EXCEEDED;
          case 404:
            return errors.NOT_FOUND;
          case 500:
            return errors.NOT_CONNECTED;
          case 403:
            return errors.PERMISSION_DENIED;
          case 2001:
            return errors.UNEXPECTED_SERVER_RESPONSE;
          default:
            return undefined;
        }
      }

      _socket.signal(_options, function (error) {
        if (error) {
          var errorName = getErrorNameFromCode(error.code);
          if (errorName) {
            error = otError(errorName, new Error(error.message), error.code);
          }
          _completion(error);
          return;
        }
        _completion.apply(undefined, arguments);
      }, this.logEvent);
      if (options && options.data && typeof options.data !== 'string') {
        _logging.warn('Signaling of anything other than Strings is deprecated. ' + 'Please update the data property to be a string.');
      }
    };

    /**
    *   Forces a remote connection to leave the session.
    *
    * <p>
    *   The <code>forceDisconnect()</code> method is normally used as a moderation tool
    *        to remove users from an ongoing session.
    * </p>
    * <p>
    *   When a connection is terminated using the <code>forceDisconnect()</code>,
    *        <code>sessionDisconnected</code>, <code>connectionDestroyed</code> and
    *        <code>streamDestroyed</code> events are dispatched in the same way as they
    *        would be if the connection had terminated itself using the <code>disconnect()</code>
    *        method. However, the <code>reason</code> property of a {@link ConnectionEvent} or
    *        {@link StreamEvent} object specifies <code>"forceDisconnected"</code> as the reason
    *        for the destruction of the connection and stream(s).
    * </p>
    * <p>
    *   While you can use the <code>forceDisconnect()</code> method to terminate your own connection,
    *        calling the <code>disconnect()</code> method is simpler.
    * </p>
    * <p>
    *   The OT object dispatches an <code>exception</code> event if the user's role
    *   does not include permissions required to force other users to disconnect.
    *   You define a user's role when you create the user token (see the
    *   <a href="https://tokbox.com/developer/guides/create-token/">Token creation overview</a>).
    *   See <a href="ExceptionEvent.html">ExceptionEvent</a> and <a href="OT.html#on">OT.on()</a>.
    * </p>
    * <p>
    *   The application throws an error if the session is not connected.
    * </p>
    *
    * <h5>Events dispatched:</h5>
    *
    * <p>
    *   <code>connectionDestroyed</code> (<a href="ConnectionEvent.html">ConnectionEvent</a>) &#151;
    *     On clients other than which had the connection terminated.
    * </p>
    * <p>
    *   <code>exception</code> (<a href="ExceptionEvent.html">ExceptionEvent</a>) &#151;
    *     The user's role does not allow forcing other user's to disconnect (<code>event.code =
    *     1530</code>),
    *   or the specified stream is not publishing to the session (<code>event.code = 1535</code>).
    * </p>
    * <p>
    *   <code>sessionDisconnected</code>
    *   (<a href="SessionDisconnectEvent.html">SessionDisconnectEvent</a>) &#151;
    *     On the client which has the connection terminated.
    * </p>
    * <p>
    *   <code>streamDestroyed</code> (<a href="StreamEvent.html">StreamEvent</a>) &#151;
    *     If streams are stopped as a result of the connection ending.
    * </p>
    *
    * @param {Connection} connection The connection to be disconnected from the session.
    * This value can either be a <a href="Connection.html">Connection</a> object or a connection
    * ID (which can be obtained from the <code>connectionId</code> property of the Connection object).
    *
    * @param {Function} completionHandler (Optional) A function to be called when the call to the
    * <code>forceDiscononnect()</code> method succeeds or fails. This function takes one parameter
    * &mdash; <code>error</code>. On success, the <code>completionHandler</code> function is
    * not passed any arguments. On error, the function is passed an <code>error</code> object
    * parameter. The <code>error</code> object, defined by the <a href="Error.html">Error</a>
    * class, has two properties: <code>code</code> (an integer)
    * and <code>message</code> (a string), which identify the cause of the failure.
    * Calling <code>forceDisconnect()</code> fails if the role assigned to your
    * token is not "moderator"; in this case the <code>error.name</code> property is set to
    * <code>"OT_PERMISSION_DENIED"</code>. The following code adds a <code>completionHandler</code>
    * when calling the <code>forceDisconnect()</code> method:
    * <pre>
    * session.forceDisconnect(connection, function (error) {
    *   if (error) {
    *     console.log(error);
    *   } else {
    *     console.log("Connection forced to disconnect: " + connection.id);
    *   }
    * });
    * </pre>
    *
    * @method #forceDisconnect
    * @memberOf Session
    */

    this.forceDisconnect = function (connectionOrConnectionId, completionHandler) {
      if (this.isNot('connected')) {
        var notConnectedErrorMsg = 'Cannot call forceDisconnect(). You are not ' + 'connected to the session.';
        dispatchOTError(otError(errors.NOT_CONNECTED, new Error(notConnectedErrorMsg), ExceptionCodes.NOT_CONNECTED), completionHandler);
        return;
      }

      var connectionId = typeof connectionOrConnectionId === 'string' ? connectionOrConnectionId : connectionOrConnectionId.id;

      var invalidParameterErrorMsg = 'Invalid Parameter. Check that you have passed valid parameter values into the method call.';

      if (!connectionId) {
        dispatchOTError(otError(errors.INVALID_PARAMETER, new Error(invalidParameterErrorMsg), ExceptionCodes.INVALID_PARAMETER), completionHandler);

        return;
      }

      var notPermittedErrorMsg = 'This token does not allow forceDisconnect. ' + 'The role must be at least `moderator` to enable this functionality';

      if (!permittedTo('forceDisconnect')) {
        dispatchOTError(otError(errors.PERMISSION_DENIED, new Error(notPermittedErrorMsg), ExceptionCodes.UNABLE_TO_FORCE_DISCONNECT), completionHandler);

        return;
      }

      _socket.forceDisconnect(connectionId, function (err) {
        if (err) {
          dispatchOTError(otError(errors.INVALID_PARAMETER, new Error(invalidParameterErrorMsg), ExceptionCodes.INVALID_PARAMETER), completionHandler);
        } else if (completionHandler && OTHelpers.isFunction(completionHandler)) {
          completionHandler.apply(undefined, arguments);
        }
      });
    };

    /**
    * Forces the publisher of the specified stream to stop publishing the stream.
    *
    * <p>
    * Calling this method causes the Session object to dispatch a <code>streamDestroyed</code>
    * event on all clients that are subscribed to the stream (including the client that is
    * publishing the stream). The <code>reason</code> property of the StreamEvent object is
    * set to <code>"forceUnpublished"</code>.
    * </p>
    * <p>
    * The OT object dispatches an <code>exception</code> event if the user's role
    * does not include permissions required to force other users to unpublish.
    * You define a user's role when you create the user token (see the
    * <a href="https://tokbox.com/developer/guides/create-token/">Token creation overview</a>).
    * You pass the token string as a parameter of the <code>connect()</code> method of the Session
    * object. See <a href="ExceptionEvent.html">ExceptionEvent</a> and
    * <a href="OT.html#on">OT.on()</a>.
    * </p>
    *
    * <h5>Events dispatched:</h5>
    *
    * <p>
    *   <code>exception</code> (<a href="ExceptionEvent.html">ExceptionEvent</a>) &#151;
    *     The user's role does not allow forcing other users to unpublish.
    * </p>
    * <p>
    *   <code>streamDestroyed</code> (<a href="StreamEvent.html">StreamEvent</a>) &#151;
    *     The stream has been unpublished. The Session object dispatches this on all clients
    *     subscribed to the stream, as well as on the publisher's client.
    * </p>
    *
    * @param {Stream} stream The stream to be unpublished.
    *
    * @param {Function} completionHandler (Optional) A function to be called when the call to the
    * <code>forceUnpublish()</code> method succeeds or fails. This function takes one parameter
    * &mdash; <code>error</code>. On success, the <code>completionHandler</code> function is
    * not passed any arguments. On error, the function is passed an <code>error</code> object
    * parameter. The <code>error</code> object, defined by the <a href="Error.html">Error</a>
    * class, has two properties: <code>code</code> (an integer)
    * and <code>message</code> (a string), which identify the cause of the failure. Calling
    * <code>forceUnpublish()</code> fails if the role assigned to your token is not "moderator";
    * in this case the <code>error.name</code> property is set to <code>"OT_PERMISSION_DENIED"</code>.
    * The following code adds a completion handler when calling the <code>forceUnpublish()</code>
    * method:
    * <pre>
    * session.forceUnpublish(stream, function (error) {
    *   if (error) {
    *       console.log(error);
    *     } else {
    *       console.log("Connection forced to disconnect: " + connection.id);
    *     }
    *   });
    * </pre>
    *
    * @method #forceUnpublish
    * @memberOf Session
    */

    this.forceUnpublish = function (streamOrStreamId) {
      var completionHandler = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {};

      var dispatchError = function dispatchError(err) {
        return dispatchOTError(otError(err.name, new Error(err.msg), err.code), completionHandler);
      };
      var invalidParameterError = {
        msg: 'Invalid Parameter. Check that you have passed valid parameter values into the method call.',
        code: ExceptionCodes.INVALID_PARAMETER,
        name: errors.INVALID_PARAMETER
      };

      var notConnectedError = {
        msg: 'Cannot call forceUnpublish(). You are not connected to the session.',
        code: ExceptionCodes.NOT_CONNECTED,
        name: errors.NOT_CONNECTED
      };

      var notPermittedError = {
        msg: 'This token does not allow forceUnpublish. The role must be at least `moderator` to enable this ' + 'functionality',
        code: ExceptionCodes.UNABLE_TO_FORCE_UNPUBLISH,
        name: errors.PERMISSION_DENIED
      };

      var notFoundError = {
        msg: 'The stream does not exist.',
        name: errors.NOT_FOUND
      };

      var unexpectedError = {
        msg: 'An unexpected error occurred.',
        name: errors.UNEXPECTED_SERVER_RESPONSE,
        code: ExceptionCodes.UNEXPECTED_SERVER_RESPONSE
      };

      if (!streamOrStreamId) {
        dispatchError(invalidParameterError);
        return;
      }

      if (_this.isNot('connected')) {
        dispatchError(notConnectedError);
        return;
      }

      var stream = getStream(streamOrStreamId);

      if (!permittedTo('forceUnpublish')) {
        // if this throws an error the handleJsException won't occur
        dispatchError(notPermittedError);
        return;
      }

      _socket.forceUnpublish(stream.id, function (err) {
        if (!err) {
          completionHandler(null);
          return;
        }
        if (err.code === '404') {
          dispatchError(notFoundError);
        } else if (err.code === '403') {
          dispatchError(notPermittedError);
        } else {
          dispatchError(unexpectedError);
        }
      });
    };

    this.isConnected = function () {
      return _this.is('connected');
    };
    this.capabilities = new Capabilities([]);

    /**
     * Dispatched when an archive recording of the session starts.
     *
     * @name archiveStarted
     * @event
     * @memberof Session
     * @see ArchiveEvent
     * @see <a href="http://www.tokbox.com/opentok/tutorials/archiving">Archiving overview</a>
     */

    /**
     * Dispatched when an archive recording of the session stops.
     *
     * @name archiveStopped
     * @event
     * @memberof Session
     * @see ArchiveEvent
     * @see <a href="http://www.tokbox.com/opentok/tutorials/archiving">Archiving overview</a>
     */

    /**
     * Dispatched when a new client (including your own) has connected to the session, and for
     * every client in the session when you first connect. (The Session object also dispatches
     * a <code>sessionConnected</code> event when your local client connects.)
     *
     * @name connectionCreated
     * @event
     * @memberof Session
     * @see ConnectionEvent
     * @see <a href="OT.html#initSession">OT.initSession()</a>
     */

    /**
     * A client, other than your own, has disconnected from the session.
     * @name connectionDestroyed
     * @event
     * @memberof Session
     * @see ConnectionEvent
     */

    /**
     * The client has connected to an OpenTok session. This event is dispatched asynchronously
     * in response to a successful call to the <code>connect()</code> method of a Session
     * object. Before calling the <code>connect()</code> method, initialize the session by
     * calling the <code>OT.initSession()</code> method. For a code example and more details,
     * see <a href="#connect">Session.connect()</a>.
     * @name sessionConnected
     * @event
     * @memberof Session
     * @see SessionConnectEvent
     * @see <a href="#connect">Session.connect()</a>
     * @see <a href="OT.html#initSession">OT.initSession()</a>
     */

    /**
     * The client has disconnected from the session. This event may be dispatched asynchronously
     * in response to a successful call to the <code>disconnect()</code> method of the Session object.
     * The event may also be disptached if a session connection is lost inadvertantly, as in the case
     * of a lost network connection.
     * <p>
     * The default behavior is that all Subscriber objects are unsubscribed and removed from the
     * HTML DOM. Each Subscriber object dispatches a <code>destroyed</code> event when the element is
     * removed from the HTML DOM. If you call the <code>preventDefault()</code> method in the event
     * listener for the <code>sessionDisconnect</code> event, the default behavior is prevented, and
     * you can, optionally, clean up Subscriber objects using your own code.
     * <p> The <code>reason</code> property of the event object indicates the reason for the client
     * being disconnected.
     * @name sessionDisconnected
     * @event
     * @memberof Session
     * @see <a href="#disconnect">Session.disconnect()</a>
     * @see <a href="#forceDisconnect">Session.forceDisconnect()</a>
     * @see SessionDisconnectEvent
     */

    /**
     * The local client has lost its connection to an OpenTok session and is trying to reconnect.
     * This results from a loss in network connectivity. If the client can reconnect to the session,
     * the Session object dispatches a <code>sessionReconnected</code> event. Otherwise, if the client
     * cannot reconnect, the Session object dispatches a <code>sessionDisconnected</code> event.
     * <p>
     * In response to this event, you may want to provide a user interface notification, to let
     * the user know that the app is trying to reconnect to the session and that audio-video streams
     * are temporarily disconnected.
     *
     * @name sessionReconnecting
     * @event
     * @memberof Session
     * @see Event
     * @see <a href="#event:sessionReconnected">sessionReconnected event</a>
     * @see <a href="#event:sessionDisconnected">sessionDisconnected event</a>
     */

    /**
     * The local client has reconnected to the OpenTok session after its connection was lost
     * temporarily. When the connection is lost, the Session object dispatches a
     * <code>sessionReconnecting</code> event, prior to the <code>sessionReconnected</code>
     * event. If the client cannot reconnect to the session, the Session object dispatches a
     * <code>sessionDisconnected</code> event instead of this event.
     * <p>
     * Any existing publishers and subscribers are automatically reconnected when client reconnects
     * and the Session object dispatches this event.
     * <p>
     * Any signals sent by other clients while your client was disconnected are received upon
     * reconnecting. By default, signals initiated by the local client while disconnected
     * (by calling the <code>Session.signal()</code> method) are sent when the client reconnects
     * to the OpenTok session. You can prevent this by setting the <code>retryAfterReconnect</code>
     * property to <code>false</code> in the <code>signal</code> object you pass into the
     * <a href="#signal">Session.signal()</a> method.
     *
     * @name sessionReconnected
     * @event
     * @memberof Session
     * @see Event
     * @see <a href="#event:sessionReconnecting">sessionReconnecting event</a>
     * @see <a href="#event:sessionDisconnected">sessionDisconnected event</a>
     */

    /**
     * A new stream, published by another client, has been created on this session. For streams
     * published by your own client, the Publisher object dispatches a <code>streamCreated</code>
     * event. For a code example and more details, see {@link StreamEvent}.
     * @name streamCreated
     * @event
     * @memberof Session
     * @see StreamEvent
     * @see <a href="Session.html#publish">Session.publish()</a>
     */

    /**
     * A stream from another client has stopped publishing to the session.
     * <p>
     * The default behavior is that all Subscriber objects that are subscribed to the stream are
     * unsubscribed and removed from the HTML DOM. Each Subscriber object dispatches a
     * <code>destroyed</code> event when the element is removed from the HTML DOM. If you call the
     * <code>preventDefault()</code> method in the event listener for the
     * <code>streamDestroyed</code> event, the default behavior is prevented and you can clean up
     * a Subscriber object for the stream by calling its <code>destroy()</code> method. See
     * <a href="Session.html#getSubscribersForStream">Session.getSubscribersForStream()</a>.
     * <p>
     * For streams published by your own client, the Publisher object dispatches a
     * <code>streamDestroyed</code> event.
     * <p>
     * For a code example and more details, see {@link StreamEvent}.
     * @name streamDestroyed
     * @event
     * @memberof Session
     * @see StreamEvent
     */

    /**
     * Defines an event dispatched when property of a stream has changed. This can happen in
     * in the following conditions:
     * <p>
     * <ul>
     *   <li> A stream has started or stopped publishing audio or video (see
     *     <a href="Publisher.html#publishAudio">Publisher.publishAudio()</a> and
     *     <a href="Publisher.html#publishVideo">Publisher.publishVideo()</a>). Note
     *     that a subscriber's video can be disabled or enabled for reasons other than
     *     the publisher disabling or enabling it. A Subscriber object dispatches
     *     <code>videoDisabled</code> and <code>videoEnabled</code> events in all
     *     conditions that cause the subscriber's stream to be disabled or enabled.
     *   </li>
     *   <li> The <code>videoDimensions</code> property of the Stream object has
     *     changed (see <a href="Stream.html#properties">Stream.videoDimensions</a>).
     *   </li>
     *   <li> The <code>videoType</code> property of the Stream object has changed.
     *     This can happen in a stream published by a mobile device. (See
     *     <a href="Stream.html#properties">Stream.videoType</a>.)
     *   </li>
     * </ul>
     *
     * @name streamPropertyChanged
     * @event
     * @memberof Session
     * @see StreamPropertyChangedEvent
     * @see <a href="Publisher.html#publishAudio">Publisher.publishAudio()</a>
     * @see <a href="Publisher.html#publishVideo">Publisher.publishVideo()</a>
     * @see <a href="Stream.html#hasAudio">Stream.hasAudio</a>
     * @see <a href="Stream.html#hasVideo">Stream.hasVideo</a>
     * @see <a href="Stream.html#videoDimensions">Stream.videoDimensions</a>
     * @see <a href="Subscriber.html#event:videoDisabled">Subscriber videoDisabled event</a>
     * @see <a href="Subscriber.html#event:videoEnabled">Subscriber videoEnabled event</a>
     */

    /**
     * A signal was received from the session. The <a href="SignalEvent.html">SignalEvent</a>
     * class defines this event object. It includes the following properties:
     * <ul>
     *   <li><code>data</code> &mdash; (String) The data string sent with the signal (if there
     *       is one).</li>
     *   <li><code>from</code> &mdash; (<a href="Connection.html">Connection</a>) The Connection
     *       corresponding to the client that sent the signal.</li>
     *   <li><code>type</code> &mdash; (String) The type assigned to the signal (if there is
     *       one).</li>
     * </ul>
     * <p>
     * You can register to receive all signals sent in the session, by adding an event handler
     * for the <code>signal</code> event. For example, the following code adds an event handler
     * to process all signals sent in the session:
     * <pre>
     * session.on("signal", function(event) {
     *   console.log("Signal sent from connection: " + event.from.id);
     *   console.log("Signal data: " + event.data);
     * });
     * </pre>
     * <p>You can register for signals of a specfied type by adding an event handler for the
     * <code>signal:type</code> event (replacing <code>type</code> with the actual type string
     * to filter on).
     *
     * @name signal
     * @event
     * @memberof Session
     * @see <a href="Session.html#signal">Session.signal()</a>
     * @see SignalEvent
     * @see <a href="#event:signal:type">signal:type</a> event
     */

    /**
     * A signal of the specified type was received from the session. The
     * <a href="SignalEvent.html">SignalEvent</a> class defines this event object.
     * It includes the following properties:
     * <ul>
     *   <li><code>data</code> &mdash; (String) The data string sent with the signal.</li>
     *   <li><code>from</code> &mdash; (<a href="Connection.html">Connection</a>) The Connection
     *   corresponding to the client that sent the signal.</li>
     *   <li><code>type</code> &mdash; (String) The type assigned to the signal (if there is one).
     *   </li>
     * </ul>
     * <p>
     * You can register for signals of a specfied type by adding an event handler for the
     * <code>signal:type</code> event (replacing <code>type</code> with the actual type string
     * to filter on). For example, the following code adds an event handler for signals of
     * type "foo":
     * <pre>
     * session.on("signal:foo", function(event) {
     *   console.log("foo signal sent from connection " + event.from.id);
     *   console.log("Signal data: " + event.data);
     * });
     * </pre>
     * <p>
     * You can register to receive <i>all</i> signals sent in the session, by adding an event
     * handler for the <code>signal</code> event.
     *
     * @name signal:type
     * @event
     * @memberof Session
     * @see <a href="Session.html#signal">Session.signal()</a>
     * @see SignalEvent
     * @see <a href="#event:signal">signal</a> event
     */
  };

  return Session;
};

},{"../../common-js-helpers/OTHelpers.js":217,"../../helpers/connectivity_attempt_pinger.js":245,"../../helpers/convertAnvilErrorCode.js":246,"../../helpers/convertRumorError.js":247,"../../helpers/hasIceRestartsCapability.js":263,"../../helpers/otError.js":271,"../../helpers/otProperties.js":272,"../../otplugin/otplugin.js":390,"../Errors.js":288,"../analytics.js":289,"../api_key.js":291,"../capabilities.js":294,"../events.js":306,"../exception_codes.js":307,"../logging.js":312,"../messaging/raptor/parse_ice_servers.js":318,"../messaging/raptor/raptor_socket.js":320,"../messaging/raptor/session_dispatcher.js":322,"../messaging/rumor/socket_close_errors.js":332,"../ot_error_class.js":334,"../publisher":355,"../publisher/init.js":356,"../subscriber":378,"../system_requirements.js":380,"./info.js":368,"./objects.js":370,"./tag.js":371,"bluebird":2,"lodash/omit":173,"lodash/pick":175,"uuid":200}],368:[function(require,module,exports){
'use strict';

// @todo enable the following disabled rules see OPENTOK-31136 for more info
/* eslint-disable no-shadow, no-void */

var Anvil = require('../anvil.js');
var Bluebird = require('bluebird');
var convertAnvilErrorCode = require('../../helpers/convertAnvilErrorCode.js');
var ExceptionCodes = require('../exception_codes.js');
var logging = require('../logging.js');

// This sequence defines the delay before retry. Therefore a 0 indicates
// that a retry should happen immediately.
//
// e.g. 0, 600, 1200 means retry immediately, then in 600 ms, then in 1200ms
//
var retryDelays = [0, 600, 1200];

// These codes are possibly transient and it's worth retrying if a Anvil request
// fails with one of these codes.
var transientErrorCodes = [ExceptionCodes.CONNECT_FAILED, ExceptionCodes.UNEXPECTED_SERVER_RESPONSE];

var SessionInfo = function SessionInfo(rawSessionInfo) {
  logging.log('SessionInfo Response:');
  logging.log(rawSessionInfo);

  /* jshint camelcase:false*/
  // jscs:disable requireCamelCaseOrUpperCaseIdentifiers
  this.sessionId = rawSessionInfo.session_id;
  this.partnerId = rawSessionInfo.partner_id;
  this.messagingServer = rawSessionInfo.messaging_server_url;
  this.mediaServerName = rawSessionInfo.media_server_hostname;
  this.messagingURL = rawSessionInfo.messaging_url;
  this.symphonyAddress = rawSessionInfo.symphony_address;
  this.iceServers = rawSessionInfo.ice_servers;

  if (rawSessionInfo.properties) {
    // `simulcast` is tri-state:
    // true: simulcast is on for this session
    // false: simulcast is off for this session
    // undefined: the developer can choose
    //
    this.simulcast = rawSessionInfo.properties.simulcast;

    this.reconnection = rawSessionInfo.properties.reconnection === undefined ? false : rawSessionInfo.properties.reconnection;

    this.renegotiation = rawSessionInfo.properties.renegotiation === undefined ? false : rawSessionInfo.properties.renegotiation;

    this.p2pEnabled = !!(rawSessionInfo.properties.p2p && rawSessionInfo.properties.p2p.preference && rawSessionInfo.properties.p2p.preference.value === 'enabled');

    this.rememberDeviceChoiceIE = rawSessionInfo.properties.rememberDeviceChoiceIE === undefined ? false : rawSessionInfo.properties.rememberDeviceChoiceIE;
  } else {
    this.p2pEnabled = false;
  }
};

// Retrieves Session Info for +session+. The SessionInfo object will be passed
// to the +onSuccess+ callback. The +onFailure+ callback will be passed an error
// object and the DOMEvent that relates to the error.
//
SessionInfo.get = function (id, token, connectionId) {
  var remainingRetryDelays = retryDelays.slice();

  var attempt = function attempt(err, resolve, reject) {
    if (remainingRetryDelays.length === 0) {
      reject(err);
      return;
    }

    Anvil.get('session/' + id + '?extended=true', token, connectionId).then(function (anvilResponse) {
      resolve(new SessionInfo(anvilResponse));
    }, function (err) {
      var normalisedCode = convertAnvilErrorCode(err.code);
      if (transientErrorCodes.indexOf(normalisedCode) > -1) {
        // This error is possibly transient, so retry
        setTimeout(function () {
          attempt(err, resolve, reject);
        }, remainingRetryDelays.shift());
      } else {
        reject(err);
      }
    });
  };

  return new Bluebird.Promise(function (resolve, reject) {
    attempt(void 0, resolve, reject);
  });
};

module.exports = SessionInfo;

},{"../../helpers/convertAnvilErrorCode.js":246,"../anvil.js":290,"../exception_codes.js":307,"../logging.js":312,"bluebird":2}],369:[function(require,module,exports){
'use strict';

// @todo enable the following disabled rules see OPENTOK-31136 for more info
/* eslint-disable no-param-reassign, global-require */

module.exports = function initSessionFactory() {
  var deps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var Session = deps.Session || require('./index.js')();
  var sessionObjects = deps.sessionObjects || require('./objects.js');

  /**
  * The first step in using the OpenTok API is to call the <code>OT.initSession()</code>
  * method. Other methods of the OT object check for system requirements and set up error logging.
  *
  * @class OT
  */

  /**
  * <p class="mSummary">
  * Initializes and returns the local session object for a specified session ID.
  * </p>
  * <p>
  * You connect to an OpenTok session using the <code>connect()</code> method
  * of the Session object returned by the <code>OT.initSession()</code> method.
  * Note that calling <code>OT.initSession()</code> does not initiate communications
  * with the cloud. It simply initializes the Session object that you can use to
  * connect (and to perform other operations once connected).
  * </p>
  *
  * <p>
  * Note that you can initialize only one Session object per session ID. Calling
  * <code>OT.initSession()</code> a second time with the same session ID returns the
  * previously created Session object. However, you can initialize multiple Session objects
  * for different sessions (with different session IDs) to connect to multiple sessions.
  * </p>
  *
  * <p>
  * When the client disconnects from the session (and the session dispatches a
  * <code>sessionDisconnected</code> event), you can reuse the Session object to
  * reconnect to the session. However, the Session object will retain any existing
  * event handlers attached to it. You can remove all event handlers by calling the
  * <code>off()</code> method of the Session object (passing in no parameters).
  * </p>
  *
  *  <p>
  *    For an example, see <a href="Session.html#connect">Session.connect()</a>.
  *  </p>
  *
  * @method OT.initSession
  * @memberof OT
  * @param {String} apiKey Your OpenTok API key (see your <a href="https://tokbox.com/account">TokBox
  * account page</a>).
  * @param {String} sessionId The session ID identifying the OpenTok session. For more
  * information, see <a href="https://tokbox.com/opentok/tutorials/create-session/">Session
  * creation</a>.
  * @param {Object} options An object that includes optional options for initializing the session.
  * Currently, this object includes one property: <code>connectionEventsSuppressed</code>.
  * Set this property to <code>true</code> to support large interactive video sessions.
  * This prevents the Session object from dispatching <code>connectionCreated</code> and
  * <code>connectionDestroyed</code> events when other clients connect to or disconnect from
  * the session. (Also, the OpenTok server does not send these events to the web client.)
  * For more information, see
  * <a href="https://tokbox.com/developer/guides/broadcast/live-interactive-video/#suppressing-connection-events">
  * Suppressing connection events</a> in the OpenTok developer guides.
  *
  * @returns {Session} The session object through which all further interactions with
  * the session will occur.
  */
  return function initSession(apiKey, sessionId, opt) {
    if (sessionId == null) {
      sessionId = apiKey;
      apiKey = null;
    }

    // Allow buggy legacy behavior to succeed, where the client can connect if sessionId
    // is an array containing one element (the session ID), but fix it so that sessionId
    // is stored as a string (not an array):
    if (Array.isArray(sessionId) && sessionId.length === 1) {
      sessionId = sessionId[0];
    }

    var session = sessionObjects.sessions.get(sessionId);

    if (!session) {
      session = new Session(apiKey, sessionId, opt);
      sessionObjects.sessions.add(session);
    }

    return session;
  };
};

},{"./index.js":367,"./objects.js":370}],370:[function(require,module,exports){
'use strict';

var OTHelpers = require('../../common-js-helpers/OTHelpers.js');

var sessionObjects = {};

// TODO: Eliminate the need for this module, which is globally tracking these objects.

// Publishers are id'd by their guid
sessionObjects.publishers = new OTHelpers.Collection('guid');

// Subscribers are id'd by their widgetId
sessionObjects.subscribers = new OTHelpers.Collection('widgetId');

sessionObjects.sessions = new OTHelpers.Collection();

module.exports = sessionObjects;

},{"../../common-js-helpers/OTHelpers.js":217}],371:[function(require,module,exports){
"use strict";

// This is used to break the dependency Raptor had on Session. It only needs to be able to know
// whether an object is an instanceof a Session. The dependency was an issue for node because
// Session depends on get_user_media.js which doesn't work in node.

module.exports = {};

},{}],372:[function(require,module,exports){
'use strict';

// @todo enable the following disabled rules see OPENTOK-31136 for more info
/* eslint-disable no-shadow, no-underscore-dangle, max-len, no-plusplus, no-use-before-define */
/* eslint-disable no-void, vars-on-top, no-var, no-restricted-syntax, no-prototype-builtins */
/* eslint-disable no-continue */

var logging = require('./logging.js');
var OTHelpers = require('../common-js-helpers/OTHelpers.js');
var sessionObjects = require('./session/objects.js');

var Events = require('./events.js')();

var validPropertyNames = ['name', 'archiving'];

/**
 * Specifies a stream. A stream is a representation of a published stream in a session. When a
 * client calls the <a href="Session.html#publish">Session.publish() method</a>, a new stream is
 * created. Properties of the Stream object provide information about the stream.
 *
 *  <p>When a stream is added to a session, the Session object dispatches a
 * <code>streamCreatedEvent</code>. When a stream is destroyed, the Session object dispatches a
 * <code>streamDestroyed</code> event. The StreamEvent object, which defines these event objects,
 * has a <code>stream</code> property, which is an array of Stream object. For details and a code
 * example, see {@link StreamEvent}.</p>
 *
 *  <p>When a connection to a session is made, the Session object dispatches a
 * <code>sessionConnected</code> event, defined by the SessionConnectEvent object. The
 * SessionConnectEvent object has a <code>streams</code> property, which is an array of Stream
 * objects pertaining to the streams in the session at that time. For details and a code example,
 * see {@link SessionConnectEvent}.</p>
 *
 * @class Stream
 * @property {Connection} connection The Connection object corresponding
 * to the connection that is publishing the stream. You can compare this to the
 * <code>connection</code> property of the Session object to see if the stream is being published
 * by the local web page.
 *
 * @property {Number} creationTime The timestamp for the creation
 * of the stream. This value is calculated in milliseconds. You can convert this value to a
 * Date object by calling <code>new Date(creationTime)</code>, where <code>creationTime</code> is
 * the <code>creationTime</code> property of the Stream object.
 *
 * @property {Number} frameRate The frame rate of the video stream. This property is only set if
 * the publisher of the stream specifies a frame rate when calling the
 * <code>OT.initPublisher()</code> method; otherwise, this property is undefined.
 *
 * @property {Boolean} hasAudio Whether the stream has audio. This property can change if the
 * publisher turns on or off audio (by calling
 * <a href="Publisher.html#publishAudio">Publisher.publishAudio()</a>). When this occurs, the
 * {@link Session} object dispatches a <code>streamPropertyChanged</code> event (see
 * {@link StreamPropertyChangedEvent}).
 *
 * @property {Boolean} hasVideo Whether the stream has video. This property can change if the
 * publisher turns on or off video (by calling
 * <a href="Publisher.html#publishVideo">Publisher.publishVideo()</a>). When this occurs, the
 * {@link Session} object dispatches a <code>streamPropertyChanged</code> event (see
 * {@link StreamPropertyChangedEvent}).
 *
 * @property {String} name The name of the stream. Publishers can specify a name when publishing
 * a stream (using the <code>publish()</code> method of the publisher's Session object).
 *
 * @property {String} streamId The unique ID of the stream.
 *
 * @property {Object} videoDimensions This object has two properties: <code>width</code> and
 * <code>height</code>. Both are numbers. The <code>width</code> property is the width of the
 * encoded stream; the <code>height</code> property is the height of the encoded stream. (These
 * are independent of the actual width of Publisher and Subscriber objects corresponding to the
 * stream.) This property can change if a stream published from a mobile device resizes, based on
 * a change in the device orientation. When the video dimensions change,
 * the {@link Session} object dispatches a <code>streamPropertyChanged</code> event
 * (see {@link StreamPropertyChangedEvent}).
 *
 * @property {String} videoType The type of video &mdash; either <code>"camera"</code> or
 * <code>"screen"</code>. A <code>"screen"</code> video uses screen sharing on the publisher
 * as the video source; for other videos, this property is set to <code>"camera"</code>.
 * This property can change if a stream published from a mobile device changes from a
 * camera to a screen-sharing video type. When the video type changes, the {@link Session} object
 * dispatches a <code>streamPropertyChanged</code> event (see {@link StreamPropertyChangedEvent}).
 */

module.exports = function Stream(id, name, creationTime, connection, session, channel) {
  var self = this;
  var destroyedReason = void 0;
  this.id = id;
  this.streamId = id;
  this.name = name;
  this.creationTime = Number(creationTime);

  this.connection = connection;
  this.channel = channel;
  this.publisher = sessionObjects.publishers.find({ streamId: this.id });

  OTHelpers.eventing(this);

  var onChannelUpdate = function onChannelUpdate(channel, key, oldValue, newValue) {
    var _key = key;

    switch (_key) {
      case 'active':
        _key = channel.type === 'audio' ? 'hasAudio' : 'hasVideo';
        self[_key] = newValue;
        break;

      case 'disableWarning':
        _key = channel.type === 'audio' ? 'audioDisableWarning' : 'videoDisableWarning';
        self[_key] = newValue;
        if (!self[channel.type === 'audio' ? 'hasAudio' : 'hasVideo']) {
          return; // Do NOT event in this case.
        }
        break;

      case 'fitMode':
        _key = 'defaultFitMode';
        self[_key] = newValue;
        break;

      case 'source':
        _key = channel.type === 'audio' ? 'audioType' : 'videoType';
        self[_key] = newValue;
        break;

      case 'videoDimensions':
        self.videoDimensions = newValue;
        break;

      case 'orientation':
      case 'width':
      case 'height':
        // We dispatch this via the videoDimensions key instead so do not
        // trigger an event for them.
        return;

      default:
    }

    self.dispatchEvent(new Events.StreamUpdatedEvent(self, _key, oldValue, newValue));
  };

  var associatedWidget = function associatedWidget() {
    if (self.publisher) {
      return self.publisher;
    }

    return sessionObjects.subscribers.find(function (subscriber) {
      return subscriber.stream && subscriber.stream.id === self.id && subscriber.session.id === session.id;
    });
  };

  // Returns true if this stream is subscribe to.
  var isBeingSubscribedTo = function isBeingSubscribedTo() {
    // @fixme This is not strictly speaking the right test as a stream
    // can be published and subscribed by the same connection. But the
    // update features don't handle this case properly right now anyway.
    //
    // The issue is that the stream needs to know whether the stream is
    // 'owned' by a publisher or a subscriber. The reason for that is that
    // when a Publisher updates a stream channel then we need to send the
    // `streamChannelUpdate` message, whereas if a Subscriber does then we
    // need to send `subscriberChannelUpdate`. The current code will always
    // send `streamChannelUpdate`.
    return !self.publisher;
  };

  // Returns all channels that have a type of +type+.
  this.getChannelsOfType = function (type) {
    return self.channel.filter(function (channel) {
      return channel.type === type;
    });
  };

  this.getChannel = function (id) {
    for (var i = 0; i < self.channel.length; ++i) {
      if (self.channel[i].id === id) {
        return self.channel[i];
      }
    }

    return null;
  };

  // // implement the following using the channels
  // hasAudio
  // hasVideo
  // videoDimensions

  var audioChannel = this.getChannelsOfType('audio')[0];
  var videoChannel = this.getChannelsOfType('video')[0];

  // @todo this should really be: "has at least one video/audio track" instead of
  // "the first video/audio track"
  this.hasAudio = audioChannel != null && audioChannel.active;
  this.hasVideo = videoChannel != null && videoChannel.active;

  this.videoType = videoChannel && videoChannel.source;
  this.defaultFitMode = videoChannel && videoChannel.fitMode;

  this.videoDimensions = {};
  if (videoChannel) {
    this.videoDimensions.width = videoChannel.width;
    this.videoDimensions.height = videoChannel.height;
    this.videoDimensions.orientation = videoChannel.orientation;

    videoChannel.on('update', onChannelUpdate);
    this.frameRate = videoChannel.frameRate;
  }

  if (audioChannel) {
    audioChannel.on('update', onChannelUpdate);
  }

  this.setChannelActiveState = function (channelType, activeState, activeReason) {
    var attributes = {
      active: activeState
    };
    if (activeReason) {
      attributes.activeReason = activeReason;
    }
    updateChannelsOfType(channelType, attributes);
  };

  this.setVideoDimensions = function (width, height) {
    updateChannelsOfType('video', {
      width: width,
      height: height,
      orientation: 0
    });
  };

  this.setRestrictFrameRate = function (restrict) {
    updateChannelsOfType('video', {
      restrictFrameRate: restrict
    });
  };

  this.setPreferredResolution = function (resolution) {
    if (!isBeingSubscribedTo()) {
      logging.warn('setPreferredResolution has no affect when called by a publisher');
      return;
    }

    if (session.sessionInfo.p2pEnabled) {
      logging.warn('Stream.setPreferredResolution will not work in a P2P Session');
      return;
    }

    if (resolution && resolution.width === void 0 && resolution.height === void 0) {
      return;
    }

    // This duplicates some of the code in updateChannelsOfType. We do this for a
    // couple of reasons:
    //   1. Because most of the work that updateChannelsOfType does is in calling
    //      getChannelsOfType, which we need to do here anyway so that we can update
    //      the value of maxResolution in the Video Channel.
    //   2. updateChannelsOfType on only sends a message to update the channel in
    //      Rumor. The client then expects to receive a subsequent channel update
    //      indicating that the update was successful. We don't receive those updates
    //      for preferredFrameRate/maxResolution so we need to complete both tasks and it's
    //      neater to do the related tasks right next to each other.
    //   3. This code shouldn't be in Stream anyway. There is way too much coupling
    //      between Stream, Session, Publisher, and Subscriber. This will eventually be
    //      fixed, and when it is then it will be easier to exact the code if it's a
    //      single piece.
    //
    var video = self.getChannelsOfType('video')[0];
    if (!video) {
      return;
    }

    if (resolution && resolution.width) {
      if (isNaN(parseInt(resolution.width, 10))) {
        throw new OTHelpers.Error('stream preferred width must be an integer', 'Subscriber');
      }

      video.preferredWidth = parseInt(resolution.width, 10);
    } else {
      video.preferredWidth = void 0;
    }

    if (resolution && resolution.height) {
      if (isNaN(parseInt(resolution.height, 10))) {
        throw new OTHelpers.Error('stream preferred height must be an integer', 'Subscriber');
      }

      video.preferredHeight = parseInt(resolution.height, 10);
    } else {
      video.preferredHeight = void 0;
    }

    session._.subscriberChannelUpdate(self, associatedWidget(), video, {
      preferredWidth: video.preferredWidth || 0,
      preferredHeight: video.preferredHeight || 0
    });
  };

  this.getPreferredResolution = function () {
    var videoChannel = self.getChannelsOfType('video')[0];
    if (!videoChannel || !videoChannel.preferredWidth && !videoChannel.preferredHeight) {
      return void 0;
    }

    return {
      width: videoChannel.preferredWidth,
      height: videoChannel.preferredHeight
    };
  };

  this.setPreferredFrameRate = function (preferredFrameRate) {
    if (!isBeingSubscribedTo()) {
      logging.warn('setPreferredFrameRate has no affect when called by a publisher');
      return;
    }

    if (session.sessionInfo.p2pEnabled) {
      logging.warn('Stream.setPreferredFrameRate will not work in a P2P Session');
      return;
    }

    if (preferredFrameRate && isNaN(parseFloat(preferredFrameRate))) {
      throw new OTHelpers.Error('stream preferred frameRate must be a number', 'Subscriber');
    }

    // This duplicates some of the code in updateChannelsOfType. We do this for a
    // couple of reasons:
    //   1. Because most of the work that updateChannelsOfType does is in calling
    //      getChannelsOfType, which we need to do here anyway so that we can update
    //      the value of preferredFrameRate in the Video Channel.
    //   2. updateChannelsOfType on only sends a message to update the channel in
    //      Rumor. The client then expects to receive a subsequent channel update
    //      indicating that the update was successful. We don't receive those updates
    //      for preferredFrameRate/maxResolution so we need to complete both tasks and it's
    //      neater to do the related tasks right next to each other.
    //   3. This code shouldn't be in Stream anyway. There is way too much coupling
    //      between Stream, Session, Publisher, and Subscriber. This will eventually be
    //      fixed, and when it is then it will be easier to exact the code if it's a
    //      single piece.
    //
    var video = self.getChannelsOfType('video')[0];

    if (video) {
      video.preferredFrameRate = preferredFrameRate ? parseFloat(preferredFrameRate) : void 0;

      session._.subscriberChannelUpdate(self, associatedWidget(), video, {
        preferredFrameRate: video.preferredFrameRate || 0
      });
    }
  };

  this.getPreferredFrameRate = function () {
    var videoChannel = self.getChannelsOfType('video')[0];
    return videoChannel ? videoChannel.preferredFrameRate : void 0;
  };

  var updateChannelsOfType = function updateChannelsOfType(channelType, attributes) {
    var setChannelActiveState = void 0;
    if (!self.publisher) {
      var subscriber = associatedWidget();

      setChannelActiveState = function setChannelActiveState(channel) {
        session._.subscriberChannelUpdate(self, subscriber, channel, attributes);
      };
    } else {
      setChannelActiveState = function setChannelActiveState(channel) {
        session._.streamChannelUpdate(self, channel, attributes);
      };
    }

    self.getChannelsOfType(channelType).forEach(setChannelActiveState);
  };

  this.destroyed = false;
  this.destroyedReason = void 0;

  this.destroy = function (reason, quiet) {
    destroyedReason = reason || 'clientDisconnected';
    self.destroyed = true;
    self.destroyedReason = destroyedReason;

    if (quiet !== true) {
      self.dispatchEvent(new Events.DestroyedEvent('destroyed', // This should be Events.Event.names.STREAM_DESTROYED, but
      // the value of that is currently shared with Session
      self, destroyedReason));
    }
  };

  // / PRIVATE STUFF CALLED BY Raptor.Dispatcher

  // Confusingly, this should not be called when you want to change
  // the stream properties. This is used by Raptor dispatch to notify
  // the stream that it's properies have been successfully updated
  //
  // @todo make this sane. Perhaps use setters for the properties that can
  // send the appropriate Raptor message. This would require that Streams
  // have access to their session.
  //
  this._ = {};
  this._.updateProperty = function (key, value) {
    if (validPropertyNames.indexOf(key) === -1) {
      logging.warn('Unknown stream property "' + key + '" was modified to "' + value + '".');
      return;
    }

    var oldValue = self[key];
    var newValue = value;

    switch (key) {
      case 'name':
        self[key] = newValue;
        break;

      case 'archiving':
        var widget = associatedWidget();
        if (self.publisher && widget) {
          widget._.archivingStatus(newValue);
        }
        self[key] = newValue;
        break;

      default:
    }

    var event = new Events.StreamUpdatedEvent(self, key, oldValue, newValue);
    self.dispatchEvent(event);
  };

  // Mass update, called by Raptor.Dispatcher
  this._.update = function (attributes) {
    for (var key in attributes) {
      if (!attributes.hasOwnProperty(key)) {
        continue;
      }
      self._.updateProperty(key, attributes[key]);
    }
  };

  this._.updateChannel = function (channelId, attributes) {
    self.getChannel(channelId).update(attributes);
  };
};

},{"../common-js-helpers/OTHelpers.js":217,"./events.js":306,"./logging.js":312,"./session/objects.js":370}],373:[function(require,module,exports){
'use strict';

// @todo enable the following disabled rules see OPENTOK-31136 for more info
/* eslint-disable max-len, no-restricted-syntax, no-prototype-builtins, no-continue */

var OTHelpers = require('../common-js-helpers/OTHelpers.js');
var logging = require('./logging.js');

var VideoOrientation = require('../helpers/video_orientation.js')();

// id: String                           | mandatory | immutable
// type: String {video/audio/data/...}  | mandatory | immutable
// active: Boolean                      | mandatory | mutable
// orientation: Integer?                | optional  | mutable
// frameRate: Float                     | optional  | mutable
// height: Integer                      | optional  | mutable
// width: Integer                       | optional  | mutable
// preferredFrameRate: Float            | optional  | mutable
// preferredHeight: Integer             | optional  | mutable
// preferredWidth: Integer              | optional  | mutable
//
module.exports = function StreamChannel(options) {
  this.id = options.id;
  this.type = options.type;
  this.active = OTHelpers.castToBoolean(options.active);
  this.orientation = options.orientation || VideoOrientation.ROTATED_NORMAL;
  if (options.frameRate) {
    this.frameRate = parseFloat(options.frameRate);
  }
  if (options.preferredFrameRate) {
    this.preferredFrameRate = parseFloat(options.preferredFrameRate);
  }
  if (options.preferredWidth) {
    this.preferredWidth = parseInt(options.preferredWidth, 10);
  }
  if (options.preferredHeight) {
    this.preferredHeight = parseInt(options.preferredHeight, 10);
  }
  this.width = parseInt(options.width, 10);
  this.height = parseInt(options.height, 10);

  // The defaults are used for incoming streams from pre 2015Q1 release clients.
  this.source = options.source || 'camera';
  this.fitMode = options.fitMode || 'cover';

  OTHelpers.eventing(this, true);

  // Returns true if a property was updated.
  this.update = function (attributes) {
    var videoDimensions = {};
    var oldVideoDimensions = {};

    for (var key in attributes) {
      if (!attributes.hasOwnProperty(key)) {
        continue;
      }

      // we shouldn't really read this before we know the key is valid
      var oldValue = this[key];

      switch (key) {
        case 'active':
          this.active = OTHelpers.castToBoolean(attributes[key]);
          break;

        case 'disableWarning':
          this.disableWarning = OTHelpers.castToBoolean(attributes[key]);
          break;

        case 'frameRate':
          this.frameRate = parseFloat(attributes[key], 10);
          break;

        case 'width':
        case 'height':
          this[key] = parseInt(attributes[key], 10);

          videoDimensions[key] = this[key];
          oldVideoDimensions[key] = oldValue;
          break;

        case 'orientation':
          this[key] = attributes[key];

          videoDimensions[key] = this[key];
          oldVideoDimensions[key] = oldValue;
          break;

        case 'fitMode':
          this[key] = attributes[key];
          break;

        case 'source':
          this[key] = attributes[key];
          break;

        default:
          logging.warn('Tried to update unknown key ' + key + ' on ' + this.type + ' channel ' + this.id);
          return false;
      }

      this.trigger('update', this, key, oldValue, this[key]);
    }

    if (Object.keys(videoDimensions).length) {
      // To make things easier for the public API, we broadcast videoDimensions changes,
      // which is an aggregate of width, height, and orientation changes.
      this.trigger('update', this, 'videoDimensions', oldVideoDimensions, videoDimensions);
    }

    return true;
  };
};

},{"../common-js-helpers/OTHelpers.js":217,"../helpers/video_orientation.js":284,"./logging.js":312}],374:[function(require,module,exports){
'use strict';

// When setting the background image uri of a publisher or subscriber, we allow the use of a raw
// data blob of a png, which requires the prefix 'data:image/png;base64,'. This function
// encapsulates that transformation.
module.exports = function fixBackgroundImageURI(bgImgURI) {
  if (bgImgURI.substr(0, 5) !== 'http:' && bgImgURI.substr(0, 6) !== 'https:' && bgImgURI.substr(0, 22) !== 'data:image/png;base64,') {
    return 'data:image/png;base64,' + bgImgURI;
  }

  return bgImgURI;
};

},{}],375:[function(require,module,exports){
'use strict';

// @todo enable the following disabled rules see OPENTOK-31136 for more info
/* eslint-disable no-param-reassign, no-underscore-dangle */

var fixBackgroundImageURI = require('./fix_background_image_uri.js');
var logging = require('../logging.js');
var Style = require('./style.js');
var styleHashLogFilter = require('./style_hash_log_filter.js');

/* Stylable Notes
 * Some bits are controlled by multiple flags, i.e. buttonDisplayMode and nameDisplayMode.
 * When there are multiple flags how is the final setting chosen?
 * When some style bits are set updates will need to be pushed through to the Chrome
 */

// Mixes the StylableComponent behaviour into the +self+ object. It will
// also set the default styles to +initialStyles+.
//
// @note This Mixin is dependent on OT.Eventing.
//
//
// @example
//
//  function SomeObject {
//      StylableComponent(this, {
//          name: 'SomeObject',
//          foo: 'bar'
//      });
//  }
//
//  var obj = new SomeObject();
//  obj.getStyle('foo');        // => 'bar'
//  obj.setStyle('foo', 'baz')
//  obj.getStyle('foo');        // => 'baz'
//  obj.getStyle();             // => {name: 'SomeObject', foo: 'baz'}
//
module.exports = function StylableComponent(self, initalStyles, showControls, logSetStyleWithPayload) {
  if (!self.trigger) {
    throw new Error('OT.StylableComponent is dependent on the mixin OTHelpers.eventing. ' + 'Ensure that this is included in the object before StylableComponent.');
  }

  logSetStyleWithPayload = logSetStyleWithPayload || function () {};

  var _readOnly = false;

  // Broadcast style changes as the styleValueChanged event
  var onStyleChange = function onStyleChange(key, value, oldValue) {
    if (oldValue) {
      self.trigger('styleValueChanged', key, value, oldValue);
    } else {
      self.trigger('styleValueChanged', key, value);
    }
  };

  if (showControls === false) {
    initalStyles = {
      buttonDisplayMode: 'off',
      nameDisplayMode: 'off',
      audioLevelDisplayMode: 'off',
      videoDisabledDisplayMode: 'off'
    };

    _readOnly = true;
    logSetStyleWithPayload({
      showControls: false
    });
  }

  var _style = new Style(initalStyles, onStyleChange);

  /**
   * Returns an object that has the properties that define the current user interface controls of
   * the Publisher. You can modify the properties of this object and pass the object to the
   * <code>setStyle()</code> method of thePublisher object. (See the documentation for
   * <a href="#setStyle">setStyle()</a> to see the styles that define this object.)
   * @return {Object} The object that defines the styles of the Publisher.
   * @see <a href="#setStyle">setStyle()</a>
   * @method #getStyle
   * @memberOf Publisher
   */

  /**
   * Returns an object that has the properties that define the current user interface controls of
   * the Subscriber. You can modify the properties of this object and pass the object to the
   * <code>setStyle()</code> method of the Subscriber object. (See the documentation for
   * <a href="#setStyle">setStyle()</a> to see the styles that define this object.)
   * @return {Object} The object that defines the styles of the Subscriber.
   * @see <a href="#setStyle">setStyle()</a>
   * @method #getStyle
   * @memberOf Subscriber
   */
  // If +key+ is falsly then all styles will be returned.
  self.getStyle = function (key) {
    return _style.get(key);
  };

  /**
   * Sets properties that define the appearance of some user interface controls of the Publisher.
   *
   * <p>You can either pass one parameter or two parameters to this method.</p>
   *
   * <p>If you pass one parameter, <code>style</code>, it is an object that has the following
   * properties:
   *
   *     <ul>
   *       <li><code>audioLevelDisplayMode</code> (String) &mdash; How to display the audio level
   *       indicator. Possible values are: <code>"auto"</code> (the indicator is displayed when the
   *       video is disabled), <code>"off"</code> (the indicator is not displayed), and
   *       <code>"on"</code> (the indicator is always displayed).</li>
   *
   *       <li><code>archiveStatusDisplayMode</code> (String) &mdash; How to display the archive
   *       status indicator. Possible values are: <code>"auto"</code> (the indicator is displayed
   *       when the session is being recorded), <code>"off"</code> (the indicator is not displayed).
   *       If you disable the archive status display indicator, you can display your own user
   *       interface notifications based on the <code>archiveStarted</code> and
   *       <code>archiveStopped</code> events dispatched by the Session object.</li>
   *
   *       <li><code>backgroundImageURI</code> (String) &mdash; A URI for an image to display as
   *       the background image when a video is not displayed. (A video may not be displayed if
   *       you call <code>publishVideo(false)</code> on the Publisher object). You can pass an http
   *       or https URI to a PNG, JPEG, or non-animated GIF file location. You can also use the
   *       <code>data</code> URI scheme (instead of http or https) and pass in base-64-encrypted
   *       PNG data, such as that obtained from the <a href="Publisher.html#getImgData">
   *       Publisher.getImgData()</a> method (for example, you could call
   *       <code>myPublisher.setStyle("backgroundImageURI", myPublisher.getImgData())</code>).
   *       If the URL or the image data is invalid, the property is ignored (the attempt to set
   *       the image fails silently).</li>
   *
   *       <li><code>buttonDisplayMode</code> (String) &mdash; How to display the microphone
   *       controls. Possible values are: <code>"auto"</code> (controls are displayed when the
   *       stream is first displayed and when the user mouses over the display), <code>"off"</code>
   *       (controls are not displayed), and <code>"on"</code> (controls are always displayed).</li>
   *
   *       <li><code>nameDisplayMode</code> (String) &#151; Whether to display the stream name.
   *       Possible values are: <code>"auto"</code> (the name is displayed when the stream is first
   *       displayed and when the user mouses over the display), <code>"off"</code> (the name is not
   *       displayed), and <code>"on"</code> (the name is always displayed).</li>
   *   </ul>
   * </p>
   *
   * <p>For example, the following code passes one parameter to the method:</p>
   *
   * <pre>myPublisher.setStyle({nameDisplayMode: "off"});</pre>
   *
   * <p>If you pass two parameters, <code>style</code> and <code>value</code>, they are
   * key-value pair that define one property of the display style. For example, the following
   * code passes two parameter values to the method:</p>
   *
   * <pre>myPublisher.setStyle("nameDisplayMode", "off");</pre>
   *
   * <p>You can set the initial settings when you call the <code>Session.publish()</code>
   * or <code>OT.initPublisher()</code> method. Pass a <code>style</code> property as part of the
   * <code>properties</code> parameter of the method.</p>
   *
   * <p>The OT object dispatches an <code>exception</code> event if you pass in an invalid style
   * to the method. The <code>code</code> property of the ExceptionEvent object is set to 1011.</p>
   *
   * @param {Object} style Either an object containing properties that define the style, or a
   * String defining this single style property to set.
   * @param {String} value The value to set for the <code>style</code> passed in. Pass a value
   * for this parameter only if the value of the <code>style</code> parameter is a String.</p>
   *
   * @see <a href="#getStyle">getStyle()</a>
   * @return {Publisher} The Publisher object
   * @see <a href="#setStyle">setStyle()</a>
   *
   * @see <a href="Session.html#subscribe">Session.publish()</a>
   * @see <a href="OT.html#initPublisher">OT.initPublisher()</a>
   * @method #setStyle
   * @memberOf Publisher
   */

  /**
   * Sets properties that define the appearance of some user interface controls of the Subscriber.
   *
   * <p>You can either pass one parameter or two parameters to this method.</p>
   *
   * <p>If you pass one parameter, <code>style</code>, it is an object that has the following
   * properties:
   *
   *     <ul>
   *       <li><code>audioLevelDisplayMode</code> (String) &mdash; How to display the audio level
   *       indicator. Possible values are: <code>"auto"</code> (the indicator is displayed when the
   *       video is disabled), <code>"off"</code> (the indicator is not displayed), and
   *       <code>"on"</code> (the indicator is always displayed).</li>
   *
   *       <li><code>backgroundImageURI</code> (String) &mdash; A URI for an image to display as
   *       the background image when a video is not displayed. (A video may not be displayed if
   *       you call <code>subscribeToVideo(false)</code> on the Publisher object). You can pass an
   *       http or https URI to a PNG, JPEG, or non-animated GIF file location. You can also use the
   *       <code>data</code> URI scheme (instead of http or https) and pass in base-64-encrypted
   *       PNG data, such as that obtained from the <a href="Subscriber.html#getImgData">
   *       Subscriber.getImgData()</a> method (for example, you could call
   *       <code>mySubscriber.setStyle("backgroundImageURI", mySubscriber.getImgData())</code>).
   *       If the URL or the image data is invalid, the property is ignored (the attempt to set
   *       the image fails silently).</li>
   *
   *       <li><code>buttonDisplayMode</code> (String) &mdash; How to display the speaker
   *       controls. Possible values are: <code>"auto"</code> (controls are displayed when the
   *       stream is first displayed and when the user mouses over the display), <code>"off"</code>
   *       (controls are not displayed), and <code>"on"</code> (controls are always displayed).</li>
   *
   *       <li><code>nameDisplayMode</code> (String) &#151; Whether to display the stream name.
   *       Possible values are: <code>"auto"</code> (the name is displayed when the stream is first
   *       displayed and when the user mouses over the display), <code>"off"</code> (the name is not
   *       displayed), and <code>"on"</code> (the name is always displayed).</li>
   *
   *       <li><code>videoDisabledDisplayMode</code> (String) &#151; Whether to display the video
   *       disabled indicator and video disabled warning icons for a Subscriber. These icons
   *       indicate that the video has been disabled (or is in risk of being disabled for
   *       the warning icon) due to poor stream quality. Possible values are: <code>"auto"</code>
   *       (the icons are automatically when the displayed video is disabled or in risk of being
   *       disabled due to poor stream quality), <code>"off"</code> (do not display the icons), and
   *       <code>"on"</code> (display the icons).</li>
   *   </ul>
   * </p>
   *
   * <p>For example, the following code passes one parameter to the method:</p>
   *
   * <pre>mySubscriber.setStyle({nameDisplayMode: "off"});</pre>
   *
   * <p>If you pass two parameters, <code>style</code> and <code>value</code>, they are key-value
   * pair that define one property of the display style. For example, the following code passes
   * two parameter values to the method:</p>
   *
   * <pre>mySubscriber.setStyle("nameDisplayMode", "off");</pre>
   *
   * <p>You can set the initial settings when you call the <code>Session.subscribe()</code> method.
   * Pass a <code>style</code> property as part of the <code>properties</code> parameter of the
   * method.</p>
   *
   * <p>The OT object dispatches an <code>exception</code> event if you pass in an invalid style
   * to the method. The <code>code</code> property of the ExceptionEvent object is set to 1011.</p>
   *
   * @param {Object} style Either an object containing properties that define the style, or a
   * String defining this single style property to set.
   * @param {String} value The value to set for the <code>style</code> passed in. Pass a value
   * for this parameter only if the value of the <code>style</code> parameter is a String.</p>
   *
   * @returns {Subscriber} The Subscriber object.
   *
   * @see <a href="#getStyle">getStyle()</a>
   * @see <a href="#setStyle">setStyle()</a>
   *
   * @see <a href="Session.html#subscribe">Session.subscribe()</a>
   * @method #setStyle
   * @memberOf Subscriber
   */

  self.setStyle = function (keyOrStyleHash, value, silent) {
    if (_readOnly) {
      logging.warn('Calling setStyle() has no effect because the' + 'showControls option was set to false');

      return this;
    }

    var styleHash = void 0;

    if (typeof keyOrStyleHash !== 'string') {
      styleHash = keyOrStyleHash;
    } else {
      styleHash = {};
      styleHash[keyOrStyleHash] = value;
    }

    if (styleHash.backgroundImageURI) {
      styleHash.backgroundImageURI = fixBackgroundImageURI(styleHash.backgroundImageURI);
    }

    _style.setAll(styleHash, silent);

    logSetStyleWithPayload(styleHashLogFilter(styleHash));

    return this;
  };
};

},{"../logging.js":312,"./fix_background_image_uri.js":374,"./style.js":376,"./style_hash_log_filter.js":377}],376:[function(require,module,exports){
'use strict';

// @todo enable the following disabled rules see OPENTOK-31136 for more info
/* eslint-disable no-underscore-dangle, prefer-const */

var cloneDeep = require('lodash/cloneDeep');
var logging = require('../logging.js');

module.exports = function Style(initalStyles, onStyleChange) {
  var styleApi = this;
  var _styles = {};

  // Styles with null here means every value is valid for that style
  var _validStyleValues = {
    buttonDisplayMode: ['auto', 'mini', 'mini-auto', 'off', 'on'],
    nameDisplayMode: ['auto', 'off', 'on'],
    audioLevelDisplayMode: ['auto', 'off', 'on'],
    showSettingsButton: [true, false],
    showSpeakerButton: null,
    showMicButton: [true, false],
    backgroundImageURI: null,
    showControlBar: [true, false],
    // 'showArchiveStatus' is kept for backwards compatibility.
    // 'archiveStatusDisplayMode' is the documented style name.
    showArchiveStatus: [true, false],
    archiveStatusDisplayMode: ['auto', 'off', 'on'],
    videoDisabledDisplayMode: ['auto', 'off', 'on']
  };

  // Validates the style +key+ and also whether +value+ is valid for +key+
  var isValidStyle = function isValidStyle(key, value) {
    var valueSpec = _validStyleValues[key];

    if (valueSpec === undefined) {
      return false;
    }

    if (valueSpec === null) {
      return true;
    }

    return valueSpec.indexOf(value) !== -1;
  };

  var castValue = function castValue(value) {
    switch (value) {
      case 'true':
        return true;
      case 'false':
        return false;
      default:
        return value;
    }
  };

  // Returns a copy of the styles.
  styleApi.getAll = function () {
    return cloneDeep(_styles);
  };

  styleApi.get = function (key) {
    if (key) {
      return _styles[key];
    }

    // We haven't been asked for any specific key, just return the lot
    return styleApi.getAll();
  };

  // *note:* this will not trigger onStyleChange if +silent+ is truthy
  styleApi.setAll = function (newStyles, silent) {
    Object.keys(newStyles).forEach(function (key) {
      styleApi.set(key, newStyles[key], silent);
    });

    return styleApi;
  };

  // *note:* this will not trigger onStyleChange if +silent+ is truthy
  styleApi.set = function (key, value, silent) {
    logging.debug('setStyle: ' + key.toString());

    var oldValue = void 0;
    var newValue = castValue(value);

    if (!isValidStyle(key, newValue)) {
      logging.warn('Style.set::Invalid style property passed ' + key + ' : ' + newValue);
      return styleApi;
    }

    oldValue = _styles[key];
    if (newValue !== oldValue) {
      _styles[key] = newValue;

      if (!silent) {
        onStyleChange(key, value, oldValue);
      }
    }

    return styleApi;
  };

  if (initalStyles) {
    styleApi.setAll(initalStyles, true);
  }
};

},{"../logging.js":312,"lodash/cloneDeep":147}],377:[function(require,module,exports){
'use strict';

var cloneDeep = require('lodash/cloneDeep');

// The backgroundImageURI of the styleHash object that we log to analytics needs to be stripped down
// because base64 data blobs are often very large and can be a privacy issue if taken from the
// user's camera.
module.exports = function styleHashLogFilter(styleHashInput) {
  var styleHash = cloneDeep(styleHashInput);

  if (styleHash.backgroundImageURI) {
    var protocol = styleHash.backgroundImageURI.split(':')[0];

    styleHash.backgroundImageURI = ['http', 'https', 'data'].indexOf(protocol) !== -1 ? protocol : 'other';
  }

  return styleHash;
};

},{"lodash/cloneDeep":147}],378:[function(require,module,exports){
(function (global){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

// @todo enable the following disabled rules see OPENTOK-31136 for more info
/* eslint-disable no-param-reassign, global-require, one-var, no-underscore-dangle */
/* eslint-disable no-use-before-define, no-shadow, max-len, no-unneeded-ternary */
/* eslint-disable no-plusplus, prefer-const */

var bluebird = require('bluebird');
var merge = require('lodash/merge');
var uuid = require('uuid');
var EventEmitter = require('events');

var DEFAULT_AUDIO_VOLUME = 100;

function normalizeAudioVolume(volume) {
  return Math.max(0, Math.min(100, parseInt(volume, 10)));
}

function determineAudioVolume(props) {
  if (props.audioVolume !== undefined) {
    return props.audioVolume;
  } else if (props.subscribeToAudio === false) {
    return 0;
  }
  return DEFAULT_AUDIO_VOLUME;
}

module.exports = function SubscriberFactory() {
  var deps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var analytics = deps.analytics || require('../analytics.js');
  var audioContext = deps.audioContext || require('../../helpers/audio_context.js')();
  var AudioLevelMeter = deps.AudioLevelMeter || require('../chrome/audio_level_meter.js');
  var AudioLevelTransformer = deps.AudioLevelTransformer || require('../audio_level_transformer');
  var BackingBar = deps.BackingBar || require('../chrome/backing_bar.js');
  var Chrome = deps.Chrome || require('../chrome/chrome.js');
  var ConnectivityAttemptPinger = deps.ConnectivityAttemptPinger || require('../../helpers/connectivity_attempt_pinger.js');
  var env = deps.env || require('../../common-js-helpers/env.js');
  var errors = deps.Errors || require('../Errors.js');
  var Events = deps.Events || require('../events.js')();
  var ExceptionCodes = deps.ExceptionCodes || require('../exception_codes.js');
  var GetstatsAudioOutputLevelSampler = deps.GetstatsAudioOutputLevelSampler || require('../../helpers/audio_level_samplers/getstats_audio_output_level_sampler');
  var getStatsHelpers = deps.getStatsHelpers || require('../peer_connection/get_stats_helpers.js');
  var hasAudioOutputLevelStatCapability = deps.hasAudioOutputLevelStatCapability || require('../../helpers/hasAudioOutputLevelStatCapability.js');
  var hasRemoteStreamsWithWebAudio = deps.hasRemoteStreamsWithWebAudio || require('../../helpers/hasRemoteStreamsWithWebAudio.js');
  var interpretPeerConnectionError = deps.interpretPeerConnectionError || require('../interpretPeerConnectionError.js')();
  var IntervalRunner = deps.IntervalRunner || require('../interval_runner.js')();
  var logging = deps.logging || require('../logging.js');
  var Message = deps.Message || require('../messaging/raptor/message.js');
  var MuteButton = deps.MuteButton || require('../chrome/mute_button.js')();
  var NamePanel = deps.NamePanel || require('../chrome/name_panel.js');
  var otError = deps.otError || require('../../helpers/otError.js')();
  var OTErrorClass = deps.OTErrorClass || require('../ot_error_class.js');
  var OTHelpers = deps.OTHelpers || require('../../common-js-helpers/OTHelpers.js');
  var otProperties = deps.otProperties || require('../../helpers/otProperties.js');
  var StylableComponent = deps.StylableComponent || require('../styling/stylable_component.js');
  var SubscriberPeerConnection = deps.SubscriberPeerConnection || require('../peer_connection/subscriber_peer_connection.js')();
  var SubscribingState = deps.SubscribingState || require('./state.js');
  var VideoDisabledIndicator = deps.VideoDisabledIndicator || require('../chrome/video_disabled_indicator.js');
  var WebaudioAudioLevelSampler = deps.WebaudioAudioLevelSampler || require('../../helpers/audio_level_samplers/webaudio_audio_level_sampler');
  var WidgetView = deps.WidgetView || require('../../helpers/widget_view.js')();

  var BIND_VIDEO_DELAY_MAX = 30000;
  var BIND_VIDEO_DELAY_WARNING = 15000;

  /**
   * The Subscriber object is a representation of the local video element that is playing back
   * a remote stream. The Subscriber object includes methods that let you disable and enable
   * local audio playback for the subscribed stream. The <code>subscribe()</code> method of the
   * {@link Session} object returns a Subscriber object.
   *
   * @property {Element} element The HTML DOM element containing the Subscriber.
   * @property {String} id The DOM ID of the Subscriber.
   * @property {Stream} stream The stream to which you are subscribing.
   *
   * @class Subscriber
   * @augments EventDispatcher
   */
  var Subscriber = function Subscriber(targetElement, options, completionHandler) {
    var _this = this;

    var _widgetView = void 0,
        _streamContainer = void 0,
        _chrome = void 0,
        _muteDisplayMode = void 0,
        _audioLevelMeter = void 0,
        _fromConnectionId = void 0,
        _peerConnection = void 0,
        _subscribeStartTime = void 0,
        _startConnectingTime = void 0,
        _state = void 0,
        _audioLevelSampler = void 0,
        _audioLevelRunner = void 0,
        _isLocalStream = void 0,
        _webRTCStream = void 0,
        _lastSubscribeToVideoReason = void 0,
        _attemptStartTime = void 0,
        _connectivityAttemptPinger = void 0,
        _streamEventHandlers = void 0,
        _isSubscribingToAudio = void 0;
    var _loaded = false;
    var _widgetId = uuid();
    var _domId = targetElement || _widgetId;
    var _session = options.session;
    var _stream = options.stream;
    var _audioVolume = void 0;
    var _previousAudioVolume = void 0;
    var _audioLevelCapable = Subscriber.hasAudioOutputLevelStatCapability() || hasRemoteStreamsWithWebAudio();
    var _frameRateRestricted = false;
    var _lastIceConnectionState = Events.Event.names.SUBSCRIBER_DISCONNECTED;
    var _subscriber = this;
    var _preDisconnectStats = {};
    var _congestionLevel = null;
    var _hasLoadedAtleastOnce = false;

    var _pcConnected = {};
    _pcConnected.promise = new bluebird.Promise(function (resolve, reject) {
      _pcConnected.resolve = resolve;
      _pcConnected.reject = reject;
    });

    // used for test purposes so that we can rely on synchronously dispatched events
    var _syncEventEmitter = new EventEmitter();

    var _properties = OTHelpers.defaults({}, options, {
      showControls: true,
      testNetwork: false,
      fitMode: _stream.defaultFitMode || 'cover',
      insertDefaultUI: true
    });

    if (_properties.testNetwork && _session.sessionInfo.p2pEnabled) {
      logging.warn('You cannot test your network with a relayed session. Use a routed session.');
    }

    if (typeof completionHandler !== 'function') {
      completionHandler = function completionHandler() {};
    }

    this.id = _domId;
    this.widgetId = _widgetId;
    this.session = _session;
    this.stream = _properties.stream;
    _stream = _properties.stream;
    this.streamId = _stream.id;

    if (!_session) {
      OTErrorClass.handleJsException('OT.Subscriber must be passed a session option', 2000, {
        session: _session,
        target: this
      });

      return null;
    }

    OTHelpers.eventing(this, false);
    _subscriber.once('subscribeComplete', completionHandler);

    if (_audioLevelCapable) {
      this.on({
        'audioLevelUpdated:added': function audioLevelUpdatedAdded(count) {
          if (count === 1 && _audioLevelRunner) {
            _audioLevelRunner.start();
          }
        },
        'audioLevelUpdated:removed': function audioLevelUpdatedRemoved(count) {
          if (count === 0 && _audioLevelRunner) {
            _audioLevelRunner.stop();
          }
        }
      });
    }

    // make sure we trigger an error if we are not getting any "data" after a reasonable
    // amount of time
    var setUpBindGuards = function setUpBindGuards() {
      var tos = [setTimeout(function () {
        logConnectivityEvent('Warning', {});
      }, BIND_VIDEO_DELAY_WARNING), setTimeout(function () {
        onPeerConnectionFailure(null, 'OT.Subscriber failed to subscribe to a stream in a ' + 'reasonable amount of time', _peerConnection, 'ICEWorkflow');
      }, BIND_VIDEO_DELAY_MAX)];

      return function cancelBindGuards() {
        tos.forEach(function (to) {
          clearTimeout(to);
        });
      };
    };

    var logAnalyticsEvent = function logAnalyticsEvent(action, variation, payload, options, throttle) {
      var stats = OTHelpers.extend({
        action: action,
        variation: variation,
        payload: payload,
        streamId: _stream ? _stream.id : null,
        sessionId: _session ? _session.sessionId : null,
        connectionId: _session && _session.isConnected() ? _session.connection.connectionId : null,
        partnerId: _session && _session.sessionInfo ? _session.sessionInfo.partnerId : null,
        subscriberId: _widgetId
      }, options);

      if (variation === 'Failure' || variation === 'iceconnectionstatechange' && payload === 'closed') {
        stats = OTHelpers.extend(stats, _preDisconnectStats);
      }

      var args = [stats];
      if (throttle) {
        args.push(throttle);
      }
      analytics.logEvent.apply(analytics, args);
    };

    var logConnectivityEvent = function logConnectivityEvent(variation, payload, options) {
      if (variation === 'Attempt' || !_connectivityAttemptPinger) {
        _attemptStartTime = new Date().getTime();
        _connectivityAttemptPinger = new ConnectivityAttemptPinger({
          action: 'Subscribe',
          sessionId: _session ? _session.sessionId : null,
          connectionId: _session && _session.isConnected() ? _session.connection.connectionId : null,
          partnerId: _session.isConnected() ? _session.sessionInfo.partnerId : null,
          p2p: _session && _session.sessionInfo.p2pEnabled,
          messagingServer: _session && _session.sessionInfo.messagingServer,
          subscriberId: _widgetId,
          streamId: _stream ? _stream.id : null
        });
      }
      _connectivityAttemptPinger.setVariation(variation);
      if (variation === 'Failure' || variation === 'Success' || variation === 'Cancel') {
        if (!options) {
          options = {};
        }
        OTHelpers.extend(options, {
          attemptDuration: new Date().getTime() - _attemptStartTime
        });
      }
      logAnalyticsEvent('Subscribe', variation, payload, options);
    };

    var logResubscribe = function logResubscribe(variation, payload) {
      logAnalyticsEvent('ICERestart', variation, payload);
    };

    var recordQOS = function recordQOS(_ref) {
      var parsedStats = _ref.parsedStats;

      var domElement = void 0;
      if (_widgetView && _widgetView.domElement) {
        domElement = _widgetView.domElement;
      } else if (_widgetView && _widgetView.video() && _widgetView.video().domElement()) {
        // If we're using insertDefaultUI=false then there is no container
        domElement = _widgetView.video().domElement();
      }
      var QoSBlob = {
        widgetType: 'Subscriber',
        width: domElement ? Number(OTHelpers.width(domElement).replace('px', '')) : null,
        height: domElement ? Number(OTHelpers.height(domElement).replace('px', '')) : null,
        audioTrack: _webRTCStream && _webRTCStream.getAudioTracks().length > 0,
        hasAudio: _stream && _stream.hasAudio,
        subscribeToAudio: _isSubscribingToAudio,
        audioVolume: this.getAudioVolume(),
        videoTrack: _webRTCStream && _webRTCStream.getVideoTracks().length > 0,
        hasVideo: _stream && _stream.hasVideo,
        subscribeToVideo: _properties.subscribeToVideo,
        sessionId: _session ? _session.sessionId : null,
        connectionId: _session ? _session.connection.connectionId : null,
        mediaServerName: _session ? _session.sessionInfo.mediaServerName : null,
        p2p: _session ? _session.sessionInfo.p2pEnabled : false,
        messagingServer: _session ? _session.sessionInfo.messagingServer : null,
        apiServer: otProperties.apiURL,
        congestionLevel: _congestionLevel,
        partnerId: _session ? _session.apiKey : null,
        streamId: _stream.id,
        subscriberId: _widgetId,
        version: otProperties.version,
        duration: Math.round((OTHelpers.now() - _subscribeStartTime) / 1000),
        remoteConnectionId: _stream.connection.connectionId
      };
      var combinedStats = OTHelpers.extend(QoSBlob, parsedStats);
      analytics.logQOS(combinedStats);
      this.trigger('qos', combinedStats);
    }.bind(this);

    var stateChangeFailed = function stateChangeFailed(changeFailed) {
      logging.error('OT.Subscriber State Change Failed: ', changeFailed.message);
      logging.debug(changeFailed);
    };

    var onLoaded = function onLoaded() {
      if (_state.isSubscribing() || !_streamContainer) {
        return;
      }

      _loaded = true;

      if (!_hasLoadedAtleastOnce) {
        _hasLoadedAtleastOnce = true;
      }

      logging.debug('OT.Subscriber.onLoaded');

      _state.set('Subscribing');
      _subscribeStartTime = OTHelpers.now();

      var payload = {
        pcc: parseInt(_subscribeStartTime - _startConnectingTime, 10),
        hasRelayCandidates: _peerConnection && _peerConnection.hasRelayCandidates()
      };
      logAnalyticsEvent('createPeerConnection', 'Success', payload);

      _widgetView.loading(false);
      if (_chrome) {
        _chrome.showAfterLoading();
      }

      if (_frameRateRestricted) {
        _stream.setRestrictFrameRate(true);
      }

      if (_audioLevelMeter) {
        _audioLevelMeter.audioOnly(_widgetView.audioOnly());
      }

      logConnectivityEvent('Success', {});

      _this.trigger('subscribeComplete', null, _this);
      _this.trigger('loaded', _this);
    };

    var onDisconnected = function onDisconnected() {
      logging.debug('OT.Subscriber has been disconnected from the Publisher\'s PeerConnection');

      if (_state.isAttemptingToSubscribe()) {
        // subscribing error
        _state.set('Failed');

        this.trigger('subscribeComplete', otError(errors.DISCONNECTED, new Error('ClientDisconnected')), this);
      } else if (_state.isSubscribing()) {
        _state.set('Failed');

        // we were disconnected after we were already subscribing
        // probably do nothing?
      }

      this.disconnect();
    };

    var onVideoError = function onVideoError(plainErr) {
      var err = otError(errors.MEDIA_ERR_DECODE, plainErr, plainErr.code || ExceptionCodes.P2P_CONNECTION_FAILED);
      err.message = 'OT.Subscriber while playing stream: ' + err.message;

      logging.error('OT.Subscriber.onVideoError');
      logConnectivityEvent('Failure', null, {
        failureReason: 'VideoElement',
        failureMessage: err.message,
        failureCode: err.code || ExceptionCodes.P2P_CONNECTION_FAILED
      });

      _state.set('Failed');

      if (_state.isAttemptingToSubscribe()) {
        _subscriber.trigger('subscribeComplete', err);
      } else {
        // FIXME: This emits a string instead of an error here for backwards compatibility despite
        // being undocumented. When possible we should remove access to this and other undocumented
        // events, and restore emitting actual errors here.
        _subscriber.trigger('error', err.message);
      }

      OTErrorClass.handleJsException(err.message, ExceptionCodes.UNABLE_TO_PUBLISH, {
        session: self.session,
        target: self
      });
    };

    var onPeerConnectionFailure = function onPeerConnectionFailure(code, reason, peerConnection, prefix) {
      if (prefix === 'ICEWorkflow' && _session.sessionInfo.reconnection && _loaded) {
        logging.debug('Ignoring peer connection failure due to possibility of reconnection.');
        return;
      }

      var errorCode = void 0;
      if (prefix === 'ICEWorkflow') {
        errorCode = ExceptionCodes.SUBSCRIBER_ICE_WORKFLOW_FAILED;
      } else if (code === ExceptionCodes.STREAM_LIMIT_EXCEEDED) {
        errorCode = code;
      } else {
        errorCode = ExceptionCodes.P2P_CONNECTION_FAILED;
      }
      var options = {
        failureReason: prefix ? prefix : 'PeerConnectionError',
        failureMessage: 'OT.Subscriber PeerConnection Error: ' + reason,
        failureCode: errorCode
      };

      if (_state.isAttemptingToSubscribe()) {
        // We weren't subscribing yet so this was a failure in setting
        // up the PeerConnection or receiving the initial stream.
        var payload = {
          hasRelayCandidates: _peerConnection && _peerConnection.hasRelayCandidates()
        };
        logAnalyticsEvent('createPeerConnection', 'Failure', payload, options);

        _state.set('Failed');

        var error = interpretPeerConnectionError(code, reason, prefix, '(not found)', 'Subscriber');

        _this.trigger('subscribeComplete', error, _this);
        logConnectivityEvent('Failure', null, options);
      } else if (_state.isSubscribing()) {
        // we were disconnected after we were already subscribing
        _state.set('Failed');
        _this.trigger('error', reason);
        logConnectivityEvent('Disconnect', null, options);
      }

      _this.disconnect();

      if (Number(code) === 404) {
        // Usually, the subscriber should be kept in an error state when the peer connection fails
        // because it still exists in the session. But when we get a 404 that means it doesn't
        // exist, even if the session still thinks it does.
        _this.destroy();
      }

      OTErrorClass.handleJsException('OT.Subscriber PeerConnection Error: ' + reason, errorCode, {
        session: _session,
        target: _this
      });
      _showError.call(_this, code);
    };

    var onRemoteStreamAdded = function onRemoteStreamAdded(webRTCStream) {
      _webRTCStream = webRTCStream;
      logging.debug('OT.Subscriber.onRemoteStreamAdded');

      _state.set('BindingRemoteStream');

      // Disable the audio/video, if needed
      this.subscribeToAudio(_isSubscribingToAudio, false);

      _lastSubscribeToVideoReason = 'loading';
      this.subscribeToVideo(_properties.subscribeToVideo, 'loading');

      // setting resolution and frame rate doesn't work in P2P
      if (!_session.sessionInfo.p2pEnabled) {
        this.setPreferredResolution(_properties.preferredResolution);
        this.setPreferredFrameRate(_properties.preferredFrameRate);
      }

      var videoContainerOptions = {
        error: onVideoError,
        audioVolume: _audioVolume
      };

      // This is a workaround for a bug in Chrome where a track disabled on
      // the remote end doesn't fire loadedmetadata causing the subscriber to timeout
      // https://jira.tokbox.com/browse/OPENTOK-15605
      // Also https://jira.tokbox.com/browse/OPENTOK-16425
      // Also https://tokbox.atlassian.net/browse/OPENTOK-27112
      //
      // Workaround for an IE issue https://jira.tokbox.com/browse/OPENTOK-18824
      // We still need to investigate further.
      //
      webRTCStream.getVideoTracks().forEach(function (track) {
        if (global.webkitMediaStream) {
          track.enabled = false;
        } else {
          track.enabled = _stream.hasVideo && _properties.subscribeToVideo;
        }
      });

      var videoBindSucceeded = new bluebird.Promise(function (resolve, reject) {
        function hasVP8First(sdp) {
          if (sdp.indexOf('VP8/') > -1) {
            if (sdp.indexOf('H264/') > -1 && sdp.indexOf('H264/') < sdp.indexOf('VP8/')) {
              // h264 first
              return false;
            }
            // vp8 only/first
            return true;
          }
          // no vp8
          return false;
        }

        if (OTHelpers.env.name === 'Safari' && !_session.sessionInfo.p2pEnabled && hasVP8First(_peerConnection.remoteDescription().sdp)) {
          _widgetView.addError('The stream is unable to be played.', 'Safari does not support VP8 streams. Please use Chrome or Firefox.');

          var errMsg = 'VP8 not supported in Safari. Please make sure you have signed up for ' + 'the Safari Beta Program. See https://tokbox.com/safari';
          cancelBindGuards();
          onVideoError(new Error(errMsg));
          return reject(new Error(errMsg));
        }

        _streamContainer = _widgetView.bindVideo(webRTCStream, videoContainerOptions, function (err) {
          if (err) {
            onVideoError(err);
            reject(err);
            return;
          }

          if (global.webkitMediaStream) {
            // Reenable any video streams that we previously disabled for OPENTOK-27112
            webRTCStream.getVideoTracks().forEach(function (track) {
              track.enabled = _stream.hasVideo && _properties.subscribeToVideo;
            });
          }

          if (_streamContainer) {
            _streamContainer.orientation({
              width: _stream.videoDimensions.width,
              height: _stream.videoDimensions.height,
              videoOrientation: _stream.videoDimensions.orientation
            });
          }

          resolve();
        });

        return undefined;
      });

      var videoElementCreated = new bluebird.Promise(function (resolve, reject) {
        if (_streamContainer && _streamContainer.domElement()) {
          resolve();
          return;
        }

        _widgetView.once('videoElementCreated', resolve);
        _subscriber.once('destroyed', reject);
      });

      bluebird.all([videoBindSucceeded, videoElementCreated, _pcConnected.promise]).then(onLoaded);
      // Note: there's no .catch here because the failure cases of both dependencies are already
      // handled separately elsewhere. This was because the code was designed pre-promises, and this
      // should be consolidated in future re-factoring.

      // if the audioLevelSampler implementation requires a stream we need to set it now
      if (_audioLevelSampler && 'webRTCStream' in _audioLevelSampler && webRTCStream.getAudioTracks().length > 0) {
        _audioLevelSampler.webRTCStream(webRTCStream);
      }

      logAnalyticsEvent('createPeerConnection', 'StreamAdded');
      this.trigger('streamAdded', this);

      // for test purposes
      _syncEventEmitter.emit('__sync__streamAdded', this);
    };

    var onRemoteStreamRemoved = function onRemoteStreamRemoved(webRTCStream) {
      _webRTCStream = null;
      logging.debug('OT.Subscriber.onStreamRemoved');

      if (_streamContainer.stream === webRTCStream) {
        _streamContainer.destroy();
        _streamContainer = null;
      }

      this.trigger('streamRemoved', this);
    };

    var connectionStateMap = {
      new: Events.Event.names.SUBSCRIBER_DISCONNECTED,
      checking: Events.Event.names.SUBSCRIBER_DISCONNECTED,
      connected: Events.Event.names.SUBSCRIBER_CONNECTED,
      completed: Events.Event.names.SUBSCRIBER_CONNECTED,
      disconnected: Events.Event.names.SUBSCRIBER_DISCONNECTED
    };

    var onIceConnectionStateChange = function onIceConnectionStateChange(state) {
      var isLoading = void 0;
      var mappedState = connectionStateMap[state];
      if (mappedState && mappedState !== _lastIceConnectionState) {
        _lastIceConnectionState = mappedState;
        logging.debug('OT.Subscriber.connectionStateChanged to ' + state);
        this.dispatchEvent(new Events.ConnectionStateChangedEvent(mappedState, this));

        if (_widgetView) {
          isLoading = mappedState !== Events.Event.names.SUBSCRIBER_CONNECTED;
          _widgetView.loading(isLoading);
        }
      }
    };

    var onIceRestartSuccess = function onIceRestartSuccess() {
      logResubscribe('Success');
    };

    var onIceRestartFailure = function onIceRestartFailure() {
      logResubscribe('Failure', {
        reason: 'ICEWorkflow',
        message: 'OT.Subscriber PeerConnection Error: ' + 'The stream was unable to connect due to a network error.' + ' Make sure your connection isn\'t blocked by a firewall.'
      });
    };

    var streamDestroyed = function streamDestroyed() {
      this.disconnect();
    };

    var streamUpdated = function streamUpdated(event) {
      switch (event.changedProperty) {
        case 'videoDimensions':
          if (!_streamContainer) {
            // Ignore videoEmension updates before streamContainer is created OPENTOK-17253
            break;
          }
          _streamContainer.orientation({
            width: event.newValue.width,
            height: event.newValue.height,
            videoOrientation: event.newValue.orientation
          });

          this.dispatchEvent(new Events.VideoDimensionsChangedEvent(this, event.oldValue, event.newValue));

          break;

        case 'videoDisableWarning':
          if (_chrome) {
            _chrome.videoDisabledIndicator.setWarning(event.newValue);
          }
          this.dispatchEvent(new Events.VideoDisableWarningEvent(event.newValue ? 'videoDisableWarning' : 'videoDisableWarningLifted'));
          _congestionLevel = event.newValue === 'videoDisableWarning' ? 1 : null;
          break;

        case 'hasVideo':

          setAudioOnly(!(_stream.hasVideo && _properties.subscribeToVideo));

          this.dispatchEvent(new Events.VideoEnabledChangedEvent(_stream.hasVideo ? 'videoEnabled' : 'videoDisabled', {
            reason: 'publishVideo'
          }));
          break;

        case 'hasAudio':
          _muteDisplayMode.update();
          break;

        default:
      }
    };

    var _hasAudioTracks = function _hasAudioTracks() {
      // Use _stream.getChannelsOfType instead of _webRTCStream.getAudioTracks
      // because its available as soon as Subscriber is instantiated.
      return _stream.getChannelsOfType('audio').length > 0;
    };

    // / Chrome

    _muteDisplayMode = {
      get: function get() {
        // Use buttonDisplayMode if we have an audio track, even if its muted
        return _hasAudioTracks() ? _subscriber.getStyle('buttonDisplayMode') : 'off';
      },
      update: function update() {
        var mode = _muteDisplayMode.get();
        if (_chrome) {
          _chrome.muteButton.setDisplayMode(mode);
          _chrome.backingBar.setMuteMode(mode);
        }
      }
    };

    var updateChromeForStyleChange = function updateChromeForStyleChange(key, value /* , oldValue*/) {
      if (!_chrome) {
        return;
      }

      switch (key) {
        case 'nameDisplayMode':
          _chrome.name.setDisplayMode(value);
          _chrome.backingBar.setNameMode(value);
          break;

        case 'videoDisabledDisplayMode':
          _chrome.videoDisabledIndicator.setDisplayMode(value);
          break;

        case 'showArchiveStatus':
          _chrome.archive.setShowArchiveStatus(value);
          break;

        case 'buttonDisplayMode':
          _muteDisplayMode.update();
          break;

        case 'audioLevelDisplayMode':
          _chrome.audioLevel.setDisplayMode(value);
          break;

        case 'bugDisplayMode':
          // bugDisplayMode can't be updated but is used by some partners
          break;

        case 'backgroundImageURI':
          _widgetView.setBackgroundImageURI(value);
          break;

        default:
      }
    };

    var _createChrome = function _createChrome() {
      var widgets = {
        backingBar: new BackingBar({
          nameMode: !_properties.name ? 'off' : this.getStyle('nameDisplayMode'),
          muteMode: _muteDisplayMode.get()
        }),

        name: new NamePanel({
          name: _properties.name,
          mode: this.getStyle('nameDisplayMode')
        }),

        muteButton: new MuteButton({
          muted: _audioVolume === 0,
          mode: _muteDisplayMode.get()
        })
      };

      if (_audioLevelCapable) {
        var audioLevelTransformer = new AudioLevelTransformer();

        var audioLevelUpdatedHandler = function audioLevelUpdatedHandler(evt) {
          _audioLevelMeter.setValue(audioLevelTransformer.transform(evt.audioLevel));
        };

        _audioLevelMeter = new AudioLevelMeter({
          mode: _subscriber.getStyle('audioLevelDisplayMode')
        });

        _audioLevelMeter.watchVisibilityChanged(function (visible) {
          if (visible) {
            _subscriber.on('audioLevelUpdated', audioLevelUpdatedHandler);
          } else {
            _subscriber.off('audioLevelUpdated', audioLevelUpdatedHandler);
          }
        });

        _audioLevelMeter.setDisplayMode(this.getStyle('audioLevelDisplayMode'));
        _audioLevelMeter.audioOnly(false);

        widgets.audioLevel = _audioLevelMeter;
      }

      widgets.videoDisabledIndicator = new VideoDisabledIndicator({
        mode: this.getStyle('videoDisabledDisplayMode')
      });

      if (_widgetView && _widgetView.domElement) {
        _chrome = new Chrome({
          parent: _widgetView.domElement
        }).set(widgets).on({
          muted: function muted() {
            _subscriber.setAudioVolume(0);
          },
          unmuted: function unmuted() {
            _subscriber.setAudioVolume(_previousAudioVolume);
          }
        }, this);
        // Hide the chrome until we explicitly show it
        _chrome.hideWhileLoading();
      }
    };

    var _showError = function _showError(code) {
      var errorMessage = void 0;
      var helpMessage = void 0;

      // Display the error message inside the container, assuming it's
      // been created by now.
      if (_widgetView) {
        if (code === ExceptionCodes.STREAM_LIMIT_EXCEEDED) {
          errorMessage = 'The stream was unable to connect.';
          helpMessage = 'The limit for the number of media streams has been reached.';
        } else {
          errorMessage = 'The stream was unable to connect due to a network error.';
          if (_hasLoadedAtleastOnce) {
            helpMessage = 'Ensure you have a stable connection and try again.';
          } else {
            helpMessage = 'Make sure you have a stable network connection and that it isn\'t ' + 'blocked by a firewall.';
          }
        }

        _widgetView.addError(errorMessage, helpMessage);
      }
    };

    StylableComponent(this, {
      nameDisplayMode: 'auto',
      buttonDisplayMode: 'auto',
      audioLevelDisplayMode: 'auto',
      videoDisabledDisplayMode: 'auto',
      backgroundImageURI: null,
      showArchiveStatus: true,
      showMicButton: true
    }, _properties.showControls, function (payload) {
      logAnalyticsEvent('SetStyle', 'Subscriber', payload, null, 0.1);
    });

    var setAudioOnly = function setAudioOnly(audioOnly) {
      if (_peerConnection) {
        _peerConnection.subscribeToVideo(!audioOnly);
      }

      if (_widgetView) {
        _widgetView.audioOnly(audioOnly);
        _widgetView.showPoster(audioOnly);
      }

      if (_audioLevelMeter) {
        _audioLevelMeter.audioOnly(audioOnly);
      }
    };

    // logs an analytics event for getStats on the first call
    var notifyGetStatsCalled = function () {
      var callCount = 0;
      return function throttlingNotifyGetStatsCalled() {
        if (callCount === 0) {
          logAnalyticsEvent('GetStats', 'Called');
        }
        callCount++;
      };
    }();

    this.destroy = function (reason, quiet) {
      if (_state.isDestroyed()) {
        return this;
      }

      if (_state.isAttemptingToSubscribe()) {
        var payload = {
          reason: reason || 'destroy'
        };

        if (reason === 'streamDestroyed') {
          // We weren't subscribing yet so the stream was destroyed before we setup
          // the PeerConnection or receiving the initial stream.
          this.trigger('subscribeComplete', otError(errors.STREAM_DESTROYED, new Error('Stream was destroyed before it could be subscribed to')), this);
        } else {
          _connectivityAttemptPinger.stop();
        }

        logConnectivityEvent('Cancel', payload);
      }

      _state.set('Destroyed');

      if (_audioLevelRunner) {
        _audioLevelRunner.stop();
      }

      _preDisconnectStats = {
        sessionId: _session.sessionId,
        connectionId: _session && _session.isConnected() ? _session.connection.connectionId : null,
        partnerId: _session && _session.sessionInfo ? _session.sessionInfo.partnerId : null,
        streamId: _stream && !_stream.destroyed ? _stream.id : null
      };

      this.disconnect();

      if (_chrome) {
        _chrome.destroy();
        _chrome = null;
      }

      if (_widgetView) {
        _widgetView.destroy();
        _widgetView = null;
        this.element = null;
      }

      if (_stream && !_stream.destroyed) {
        logAnalyticsEvent('unsubscribe', null, { streamId: _stream.id });
      }

      _stream.off(_streamEventHandlers, this);

      this.id = null;
      _domId = null;
      this.stream = null;
      _stream = null;
      this.streamId = null;

      this.session = null;
      _session = null;
      _properties = null;

      if (quiet !== true) {
        this.dispatchEvent(new Events.DestroyedEvent(Events.Event.names.SUBSCRIBER_DESTROYED, this, reason), this.off.bind(this));
      }

      return this;
    };

    this.disconnect = function () {
      if (!_state.isDestroyed() && !_state.isFailed()) {
        // If we are already in the destroyed state then disconnect
        // has been called after (or from within) destroy.
        _state.set('NotSubscribing');
      }

      if (_streamContainer) {
        _streamContainer.destroy();
        _streamContainer = null;
      }

      if (_peerConnection) {
        _peerConnection.destroy();
        _peerConnection = null;

        logAnalyticsEvent('disconnect', 'PeerConnection', { streamId: _stream.id });
      }
    };

    this.processMessage = function (type, fromConnectionId, message) {
      logging.debug('OT.Subscriber.processMessage: Received ' + type + ' message from ' + fromConnectionId);
      logging.debug(message);

      if (_fromConnectionId !== fromConnectionId) {
        _fromConnectionId = fromConnectionId;
      }

      if (_peerConnection) {
        _peerConnection.processMessage(type, message);
      }
    };

    this.disableVideo = function (active) {
      if (!active) {
        logging.warn('Due to high packet loss and low bandwidth, video has been disabled');
      } else if (_lastSubscribeToVideoReason === 'auto') {
        logging.info('Video has been re-enabled');
        if (_chrome) {
          _chrome.videoDisabledIndicator.disableVideo(false);
        }
      } else {
        logging.info('Video was not re-enabled because it was manually disabled');
        return;
      }
      this.subscribeToVideo(active, 'auto');
      if (!active && _chrome) {
        _chrome.videoDisabledIndicator.disableVideo(true);
      }
      var payload = active ? { videoEnabled: true } : { videoDisabled: true };
      logAnalyticsEvent('updateQuality', 'video', payload);
    };

    /**
     * Returns the base-64-encoded string of PNG data representing the Subscriber video.
     *
     *  <p>You can use the string as the value for a data URL scheme passed to the src parameter of
     *  an image file, as in the following:</p>
     *
     *  <pre>
     *  var imgData = subscriber.getImgData();
     *
     *  var img = document.createElement("img");
     *  img.setAttribute("src", "data:image/png;base64," + imgData);
     *  var imgWin = window.open("about:blank", "Screenshot");
     *  imgWin.document.write("&lt;body&gt;&lt;/body&gt;");
     *  imgWin.document.body.appendChild(img);
     *  </pre>
     * @method #getImgData
     * @memberOf Subscriber
     * @return {String} The base-64 encoded string. Returns an empty string if there is no video.
     */
    this.getImgData = function () {
      if (!this.isSubscribing()) {
        logging.error('OT.Subscriber.getImgData: Cannot getImgData before the Subscriber ' + 'is subscribing.');
        return null;
      }

      return _streamContainer.imgData();
    };

    /**
    *  Returns the details on the subscriber stream quality, including the following:
    *
    * <ul>
    *
    *   <li>Total audio and video packets lost</li>
    *   <li>Total audio and video packets received</li>
    *   <li>Total audio and video bytes received</li>
    *   <li>Current video frame rate</li>
    *
    * </ul>
    *
    * You can publish a test stream, subscribe to it (on the publishing client), and use this method
    * to check its quality. Based on the stream's quality, you can determine what video resolution is
    * supported and whether conditions support video or audio. You can then publish an appropriate
    * stream, based on the results. When using this method to test a stream published by your
    * own client, set the <code>testNetwork</code> property to <code>true</code> in the options you
    * pass into the <a href="Session.html#subscribe">Session.subscribe()</a> method. For an example,
    * see the <a href="https://github.com/opentok/opentok-network-test">opentok-network-test</a>
    * project on GitHub.
    * <p>
    * You may also use these statistics to have a Subscriber subscribe to audio-only if the audio
    * packet loss reaches a certain threshold. If you choose to do this, you should set the
    * <code>audioFallbackEnabled</code> setting to <code>false</code> when you initialize Publisher
    * objects for the session. This prevents the OpenTok Media Router from using its own audio-only
    * toggling implementation. (See the documentation for the
    * <a href="OT.html#initPublisher">OT.initPublisher()</a> method.)
    *
    * @param {Function} completionHandler A function that takes the following
    * parameters:
    *
    * <ul>
    *
    *   <li><code>error</code> (<a href="Error.html">Error</a>) &mdash; Upon successful completion of
    *   the network test, this is undefined. The error results if the client is not connected or
    *   the stream published by your own client.</li>
    *
    *   <li><code>stats</code> (Object) &mdash; An object with the following properties:
    *     <p>
    *     <ul>
    *       <li><code>audio.bytesReceived</code> (Number) &mdash; The total number of audio bytes
    *         received by the subscriber</li>
    *       <li><code>audio.packetsLost</code> (Number) &mdash; Total audio packets that did not reach
    *         the subscriber</li>
    *       <li><code>audio.packetsReceived</code> (Number) &mdash; The total number of audio packets
    *         received by the subscriber</li>
    *       <li><code>timestamp</code> (Number) &mdash; The timestamp, in milliseconds since the Unix
    *         epoch, for when these stats were gathered</li>
    *       <li><code>video.bytesReceived</code> (Number) &mdash; The total video bytes received by
    *         the subscriber</li>
    *       <li><code>video.packetsLost</code> (Number) &mdash; The total number of video packets that
    *         did not reach the subscriber</li>
    *       <li><code>video.packetsReceived</code> (Number) &mdash; The total number of video packets
    *         received by the subscriber</li>
    *       <li><code>video.frameRate</code> (Number) &mdash; The current video frame rate</li>
    *     </ul>
    *   </li>
    * </ul>
    * @method #getStats
    * @memberOf Subscriber
    */
    this.getStats = function (callback) {
      if (!_peerConnection) {
        callback(otError(errors.NOT_CONNECTED, new Error('OT.Subscriber is not connected cannot getStats'), 1015));
        return;
      }

      notifyGetStatsCalled();

      _peerConnection.getStats(function (error, stats) {
        if (error) {
          if (error.code === 1015) {
            error = otError(errors.NOT_CONNECTED, error, 1015);
          }
          callback(error);
          return;
        }

        var otStats = {
          timestamp: 0
        };

        Array.from(stats).forEach(function (stat) {
          if (getStatsHelpers.isInboundStat(stat)) {
            var video = getStatsHelpers.isVideoStat(stat);
            var audio = getStatsHelpers.isAudioStat(stat);

            // it is safe to override the timestamp of one by another
            // if they are from the same getStats "batch" video and audio ts have the same value
            if (audio || video) {
              otStats.timestamp = getStatsHelpers.normalizeTimestamp(stat.timestamp);
            }
            if (video) {
              merge(otStats, { video: getStatsHelpers.parseStatCategory(stat) });
            } else if (audio) {
              merge(otStats, { audio: getStatsHelpers.parseStatCategory(stat) });
            }
          } else if (stat.type === 'track' && stat.id.toLowerCase().indexOf('video') !== -1) {
            merge(otStats, { video: { frameRate: stat.framesPerSecond } });
          }
        });

        callback(null, otStats);
      });
    };

    function setAudioVolume(audioVolume) {
      if (_streamContainer) {
        _streamContainer.setAudioVolume(audioVolume);
      }

      if (_chrome) {
        _chrome.muteButton.muted(audioVolume === 0);
      }
    }

    /**
     * Sets the audio volume, between 0 and 100, of the Subscriber.
     *
     * <p>You can set the initial volume when you call the <code>Session.subscribe()</code>
     * method. Pass a <code>audioVolume</code> property of the <code>properties</code> parameter
     * of the method.</p>
     *
     * @param {Number} value The audio volume, between 0 and 100.
     *
     * @return {Subscriber} The Subscriber object. This lets you chain method calls, as in the
     * following:
     *
     * <pre>mySubscriber.setAudioVolume(50).setStyle(newStyle);</pre>
     *
     * @see <a href="#getAudioVolume">getAudioVolume()</a>
     * @see <a href="Session.html#subscribe">Session.subscribe()</a>
     * @method #setAudioVolume
     * @memberOf Subscriber
     */

    this.setAudioVolume = function (requestedVolume) {
      var volume = normalizeAudioVolume(requestedVolume);

      if (isNaN(volume)) {
        logging.error('OT.Subscriber.setAudioVolume: value should be an integer between 0 and 100');
        return this;
      }

      if (volume !== requestedVolume) {
        logging.warn('OT.Subscriber.setAudioVolume: value should be an integer between 0 and 100');
      }

      if (volume === _audioVolume) {
        setAudioVolume(_audioVolume);
        return this;
      }

      _previousAudioVolume = _audioVolume;
      _audioVolume = volume;

      setAudioVolume(_audioVolume);

      if (_audioVolume > 0 && !_isSubscribingToAudio) {
        // in Firefox (and others) we don't stop subscribing to audio when muted, however if we are 'unmuting' and in
        // the subscribeToAudio: false state we should subscribe to audio again
        this.subscribeToAudio(true);
      }

      return this;
    };

    /**
    * Returns the audio volume, between 0 and 100, of the Subscriber.
    *
    * <p>Generally you use this method in conjunction with the <code>setAudioVolume()</code>
    * method.</p>
    *
    * @return {Number} The audio volume, between 0 and 100, of the Subscriber.
    * @see <a href="#setAudioVolume">setAudioVolume()</a>
    * @method #getAudioVolume
    * @memberOf Subscriber
    */
    this.getAudioVolume = function () {
      if (_streamContainer) {
        return _streamContainer.getAudioVolume();
      }
      return _audioVolume;
    };

    /**
    * Toggles audio on and off. Starts subscribing to audio (if it is available and currently
    * not being subscribed to) when the <code>value</code> is <code>true</code>; stops
    * subscribing to audio (if it is currently being subscribed to) when the <code>value</code>
    * is <code>false</code>.
    * <p>
    * <i>Note:</i> This method only affects the local playback of audio. It has no impact on the
    * audio for other connections subscribing to the same stream. If the Publisher is not
    * publishing audio, enabling the Subscriber audio will have no practical effect.
    * </p>
    *
    * @param {Boolean} value Whether to start subscribing to audio (<code>true</code>) or not
    * (<code>false</code>).
    *
    * @return {Subscriber} The Subscriber object. This lets you chain method calls, as in the
    * following:
    *
    * <pre>mySubscriber.subscribeToAudio(true).subscribeToVideo(false);</pre>
    *
    * @see <a href="#subscribeToVideo">subscribeToVideo()</a>
    * @see <a href="Session.html#subscribe">Session.subscribe()</a>
    * @see <a href="StreamPropertyChangedEvent.html">StreamPropertyChangedEvent</a>
    *
    * @method #subscribeToAudio
    * @memberOf Subscriber
    */

    this.subscribeToAudio = function (pValue) {
      var value = OTHelpers.castToBoolean(pValue, true);

      if (value !== _isSubscribingToAudio) {
        if (this.getAudioVolume() === 0 && value) {
          this.setAudioVolume(_previousAudioVolume);
        }
        if (this.getAudioVolume() > 0 && !value) {
          this.setAudioVolume(0);
        }
      }

      if (_peerConnection) {
        _peerConnection.subscribeToAudio(value);

        if (_stream) {
          _stream.setChannelActiveState('audio', value);
        }
      }

      _isSubscribingToAudio = value;

      return this;
    };

    var reasonMap = {
      auto: 'quality',
      publishVideo: 'publishVideo',
      subscribeToVideo: 'subscribeToVideo'
    };

    /**
    * Toggles video on and off. Starts subscribing to video (if it is available and
    * currently not being subscribed to) when the <code>value</code> is <code>true</code>;
    * stops subscribing to video (if it is currently being subscribed to) when the
    * <code>value</code> is <code>false</code>.
    * <p>
    * <i>Note:</i> This method only affects the local playback of video. It has no impact on
    * the video for other connections subscribing to the same stream. If the Publisher is not
    * publishing video, enabling the Subscriber video will have no practical effect.
    * </p>
    *
    * @param {Boolean} value Whether to start subscribing to video (<code>true</code>) or not
    * (<code>false</code>).
    *
    * @return {Subscriber} The Subscriber object. This lets you chain method calls, as in the
    * following:
    *
    * <pre>mySubscriber.subscribeToVideo(true).subscribeToAudio(false);</pre>
    *
    * @see <a href="#subscribeToAudio">subscribeToAudio()</a>
    * @see <a href="Session.html#subscribe">Session.subscribe()</a>
    * @see <a href="StreamPropertyChangedEvent.html">StreamPropertyChangedEvent</a>
    *
    * @method #subscribeToVideo
    * @memberOf Subscriber
    */
    this.subscribeToVideo = function (pValue, reason) {
      var value = OTHelpers.castToBoolean(pValue, true);

      setAudioOnly(!(value && _stream.hasVideo));

      if (value && !_properties.subscribeToVideo && _widgetView && _widgetView.video() && _stream.hasVideo) {
        _widgetView.loading(value);
        _widgetView.video().whenTimeIncrements(function () {
          _widgetView.loading(false);
        }, this);
      }

      if (_chrome && _chrome.videoDisabledIndicator) {
        _chrome.videoDisabledIndicator.disableVideo(false);
      }

      if (_peerConnection) {
        if (_session && _stream && (value !== _properties.subscribeToVideo || reason !== _lastSubscribeToVideoReason)) {
          _stream.setChannelActiveState('video', value, reason);
        }
      }

      _properties.subscribeToVideo = value;
      _lastSubscribeToVideoReason = reason;

      if (reason !== 'loading') {
        this.dispatchEvent(new Events.VideoEnabledChangedEvent(value ? 'videoEnabled' : 'videoDisabled', {
          reason: reasonMap[reason] || 'subscribeToVideo'
        }));
        if (value === 'videoDisabled' && reason === 'auto') {
          _congestionLevel = 2;
        }
      }

      return this;
    };

    /**
    * Sets the preferred resolution of the subscriber's video. This method is part of
    * the subscriber quality preference beta feature. For more infomation, see the
    * <a href="https://tokbox.com/platform/beta-programs/">OpenTok Beta Programs page</a>.
    * <p>
    * Lowering the preferred resolution
    * lowers video quality on the subscribing client, but it also reduces network and CPU usage.
    * You may want to use a lower resolution based on the dimensions of subscriber's video on
    * the web page. You may want to use a resolution rate for a subscriber to a stream that is less
    * important (and smaller) than other streams.
    * <p>
    * Not every frame rate is available to a subscriber. When you set the preferred resolution for
    * the subscriber, OpenTok.js picks the best resolution available that matches your setting.
    * The resolutions available are based on the value of the Subscriber object's
    * <code>stream.resolution</code> property, which represents the maximum resolution available for
    * the stream. The actual resolutions available depend, dynamically, on network and CPU resources
    * available to the publisher and subscriber.
    * <p>
    * You can set the initial preferred resolution used by setting the
    * <code>preferredResolution</code> property of the <code>options</code> object you pass into the
    * <code>Session.subscribe()</code> method.
    *
    * @param {Object} resolution Set this to an object with two properties: <code>width</code> and
    * <code>height</code> (both numbers), such as <code>{width: 320, height: 240}</code>. Set this to
    * <code>null</code> to remove the preferred resolution, and the client will use the highest
    * resolution available.
    *
    * @see <a href="#setPreferredFrameRate">Subscriber.setPreferredFrameRate()</a>
    * @see <a href="Session.html#subscribe">Session.subscribe()</a>
    *
    * @method #setPreferredResolution
    * @memberOf Subscriber
    */
    this.setPreferredResolution = function (preferredResolution) {
      if (_state.isDestroyed() || !_peerConnection) {
        logging.warn('Cannot set the max Resolution when not subscribing to a publisher');
        return;
      }

      _properties.preferredResolution = preferredResolution;

      if (_session.sessionInfo.p2pEnabled) {
        logging.warn('OT.Subscriber.setPreferredResolution will not work in a P2P Session');
        return;
      }

      var curMaxResolution = _stream.getPreferredResolution();

      var isUnchanged = curMaxResolution && preferredResolution && curMaxResolution.width === preferredResolution.width && curMaxResolution.height === preferredResolution.height || !curMaxResolution && !preferredResolution;

      if (isUnchanged) {
        return;
      }

      _stream.setPreferredResolution(preferredResolution);
    };

    /**
    * Sets the preferred frame rate of the subscriber's video. This method is part of
    * the subscriber quality preference beta feature. For more infomation, see the
    * <a href="https://tokbox.com/platform/beta-programs/">OpenTok Beta Programs page</a>.
    * <p>
    * Lowering the preferred frame rate
    * lowers video quality on the subscribing client, but it also reduces network and CPU usage.
    * You may want to use a lower frame rate for a subscriber to a stream that is less important
    * than other streams.
    * <p>
    * Not every frame rate is available to a subscriber. When you set the preferred frame rate for
    * the subscriber, OpenTok.js picks the best frame rate available that matches your setting.
    * The frame rates available are based on the value of the Subscriber object's
    * <code>stream.frameRate</code> property, which represents the maximum value available for the
    * stream. The actual frame rates available depend, dynamically, on network and CPU resources
    * available to the publisher and subscriber.
    * <p>
    * You can set the initial preferred frame rate used by setting the <code>preferredFrameRate</code>
    * property of the <code>options</code> object you pass into the <code>Session.subscribe()</code>
    * method.
    *
    * @param {Number} frameRate Set this to the desired frame rate (in frames per second). Set this to
    * <code>null</code> to remove the preferred frame rate, and the client will use the highest
    * frame rate available.
    *
    * @see <a href="#setPreferredResolution">Subscriber.setPreferredResolution()</a>
    * @see <a href="Session.html#subscribe">Session.subscribe()</a>
    *
    * @method #setPreferredFrameRate
    * @memberOf Subscriber
    */
    this.setPreferredFrameRate = function (preferredFrameRate) {
      if (_state.isDestroyed() || !_peerConnection) {
        logging.warn('Cannot set the max frameRate when not subscribing to a publisher');
        return;
      }

      _properties.preferredFrameRate = preferredFrameRate;

      if (_session.sessionInfo.p2pEnabled) {
        logging.warn('OT.Subscriber.setPreferredFrameRate will not work in a P2P Session');
        return;
      }

      /* jshint -W116 */
      if (_stream.getPreferredFrameRate() === preferredFrameRate) {
        return;
      }
      /* jshint +W116 */

      _stream.setPreferredFrameRate(preferredFrameRate);
    };

    this.isSubscribing = function () {
      return _state.isSubscribing();
    };

    this.isWebRTC = true;

    this.isLoading = function () {
      return _widgetView && _widgetView.loading();
    };

    this.videoElement = function () {
      return _streamContainer.domElement();
    };

    /**
    * Returns the width, in pixels, of the Subscriber video.
    *
    * @method #videoWidth
    * @memberOf Subscriber
    * @return {Number} the width, in pixels, of the Subscriber video.
    */
    this.videoWidth = function () {
      return _streamContainer.videoWidth();
    };

    /**
    * Returns the height, in pixels, of the Subscriber video.
    *
    * @method #videoHeight
    * @memberOf Subscriber
    * @return {Number} the width, in pixels, of the Subscriber video.
    */
    this.videoHeight = function () {
      return _streamContainer.videoHeight();
    };

    /**
    * Restricts the frame rate of the Subscriber's video stream, when you pass in
    * <code>true</code>. When you pass in <code>false</code>, the frame rate of the video stream
    * is not restricted.
    * <p>
    * When the frame rate is restricted, the Subscriber video frame will update once or less per
    * second.
    * <p>
    * This feature is only available in sessions that use the OpenTok Media Router (sessions with
    * the <a href="http://tokbox.com/opentok/tutorials/create-session/#media-mode">media mode</a>
    * set to routed), not in sessions with the media mode set to relayed. In relayed sessions,
    * calling this method has no effect.
    * <p>
    * Restricting the subscriber frame rate has the following benefits:
    * <ul>
    *    <li>It reduces CPU usage.</li>
    *    <li>It reduces the network bandwidth consumed.</li>
    *    <li>It lets you subscribe to more streams simultaneously.</li>
    * </ul>
    * <p>
    * Reducing a subscriber's frame rate has no effect on the frame rate of the video in
    * other clients.
    *
    * @param {Boolean} value Whether to restrict the Subscriber's video frame rate
    * (<code>true</code>) or not (<code>false</code>).
    *
    * @return {Subscriber} The Subscriber object. This lets you chain method calls, as in the
    * following:
    *
    * <pre>mySubscriber.restrictFrameRate(false).subscribeToAudio(true);</pre>
    *
    * @method #restrictFrameRate
    * @memberOf Subscriber
    */
    this.restrictFrameRate = function (val) {
      logging.debug('OT.Subscriber.restrictFrameRate(' + val + ')');

      logAnalyticsEvent('restrictFrameRate', val.toString(), { streamId: _stream.id });

      if (_session.sessionInfo.p2pEnabled) {
        logging.warn('OT.Subscriber.restrictFrameRate: Cannot restrictFrameRate on a P2P session');
      }

      if (typeof val !== 'boolean') {
        logging.error('OT.Subscriber.restrictFrameRate: expected a boolean value got a ' + (typeof val === 'undefined' ? 'undefined' : _typeof(val)));
      } else {
        _frameRateRestricted = val;
        _stream.setRestrictFrameRate(val);
      }
      return this;
    };

    this.on('styleValueChanged', updateChromeForStyleChange, this);

    this._ = {
      getDataChannel: function getDataChannel(label, options, completion) {
        // @fixme this will fail if it's called before we have a SubscriberPeerConnection.
        // I.e. before we have a publisher connection.
        if (!_peerConnection) {
          completion(new OTHelpers.Error('Cannot create a DataChannel before there is a publisher connection.'));

          return;
        }

        _peerConnection.getDataChannel(label, options, completion);
      },
      iceRestart: function iceRestart(force) {
        if (!_peerConnection) {
          logging.debug('Subscriber: Skipping ice restart, we have no peer connection');
        } else if (force || !_peerConnection.iceConnectionStateIsConnected()) {
          logResubscribe('Attempt');
          _peerConnection.iceRestart();
        } else {
          logging.debug('Subscriber: Skipping ice restart, we are connected.');
        }
      },


      syncEventEmitter: _syncEventEmitter,

      webRtcStream: function webRtcStream() {
        return _webRTCStream;
      }
    };

    _state = new SubscribingState(stateChangeFailed);

    logging.debug('OT.Subscriber: subscribe to ' + _stream.id);

    _state.set('Init');

    if (!_stream) {
      // @todo error
      logging.error('OT.Subscriber: No stream parameter.');
      return false;
    }

    _streamEventHandlers = {
      updated: streamUpdated,
      destroyed: streamDestroyed
    };

    _stream.on(_streamEventHandlers, this);

    _fromConnectionId = _stream.connection.id;
    _properties.name = _properties.name || _stream.name;
    _properties.classNames = 'OT_root OT_subscriber';

    if (_properties.style) {
      this.setStyle(_properties.style, null, true);
    }

    _properties.subscribeToVideo = OTHelpers.castToBoolean(_properties.subscribeToVideo, true);
    this.subscribeToAudio(OTHelpers.castToBoolean(_properties.subscribeToAudio, true));

    this.setAudioVolume(determineAudioVolume(_properties));
    _previousAudioVolume = DEFAULT_AUDIO_VOLUME;

    _widgetView = new Subscriber.WidgetView(targetElement, _properties);
    this.id = _widgetView.domId();
    _domId = _widgetView.domId();
    this.element = _widgetView.domElement;

    _widgetView.on('videoElementCreated', function (element) {
      var event = new Events.VideoElementCreatedEvent(element);
      var self = _this;
      if (!_loaded) {
        _this.once('loaded', function () {
          self.dispatchEvent(event);
        });
      } else {
        _this.dispatchEvent(event);
      }
    });

    if (this.element) {
      // Only create the chrome if there is an element to insert it in
      // for insertDefautlUI:false we don't create the chrome
      _createChrome.call(this);
    }

    _startConnectingTime = OTHelpers.now();

    logAnalyticsEvent('createPeerConnection', 'Attempt');

    _isLocalStream = _stream.connection.id === _session.connection.id;

    if (!_properties.testNetwork && _isLocalStream) {
      // Subscribe to yourself edge-case
      var publisher = _session.getPublisherForStream(_stream);
      if (!(publisher && publisher._.webRtcStream())) {
        this.trigger('subscribeComplete', otError(errors.STREAM_DESTROYED, new Error('Tried to subscribe to a local publisher, but its stream no longer exists')), this);
        return this;
      }

      _pcConnected.resolve();
      onRemoteStreamAdded.call(this, publisher._.webRtcStream());
    } else {
      if (_properties.testNetwork) {
        this.setAudioVolume(0);
      }

      _state.set('ConnectingToPeer');

      var uri = Message.subscribers.uri(_session.apiKey, _session.sessionId, _stream.id, this.widgetId);

      _peerConnection = new Subscriber.SubscriberPeerConnection({
        clientCandidates: _session.sessionInfo.clientCandidates,
        iceServers: _session.sessionInfo.iceServers,
        socket: _session._.getSocket(),
        stream: _stream,
        subscriberId: this.widgetId,
        subscriberUri: uri,
        properties: _properties,
        logAnalyticsEvent: logAnalyticsEvent
      });

      if (env.name === 'IE') {
        // IE doesn't seem to expose ice connection state changes :-(
        _pcConnected.resolve();
      } else {
        _peerConnection.once('iceConnected', _pcConnected.resolve);
        _peerConnection.once('error', _pcConnected.reject);
      }

      _peerConnection.on({
        disconnected: onDisconnected,
        error: onPeerConnectionFailure,
        remoteStreamAdded: onRemoteStreamAdded,
        remoteStreamRemoved: onRemoteStreamRemoved,
        signalingStateStable: function signalingStateStable() {
          _subscriber.trigger('signalingStateStable');
          if (_streamContainer && _webRTCStream) {
            _streamContainer.bindToStream(_webRTCStream, function (err) {
              if (err) {
                logging.debug('Could not bind to stream', err);
              }
            });
            if (_audioLevelSampler && 'webRTCStream' in _audioLevelSampler && _webRTCStream.getAudioTracks().length > 0) {
              _audioLevelSampler.webRTCStream(_webRTCStream);
            }
          }
        },

        qos: recordQOS,
        iceConnectionStateChange: onIceConnectionStateChange,
        iceRestartSuccess: onIceRestartSuccess,
        iceRestartFailure: onIceRestartFailure
      }, this);

      // initialize the peer connection AFTER we've added the event listeners
      _peerConnection.init(function (err) {
        if (err) {
          throw err;
        }
      });

      if (Subscriber.hasAudioOutputLevelStatCapability()) {
        _audioLevelSampler = new GetstatsAudioOutputLevelSampler(_peerConnection.getStats);
      } else if (hasRemoteStreamsWithWebAudio()) {
        _audioLevelSampler = new WebaudioAudioLevelSampler(audioContext());
      }

      if (_audioLevelSampler) {
        var subscriber = this;
        // sample with interval to minimise disturbance on animation loop but dispatch the
        // event with RAF since the main purpose is animation of a meter
        _audioLevelRunner = new IntervalRunner(function () {
          _audioLevelSampler.sample(function (audioOutputLevel) {
            if (audioOutputLevel !== null) {
              global.requestAnimationFrame(function () {
                subscriber.dispatchEvent(new Events.AudioLevelUpdatedEvent(audioOutputLevel));
              });
            }
          });
        }, 60);
      }
    }

    var cancelBindGuards = setUpBindGuards();
    _subscriber.once('subscribeComplete destroyed', cancelBindGuards);

    logConnectivityEvent('Attempt', {});

    return undefined;

    /**
    * Dispatched periodically to indicate the subscriber's audio level. The event is dispatched
    * up to 60 times per second, depending on the browser. The <code>audioLevel</code> property
    * of the event is audio level, from 0 to 1.0. See {@link AudioLevelUpdatedEvent} for more
    * information.
    * <p>
    * The following example adjusts the value of a meter element that shows volume of the
    * subscriber. Note that the audio level is adjusted logarithmically and a moving average
    * is applied:
    * <pre>
    * var movingAvg = null;
    * subscriber.on('audioLevelUpdated', function(event) {
    *   if (movingAvg === null || movingAvg &lt;= event.audioLevel) {
    *     movingAvg = event.audioLevel;
    *   } else {
    *     movingAvg = 0.7 * movingAvg + 0.3 * event.audioLevel;
    *   }
    *
    *   // 1.5 scaling to map the -30 - 0 dBm range to [0,1]
    *   var logLevel = (Math.log(movingAvg) / Math.LN10) / 1.5 + 1;
    *   logLevel = Math.min(Math.max(logLevel, 0), 1);
    *   document.getElementById('subscriberMeter').value = logLevel;
    * });
    * </pre>
    * <p>This example shows the algorithm used by the default audio level indicator displayed
    * in an audio-only Subscriber.
    *
    * @name audioLevelUpdated
    * @event
    * @memberof Subscriber
    * @see AudioLevelUpdatedEvent
    */

    /**
    * Dispatched when the video for the subscriber is disabled.
    * <p>
    * The <code>reason</code> property defines the reason the video was disabled. This can be set to
    * one of the following values:
    * <p>
    *
    * <ul>
    *
    *   <li><code>"publishVideo"</code> &mdash; The publisher stopped publishing video by calling
    *   <code>publishVideo(false)</code>.</li>
    *
    *   <li><code>"quality"</code> &mdash; The OpenTok Media Router stopped sending video
    *   to the subscriber based on stream quality changes. This feature of the OpenTok Media
    *   Router has a subscriber drop the video stream when connectivity degrades. (The subscriber
    *   continues to receive the audio stream, if there is one.)
    *   <p>
    *   Before sending this event, when the Subscriber's stream quality deteriorates to a level
    *   that is low enough that the video stream is at risk of being disabled, the Subscriber
    *   dispatches a <code>videoDisableWarning</code> event.
    *   <p>
    *   If connectivity improves to support video again, the Subscriber object dispatches
    *   a <code>videoEnabled</code> event, and the Subscriber resumes receiving video.
    *   <p>
    *   By default, the Subscriber displays a video disabled indicator when a
    *   <code>videoDisabled</code> event with this reason is dispatched and removes the indicator
    *   when the <code>videoEnabled</code> event with this reason is dispatched. You can control
    *   the display of this icon by calling the <code>setStyle()</code> method of the Subscriber,
    *   setting the <code>videoDisabledDisplayMode</code> property(or you can set the style when
    *   calling the <code>Session.subscribe()</code> method, setting the <code>style</code> property
    *   of the <code>properties</code> parameter).
    *   <p>
    *   This feature is only available in sessions that use the OpenTok Media Router (sessions with
    *   the <a href="http://tokbox.com/opentok/tutorials/create-session/#media-mode">media mode</a>
    *   set to routed), not in sessions with the media mode set to relayed.
    *   <p>
    *   You can disable this audio-only fallback feature, by setting the
    *   <code>audioFallbackEnabled</code> property to <code>false</code> in the options you pass
    *   into the <code>OT.initPublisher()</code> method on the publishing client. (See
    *   <a href="OT.html#initPublisher">OT.initPublisher()</a>.)
    *   </li>
    *
    *   <li><code>"subscribeToVideo"</code> &mdash; The subscriber started or stopped subscribing to
    *   video, by calling <code>subscribeToVideo(false)</code>.
    *   </li>
    *
    * </ul>
    *
    * @see VideoEnabledChangedEvent
    * @see <a href="Subscriber.html#event:videoDisableWarning">videoDisableWarning</a> event
    * @see <a href="Subscriber.html#event:videoEnabled">videoEnabled</a> event
    * @name videoDisabled
    * @event
    * @memberof Subscriber
    */

    /**
    * Dispatched when the OpenTok Media Router determines that the stream quality has degraded
    * and the video will be disabled if the quality degrades more. If the quality degrades further,
    * the Subscriber disables the video and dispatches a <code>videoDisabled</code> event.
    * <p>
    * By default, the Subscriber displays a video disabled warning indicator when this event
    * is dispatched (and the video is disabled). You can control the display of this icon by
    * calling the <code>setStyle()</code> method and setting the
    * <code>videoDisabledDisplayMode</code> property (or you can set the style when calling
    * the <code>Session.subscribe()</code> method and setting the <code>style</code> property
    * of the <code>properties</code> parameter).
    * <p>
    * This feature is only available in sessions that use the OpenTok Media Router (sessions with
    * the <a href="http://tokbox.com/opentok/tutorials/create-session/#media-mode">media mode</a>
    * set to routed), not in sessions with the media mode set to relayed.
    *
    * @see Event
    * @see <a href="Subscriber.html#event:videoDisabled">videoDisabled</a> event
    * @see <a href="Subscriber.html#event:videoDisableWarningLifted">videoDisableWarningLifted</a> event
    * @name videoDisableWarning
    * @event
    * @memberof Subscriber
    */

    /**
    * Dispatched when the Subscriber's video element is created. Add a listener for this event when
    * you set the <code>insertDefaultUI</code> option to <code>false</code> in the call to the
    * <a href="Session.html#subscribe">Session.subscribe()</a> method. The <code>element</code>
    * property of the event object is a reference to the Subscriber's <code>video</code> element
    * (or in Internet Explorer the <code>object</code> element containing the video). Add it to
    * the HTML DOM to display the video. When you set the <code>insertDefaultUI</code> option to
    * <code>false</code>, the <code>video</code> (or <code>object</code>) element is not automatically
    * inserted into the DOM.
    * <p>
    * Add a listener for this event only if you have set the <code>insertDefaultUI</code> option to
    * <code>false</code>. If you have not set <code>insertDefaultUI</code> option to
    * <code>false</code>, do not move the <code>video</code> (or <code>object</code>) element in
    * in the HTML DOM. Doing so causes the Subscriber object to be destroyed.
    *
    * @name videoElementCreated
    * @event
    * @memberof Subscriber
    * @see VideoElementCreatedEvent
    */

    /**
    * Dispatched when the OpenTok Media Router determines that the stream quality has improved
    * to the point at which the video being disabled is not an immediate risk. This event is
    * dispatched after the Subscriber object dispatches a <code>videoDisableWarning</code> event.
    * <p>
    * This feature is only available in sessions that use the OpenTok Media Router (sessions with
    * the <a href="http://tokbox.com/opentok/tutorials/create-session/#media-mode">media mode</a>
    * set to routed), not in sessions with the media mode set to relayed.
    *
    * @see Event
    * @see <a href="Subscriber.html#event:videoDisableWarning">videoDisableWarning</a> event
    * @see <a href="Subscriber.html#event:videoDisabled">videoDisabled</a> event
    * @name videoDisableWarningLifted
    * @event
    * @memberof Subscriber
    */

    /**
    * Dispatched when the OpenTok Media Router resumes sending video to the subscriber
    * after video was previously disabled.
    * <p>
    * The <code>reason</code> property defines the reason the video was enabled. This can be set to
    * one of the following values:
    * <p>
    *
    * <ul>
    *
    *   <li><code>"publishVideo"</code> &mdash; The publisher started publishing video by calling
    *   <code>publishVideo(true)</code>.</li>
    *
    *   <li><code>"quality"</code> &mdash; The OpenTok Media Router resumed sending video
    *   to the subscriber based on stream quality changes. This feature of the OpenTok Media
    *   Router has a subscriber drop the video stream when connectivity degrades and then resume
    *   the video stream if the stream quality improves.
    *   <p>
    *   This feature is only available in sessions that use the OpenTok Media Router (sessions with
    *   the <a href="http://tokbox.com/opentok/tutorials/create-session/#media-mode">media mode</a>
    *   set to routed), not in sessions with the media mode set to relayed.
    *   </li>
    *
    *   <li><code>"subscribeToVideo"</code> &mdash; The subscriber started or stopped subscribing to
    *   video, by calling <code>subscribeToVideo(false)</code>.
    *   </li>
    *
    * </ul>
    *
    * <p>
    * To prevent video from resuming, in the <code>videoEnabled</code> event listener,
    * call <code>subscribeToVideo(false)</code> on the Subscriber object.
    *
    * @see VideoEnabledChangedEvent
    * @see <a href="Subscriber.html#event:videoDisabled">videoDisabled</a> event
    * @name videoEnabled
    * @event
    * @memberof Subscriber
    */

    /**
    * Sent when the subscriber's stream has been interrupted.
    * <p>
    * In response to this event, you may want to provide a user interface notification, to let the
    * user know that the audio-video stream is temporarily disconnected and that the app is trying
    * to reconnect to it.
    * <p>
    * If the client reconnects to the stream, the Subscriber object dispatches a
    * <code>connected</code> event. Otherwise, if the client cannot reconnect to the stream,
    * the Subscriber object dispatches a <code>destroyed</code> event.
    *
    * @name disconnected
    * @event
    * @memberof Subscriber
    * @see <a href="Subscriber.html#event:connected">connected event</a>
    * @see Event
    */

    /**
    * Sent when the subscriber's stream has resumed, after the Subscriber dispatches a
    * <code>disconnected</code> event.
    *
    * @name connected
    * @event
    * @memberof Subscriber
    * @see <a href="Subscriber.html#event:disconnected">disconnected event</a>
    * @see Event
    */

    /**
    * Dispatched when the Subscriber element is removed from the HTML DOM. When this event is
    * dispatched, you may choose to adjust or remove HTML DOM elements related to the subscriber.
    * <p>
    * To prevent the Subscriber from being removed from the DOM when the stream is destroyed,
    * listen for the <a href="Session.html#event:streamDestroyed">streamDestroyed event</a>
    * dispatched by the Session object. The <code>streamDestroyed</code> event dispatched by the
    * Session object is cancelable, and calling the <code>preventDefault()</code> method of the
    * event object prevents Subscribers of the stream from being removed from the HTML DOM.
    *
    * @see Event
    * @name destroyed
    * @event
    * @memberof Subscriber
    */

    /**
    * Dispatched when the video dimensions of the video change. This can occur when the
    * <code>stream.videoType</code> property is set to <code>"screen"</code> (for a screen-sharing
    * video stream), when the user resizes the window being captured. It can also occur if the video
    * is being published by a mobile device and the user rotates the device (causing the camera
    * orientation to change). This event object has a <code>newValue</code> property and an
    * <code>oldValue</code> property, representing the new and old dimensions of the video.
    * Each of these has a <code>height</code> property and a <code>width</code> property,
    * representing the height and width, in pixels.
    * @name videoDimensionsChanged
    * @event
    * @memberof Subscriber
    * @see VideoDimensionsChangedEvent
    */
  };

  Subscriber.hasAudioOutputLevelStatCapability = hasAudioOutputLevelStatCapability;
  Subscriber.WidgetView = WidgetView;
  Subscriber.SubscriberPeerConnection = SubscriberPeerConnection;

  return Subscriber;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../common-js-helpers/OTHelpers.js":217,"../../common-js-helpers/env.js":233,"../../helpers/audio_context.js":242,"../../helpers/audio_level_samplers/getstats_audio_output_level_sampler":243,"../../helpers/audio_level_samplers/webaudio_audio_level_sampler":244,"../../helpers/connectivity_attempt_pinger.js":245,"../../helpers/hasAudioOutputLevelStatCapability.js":259,"../../helpers/hasRemoteStreamsWithWebAudio.js":267,"../../helpers/otError.js":271,"../../helpers/otProperties.js":272,"../../helpers/widget_view.js":286,"../Errors.js":288,"../analytics.js":289,"../audio_level_transformer":293,"../chrome/audio_level_meter.js":296,"../chrome/backing_bar.js":297,"../chrome/chrome.js":299,"../chrome/mute_button.js":300,"../chrome/name_panel.js":301,"../chrome/video_disabled_indicator.js":302,"../events.js":306,"../exception_codes.js":307,"../interpretPeerConnectionError.js":310,"../interval_runner.js":311,"../logging.js":312,"../messaging/raptor/message.js":317,"../ot_error_class.js":334,"../peer_connection/get_stats_helpers.js":338,"../peer_connection/subscriber_peer_connection.js":350,"../styling/stylable_component.js":375,"./state.js":379,"bluebird":2,"events":3,"lodash/merge":171,"uuid":200}],379:[function(require,module,exports){
'use strict';

var generateSimpleStateMachine = require('../generate_simple_state_machine.js')();

// Models a Subscriber's subscribing State
//
// Valid States:
//     NotSubscribing            (the initial state
//     Init                      (basic setup of DOM
//     ConnectingToPeer          (Failure Cases -> No Route, Bad Offer, Bad Answer
//     BindingRemoteStream       (Failure Cases -> Anything to do with the media being
//                               (invalid, the media never plays
//     Subscribing               (this is 'onLoad'
//     Failed                    (terminal state, with a reason that maps to one of the
//                               (failure cases above
//     Destroyed                 (The subscriber has been cleaned up, terminal state
//
//
// Valid Transitions:
//     NotSubscribing ->
//         Init
//
//     Init ->
//             ConnectingToPeer
//           | BindingRemoteStream         (if we are subscribing to ourselves and we alreay
//                                         (have a stream
//           | NotSubscribing              (destroy()
//
//     ConnectingToPeer ->
//             BindingRemoteStream
//           | NotSubscribing
//           | Failed
//           | NotSubscribing              (destroy()
//
//     BindingRemoteStream ->
//             Subscribing
//           | Failed
//           | NotSubscribing              (destroy()
//
//     Subscribing ->
//             NotSubscribing              (unsubscribe
//           | Failed                      (probably a peer connection failure after we began
//                                         (subscribing
//
//     Failed ->
//             Destroyed
//
//     Destroyed ->                        (terminal state)
//
//
// @example
//     var state = new SubscribingState(function(change) {
//       console.log(change.message);
//     });
//
//     state.set('Init');
//     state.current;                 -> 'Init'
//
//     state.set('Subscribing');      -> triggers stateChangeFailed and logs out the error message
//
//
var initialState = 'NotSubscribing';

var validStates = ['NotSubscribing', 'Init', 'ConnectingToPeer', 'BindingRemoteStream', 'Subscribing', 'Failed', 'Destroyed'];

var validTransitions = {
  NotSubscribing: ['NotSubscribing', 'Init', 'Destroyed'],
  Init: ['NotSubscribing', 'ConnectingToPeer', 'BindingRemoteStream', 'Destroyed'],
  ConnectingToPeer: ['NotSubscribing', 'BindingRemoteStream', 'Failed', 'Destroyed'],
  BindingRemoteStream: ['NotSubscribing', 'Subscribing', 'Failed', 'Destroyed'],
  Subscribing: ['NotSubscribing', 'Failed', 'Destroyed', 'BindingRemoteStream'],
  Failed: ['Destroyed'],
  Destroyed: []
};

var SubscribingState = generateSimpleStateMachine(initialState, validStates, validTransitions);

SubscribingState.prototype.isDestroyed = function () {
  return this.current === 'Destroyed';
};

SubscribingState.prototype.isFailed = function () {
  return this.current === 'Failed';
};

SubscribingState.prototype.isSubscribing = function () {
  return this.current === 'Subscribing';
};

SubscribingState.prototype.isAttemptingToSubscribe = function () {
  return ['Init', 'ConnectingToPeer', 'BindingRemoteStream'].indexOf(this.current) !== -1;
};

module.exports = SubscribingState;

},{"../generate_simple_state_machine.js":308}],380:[function(require,module,exports){
(function (global){
'use strict';

// @todo enable the following disabled rules see OPENTOK-31136 for more info
/* eslint-disable no-underscore-dangle,  no-mixed-operators */

var analytics = require('./analytics.js');
var APIKEY = require('./api_key.js');
var Dialogs = require('../helpers/dialogs.js');
var EnvironmentLoader = require('../ot/environment_loader.js');
var hasOpenTokSupport = require('../helpers/hasOpenTokSupport.js').once;
var isWebSocketSupported = require('../common-js-helpers/isWebSocketSupported.js');
var once = require('lodash/once');
var OTPlugin = require('../otplugin/otplugin.js');
var OTHelpers = require('../common-js-helpers/OTHelpers.js');
var logging = require('./logging.js');
var otProperties = require('../helpers/otProperties.js');

var systemRequirements = {};
module.exports = systemRequirements;

// Global parameters used by upgradeSystemRequirements
var _intervalId = void 0;
var _lastHash = document.location.hash;

var HAS_REQUIREMENTS = 1;
var NOT_HAS_REQUIREMENTS = 0;

/**
 * Checks if the system supports OpenTok for WebRTC. Note that this method is called
 * automatically when you call <code>OT.initPublisher()</code> or <code>OT.initSession()</code>,
 * and if the system doesn't support OpenTok, the OpenTok.js library displays a message to
 * the user. Call the <code>OT.checkSystemRequirements()</code> method before calling
 * <code>OT.initPublisher()</code> or <code>OT.initSession()</code> if you do not want the
 * library to display that message.
 *
 * @return {Number} Whether the system supports OpenTok for WebRTC (1) or not (0).
 * @see <a href="#upgradeSystemRequirements">OT.upgradeSystemRequirements()</a>
 * @method OT.checkSystemRequirements
 * @memberof OT
 */
systemRequirements.check = function () {
  logging.debug('OT.checkSystemRequirements()');

  // Try native support first, then OTPlugin...
  var systemRequirementsMet = isWebSocketSupported() && hasOpenTokSupport() || OTPlugin.isInstalled();

  systemRequirementsMet = systemRequirementsMet ? HAS_REQUIREMENTS : NOT_HAS_REQUIREMENTS;

  systemRequirements.check = function () {
    logging.debug('OT.checkSystemRequirements()');
    return systemRequirementsMet;
  };

  if (systemRequirementsMet === NOT_HAS_REQUIREMENTS) {
    analytics.logEvent({
      action: 'checkSystemRequirements',
      variation: 'notHasRequirements',
      partnerId: APIKEY.value,
      payload: { userAgent: OTHelpers.env.userAgent }
    });
  }

  return systemRequirementsMet;
};

/**
 * Displays information about system requirments for OpenTok for WebRTC. This
 * information is displayed in an iframe element that fills the browser window.
 * <p>
 * <i>Note:</i> this information is displayed automatically when you call the
 * <code>OT.initSession()</code> or the <code>OT.initPublisher()</code> method
 * if the client does not support OpenTok for WebRTC.
 * </p>
 * @see <a href="#checkSystemRequirements">OT.checkSystemRequirements()</a>
 * @method OT.upgradeSystemRequirements
 * @memberof OT
 */
systemRequirements.upgrade = once(function () {
  // trigger after the OT environment has loaded
  EnvironmentLoader.onLoad(function () {
    if (OTPlugin.isSupported()) {
      Dialogs.Plugin.promptToInstall().on({
        download: function download() {
          global.location = OTPlugin.pathToInstaller();
        },
        refresh: function refresh() {
          location.reload();
        },
        closed: function closed() {}
      });
      return;
    }

    var id = '_upgradeBrowser';

    // Load the iframe over the whole page.
    document.body.appendChild(function () {
      var d = document.createElement('iframe');
      d.id = id;
      d.style.position = 'absolute';
      d.style.position = 'fixed';
      d.style.height = '100%';
      d.style.width = '100%';
      d.style.top = '0px';
      d.style.left = '0px';
      d.style.right = '0px';
      d.style.bottom = '0px';
      d.style.zIndex = 1000;
      d.style.backgroundColor = 'rgba(0,0,0,0.2)';
      d.setAttribute('frameBorder', '0');
      d.frameBorder = '0';
      d.scrolling = 'no';
      d.setAttribute('scrolling', 'no');

      // If we list a minimum version for the browser, it must be supported, but old because we've
      // called .upgrade()
      var isSupportedButOld = OTHelpers.env.name.toLowerCase() in otProperties.minimumVersion;
      d.src = otProperties.assetURL + '/html/upgrade.html#' + encodeURIComponent(isSupportedButOld ? 'true' : 'false') + ',' + encodeURIComponent(JSON.stringify(otProperties.minimumVersion)) + '|' + encodeURIComponent(document.location.href);

      return d;
    }());

    // Now we need to listen to the event handler if the user closes this dialog.
    // Since this is from an IFRAME within another domain we are going to listen to hash
    // changes. The best cross browser solution is to poll for a change in the hashtag.
    if (_intervalId) {
      clearInterval(_intervalId);
    }
    _intervalId = setInterval(function () {
      var hash = document.location.hash;
      var re = /^#?\d+&/;
      if (hash !== _lastHash && re.test(hash)) {
        _lastHash = hash;
        if (hash.replace(re, '') === 'close_window') {
          document.body.removeChild(document.getElementById(id));
          document.location.hash = '';
        }
      }
    }, 100);
  });
});

module.exports = systemRequirements;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../common-js-helpers/OTHelpers.js":217,"../common-js-helpers/isWebSocketSupported.js":235,"../helpers/dialogs.js":252,"../helpers/hasOpenTokSupport.js":264,"../helpers/otProperties.js":272,"../ot/environment_loader.js":305,"../otplugin/otplugin.js":390,"./analytics.js":289,"./api_key.js":291,"./logging.js":312,"lodash/once":174}],381:[function(require,module,exports){
(function (global){
'use strict';

// @todo enable the following disabled rules see OPENTOK-31136 for more info
/* eslint-disable no-void, prefer-rest-params,  no-shadow */

var curryCallAsync = require('./curry_call_async.js');
var logging = require('../ot/logging.js');
var meta = require('./meta.js');

// TODO: fix this super duper evil circular dependency between this project and webrtc-js via global
// scope
var OT = global.OT;

var OTHelpers = require('../common-js-helpers/OTHelpers.js');
var PluginProxies = require('./plugin_proxies.js');

var autoUpdaterController = void 0;

var AutoUpdater = function AutoUpdater() {
  var plugin = void 0;

  var getControllerCurry = function getControllerFirstCurry(fn) {
    var _arguments = arguments;

    return function () {
      if (plugin) {
        fn(void 0, _arguments);
        return;
      }

      PluginProxies.create({
        mimeType: meta.getInstallerMimeType(),
        isVisible: false,
        windowless: false
      }, function (err, p) {
        plugin = p;

        if (err) {
          logging.error('Error while loading the AutoUpdater: ' + err);
          return undefined;
        }

        return fn.apply(undefined, _arguments);
      });
    };
  };

  // Returns true if the version of the plugin installed on this computer
  // matches the one expected by this version of OTPlugin.
  this.hasRequiredVersion = function () {
    return meta.version() === meta.installedVersion();
  };

  this.autoUpdate = getControllerCurry(function () {
    var modal = OT.Dialogs.Plugin.updateInProgress();
    var analytics = new OT.Analytics();

    var payload = {
      ieVersion: OTHelpers.env.version,
      pluginOldVersion: meta.installedVersion(),
      pluginNewVersion: meta.version
    };

    var success = curryCallAsync(function () {
      analytics.logEvent({
        action: 'OTPluginAutoUpdate',
        variation: 'Success',
        partnerId: OT.APIKEY,
        payload: JSON.stringify(payload)
      });

      plugin.destroy();

      modal.close();
      OT.Dialogs.Plugin.updateComplete().on({
        reload: function reload() {
          window.location.reload();
        }
      });
    });

    var error = curryCallAsync(function (errorCode, errorMessage, systemErrorCode) {
      payload.errorCode = errorCode;
      payload.systemErrorCode = systemErrorCode;

      analytics.logEvent({
        action: 'OTPluginAutoUpdate',
        variation: 'Failure',
        partnerId: OT.APIKEY,
        payload: JSON.stringify(payload)
      });

      plugin.destroy();

      modal.close();
      var updateMessage = errorMessage + ' (' + errorCode + '). Please restart your browser and try again.';

      modal = OT.Dialogs.Plugin.updateComplete(updateMessage).on({
        reload: function reload() {
          modal.close();
        }
      });

      logging.error('autoUpdate failed: ' + errorMessage + ' (' + errorCode + '). Please restart your browser and try again.');
      // TODO log client event
    });

    var progress = curryCallAsync(function (progress) {
      modal.setUpdateProgress(progress.toFixed());
      // modalBody.innerHTML = 'Updating...' + progress.toFixed() + '%';
    });

    plugin._.updatePlugin(meta.pathToInstaller(), success, error, progress);
  });

  this.destroy = function () {
    if (plugin) {
      plugin.destroy();
    }
  };

  // Refresh the plugin list so that we'll hopefully detect newer versions
  if (navigator.plugins) {
    navigator.plugins.refresh(false);
  }
};

AutoUpdater.get = function get(completion) {
  if (!autoUpdaterController) {
    if (!this.isinstalled()) {
      completion.call(null, 'Plugin was not installed');
      return;
    }

    autoUpdaterController = new AutoUpdater();
  }

  completion.call(null, void 0, autoUpdaterController);
};

AutoUpdater.isinstalled = function () {
  return meta.getInstallerMimeType() !== null && !meta.hasBrokenUpdater();
};

AutoUpdater.installedVersion = function () {
  return meta.installedVersion();
};

module.exports = AutoUpdater;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../common-js-helpers/OTHelpers.js":217,"../ot/logging.js":312,"./curry_call_async.js":382,"./meta.js":389,"./plugin_proxies.js":399}],382:[function(require,module,exports){
"use strict";

// @todo enable the following disabled rules see OPENTOK-31136 for more info
/* eslint-disable prefer-rest-params */

module.exports = function curryCallAsync(fn) {
  return function () {
    var args = arguments;

    setTimeout(function () {
      fn.apply(undefined, args);
    });
  };
};

},{}],383:[function(require,module,exports){
"use strict";

// Magic number to avoid plugin crashes through a settimeout call
module.exports = 3000;

},{}],384:[function(require,module,exports){
"use strict";

// @todo enable the following disabled rules see OPENTOK-31136 for more info
/* eslint-disable no-prototype-builtins, max-len, prefer-rest-params */

module.exports = function EventEmitter() {
  var ee = {};

  var eventHandlers = {};

  ee.on = function (name, callback, context) {
    if (!eventHandlers.hasOwnProperty(name)) {
      eventHandlers[name] = [];
    }

    eventHandlers[name].push([callback, context]);
    return ee;
  };

  ee.off = function (name, callback, context) {
    if (!eventHandlers.hasOwnProperty(name) || eventHandlers[name].length === 0) {
      return undefined; // TODO: Wouldn't it be more consistent to return ee?
    }

    eventHandlers[name] = eventHandlers[name].filter(function (listener) {
      return listener[0] !== callback && listener[1] !== context;
    });

    return ee;
  };

  ee.once = function (name, callback, context) {
    var fn = function fn() {
      ee.off(name, fn);
      return callback.apply(context, arguments);
    };

    ee.on(name, fn);
    return ee;
  };

  ee.emit = function (name, args) {
    setTimeout(function () {
      if (!eventHandlers.hasOwnProperty(name) || eventHandlers[name].length === 0) {
        return;
      }

      eventHandlers[name].forEach(function (handler) {
        handler[0].apply(handler[1], args);
      });
    });

    return ee;
  };

  return ee;
};

},{}],385:[function(require,module,exports){
'use strict';

// @todo enable the following disabled rules see OPENTOK-31136 for more info
/* eslint-disable no-void */

var OTHelpers = require('../common-js-helpers/OTHelpers.js');

module.exports = function MediaConstraints(userConstraints) {
  var constraints = OTHelpers.clone(userConstraints);

  this.hasVideo = constraints.video !== void 0 && constraints.video !== false;
  this.hasAudio = constraints.audio !== void 0 && constraints.audio !== false;

  if (constraints.video === true) {
    constraints.video = {};
  }

  if (constraints.audio === true) {
    constraints.audio = {};
  }

  if (this.hasVideo && !constraints.video.mandatory) {
    constraints.video.mandatory = {};
  }

  if (this.hasAudio && !constraints.audio.mandatory) {
    constraints.audio.mandatory = {};
  }

  this.screenSharing = this.hasVideo && (constraints.video.mandatory.chromeMediaSource === 'screen' || constraints.video.mandatory.chromeMediaSource === 'window');

  this.audio = constraints.audio;
  this.video = constraints.video;

  this.setVideoSource = function (sourceId) {
    if (sourceId !== void 0) {
      constraints.video.mandatory.sourceId = sourceId;
    } else {
      delete constraints.video;
    }
  };

  this.setAudioSource = function (sourceId) {
    if (sourceId !== void 0) {
      constraints.audio.mandatory.sourceId = sourceId;
    } else {
      delete constraints.audio;
    }
  };

  this.toHash = function () {
    return constraints;
  };
};

},{"../common-js-helpers/OTHelpers.js":217}],386:[function(require,module,exports){
'use strict';

// @todo enable the following disabled rules see OPENTOK-31136 for more info
/* eslint-disable no-shadow */

var isReady = require('./readiness.js').isReady;
var PluginProxies = require('./plugin_proxies.js');
var registerReadyListner = require('./readiness.js').listen;

// Exposes a enumerateDevices method and emits a devicechange event
//
// http://w3c.github.io/mediacapture-main/#idl-def-MediaDevices
//
module.exports = function MediaDevices() {
  var Proto = function MediaDevices() {};
  var mediaDevices = new Proto();

  mediaDevices.enumerateDevices = function enumerateDevices(completion) {
    registerReadyListner(function (error) {
      if (error) {
        completion(error);
      } else {
        PluginProxies.mediaCapturer.enumerateDevices(completion);
      }
    });
  };

  mediaDevices.addListener = function addListener(fn, context) {
    registerReadyListner(function (error) {
      if (error) {
        // No error message here, ready failing would have
        // created a bunch elsewhere
        return;
      }

      PluginProxies.mediaCapturer.on('devicesChanged', fn, context);
    });
  };

  mediaDevices.removeListener = function removeListener(fn, context) {
    if (isReady()) {
      PluginProxies.mediaCapturer.off('devicesChanged', fn, context);
    }
  };

  return mediaDevices;
};

},{"./plugin_proxies.js":399,"./readiness.js":401}],387:[function(require,module,exports){
'use strict';

// @todo enable the following disabled rules see OPENTOK-31136 for more info
/* eslint-disable no-shadow, array-callback-return */

var MediaStreamTrack = require('./media_stream_track.js');
var VideoContainer = require('./video_container.js');

var MediaStream = function MediaStream(options, plugin) {
  var Proto = function MediaStream() {};
  var mediaStream = new Proto();
  var audioTracks = [];
  var videoTracks = [];

  mediaStream.id = options.id;
  plugin.addRef(mediaStream);

  // TODO
  // mediaStream.ended =
  // mediaStream.onended =

  if (options.videoTracks) {
    options.videoTracks.map(function (track) {
      videoTracks.push(new MediaStreamTrack(options.id, track, plugin));
    });
  }

  if (options.audioTracks) {
    options.audioTracks.map(function (track) {
      audioTracks.push(new MediaStreamTrack(options.id, track, plugin));
    });
  }

  var hasTracksOfType = function hasTracksOfType(type) {
    var tracks = type === 'video' ? videoTracks : audioTracks;

    return tracks.some(function (track) {
      return track.enabled;
    });
  };

  mediaStream.getVideoTracks = function () {
    return videoTracks;
  };
  mediaStream.getAudioTracks = function () {
    return audioTracks;
  };
  mediaStream.getTracks = function () {
    return videoTracks.concat(audioTracks);
  };

  mediaStream.getTrackById = function (id) {
    videoTracks.concat(audioTracks).forEach(function (track) {
      if (track.id === id) {
        return track;
      }

      // FIXME: I added this line to satisfy consistent-return in eslint, but I think this whole
      // method doesn't work / doesn't make sense / must not be tested.
      return undefined;
    });

    return null;
  };

  mediaStream.hasVideo = function () {
    return hasTracksOfType('video');
  };

  mediaStream.hasAudio = function () {
    return hasTracksOfType('audio');
  };

  mediaStream.addTrack = function () /* MediaStreamTrack */{
    // TODO
  };

  mediaStream.removeTrack = function () /* MediaStreamTrack */{
    // TODO
  };

  mediaStream.stop = function () {
    plugin._.stopMediaStream(mediaStream.id);
    plugin.removeRef(mediaStream);
  };

  mediaStream.destroy = function () {
    mediaStream.stop();
  };

  // Private MediaStream API
  mediaStream._ = {
    plugin: plugin,

    // Get a VideoContainer to render the stream in.
    render: function render() {
      return new VideoContainer(plugin, mediaStream);
    }
  };

  return mediaStream;
};

MediaStream.fromJson = function (json, plugin) {
  if (!json) {
    return null; // TODO: This seems odd. Consider removing/throwing/logging.
  }

  return new MediaStream(JSON.parse(json), plugin);
};

module.exports = MediaStream;

},{"./media_stream_track.js":388,"./video_container.js":409}],388:[function(require,module,exports){
'use strict';

// @todo enable the following disabled rules see OPENTOK-31136 for more info
/* eslint-disable no-shadow */

module.exports = function MediaStreamTrack(mediaStreamId, options, plugin) {
  var Proto = function MediaStreamTrack() {};
  var mediaStreamTrack = new Proto();

  mediaStreamTrack.id = options.id;
  mediaStreamTrack.kind = options.kind;
  mediaStreamTrack.label = options.label;
  mediaStreamTrack.streamId = mediaStreamId;

  var enabled = options.enabled === true || options.enabled === 'true';

  Object.defineProperty(mediaStreamTrack, 'enabled', {
    get: function get() {
      return enabled;
    },
    set: function set(newEnabledValue) {
      enabled = newEnabledValue === true || newEnabledValue === 'true';

      if (enabled) {
        plugin._.enableMediaStreamTrack(mediaStreamId, mediaStreamTrack.id);
      } else {
        plugin._.disableMediaStreamTrack(mediaStreamId, mediaStreamTrack.id);
      }
    }
  });

  // Deprecated: use .enabled property directly
  mediaStreamTrack.setEnabled = function (newEnabledValue) {
    mediaStreamTrack.enabled = newEnabledValue;
  };

  return mediaStreamTrack;
};

},{}],389:[function(require,module,exports){
(function (global){
'use strict';

// @todo enable the following disabled rules see OPENTOK-31136 for more info
/* eslint-disable one-var, no-void, no-plusplus, no-underscore-dangle, max-len */

/* global ActiveXObject */

var logging = require('../ot/logging.js');
var OTHelpers = require('../common-js-helpers/OTHelpers.js');
var pluginVersion = require('./pluginVersion');
var otProperties = require('../helpers/otProperties.js');
var versionGreaterThan = require('./version_greater_than.js');

var meta = {};
module.exports = meta;

var ie64 = OTHelpers.env.name === 'IE' && OTHelpers.env.userAgent.indexOf('Win64') !== -1;

var archSuffix = ie64 ? '_x64' : '';

meta.mimeType = 'application/x-opentokplugin' + archSuffix + ',version=' + pluginVersion;
meta.activeXName = 'TokBox.OpenTokPlugin' + archSuffix + '.' + pluginVersion;

var updaterMimeType = void 0,
    // <- cached version, use getInstallerMimeType instead
installedVersion = -1; // <- cached version, use getInstallerMimeType instead

// Work out the full mimeType (including the currently installed version)
// of the installer.
var findMimeTypeAndVersion = function findMimeTypeAndVersion() {
  if (updaterMimeType !== void 0) {
    return;
  }

  var activeXControlId = 'TokBox.OpenTokPluginInstaller' + archSuffix;
  var installPluginName = 'OpenTokPluginInstaller';
  var unversionedMimeType = 'application/x-opentokplugininstaller' + archSuffix;
  var plugin = global.navigator.plugins[activeXControlId] || global.navigator.plugins[installPluginName];

  installedVersion = -1;

  if (plugin) {
    // Look through the supported mime-types for the version
    // There should only be one mime-type in our use case, and
    // if there's more than one they should all have the same
    // version.
    var numMimeTypes = plugin.length;

    var extractVersion = new RegExp(unversionedMimeType.replace('-', '\\-') + ',version=([0-9a-zA-Z-_.]+)', 'i');

    var mimeType = void 0,
        bits = void 0;

    for (var i = 0; i < numMimeTypes; ++i) {
      mimeType = plugin[i];

      // Look through the supported mimeTypes and find
      // the one we require.
      if (mimeType && mimeType.enabledPlugin && mimeType.enabledPlugin.name === plugin.name && mimeType.type.indexOf(unversionedMimeType) !== -1) {
        bits = extractVersion.exec(mimeType.type);

        if (bits !== null) {
          installedVersion = bits[1];
          if (installedVersion === pluginVersion) {
            // If we have found the version we want then stop searching
            break;
          }
        }
      }
    }
  } else if (OTHelpers.env.name === 'IE') {
    // This may mean that the installer plugin is not installed.
    // Although it could also mean that we're on IE 9 and below,
    // which does not support navigator.plugins. Fallback to
    // using 'ActiveXObject' instead.
    try {
      plugin = new ActiveXObject(activeXControlId);
      installedVersion = plugin.getMasterVersion();
    } catch (e) {
      logging.error(e);
    }
  }

  updaterMimeType = installedVersion !== -1 ? unversionedMimeType + ',version=' + installedVersion : null;
};

meta.getInstallerMimeType = function () {
  if (updaterMimeType === void 0) {
    findMimeTypeAndVersion();
  }

  return updaterMimeType;
};

meta.version = function () {
  return pluginVersion;
};

meta.installedVersion = function () {
  if (installedVersion === void 0) {
    findMimeTypeAndVersion();
  }

  return installedVersion;
};

// Version 0.4.0.4 autoupdate was broken. We want to prompt
// for install on 0.4.0.4 or earlier. We're also including
// earlier versions just in case. Version 0.4.0.10 also
// had a broken updater, we'll treat that version the same
// way.
meta.hasBrokenUpdater = function () {
  var _broken = meta.installedVersion() === '0.4.0.9' || !versionGreaterThan(meta.installedVersion(), '0.4.0.4');

  meta.hasBrokenUpdater = function () {
    return _broken;
  };
  return _broken;
};

// Returns a URI to the OTPlugin installer that is paired with
// this version of OTPlugin.js.
meta.pathToInstaller = function (callback) {
  var installerPath = otProperties.assetURL + '/plugin/' + ('OpenTokPluginMain_x' + (ie64 ? '64' : '32') + '.msi');

  // Backwards compatibility here. No possibility of this being async anymore.
  if (callback) {
    callback(installerPath);
  }

  return installerPath;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../common-js-helpers/OTHelpers.js":217,"../helpers/otProperties.js":272,"../ot/logging.js":312,"./pluginVersion":398,"./version_greater_than.js":408}],390:[function(require,module,exports){
(function (global){
'use strict';

// @todo enable the following disabled rules see OPENTOK-31136 for more info
/* eslint-disable global-require, no-underscore-dangle, no-restricted-syntax */
/* eslint-disable no-prototype-builtins, no-param-reassign, prefer-rest-params, no-shadow */

var analytics = require('../ot/analytics.js');
var OTHelpers = require('../common-js-helpers/OTHelpers.js');
var startupAnalyticsLogger = require('./startupAnalyticsLogger.js');

var OTPlugin = {};
module.exports = OTPlugin;
global.OTPlugin = OTPlugin;

// Establish the environment that we're running in
OTPlugin.isSupported = function () {
  return OTHelpers.env.name === 'IE' && OTHelpers.env.version >= 9;
};

// If this client isn't supported we still make sure that OTPlugin is defined
// and the basic API (isSupported() and isInstalled()) is created.
// TODO: ^^^ Is this really needed? It would be nice to not monkey around with this early exit
// thingy.
if (!OTPlugin.isSupported()) {
  OTPlugin.isInstalled = function isInstalled() {
    return false;
  };
} else {
  var AutoUpdater = require('./auto_updater.js');
  var logging = require('../ot/logging.js');
  var MediaConstraints = require('./media_constraints.js');
  var MediaDevices = require('./media_devices.js');
  var MediaStream = require('./media_stream.js');
  var meta = require('./meta.js');
  var createPeerConnection = require('./peer_connection/create_peer_connection.js');
  var PluginProxies = require('./plugin_proxies.js');
  var readiness = require('./readiness.js');
  var settings = require('./settings.js');
  var RTCIceCandidate = require('./rtc/rtc_ice_candidate.js');
  var RTCSessionDescription = require('./rtc/rtc_session_description.js');

  // TODO: Can we remove this? It's only here for possible external use.
  OTPlugin.isReady = readiness.isReady;

  OTPlugin.meta = meta;

  OTPlugin.isInstalled = function isInstalled() {
    if (!OTPlugin.isSupported()) {
      return false;
    }

    return AutoUpdater.isinstalled();
  };

  OTPlugin.settings = settings;

  OTPlugin.version = meta.version;
  OTPlugin.installedVersion = meta.installedVersion;

  // Returns a URI to the OTPlugin installer that is paired with
  // this version of OTPlugin.js.
  OTPlugin.pathToInstaller = meta.pathToInstaller;

  // Trigger +callback+ when the plugin is ready
  //
  // Most of the public API cannot be called until
  // the plugin is ready.
  OTPlugin.ready = function ready(callback) {
    readiness.listen(callback.bind(OTPlugin));
  };

  // Helper function for OTPlugin.getUserMedia
  var _getUserMedia = function _getUserMedia(mediaConstraints, success, error) {
    PluginProxies.createMediaPeer(function (err, plugin) {
      if (err) {
        error.call(OTPlugin, err);
        return;
      }

      plugin._.getUserMedia(mediaConstraints.toHash(), function (streamJson) {
        success.call(OTPlugin, MediaStream.fromJson(streamJson, plugin));
      }, error);
    });
  };

  // Equivalent to: window.getUserMedia(constraints, success, error);
  //
  // Except that the constraints won't be identical
  OTPlugin.getUserMedia = function getUserMedia(userConstraints, success, error) {
    var constraints = new MediaConstraints(userConstraints);

    if (constraints.screenSharing) {
      _getUserMedia(constraints, success, error);
    } else {
      var sources = [];
      if (constraints.hasVideo) {
        sources.push('video');
      }

      if (constraints.hasAudio) {
        sources.push('audio');
      }

      PluginProxies.mediaCapturer.selectSources(sources, function (captureDevices) {
        for (var key in captureDevices) {
          if (captureDevices.hasOwnProperty(key)) {
            logging.debug(key + ' Capture Device: ' + captureDevices[key]);
          }
        }

        // Use the sources to acquire the hardware and start rendering
        constraints.setVideoSource(captureDevices.video);
        constraints.setAudioSource(captureDevices.audio);

        _getUserMedia(constraints, function (stream) {
          // Modify the tracks to include the deviceId
          if (stream) {
            stream.getVideoTracks().forEach(function (track) {
              track.deviceId = captureDevices.video;
              return track;
            });
            stream.getAudioTracks().forEach(function (track) {
              track.deviceId = captureDevices.audio;
              return track;
            });
          }
          success.apply(this, arguments);
        }, error);
      }, error, settings.usePreviousDeviceSelection);
    }
  };

  OTPlugin.enumerateDevices = function (completion) {
    readiness.listen(function (error) {
      if (error) {
        completion(error);
      } else {
        PluginProxies.mediaCapturer.enumerateDevices(completion);
      }
    });
  };

  // Equivalent to: var pc = new window.RTCPeerConnection(iceServers, options);
  //
  // Except that it is async and takes a completion handler
  OTPlugin.initPeerConnection = function initPeerConnection(iceServers, options, localStream, completion) {
    var gotPeerObject = function gotPeerObject(err, plugin) {
      if (err) {
        completion(err);
        return;
      }

      logging.debug('Got PeerConnection for ' + plugin.id);

      createPeerConnection(iceServers, options, plugin).then(function (peerConnection) {
        completion(null, peerConnection);
      }, function (err) {
        completion(err);
      });
    };

    // @fixme this is nasty and brittle. We need some way to use the same Object
    // for the PeerConnection that was used for the getUserMedia call (in the case
    // of publishers). We don't really have a way of implicitly associating them though.
    // Hence, publishers will have to pass through their localStream (if they have one)
    // and we will look up the original Object and use that. Otherwise we generate
    // a new one.
    if (localStream && localStream._.plugin) {
      gotPeerObject(null, localStream._.plugin);
    } else {
      PluginProxies.createMediaPeer(gotPeerObject);
    }
  };

  OTPlugin.RTCSessionDescription = RTCSessionDescription;
  OTPlugin.RTCIceCandidate = RTCIceCandidate;

  OTPlugin.mediaDevices = new MediaDevices();

  startupAnalyticsLogger({ analytics: analytics, meta: meta, readiness: readiness });

  module.exports = OTPlugin;
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../common-js-helpers/OTHelpers.js":217,"../ot/analytics.js":289,"../ot/logging.js":312,"./auto_updater.js":381,"./media_constraints.js":385,"./media_devices.js":386,"./media_stream.js":387,"./meta.js":389,"./peer_connection/create_peer_connection.js":397,"./plugin_proxies.js":399,"./readiness.js":401,"./rtc/rtc_ice_candidate.js":403,"./rtc/rtc_session_description.js":404,"./settings.js":406,"./startupAnalyticsLogger.js":407}],391:[function(require,module,exports){
'use strict';

var createSingleElementContainer = require('./create_single_element_container.js');
var curryCallAsync = require('../../curry_call_async.js');
var once = require('lodash/once');
var Promise = require('bluebird');
var requestManager = require('./request_manager.js');
var RTCStatsReport = require('../../rtc/rtc_stats_report.js');

// The plugin exposes an inflexible and non-standard version of getStats that does not allow
// concurrent calls and gives results by calling a success or error callback that can only be
// registered once via registerXCallback (you can't provide new callbacks for each call). JS
// code that simulates this part of the plugin behaviour can be found in tests/mocks.
//
// The purpose of this adaptor is to transform the getStats provided by the plugin to one that has
// no restrictions on concurrency and returns a promise. Concurrent getStats for the same track are
// compressed into a single request to the plugin's getStats and concurrent getStats for different
// tracks are serialized so that the plugin doesn't receive a getStats call until it has fulfilled
// the previous one.
//
// To be more in line with webrtc (and preserve the previous api otplugin.js exposed), there is
// another thin wrapper around this adaptor which takes success and error callbacks instead of
// returning a promise.

module.exports = function (pluginElement, id) {
  var callbacks = createSingleElementContainer();

  var registerXCallbacks = once(function () {
    pluginElement.registerXCallback('getStatsSuccess', curryCallAsync(function (statsReportJson) {
      callbacks.pop().success(statsReportJson);
    }));

    pluginElement.registerXCallback('getStatsError', curryCallAsync(function (err) {
      callbacks.pop().error(err);
    }));
  });

  return requestManager(function (mediaStreamTrack) {
    return new Promise(function (resolve, reject) {
      registerXCallbacks();

      callbacks.push({
        success: function success(statsReportJson) {
          resolve(new RTCStatsReport(JSON.parse(statsReportJson)));
        },

        error: reject
      });

      pluginElement.getStats(id, mediaStreamTrack);
    });
  });
};

},{"../../curry_call_async.js":382,"../../rtc/rtc_stats_report.js":405,"./create_single_element_container.js":393,"./request_manager.js":395,"bluebird":2,"lodash/once":174}],392:[function(require,module,exports){
"use strict";

// A resolver for lodash/memoize (its second argument, see lodash docs) that assigns a consistent
// number to any object/value passed to it by storing an array of seen objects and looking up the
// index of the of the current object/value.

module.exports = function () {
  var seenObjects = [];

  return function (obj) {
    var seenIndex = seenObjects.indexOf(obj);

    if (seenIndex === -1) {
      seenIndex = seenObjects.length;
      seenObjects.push(obj);
    }

    return String(seenIndex);
  };
};

},{}],393:[function(require,module,exports){
'use strict';

var assert = require('assert');

// A single element container. Simply models an array, delegating push and pop, and asserting if
// you try to store more than one element or pop when empty.
//
// When this is used, the alternative would be to either forgo the protective assertions or do
// inline duplicates of this functionality like this:
//
// var foo;
// ...
// assert(foo === undefined);
// foo = getFoo();
// ...
// assert(foo !== undefined);
// use(foo);
// foo = undefined;
//
// With a singleElementContainer, the above code becomes:
// ...
// var foo = createSingleElementContainer();
// ...
// foo.push(getFoo());
// ...
// use(foo.pop());

module.exports = function () {
  var container = {};
  var elements = [];

  container.push = function (value) {
    assert(elements.length === 0);
    elements.push(value);
  };

  container.pop = function () {
    assert(elements.length === 1);
    return elements.pop();
  };

  return container;
};

},{"assert":1}],394:[function(require,module,exports){
'use strict';

// core modules
var assert = require('assert');

// Takes a function of the form function() => promise (no args and returns a promise) and returns
// a function of the same form which prevents concurrent requests by returning the pending result
// when additional requests are made before the first is fulfilled.

module.exports = function (request) {
  var responsePromise = void 0;

  return function () {
    assert(arguments.length === 0);

    if (responsePromise) {
      return responsePromise;
    }

    responsePromise = request().finally(function () {
      responsePromise = undefined;
    });

    return responsePromise;
  };
};

},{"assert":1}],395:[function(require,module,exports){
'use strict';

var createLinearResolver = require('./create_linear_resolver.js');
var memoize = require('lodash/memoize');
var requestCompressor = require('./request_compressor.js');
var requestSerializer = require('./request_serializer.js');

// Takes a function of the form function(input?) => promise (one optional argument and returns a
// promise) and returns a function of the same form which prevents concurrent requests by combining
// requestCompressor and requestSerializer. When concurrent requests are made, they will be
// compressed when the input is the same, and serialized when the input is different.

module.exports = function (request) {
  var serializedRequest = requestSerializer(request);

  var rawGetCompressedRequest = function rawGetCompressedRequest(input) {
    return requestCompressor(function () {
      return serializedRequest(input);
    });
  };

  // This is an uncommon way to use memoize. It's not being done to improve the performance of
  // rawGetCompressedRequest* but to lazily create a compressedRequest for each input and recall the
  // existing compressedRequest when that input is used again later.
  // * (there is a broader performance goal of reducing requests here though)
  //
  // Another way to think of this is that a pure function is like a map, and memoize is usually used
  // to speed up a pure function while preserving behaviour. Here a not-pure function becomes pure
  // and like a map by changing its behaviour. rawGetCompressedRequest is not pure because it
  // generates a new compressedRequest instance each time even if the input is the same. memoize is
  // used to make it pure, so that it is like a map that always returns the same compressedRequest
  // for each input.
  //
  // (The verb form of request is being used here, not the noun form.)
  //
  var getCompressedRequest = memoize(rawGetCompressedRequest, createLinearResolver());

  return function (input) {
    var compressedRequest = getCompressedRequest(input);
    return compressedRequest();
  };
};

},{"./create_linear_resolver.js":392,"./request_compressor.js":394,"./request_serializer.js":396,"lodash/memoize":170}],396:[function(require,module,exports){
// @todo enable the following disabled rules see OPENTOK-31136 for more info
/* eslint-disable one-var */

// eslint-disable-next-line
'use strict';

// core modules

var assert = require('assert');

// community modules
var Promise = require('bluebird');

// Takes a function of the form function(input?) => promise (one optional argument and returns a
// promise) and returns a function of the same form which prevents concurrent requests by
// serializing them. That is, when there is a pending result and a new request is made, the
// underlying request function is not called until the pending result has been fulfilled.

module.exports = function (request) {
  var queue = [];
  var responsePromise = void 0,
      _tryNext = void 0;

  var serializedRequest = function serializedRequest(input) {
    assert(this === undefined);
    assert(arguments.length <= 1);

    return new Promise(function (resolve) {
      queue.push({
        input: input,
        resolve: resolve
      });

      _tryNext();
    });
  };

  _tryNext = function tryNext() {
    if (queue.length === 0 || responsePromise) {
      return;
    }

    var job = queue.shift();

    responsePromise = request(job.input).finally(function () {
      responsePromise = undefined;
      _tryNext();
    });

    job.resolve(responsePromise);
  };

  return serializedRequest;
};

},{"assert":1,"bluebird":2}],397:[function(require,module,exports){
'use strict';

// @todo enable the following disabled rules see OPENTOK-31136 for more info
/* eslint-disable one-var, prefer-const, no-plusplus, prefer-rest-params, no-cond-assign */
/* eslint-disable no-prototype-builtins, no-shadow, no-restricted-syntax, no-param-reassign */
/* eslint-disable no-void */

var bluebird = require('bluebird');
var uuid = require('uuid');

var curryCallAsync = require('../curry_call_async.js');
var createGetStatsAdaptor = require('./create_get_stats_adaptor/create_get_stats_adaptor.js');
var logging = require('../../ot/logging.js');
var MediaStream = require('../media_stream');
var OTHelpers = require('../../common-js-helpers/OTHelpers.js');
var RTCIceCandidate = require('../rtc/rtc_ice_candidate.js');
var RTCSessionDescription = require('../rtc/rtc_session_description.js');

// Our RTCPeerConnection shim, it should look like a normal PeerConection
// from the outside, but it actually delegates to our plugin.
//
var createPeerConnection = function createPeerConnection(iceServers, options, plugin) {
  var Proto = function PeerConnection() {};
  var peerConnection = new Proto();
  var id = uuid();
  var candidates = [];
  var inited = false;
  var deferMethods = [];

  var resolvePeerConn = void 0;
  var rejectPeerConn = void 0;
  var peerConnPromise = new bluebird.Promise(function (resolve, reject) {
    resolvePeerConn = resolve;
    rejectPeerConn = reject;
  });

  var events = void 0,
      streamAdded = void 0;

  plugin.addRef(peerConnection);

  events = {
    addstream: [],
    removestream: [],
    icecandidate: [],
    signalingstatechange: [],
    iceconnectionstatechange: []
  };

  var onAddIceCandidate = function onAddIceCandidate() {/* success */};

  var canAddCandidate = function canAddCandidate() {
    return peerConnection.localDescription && peerConnection.remoteDescription;
  };

  var onAddIceCandidateFailed = function onAddIceCandidateFailed(err) {
    logging.error('Failed to process candidate');
    logging.error(err);
  };

  var maybeProcessPendingCandidates = function maybeProcessPendingCandidates() {
    if (canAddCandidate()) {
      for (var i = 0; i < candidates.length; ++i) {
        plugin._.addIceCandidate(id, candidates[i], onAddIceCandidate, onAddIceCandidateFailed);
      }
    }
  };

  var deferMethod = function deferMethod(method) {
    return function () {
      if (inited === true) {
        return method.apply(peerConnection, arguments);
      }

      deferMethods.push([method, arguments]);

      // FIXME: Adding the following line to satisfy consistent-return, but this needs to be fixed
      // properly - probably shouldn't return a value above.
      return undefined;
    };
  };

  var processDeferredMethods = function processDeferredMethods() {
    var m = void 0;
    while (m = deferMethods.shift()) {
      m[0].apply(peerConnection, m[1]);
    }
  };

  var triggerEvent = function triggerEvent() /* eventName [, arg1, arg2, ..., argN] */{
    var args = Array.prototype.slice.call(arguments);
    var eventName = args.shift();

    if (!events.hasOwnProperty(eventName)) {
      logging.error('PeerConnection does not have an event called: ' + eventName);
      return;
    }

    events[eventName].forEach(function (listener) {
      listener.apply(undefined, args);
    });
  };

  var bindAndDelegateEvents = function bindAndDelegateEvents(events) {
    for (var name in events) {
      if (events.hasOwnProperty(name)) {
        events[name] = curryCallAsync(events[name]);
      }
    }

    plugin._.on(id, events);
  };

  var callAsync = function callAsync(fn) {
    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    return setTimeout(function () {
      return fn.apply(undefined, args);
    });
  };

  var addStream = function addStream(streamJson) {
    var stream = MediaStream.fromJson(streamJson, plugin);
    var event = { stream: stream, target: peerConnection };

    if (peerConnection.onaddstream && OTHelpers.isFunction(peerConnection.onaddstream)) {
      callAsync(peerConnection.onaddstream, event);
    }

    triggerEvent('addstream', event);
  };

  var removeStream = function removeStream(streamJson) {
    var stream = MediaStream.fromJson(streamJson, plugin);
    var event = { stream: stream, target: peerConnection };

    if (peerConnection.onremovestream && OTHelpers.isFunction(peerConnection.onremovestream)) {
      callAsync(peerConnection.onremovestream, event);
    }

    triggerEvent('removestream', event);
  };

  var iceCandidate = function iceCandidate(candidateSdp, sdpMid, sdpMLineIndex) {
    var candidate = new RTCIceCandidate({
      candidate: candidateSdp,
      sdpMid: sdpMid,
      sdpMLineIndex: sdpMLineIndex
    });

    var event = { candidate: candidate, target: peerConnection };

    if (peerConnection.onicecandidate && OTHelpers.isFunction(peerConnection.onicecandidate)) {
      callAsync(peerConnection.onicecandidate, event);
    }

    triggerEvent('icecandidate', event);
  };

  var signalingStateChange = function signalingStateChange(state) {
    peerConnection.signalingState = state;
    var event = { state: state, target: peerConnection };

    if (peerConnection.onsignalingstatechange && OTHelpers.isFunction(peerConnection.onsignalingstatechange)) {
      callAsync(peerConnection.onsignalingstatechange, event);
    }

    triggerEvent('signalingstatechange', event);
  };

  var iceConnectionChange = function iceConnectionChange(state) {
    peerConnection.iceConnectionState = state;
    var event = { state: state, target: peerConnection };

    if (peerConnection.oniceconnectionstatechange && OTHelpers.isFunction(peerConnection.oniceconnectionstatechange)) {
      callAsync(peerConnection.oniceconnectionstatechange, event);
    }

    triggerEvent('iceconnectionstatechange', event);
  };

  peerConnection.createOffer = function (constraints) {
    return peerConnPromise.then(function () {
      logging.debug('createOffer', constraints);

      return new bluebird.Promise(function (resolve, reject) {
        return plugin._.createOffer(id, function (type, sdp) {
          resolve(new RTCSessionDescription({
            type: type,
            sdp: sdp
          }));
        }, reject, constraints || {});
      });
    });
  };

  peerConnection.createAnswer = function (constraints) {
    return peerConnPromise.then(function () {
      logging.debug('createAnswer', constraints);

      return new bluebird.Promise(function (resolve, reject) {
        return plugin._.createAnswer(id, function (type, sdp) {
          resolve(new RTCSessionDescription({
            type: type,
            sdp: sdp
          }));
        }, reject, constraints || {});
      });
    });
  };

  peerConnection.setLocalDescription = function (description) {
    return peerConnPromise.then(function () {
      logging.debug('setLocalDescription');

      return new bluebird.Promise(function (resolve, reject) {
        return plugin._.setLocalDescription(id, description, function () {
          peerConnection.localDescription = description;
          resolve();
          maybeProcessPendingCandidates();
        }, reject);
      });
    });
  };

  peerConnection.setRemoteDescription = function (description) {
    return peerConnPromise.then(function () {
      logging.debug('setRemoteDescription');

      return new bluebird.Promise(function (resolve, reject) {
        return plugin._.setRemoteDescription(id, description, function () {
          peerConnection.remoteDescription = description;
          resolve();
          maybeProcessPendingCandidates();
        }, reject);
      });
    });
  };

  peerConnection.addIceCandidate = deferMethod(function (candidate) {
    logging.debug('addIceCandidate');

    if (canAddCandidate()) {
      plugin._.addIceCandidate(id, candidate, onAddIceCandidate, onAddIceCandidateFailed);
    } else {
      candidates.push(candidate);
    }
  });

  peerConnection.addStream = deferMethod(function (stream) {
    var constraints = {};
    plugin._.addStream(id, stream, constraints);
  });

  peerConnection.removeStream = deferMethod(function (stream) {
    plugin._.removeStream(id, stream);
  });

  peerConnection.getRemoteStreams = function () {
    var remoteStreams = plugin._.getRemoteStreams(id);
    if (remoteStreams) {
      return remoteStreams.map(function (stream) {
        return MediaStream.fromJson(stream, plugin);
      });
    }
    return [];
  };

  peerConnection.getLocalStreams = function () {
    return plugin._.getLocalStreams(id).map(function (stream) {
      return MediaStream.fromJson(stream, plugin);
    });
  };

  peerConnection.getStreamById = function (streamId) {
    return MediaStream.fromJson(plugin._.getStreamById(id, streamId), plugin);
  };

  var adaptedGetStats = createGetStatsAdaptor(plugin._, id);

  peerConnection.getStats = deferMethod(function (mediaStreamTrack, success, error) {
    streamAdded.then(function () {
      var getStatsPromise = adaptedGetStats(mediaStreamTrack);

      getStatsPromise.then(success);
      getStatsPromise.catch(error);
    });
  });

  peerConnection.close = function () {
    plugin._.destroyPeerConnection(id);
    plugin.removeRef(this);
  };

  peerConnection.destroy = function () {
    peerConnection.close();
  };

  peerConnection.addEventListener = function (event, handler /* [, useCapture] we ignore this */) {
    if (events[event] === void 0) {
      return;
    }

    events[event].push(handler);
  };

  peerConnection.removeEventListener = function (event, handler /* [, useCapture] we ignore this */
  ) {
    if (events[event] === void 0) {
      return;
    }

    events[event] = events[event].filter(function (fn) {
      return fn !== handler;
    });
  };

  // These should appear to be null, instead of undefined, if no
  // callbacks are assigned. This more closely matches how the native
  // objects appear and allows 'if (pc.onsignalingstatechange)' type
  // feature detection to work.
  peerConnection.onaddstream = null;
  peerConnection.onremovestream = null;
  peerConnection.onicecandidate = null;
  peerConnection.onsignalingstatechange = null;
  peerConnection.oniceconnectionstatechange = null;

  // Both username and credential must exist, otherwise the plugin throws an error
  iceServers.iceServers.forEach(function (iceServer) {
    if (!iceServer.username) {
      iceServer.username = '';
    }
    if (!iceServer.credential) {
      iceServer.credential = '';
    }
  });

  plugin._.initPeerConnection(id, iceServers, options, function () {
    bindAndDelegateEvents({
      addStream: addStream,
      removeStream: removeStream,
      iceCandidate: iceCandidate,
      signalingStateChange: signalingStateChange,
      iceConnectionChange: iceConnectionChange
    });

    streamAdded = new bluebird.Promise(function (resolve) {
      if (plugin._.getLocalStreams(id).length > 0) {
        resolve();
      } else {
        peerConnection.addEventListener('addstream', function () {
          setTimeout(function () {
            resolve();
          }, 200);
        });
      }
    });

    inited = true;
    processDeferredMethods();
    resolvePeerConn(peerConnection);
  }, function (error) {
    rejectPeerConn(error);
  });

  return peerConnPromise;
};

module.exports = createPeerConnection;

},{"../../common-js-helpers/OTHelpers.js":217,"../../ot/logging.js":312,"../curry_call_async.js":382,"../media_stream":387,"../rtc/rtc_ice_candidate.js":403,"../rtc/rtc_session_description.js":404,"./create_get_stats_adaptor/create_get_stats_adaptor.js":391,"bluebird":2,"uuid":200}],398:[function(require,module,exports){
'use strict';

module.exports = '2.2.0.122';

},{}],399:[function(require,module,exports){
'use strict';

// @todo enable the following disabled rules see OPENTOK-31136 for more info
/* eslint-disable no-prototype-builtins, no-restricted-syntax, one-var, no-void */

var meta = require('./meta.js');
var OTHelpers = require('../common-js-helpers/OTHelpers.js');
var proxyExtras = require('./proxy_extras.js');

var Proto = function PluginProxies() {};
var pluginProxies = new Proto();
var proxies = {};

// Private API

// This is called whenever a Proxy's destroy event fires.
var cleanupProxyOnDestroy = function cleanupProxyOnDestroy(object) {
  if (pluginProxies.mediaCapturer && pluginProxies.mediaCapturer.id === object.id) {
    pluginProxies.mediaCapturer = null;
  } else if (proxies.hasOwnProperty(object.id)) {
    delete proxies[object.id];
  }

  if (object.OTHelpers) {
    object.OTHelpers.remove();
  }
};

// Public API

// Public accessor for the MediaCapturer
pluginProxies.mediaCapturer = null;

pluginProxies.removeAll = function removeAll() {
  for (var id in proxies) {
    if (proxies.hasOwnProperty(id)) {
      proxies[id].destroy();
    }
  }

  if (pluginProxies.mediaCapturer) {
    pluginProxies.mediaCapturer.destroy();
  }
};

pluginProxies.create = function create(options, completion) {
  var proxy = proxyExtras.createPluginProxy(options, completion);

  proxies[proxy.uuid] = proxy;

  // Clean up after this Proxy when it's destroyed.
  proxy.on('destroy', function () {
    cleanupProxyOnDestroy(proxy);
  });

  return proxy;
};

// Two ways to call this function
// - pluginProxies.createMediaPeer(options, completion)
// - pluginProxies.createMediaPeer(completion)
//
// If options is omitted, it defaults to {}.
//
pluginProxies.createMediaPeer = function createMediaPeer(arg1, arg2) {
  var options = void 0,
      completion = void 0;

  if (OTHelpers.isFunction(arg1)) {
    options = {};
    completion = arg1;
  } else {
    options = arg1;
    completion = arg2;
  }

  var mediaPeer = pluginProxies.create(OTHelpers.extend(options || {}, {
    mimeType: meta.mimeType,
    isVisible: true,
    windowless: true
  }), function (err) {
    if (err) {
      completion.call(void 0, err);
      return;
    }

    proxies[mediaPeer.id] = mediaPeer;
    completion.call(void 0, void 0, mediaPeer);
  });

  proxyExtras.makeMediaPeerProxy(mediaPeer);
};

pluginProxies.createMediaCapturer = function createMediaCapturer(completion) {
  // TODO: This violates the always sync or always async idiom.

  if (pluginProxies.mediaCapturer) {
    completion.call(void 0, void 0, pluginProxies.mediaCapturer);
    return;
  }

  pluginProxies.mediaCapturer = pluginProxies.create({
    mimeType: meta.mimeType,
    isVisible: false,
    windowless: false
  }, function (err) {
    completion.call(void 0, err, pluginProxies.mediaCapturer);
  });

  proxyExtras.makeMediaCapturerProxy(pluginProxies.mediaCapturer);
};

module.exports = pluginProxies;

},{"../common-js-helpers/OTHelpers.js":217,"./meta.js":389,"./proxy_extras.js":400}],400:[function(require,module,exports){
(function (global){
'use strict';

// @todo enable the following disabled rules see OPENTOK-31136 for more info
/* eslint-disable no-void, prefer-rest-params, no-useless-escape, no-restricted-syntax */
/* eslint-disable no-prototype-builtins, no-shadow, no-param-reassign, prefer-spread */

// community modules
var assign = require('lodash/assign');
var bluebird = require('bluebird');
var OTHelpers = require('../common-js-helpers/OTHelpers.js');
var uuid = require('uuid');

// local modules
var curryCallAsync = require('./curry_call_async.js');
var empiricDelay = require('./empiric_delay.js');
var EventEmitter = require('./event_emitter.js');
var logging = require('../ot/logging.js');
var refCountBehaviour = require('./ref_count_behaviour.js');
var waitForReadySignal = require('./wait_for_ready_signal.js');

var PROXY_LOAD_TIMEOUT = 5000;

var objectTimeouts = {};

var clearGlobalCallback = function clearGlobalCallback(callbackId) {
  if (!callbackId) {
    return; // TODO: Is this really a valid call? Would it be better to throw?
  }

  if (objectTimeouts[callbackId]) {
    clearTimeout(objectTimeouts[callbackId]);
    objectTimeouts[callbackId] = null;
  }

  if (global[callbackId]) {
    try {
      delete global[callbackId];
    } catch (err) {
      global[callbackId] = void 0;
    }
  }
};

var waitOnGlobalCallback = function waitOnGlobalCallback(callbackId, completion) {
  objectTimeouts[callbackId] = setTimeout(function () {
    clearGlobalCallback(callbackId);
    completion('The object timed out while loading.');
  }, PROXY_LOAD_TIMEOUT);

  global[callbackId] = function () {
    clearGlobalCallback(callbackId);

    var args = Array.prototype.slice.call(arguments);
    args.unshift(null);
    completion.apply(undefined, args);
  };
};

var generateCallbackID = function generateCallbackID() {
  return 'OTPlugin_loaded_' + uuid().replace(/\-+/g, '');
};

var generateObjectHtml = function generateObjectHtml(callbackId, optionsParam) {
  var options = optionsParam || {};
  var objBits = [];

  var attrs = ['type="' + options.mimeType + '"', 'id="' + callbackId + '_obj"', 'tb_callback_id="' + callbackId + '"', 'width="0" height="0"'];

  var params = {
    userAgent: OTHelpers.env.userAgent.toLowerCase(),
    windowless: options.windowless,
    onload: callbackId
  };

  if (options.isVisible !== true) {
    attrs.push('visibility="hidden"');
  }

  objBits.push('<object ' + attrs.join(' ') + '>');

  for (var name in params) {
    if (params.hasOwnProperty(name)) {
      objBits.push('<param name="' + name + '" value="' + params[name] + '" />');
    }
  }

  objBits.push('</object>');
  return objBits.join('');
};

var createObject = function createObject(callbackId, optionsParam, completion) {
  var options = optionsParam || {};

  var html = generateObjectHtml(callbackId, options);
  var doc = options.doc || global.document;

  doc.body.insertAdjacentHTML('beforeend', html);
  var object = doc.body.querySelector('#' + callbackId + '_obj');

  completion(void 0, object);
};

// Reference counted wrapper for a plugin object
var createPluginProxy = function createPluginProxy(options, completion) {
  var Proto = function PluginProxy() {};
  var pluginProxy = new Proto();

  pluginProxy.ready = {};

  pluginProxy.ready.promise = new bluebird.Promise(function (resolve, reject) {
    pluginProxy.ready.resolve = resolve;
    pluginProxy.ready.reject = reject;
  });

  assign(pluginProxy, EventEmitter());

  // Calling this will bind a listener to the devicesChanged events that
  // the plugin emits and then rebroadcast them.
  pluginProxy.listenForDeviceChanges = function () {
    pluginProxy.ready.promise.then(function () {
      return bluebird.delay(empiricDelay);
    }).then(function () {
      pluginProxy._.registerXCallback('devicesChanged', function () {
        var args = Array.prototype.slice.call(arguments);
        logging.debug(args);
        pluginProxy.emit('devicesChanged', args);
      });
    });
  };

  refCountBehaviour(pluginProxy);

  // Assign +plugin+ to this object and setup all the public
  // accessors that relate to the DOM Object.
  //
  var setPlugin = function setPlugin(plugin) {
    if (plugin) {
      pluginProxy._ = plugin;
      pluginProxy.parentElement = plugin.parentElement;
      pluginProxy.OTHelpers = OTHelpers(plugin);
    } else {
      pluginProxy._ = null;
      pluginProxy.parentElement = null;
      pluginProxy.OTHelpers = OTHelpers();
    }
  };

  pluginProxy.uuid = generateCallbackID();

  pluginProxy.isValid = function () {
    return pluginProxy._.valid;
  };

  pluginProxy.destroy = function () {
    pluginProxy.removeAllRefs();
    setPlugin(null);

    // Let listeners know that they should do any final book keeping
    // that relates to us.
    pluginProxy.emit('destroy');
  };

  pluginProxy.enumerateDevices = function (completion) {
    pluginProxy._.enumerateDevices(completion);
  };

  // Initialise

  // The next statement creates the raw plugin object accessor on the Proxy.
  // This is null until we actually have created the Object.
  setPlugin(null);

  waitOnGlobalCallback(pluginProxy.uuid, function (err) {
    if (err) {
      completion('The plugin with the mimeType of ' + options.mimeType + ' timed out while loading: ' + err);

      pluginProxy.destroy();
      return;
    }

    pluginProxy._.setAttribute('id', 'tb_plugin_' + pluginProxy._.uuid);
    pluginProxy._.removeAttribute('tb_callback_id');
    pluginProxy.uuid = pluginProxy._.uuid;
    pluginProxy.id = pluginProxy._.id;

    // TODO: This guard shouldn't be necessary, and if it is we should throw an error if it's not
    // there.
    if (pluginProxy._.on) {
      // If the plugin supports custom events we'll use them
      pluginProxy._.on(-1, {
        customEvent: curryCallAsync(function () {
          var args = Array.prototype.slice.call(arguments);
          pluginProxy.emit(args.shift(), args);
        })
      });
    }

    waitForReadySignal(pluginProxy, function (err) {
      if (err) {
        completion('Error while starting up plugin ' + pluginProxy.uuid + ': ' + err);
        pluginProxy.destroy();
        return;
      }

      completion(void 0, pluginProxy);
    });
  });

  createObject(pluginProxy.uuid, options, function (err, plugin) {
    if (err) {
      logging.error(err); // TODO: would it be better to throw?
      return;
    }

    setPlugin(plugin);
  });

  // TODO: Why is there both a completion handler and a return value?
  return pluginProxy;
};

// Specialisation for the MediaCapturer API surface
var makeMediaCapturerProxy = function makeMediaCapturerProxy(mediaCapturer) {
  mediaCapturer.selectSources = function () {
    return mediaCapturer._.selectSources.apply(mediaCapturer._, arguments);
  };

  mediaCapturer.listenForDeviceChanges();
  return mediaCapturer;
};

// Specialisation for the MediaPeer API surface
var makeMediaPeerProxy = function makeMediaPeerProxy(mediaPeer) {
  mediaPeer.setStream = function (stream, completion) {
    mediaPeer._.setStream(stream, mediaPeer._.msMatchesSelector('.OT_publisher.OT_mirrored object'));

    if (completion) {
      // TODO Investigate whether there is a good way to detect
      // when the media is flowing

      // This fires a little too soon.
      setTimeout(completion, 200);
    }

    return mediaPeer;
  };

  return mediaPeer;
};

module.exports = {
  createPluginProxy: createPluginProxy,
  makeMediaPeerProxy: makeMediaPeerProxy,
  makeMediaCapturerProxy: makeMediaCapturerProxy
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../common-js-helpers/OTHelpers.js":217,"../ot/logging.js":312,"./curry_call_async.js":382,"./empiric_delay.js":383,"./event_emitter.js":384,"./ref_count_behaviour.js":402,"./wait_for_ready_signal.js":410,"bluebird":2,"lodash/assign":142,"uuid":200}],401:[function(require,module,exports){
'use strict';

// @todo enable the following disabled rules see OPENTOK-31136 for more info
/* eslint-disable no-void, no-cond-assign, no-shadow */

var AutoUpdater = require('./auto_updater.js');
var logging = require('../ot/logging.js');
var OTHelpers = require('../common-js-helpers/OTHelpers.js');
var PluginProxies = require('./plugin_proxies.js');
var domState = require('../helpers/domState.js');

var _isReady = false;

var readyCallbacks = [];

// This stores the error from the load attempt. We use
// this if registerReadyListener gets called after a load
// attempt fails.
var loadError = void 0;

var destroy = function destroy() {
  PluginProxies.removeAll();
};

var registerReadyListener = function registerReadyListener(callback) {
  if (!OTHelpers.isFunction(callback)) {
    logging.warn('registerReadyListener was called with something that was not a function.');
    return;
  }

  if (_isReady) {
    callback.call(void 0, loadError);
  } else {
    readyCallbacks.push(callback);
  }
};

var notifyReadyListeners = function notifyReadyListeners() {
  _isReady = true;

  var callback = void 0;

  while ((callback = readyCallbacks.pop()) && OTHelpers.isFunction(callback)) {
    callback.call(void 0, loadError);
  }
};

var onDomReady = function onDomReady() {
  AutoUpdater.get(function (err, updater) {
    if (err) {
      loadError = 'Error while loading the AutoUpdater: ' + err;
      notifyReadyListeners();
      return;
    }

    // If the plugin is out of date then we kick off the
    // auto update process and then bail out.
    if (!updater.hasRequiredVersion()) {
      updater.autoUpdate();
      return;
    }

    // Inject the controller object into the page, wait for it to load or timeout...
    PluginProxies.createMediaCapturer(function (err) {
      loadError = err;

      if (!loadError && (!PluginProxies.mediaCapturer || !PluginProxies.mediaCapturer.isValid())) {
        loadError = 'The TB Plugin failed to load properly';
      }

      notifyReadyListeners();

      domState.whenUnloaded.then(destroy);
    });
  });
};

domState.whenLoaded.then(onDomReady);

module.exports = {
  listen: registerReadyListener,
  isReady: function isReady() {
    return _isReady;
  }
};

},{"../common-js-helpers/OTHelpers.js":217,"../helpers/domState.js":253,"../ot/logging.js":312,"./auto_updater.js":381,"./plugin_proxies.js":399}],402:[function(require,module,exports){
"use strict";

// @todo enable the following disabled rules see OPENTOK-31136 for more info
/* eslint-disable no-underscore-dangle, no-param-reassign */

module.exports = function refCountBehaviour(api) {
  var _liveObjects = [];

  api.addRef = function (ref) {
    _liveObjects.push(ref);
    return api;
  };

  api.removeRef = function (ref) {
    if (_liveObjects.length === 0) {
      return api;
    }

    var index = _liveObjects.indexOf(ref);
    if (index !== -1) {
      _liveObjects.splice(index, 1);
    }

    if (_liveObjects.length === 0) {
      api.destroy();
    }

    return api;
  };

  api.removeAllRefs = function () {
    while (_liveObjects.length) {
      _liveObjects.shift().destroy();
    }
  };
};

},{}],403:[function(require,module,exports){
"use strict";

// A RTCIceCandidate like object exposed for native WebRTC compatability
module.exports = function RTCIceCandidate(options) {
  this.sdpMid = options.sdpMid;
  this.sdpMLineIndex = parseInt(options.sdpMLineIndex, 10);
  this.candidate = options.candidate;
};

},{}],404:[function(require,module,exports){
"use strict";

// A RTCSessionDescription like object exposed for native WebRTC compatability
module.exports = function RTCSessionDescription(options) {
  this.type = options.type;
  this.sdp = options.sdp;
};

},{}],405:[function(require,module,exports){
"use strict";

// @todo enable the following disabled rules see OPENTOK-31136 for more info
/* eslint-disable no-restricted-syntax, no-prototype-builtins */

var RTCStatsReport = function RTCStatsReport(reports) {
  for (var id in reports) {
    if (reports.hasOwnProperty(id)) {
      this[id] = reports[id];
    }
  }
};

RTCStatsReport.prototype.forEach = function (callback, context) {
  for (var id in this) {
    if (this.hasOwnProperty(id)) {
      callback.call(context, this[id]);
    }
  }
};

module.exports = RTCStatsReport;

},{}],406:[function(require,module,exports){
"use strict";

// Settings for the plugin. The values below are defaults and can be overridden
module.exports = {
  // Whether to remember the previous devices picked or to prompt the user to choose.
  // The default is to prompt the user to choose. This only works if on https.
  usePreviousDeviceSelection: false
};

},{}],407:[function(require,module,exports){
'use strict';

/* eslint-disable global-require */

module.exports = function (_ref) {
  var _ref$analytics = _ref.analytics,
      analytics = _ref$analytics === undefined ? require('../ot/analytics.js') : _ref$analytics,
      _ref$meta = _ref.meta,
      meta = _ref$meta === undefined ? require('./meta.js') : _ref$meta,
      _ref$readiness = _ref.readiness,
      readiness = _ref$readiness === undefined ? require('./readiness.js') : _ref$readiness;

  readiness.listen(function (error) {
    var payload = {
      version: meta.installedVersion()
    };

    if (error) {
      payload.message = error.message;
      payload.stack = error.stack;
    }

    analytics.logEvent({
      action: 'OTPlugin-Load',
      variation: error ? 'Failure' : 'Success',
      payload: payload
    });
  });
};

},{"../ot/analytics.js":289,"./meta.js":389,"./readiness.js":401}],408:[function(require,module,exports){
'use strict';

// @todo enable the following disabled rules see OPENTOK-31136 for more info
/* eslint-disable no-plusplus, no-continue */

var assert = require('assert');

// Matches 1, 0.3, 1.1.1, 4.1.5.7, etc.
var versionRegex = /^[0-9]+(\.[0-9]+)*$/;

module.exports = function versionGreaterThan(version1, version2) {
  assert(versionRegex.test(version1));
  assert(versionRegex.test(version2));

  var v1 = version1.split('.').map(Number);
  var v2 = version2.split('.').map(Number);

  // There is a way to nicely compare arrays of different lengths, but in our case, if there is a
  // mismatch, it indicates something went wrong. So we throw instead.
  assert(v1.length === v2.length);

  var len = v1.length;

  for (var i = 0; i < len; ++i) {
    // Continue until we find a pair that doesn't match.
    if (v1[i] === v2[i]) {
      continue;
    }

    // The first mismatched pair determines the overall result.
    return v1[i] > v2[i];
  }

  // If all the pieces are equal, then the versions should be equal.
  assert(version1 === version2);

  // And since they're equal, version1 is not greater than version2.
  return false;
};

},{"assert":1}],409:[function(require,module,exports){
'use strict';

// @todo enable the following disabled rules see OPENTOK-31136 for more info
/* eslint-disable no-shadow, no-void */

var logging = require('../ot/logging.js');
var OTHelpers = require('../common-js-helpers/OTHelpers.js');

module.exports = function VideoContainer(plugin, stream) {
  var Proto = function VideoContainer() {};
  var videoContainer = new Proto();
  var audioInputLevelMonitoringEnabled = false;

  videoContainer.domElement = plugin._;
  videoContainer.OTHelpers = OTHelpers(plugin._);
  videoContainer.parentElement = plugin._.parentNode;

  plugin.addRef(videoContainer);

  videoContainer.appendTo = function (parentDomElement) {
    if (parentDomElement && plugin._.parentNode !== parentDomElement) {
      logging.debug('VideoContainer appendTo', parentDomElement);
      parentDomElement.appendChild(plugin._);
      videoContainer.parentElement = parentDomElement;
    }
  };

  videoContainer.show = function (completion) {
    logging.debug('VideoContainer show');
    plugin._.removeAttribute('width');
    plugin._.removeAttribute('height');
    plugin.setStream(stream, completion);
    OTHelpers.show(plugin._);
    return videoContainer;
  };

  videoContainer.setSize = function (width, height) {
    plugin._.setAttribute('width', width);
    plugin._.setAttribute('height', height);
    return videoContainer;
  };

  videoContainer.getAudioInputLevel = function () {
    // we don't need to expose a mechanism to enable / disable the monitoring
    // so we use this opportunity the keep the API simple
    if (!audioInputLevelMonitoringEnabled) {
      plugin._.enableVolumeLevelMonitoring(true);
      audioInputLevelMonitoringEnabled = true;
    }
    return plugin._.getInputLevel();
  };

  videoContainer.setFitMode = function (fitMode) {
    plugin._.fitMode(fitMode);
  };

  videoContainer.width = function (newWidth) {
    if (newWidth !== void 0) {
      logging.debug('VideoContainer set width to ' + newWidth);
      plugin._.setAttribute('width', newWidth);
    }

    return plugin._.getAttribute('width');
  };

  videoContainer.height = function (newHeight) {
    if (newHeight !== void 0) {
      logging.debug('VideoContainer set height to ' + newHeight);
      plugin._.setAttribute('height', newHeight);
    }

    return plugin._.getAttribute('height');
  };

  videoContainer.volume = function (newVolume) {
    if (newVolume !== void 0) {
      // TODO
      logging.debug('VideoContainer setVolume not implemented: called with ' + newVolume);
    } else {
      logging.debug('VideoContainer getVolume not implemented');
    }

    return 0.5;
  };

  videoContainer.getImgData = function () {
    return plugin._.getImgData('image/png');
  };

  videoContainer.videoWidth = function () {
    return plugin._.videoWidth;
  };

  videoContainer.videoHeight = function () {
    return plugin._.videoHeight;
  };

  videoContainer.destroy = function () {
    plugin._.setStream(null);
    plugin.removeRef(videoContainer);
  };

  return videoContainer;
};

},{"../common-js-helpers/OTHelpers.js":217,"../ot/logging.js":312}],410:[function(require,module,exports){
'use strict';

// @todo enable the following disabled rules see OPENTOK-31136 for more info
/* eslint-disable no-void */

var curryCallAsync = require('./curry_call_async.js');
var logging = require('../ot/logging.js');

module.exports = function (pluginProxy, completion) {
  var internalReadyCallback = function internalReadyCallback() {
    // It's not safe to do most plugin operations until the plugin
    // is ready for us to do so. We use ready as a guard in.
    pluginProxy.ready.resolve();

    pluginProxy.ready.promise.then(function (err) {
      if (err) {
        logging.error('Error while starting up plugin ' + pluginProxy.uuid + ': ' + err);
        completion(err);
        return;
      }

      logging.debug('Plugin ' + pluginProxy.id + ' is loaded');
      completion(void 0, pluginProxy);
    });
  };

  // Only the main plugin has an initialise method
  if (pluginProxy._.initialise) {
    pluginProxy.on('ready', curryCallAsync(internalReadyCallback));
    pluginProxy._.initialise();
  } else {
    internalReadyCallback();
  }
};

},{"../ot/logging.js":312,"./curry_call_async.js":382}]},{},[287])(287)
});


//# sourceMappingURL=sourcemaps/TB.js.map
